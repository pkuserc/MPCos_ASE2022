[
    {
        "id": 1,
        "code": "protected E[] createArrayWithNullElement() {\n  E[] array = createSamplesArray();\n  array[getNullLocation()] = null;\n  return array;\n}",
        "summary_tokens": [
            "an",
            "array",
            "of",
            "the",
            "proper",
            "size",
            "with",
            "null",
            "inserted",
            "into",
            "the",
            "middle",
            "element"
        ]
    },
    {
        "id": 2,
        "code": "protected void expectNullMissingWhenNullUnsupported(String message) {\n  try {\n    assertFalse(message, actualContents().contains(null));\n  } catch (NullPointerException tolerated) {\n      \n  }\n}",
        "summary_tokens": [
            "equivalent",
            "to",
            "expect",
            "missing",
            "object",
            "expect",
            "missing",
            "null",
            "except",
            "that",
            "the",
            "call",
            "to",
            "contains",
            "null",
            "is",
            "permitted",
            "to",
            "throw",
            "a",
            "null",
            "pointer",
            "exception"
        ]
    },
    {
        "id": 3,
        "code": "protected C resetContainer(C newValue) {\n  container = newValue;\n  return container;\n}",
        "summary_tokens": [
            "replaces",
            "the",
            "existing",
            "container",
            "under",
            "test",
            "with",
            "a",
            "new",
            "container"
        ]
    },
    {
        "id": 4,
        "code": "protected void expectContents(Collection<E> expected) {\n  Helpers.assertEqualIgnoringOrder(expected, actualContents());\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "the",
            "collection",
            "under",
            "test",
            "contains",
            "exactly",
            "the",
            "given",
            "elements",
            "respecting",
            "cardinality",
            "but",
            "not",
            "order"
        ]
    },
    {
        "id": 5,
        "code": "protected final void expectAdded(E... elements) {\n  List<E> expected = Helpers.copyToList(getSampleElements());\n  expected.addAll(Arrays.asList(elements));\n  expectContents(expected);\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "the",
            "collection",
            "under",
            "test",
            "contains",
            "exactly",
            "the",
            "elements",
            "it",
            "was",
            "initialized",
            "with",
            "plus",
            "the",
            "given",
            "elements",
            "according",
            "to",
            "expect",
            "contents",
            "java"
        ]
    },
    {
        "id": 6,
        "code": "protected ArrayWithDuplicate<E> createArrayWithDuplicateElement() {\n  E[] elements = createSamplesArray();\n  E duplicate = elements[(elements.length / 2) - 1];\n  elements[(elements.length / 2) + 1] = duplicate;\n  return new ArrayWithDuplicate<>(elements, duplicate);\n}",
        "summary_tokens": [
            "an",
            "array",
            "of",
            "the",
            "proper",
            "size",
            "with",
            "a",
            "duplicate",
            "element"
        ]
    },
    {
        "id": 7,
        "code": "protected List<E> getOrderedElements() {\n  List<E> list = new ArrayList<>();\n  for (E e : getSubjectGenerator().order(new ArrayList<E>(getSampleElements()))) {\n    list.add(e);\n  }\n  return Collections.unmodifiableList(list);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "get",
            "sample",
            "elements",
            "sample",
            "elements",
            "as",
            "ordered",
            "by",
            "test",
            "container",
            "generator",
            "order",
            "list"
        ]
    },
    {
        "id": 8,
        "code": "protected int getNullLocation() {\n  return getNumElements() / 2;\n}",
        "summary_tokens": [
            "a",
            "suitable",
            "location",
            "for",
            "a",
            "null",
            "element",
            "to",
            "use",
            "when",
            "initializing",
            "containers",
            "for",
            "tests",
            "that",
            "involve",
            "a",
            "null",
            "element",
            "being",
            "present"
        ]
    },
    {
        "id": 9,
        "code": "protected void verify(List<E> elements) {}",
        "summary_tokens": [
            "override",
            "this",
            "to",
            "verify",
            "anything",
            "after",
            "running",
            "a",
            "list",
            "of",
            "stimuli"
        ]
    },
    {
        "id": 10,
        "code": "private <T extends Iterator<E>> void internalExecuteAndCompare(\n    T reference, T target, IteratorOperation method) {\n  Object referenceReturnValue = null;\n  PermittedMetaException referenceException = null;\n  Object targetReturnValue = null;\n  RuntimeException targetException = null;\n\n  try {\n    targetReturnValue = method.execute(target);\n  } catch (RuntimeException e) {\n    targetException = e;\n  }\n\n  try {\n    if (method == NEXT_METHOD\n        && targetException == null\n        && knownOrder == KnownOrder.UNKNOWN_ORDER) {\n        \n      @SuppressWarnings(\"unchecked\")\n      E targetReturnValueFromNext = (E) targetReturnValue;\n        \n      MultiExceptionListIterator multiExceptionListIterator =\n          (MultiExceptionListIterator) reference;\n      multiExceptionListIterator.promoteToNext(targetReturnValueFromNext);\n    }\n\n    referenceReturnValue = method.execute(reference);\n  } catch (PermittedMetaException e) {\n    referenceException = e;\n  } catch (UnknownElementException e) {\n    Helpers.fail(e, e.getMessage());\n  }\n\n  if (referenceException == null) {\n    if (targetException != null) {\n      Helpers.fail(targetException, \"Target threw exception when reference did not\");\n    }\n\n      \n    assertEquals(referenceReturnValue, targetReturnValue);\n\n    return;\n  }\n\n  if (targetException == null) {\n    fail(\"Target failed to throw \" + referenceException);\n  }\n\n    \n  referenceException.assertPermitted(targetException);\n}",
        "summary_tokens": [
            "apply",
            "this",
            "method",
            "to",
            "both",
            "iterators",
            "and",
            "return",
            "normally",
            "only",
            "if",
            "both",
            "produce",
            "the",
            "same",
            "response"
        ]
    },
    {
        "id": 11,
        "code": "protected Entry<K, V>[] createArrayWithNullKey() {\n  Entry<K, V>[] array = createSamplesArray();\n  int nullKeyLocation = getNullLocation();\n  Entry<K, V> oldEntry = array[nullKeyLocation];\n  array[nullKeyLocation] = entry(null, oldEntry.getValue());\n  return array;\n}",
        "summary_tokens": [
            "an",
            "array",
            "of",
            "the",
            "proper",
            "size",
            "with",
            "null",
            "as",
            "the",
            "key",
            "of",
            "the",
            "middle",
            "element"
        ]
    },
    {
        "id": 12,
        "code": "protected Entry<K, V>[] createArrayWithNullValue() {\n  Entry<K, V>[] array = createSamplesArray();\n  int nullValueLocation = getNullLocation();\n  Entry<K, V> oldEntry = array[nullValueLocation];\n  array[nullValueLocation] = entry(oldEntry.getKey(), null);\n  return array;\n}",
        "summary_tokens": [
            "an",
            "array",
            "of",
            "the",
            "proper",
            "size",
            "with",
            "null",
            "as",
            "the",
            "value",
            "of",
            "the",
            "middle",
            "element"
        ]
    },
    {
        "id": 13,
        "code": "protected void expectNullKeyMissingWhenNullKeysUnsupported(String message) {\n  try {\n    assertFalse(message, getMap().containsKey(null));\n  } catch (NullPointerException tolerated) {\n      \n  }\n}",
        "summary_tokens": [
            "equivalent",
            "to",
            "expect",
            "missing",
            "keys",
            "object",
            "expect",
            "missing",
            "keys",
            "null",
            "except",
            "that",
            "the",
            "call",
            "to",
            "contains",
            "null",
            "is",
            "permitted",
            "to",
            "throw",
            "a",
            "null",
            "pointer",
            "exception"
        ]
    },
    {
        "id": 14,
        "code": "protected void expectNullValueMissingWhenNullValuesUnsupported(String message) {\n  try {\n    assertFalse(message, getMap().containsValue(null));\n  } catch (NullPointerException tolerated) {\n      \n  }\n}",
        "summary_tokens": [
            "equivalent",
            "to",
            "expect",
            "missing",
            "values",
            "object",
            "expect",
            "missing",
            "values",
            "null",
            "except",
            "that",
            "the",
            "call",
            "to",
            "contains",
            "null",
            "is",
            "permitted",
            "to",
            "throw",
            "a",
            "null",
            "pointer",
            "exception"
        ]
    },
    {
        "id": 15,
        "code": "protected V get(K key) {\n  return getMap().get(key);\n}",
        "summary_tokens": [
            "wrapper",
            "for",
            "map",
            "get",
            "object",
            "that",
            "forces",
            "the",
            "caller",
            "to",
            "pass",
            "in",
            "a",
            "key",
            "of",
            "the",
            "same",
            "type",
            "as",
            "the",
            "map"
        ]
    },
    {
        "id": 16,
        "code": "public final String getTestMethodName() {\n  return super.getName();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "name",
            "of",
            "the",
            "test",
            "method",
            "invoked",
            "by",
            "this",
            "test",
            "instance"
        ]
    },
    {
        "id": 17,
        "code": "public B withFeatures(Feature<?>... features) {\n  return withFeatures(Arrays.asList(features));\n}",
        "summary_tokens": [
            "configures",
            "this",
            "builder",
            "to",
            "produce",
            "tests",
            "appropriate",
            "for",
            "the",
            "given",
            "features"
        ]
    },
    {
        "id": 18,
        "code": "public B named(String name) {\n  if (name.contains(\"(\")) {\n    throw new IllegalArgumentException(\n        \"Eclipse hides all characters after \"\n            + \"'('; please use '[]' or other characters instead of parentheses\");\n  }\n  this.name = name;\n  return self();\n}",
        "summary_tokens": [
            "configures",
            "this",
            "builder",
            "produce",
            "a",
            "test",
            "suite",
            "with",
            "the",
            "given",
            "name"
        ]
    },
    {
        "id": 19,
        "code": "public B suppressing(Method... methods) {\n  return suppressing(Arrays.asList(methods));\n}",
        "summary_tokens": [
            "prevents",
            "the",
            "given",
            "methods",
            "from",
            "being",
            "run",
            "as",
            "part",
            "of",
            "the",
            "test",
            "suite"
        ]
    },
    {
        "id": 20,
        "code": "public TestSuite createTestSuite() {\n  checkCanCreate();\n\n  logger.fine(\" Testing: \" + name);\n  logger.fine(\"Features: \" + formatFeatureSet(features));\n\n  FeatureUtil.addImpliedFeatures(features);\n\n  logger.fine(\"Expanded: \" + formatFeatureSet(features));\n\n    \n  List<Class<? extends AbstractTester>> testers = getTesters();\n\n  TestSuite suite = new TestSuite(name);\n  for (Class<? extends AbstractTester> testerClass : testers) {\n    TestSuite testerSuite =\n        makeSuiteForTesterClass((Class<? extends AbstractTester<?>>) testerClass);\n    if (testerSuite.countTestCases() > 0) {\n      suite.addTest(testerSuite);\n    }\n  }\n  return suite;\n}",
        "summary_tokens": [
            "creates",
            "a",
            "runnable",
            "junit",
            "test",
            "suite",
            "based",
            "on",
            "the",
            "criteria",
            "already",
            "given"
        ]
    },
    {
        "id": 21,
        "code": "protected void checkCanCreate() {\n  if (subjectGenerator == null) {\n    throw new IllegalStateException(\"Call using() before createTestSuite().\");\n  }\n  if (name == null) {\n    throw new IllegalStateException(\"Call named() before createTestSuite().\");\n  }\n  if (features == null) {\n    throw new IllegalStateException(\"Call withFeatures() before createTestSuite().\");\n  }\n}",
        "summary_tokens": [
            "throw",
            "illegal",
            "state",
            "exception",
            "if",
            "create",
            "test",
            "suite",
            "can",
            "t",
            "be",
            "called",
            "yet"
        ]
    },
    {
        "id": 22,
        "code": "public static <T> void testComparator(\n    Comparator<? super T> comparator, List<T> valuesInExpectedOrder) {\n    \n  for (int i = 0; i < valuesInExpectedOrder.size(); i++) {\n    T t = valuesInExpectedOrder.get(i);\n\n    for (int j = 0; j < i; j++) {\n      T lesser = valuesInExpectedOrder.get(j);\n      assertTrue(\n          comparator + \".compare(\" + lesser + \", \" + t + \")\", comparator.compare(lesser, t) < 0);\n    }\n\n    assertEquals(comparator + \".compare(\" + t + \", \" + t + \")\", 0, comparator.compare(t, t));\n\n    for (int j = i + 1; j < valuesInExpectedOrder.size(); j++) {\n      T greater = valuesInExpectedOrder.get(j);\n      assertTrue(\n          comparator + \".compare(\" + greater + \", \" + t + \")\",\n          comparator.compare(greater, t) > 0);\n    }\n  }\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "all",
            "pairs",
            "of",
            "t",
            "values",
            "within",
            "values",
            "in",
            "expected",
            "order",
            "are",
            "ordered",
            "consistently",
            "between",
            "their",
            "order",
            "within",
            "values",
            "in",
            "expected",
            "order",
            "and",
            "the",
            "order",
            "implied",
            "by",
            "the",
            "given",
            "comparator"
        ]
    },
    {
        "id": 23,
        "code": "public static <T> Collection<T> misleadingSizeCollection(int delta) {\n    \n    \n    \n  return new ArrayList<T>() {\n    @Override\n    public int size() {\n      return Math.max(0, super.size() + delta);\n    }\n  };\n}",
        "summary_tokens": [
            "returns",
            "a",
            "collection",
            "that",
            "simulates",
            "concurrent",
            "modification",
            "by",
            "having",
            "its",
            "size",
            "method",
            "return",
            "incorrect",
            "values"
        ]
    },
    {
        "id": 24,
        "code": "public static <K, V> Entry<K, V> nefariousMapEntry(K key, V value) {\n  return new Entry<K, V>() {\n    @Override\n    public K getKey() {\n      return key;\n    }\n\n    @Override\n    public V getValue() {\n      return value;\n    }\n\n    @Override\n    public V setValue(V value) {\n      throw new UnsupportedOperationException();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public boolean equals(Object o) {\n      if (o instanceof Entry) {\n        Entry<K, V> e = (Entry<K, V>) o;\n        e.setValue(value); \n\n        return equal(this.getKey(), e.getKey()) && equal(this.getValue(), e.getValue());\n      }\n      return false;\n    }\n\n    @Override\n    public int hashCode() {\n      K k = getKey();\n      V v = getValue();\n      return ((k == null) ? 0 : k.hashCode()) ^ ((v == null) ? 0 : v.hashCode());\n    }\n\n    @Override\n    public String toString() {\n      return getKey() + \"=\" + getValue();\n    }\n  };\n}",
        "summary_tokens": [
            "returns",
            "a",
            "nefarious",
            "map",
            "entry",
            "with",
            "the",
            "specified",
            "key",
            "and",
            "value",
            "meaning",
            "an",
            "entry",
            "that",
            "is",
            "suitable",
            "for",
            "testing",
            "that",
            "map",
            "entries",
            "cannot",
            "be",
            "modified",
            "via",
            "a",
            "nefarious",
            "implementation",
            "of",
            "equals"
        ]
    },
    {
        "id": 25,
        "code": "public TestSuite createTestSuite() {\n  withFeatures(KNOWN_ORDER);\n  return super.createTestSuite();\n}",
        "summary_tokens": [
            "specifies",
            "collection",
            "feature",
            "known",
            "order",
            "for",
            "all",
            "list",
            "tests",
            "since",
            "lists",
            "have",
            "an",
            "iteration",
            "ordering",
            "corresponding",
            "to",
            "the",
            "insertion",
            "order"
        ]
    },
    {
        "id": 26,
        "code": "protected Map<K, V> makeEitherMap() {\n  try {\n    return makePopulatedMap();\n  } catch (UnsupportedOperationException e) {\n    return makeEmptyMap();\n  }\n}",
        "summary_tokens": [
            "used",
            "by",
            "tests",
            "that",
            "require",
            "a",
            "map",
            "but",
            "don",
            "t",
            "care",
            "whether",
            "it",
            "s",
            "populated",
            "or",
            "not"
        ]
    },
    {
        "id": 27,
        "code": "protected final void assertInvariants(Map<K, V> map) {\n  Set<K> keySet = map.keySet();\n  Collection<V> valueCollection = map.values();\n  Set<Entry<K, V>> entrySet = map.entrySet();\n\n  assertEquals(map.size() == 0, map.isEmpty());\n  assertEquals(map.size(), keySet.size());\n  assertEquals(keySet.size() == 0, keySet.isEmpty());\n  assertEquals(!keySet.isEmpty(), keySet.iterator().hasNext());\n\n  int expectedKeySetHash = 0;\n  for (K key : keySet) {\n    V value = map.get(key);\n    expectedKeySetHash += key != null ? key.hashCode() : 0;\n    assertTrue(map.containsKey(key));\n    assertTrue(map.containsValue(value));\n    assertTrue(valueCollection.contains(value));\n    assertTrue(valueCollection.containsAll(Collections.singleton(value)));\n    assertTrue(entrySet.contains(mapEntry(key, value)));\n    assertTrue(allowsNullKeys || (key != null));\n  }\n  assertEquals(expectedKeySetHash, keySet.hashCode());\n\n  assertEquals(map.size(), valueCollection.size());\n  assertEquals(valueCollection.size() == 0, valueCollection.isEmpty());\n  assertEquals(!valueCollection.isEmpty(), valueCollection.iterator().hasNext());\n  for (V value : valueCollection) {\n    assertTrue(map.containsValue(value));\n    assertTrue(allowsNullValues || (value != null));\n  }\n\n  assertEquals(map.size(), entrySet.size());\n  assertEquals(entrySet.size() == 0, entrySet.isEmpty());\n  assertEquals(!entrySet.isEmpty(), entrySet.iterator().hasNext());\n  assertEntrySetNotContainsString(entrySet);\n\n  boolean supportsValuesHashCode = supportsValuesHashCode(map);\n  if (supportsValuesHashCode) {\n    int expectedEntrySetHash = 0;\n    for (Entry<K, V> entry : entrySet) {\n      assertTrue(map.containsKey(entry.getKey()));\n      assertTrue(map.containsValue(entry.getValue()));\n      int expectedHash =\n          (entry.getKey() == null ? 0 : entry.getKey().hashCode())\n              ^ (entry.getValue() == null ? 0 : entry.getValue().hashCode());\n      assertEquals(expectedHash, entry.hashCode());\n      expectedEntrySetHash += expectedHash;\n    }\n    assertEquals(expectedEntrySetHash, entrySet.hashCode());\n    assertTrue(entrySet.containsAll(new HashSet<Entry<K, V>>(entrySet)));\n    assertTrue(entrySet.equals(new HashSet<Entry<K, V>>(entrySet)));\n  }\n\n  Object[] entrySetToArray1 = entrySet.toArray();\n  assertEquals(map.size(), entrySetToArray1.length);\n  assertTrue(Arrays.asList(entrySetToArray1).containsAll(entrySet));\n\n  Entry<?, ?>[] entrySetToArray2 = new Entry<?, ?>[map.size() + 2];\n  entrySetToArray2[map.size()] = mapEntry(\"foo\", 1);\n  assertSame(entrySetToArray2, entrySet.toArray(entrySetToArray2));\n  assertNull(entrySetToArray2[map.size()]);\n  assertTrue(Arrays.asList(entrySetToArray2).containsAll(entrySet));\n\n  Object[] valuesToArray1 = valueCollection.toArray();\n  assertEquals(map.size(), valuesToArray1.length);\n  assertTrue(Arrays.asList(valuesToArray1).containsAll(valueCollection));\n\n  Object[] valuesToArray2 = new Object[map.size() + 2];\n  valuesToArray2[map.size()] = \"foo\";\n  assertSame(valuesToArray2, valueCollection.toArray(valuesToArray2));\n  assertNull(valuesToArray2[map.size()]);\n  assertTrue(Arrays.asList(valuesToArray2).containsAll(valueCollection));\n\n  if (supportsValuesHashCode) {\n    int expectedHash = 0;\n    for (Entry<K, V> entry : entrySet) {\n      expectedHash += entry.hashCode();\n    }\n    assertEquals(expectedHash, map.hashCode());\n  }\n\n  assertMoreInvariants(map);\n}",
        "summary_tokens": [
            "checks",
            "all",
            "the",
            "properties",
            "that",
            "should",
            "always",
            "hold",
            "of",
            "a",
            "map"
        ]
    },
    {
        "id": 28,
        "code": "protected void assertMoreInvariants(Map<K, V> map) {}",
        "summary_tokens": [
            "override",
            "this",
            "to",
            "check",
            "invariants",
            "which",
            "should",
            "hold",
            "true",
            "for",
            "a",
            "particular",
            "implementation",
            "but",
            "which",
            "are",
            "not",
            "generally",
            "applicable",
            "to",
            "every",
            "instance",
            "of",
            "map"
        ]
    },
    {
        "id": 29,
        "code": "public static <E> MinimalIterable<E> of(E... elements) {\n    \n  return new MinimalIterable<>(Arrays.asList(elements).iterator());\n}",
        "summary_tokens": [
            "returns",
            "an",
            "iterable",
            "whose",
            "iterator",
            "returns",
            "the",
            "given",
            "elements",
            "in",
            "order"
        ]
    },
    {
        "id": 30,
        "code": "public static <E> MinimalIterable<E> from(Collection<E> elements) {\n  return (MinimalIterable) of(elements.toArray());\n}",
        "summary_tokens": [
            "returns",
            "an",
            "iterable",
            "whose",
            "iterator",
            "returns",
            "the",
            "given",
            "elements",
            "in",
            "order"
        ]
    },
    {
        "id": 31,
        "code": "private TestSuite createDescendingSuite(\n    FeatureSpecificTestSuiteBuilder<\n            ?, ? extends OneSizeTestContainerGenerator<Map<K, V>, Entry<K, V>>>\n        parentBuilder) {\n  TestSortedMapGenerator<K, V> delegate =\n      (TestSortedMapGenerator<K, V>) parentBuilder.getSubjectGenerator().getInnerGenerator();\n\n  List<Feature<?>> features = new ArrayList<>();\n  features.add(NoRecurse.DESCENDING);\n  features.addAll(parentBuilder.getFeatures());\n\n  return subSuiteUsing(new DescendingTestMapGenerator<K, V>(delegate))\n      .named(parentBuilder.getName() + \" descending\")\n      .withFeatures(features)\n      .suppressing(parentBuilder.getSuppressedTests())\n      .createTestSuite();\n}",
        "summary_tokens": [
            "create",
            "a",
            "suite",
            "whose",
            "maps",
            "are",
            "descending",
            "views",
            "of",
            "other",
            "maps"
        ]
    },
    {
        "id": 32,
        "code": "private TestSuite createDescendingSuite(\n    FeatureSpecificTestSuiteBuilder<?, ? extends OneSizeTestContainerGenerator<Collection<E>, E>>\n        parentBuilder) {\n  TestSetGenerator<E> delegate =\n      (TestSetGenerator<E>) parentBuilder.getSubjectGenerator().getInnerGenerator();\n\n  List<Feature<?>> features = new ArrayList<>();\n  features.add(DESCENDING_VIEW);\n  features.addAll(parentBuilder.getFeatures());\n\n  return NavigableSetTestSuiteBuilder.using(\n          new TestSetGenerator<E>() {\n\n            @Override\n            public SampleElements<E> samples() {\n              return delegate.samples();\n            }\n\n            @Override\n            public E[] createArray(int length) {\n              return delegate.createArray(length);\n            }\n\n            @Override\n            public Iterable<E> order(List<E> insertionOrder) {\n              List<E> list = new ArrayList<>();\n              for (E e : delegate.order(insertionOrder)) {\n                list.add(e);\n              }\n              Collections.reverse(list);\n              return list;\n            }\n\n            @Override\n            public Set<E> create(Object... elements) {\n              NavigableSet<E> navigableSet = (NavigableSet<E>) delegate.create(elements);\n              return navigableSet.descendingSet();\n            }\n          })\n      .named(parentBuilder.getName() + \" descending\")\n      .withFeatures(features)\n      .suppressing(parentBuilder.getSuppressedTests())\n      .createTestSuite();\n}",
        "summary_tokens": [
            "create",
            "a",
            "suite",
            "whose",
            "maps",
            "are",
            "descending",
            "views",
            "of",
            "other",
            "maps"
        ]
    },
    {
        "id": 33,
        "code": "public TestSuite createTestSuite() {\n  checkCanCreate();\n\n  String name = getName();\n    \n  Set<Feature<?>> features = Helpers.copyToSet(getFeatures());\n  List<Class<? extends AbstractTester>> testers = getTesters();\n\n  logger.fine(\" Testing: \" + name);\n\n    \n  Set<Feature<?>> sizesToTest = Helpers.<Feature<?>>copyToSet(CollectionSize.values());\n  sizesToTest.retainAll(features);\n  features.removeAll(sizesToTest);\n\n  FeatureUtil.addImpliedFeatures(sizesToTest);\n  sizesToTest.retainAll(\n      Arrays.asList(CollectionSize.ZERO, CollectionSize.ONE, CollectionSize.SEVERAL));\n\n  logger.fine(\"   Sizes: \" + formatFeatureSet(sizesToTest));\n\n  if (sizesToTest.isEmpty()) {\n    throw new IllegalStateException(\n        name\n            + \": no CollectionSizes specified (check the argument to \"\n            + \"FeatureSpecificTestSuiteBuilder.withFeatures().)\");\n  }\n\n  TestSuite suite = new TestSuite(name);\n  for (Feature<?> collectionSize : sizesToTest) {\n    String oneSizeName =\n        Platform.format(\n            \"%s [collection size: %s]\", name, collectionSize.toString().toLowerCase());\n    OneSizeGenerator<T, E> oneSizeGenerator =\n        new OneSizeGenerator<>(getSubjectGenerator(), (CollectionSize) collectionSize);\n    Set<Feature<?>> oneSizeFeatures = Helpers.copyToSet(features);\n    oneSizeFeatures.add(collectionSize);\n    Set<Method> oneSizeSuppressedTests = getSuppressedTests();\n\n    OneSizeTestSuiteBuilder<T, E> oneSizeBuilder =\n        new OneSizeTestSuiteBuilder<T, E>(testers)\n            .named(oneSizeName)\n            .usingGenerator(oneSizeGenerator)\n            .withFeatures(oneSizeFeatures)\n            .withSetUp(getSetUp())\n            .withTearDown(getTearDown())\n            .suppressing(oneSizeSuppressedTests);\n    TestSuite oneSizeSuite = oneSizeBuilder.createTestSuite();\n    suite.addTest(oneSizeSuite);\n\n    for (TestSuite derivedSuite : createDerivedSuites(oneSizeBuilder)) {\n      oneSizeSuite.addTest(derivedSuite);\n    }\n  }\n  return suite;\n}",
        "summary_tokens": [
            "creates",
            "a",
            "runnable",
            "junit",
            "test",
            "suite",
            "based",
            "on",
            "the",
            "criteria",
            "already",
            "given"
        ]
    },
    {
        "id": 34,
        "code": "public QueueTestSuiteBuilder<E> skipCollectionTests() {\n  runCollectionTests = false;\n  return this;\n}",
        "summary_tokens": [
            "specify",
            "whether",
            "to",
            "skip",
            "the",
            "general",
            "collection",
            "tests"
        ]
    },
    {
        "id": 35,
        "code": "final TestSuite createSubmapSuite(\n    FeatureSpecificTestSuiteBuilder<\n            ?, ? extends OneSizeTestContainerGenerator<Map<K, V>, Entry<K, V>>>\n        parentBuilder,\n    Bound from,\n    Bound to) {\n  TestSortedMapGenerator<K, V> delegate =\n      (TestSortedMapGenerator<K, V>) parentBuilder.getSubjectGenerator().getInnerGenerator();\n\n  List<Feature<?>> features = new ArrayList<>();\n  features.add(NoRecurse.SUBMAP);\n  features.addAll(parentBuilder.getFeatures());\n\n  return newBuilderUsing(delegate, to, from)\n      .named(parentBuilder.getName() + \" subMap \" + from + \"-\" + to)\n      .withFeatures(features)\n      .suppressing(parentBuilder.getSuppressedTests())\n      .withSetUp(parentBuilder.getSetUp())\n      .withTearDown(parentBuilder.getTearDown())\n      .createTestSuite();\n}",
        "summary_tokens": [
            "creates",
            "a",
            "suite",
            "whose",
            "map",
            "has",
            "some",
            "elements",
            "filtered",
            "out",
            "of",
            "view"
        ]
    },
    {
        "id": 36,
        "code": "SortedMapTestSuiteBuilder<K, V> newBuilderUsing(\n    TestSortedMapGenerator<K, V> delegate, Bound to, Bound from) {\n  return using(new SortedMapSubmapTestMapGenerator<K, V>(delegate, to, from));\n}",
        "summary_tokens": [
            "like",
            "using",
            "but",
            "overrideable",
            "by",
            "navigable",
            "map",
            "test",
            "suite",
            "builder"
        ]
    },
    {
        "id": 37,
        "code": "final TestSuite createSubsetSuite(\n    FeatureSpecificTestSuiteBuilder<?, ? extends OneSizeTestContainerGenerator<Collection<E>, E>>\n        parentBuilder,\n    Bound from,\n    Bound to) {\n  TestSortedSetGenerator<E> delegate =\n      (TestSortedSetGenerator<E>) parentBuilder.getSubjectGenerator().getInnerGenerator();\n\n  List<Feature<?>> features = new ArrayList<>(parentBuilder.getFeatures());\n  features.remove(CollectionFeature.ALLOWS_NULL_VALUES);\n  features.add(CollectionFeature.SUBSET_VIEW);\n\n  return newBuilderUsing(delegate, to, from)\n      .named(parentBuilder.getName() + \" subSet \" + from + \"-\" + to)\n      .withFeatures(features)\n      .suppressing(parentBuilder.getSuppressedTests())\n      .withSetUp(parentBuilder.getSetUp())\n      .withTearDown(parentBuilder.getTearDown())\n      .createTestSuite();\n}",
        "summary_tokens": [
            "creates",
            "a",
            "suite",
            "whose",
            "set",
            "has",
            "some",
            "elements",
            "filtered",
            "out",
            "of",
            "view"
        ]
    },
    {
        "id": 38,
        "code": "SortedSetTestSuiteBuilder<E> newBuilderUsing(\n    TestSortedSetGenerator<E> delegate, Bound to, Bound from) {\n  return using(new SortedSetSubsetTestSetGenerator<E>(delegate, to, from));\n}",
        "summary_tokens": [
            "like",
            "using",
            "but",
            "overrideable",
            "by",
            "navigable",
            "set",
            "test",
            "suite",
            "builder"
        ]
    },
    {
        "id": 39,
        "code": "public List<Character> order(List<Character> insertionOrder) {\n  return insertionOrder;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "original",
            "element",
            "list",
            "unchanged"
        ]
    },
    {
        "id": 40,
        "code": "public List<Object> order(List<Object> insertionOrder) {\n  return insertionOrder;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "original",
            "element",
            "list",
            "unchanged"
        ]
    },
    {
        "id": 41,
        "code": "public Iterable<Entry<AnEnum, String>> order(List<Entry<AnEnum, String>> insertionOrder) {\n  return orderEntriesByKey(insertionOrder);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "elements",
            "sorted",
            "in",
            "natural",
            "order"
        ]
    },
    {
        "id": 42,
        "code": "public List<AnEnum> order(List<AnEnum> insertionOrder) {\n  Collections.sort(insertionOrder);\n  return insertionOrder;\n}",
        "summary_tokens": [
            "sorts",
            "the",
            "enums",
            "according",
            "to",
            "their",
            "natural",
            "ordering"
        ]
    },
    {
        "id": 43,
        "code": "public List<Integer> order(List<Integer> insertionOrder) {\n  Collections.sort(insertionOrder);\n  return insertionOrder;\n}",
        "summary_tokens": [
            "sorts",
            "the",
            "elements",
            "by",
            "their",
            "natural",
            "ordering"
        ]
    },
    {
        "id": 44,
        "code": "public List<Entry<K, V>> order(List<Entry<K, V>> insertionOrder) {\n  return insertionOrder;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "original",
            "element",
            "list",
            "unchanged"
        ]
    },
    {
        "id": 45,
        "code": "public List<String> order(List<String> insertionOrder) {\n  return insertionOrder;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "original",
            "element",
            "list",
            "unchanged"
        ]
    },
    {
        "id": 46,
        "code": "public List<String> order(List<String> insertionOrder) {\n  return insertionOrder;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "original",
            "element",
            "list",
            "unchanged"
        ]
    },
    {
        "id": 47,
        "code": "public Iterable<Entry<String, String>> order(List<Entry<String, String>> insertionOrder) {\n  return insertionOrder;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "original",
            "element",
            "list",
            "unchanged"
        ]
    },
    {
        "id": 48,
        "code": "public List<String> order(List<String> insertionOrder) {\n  return insertionOrder;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "original",
            "element",
            "list",
            "unchanged"
        ]
    },
    {
        "id": 49,
        "code": "public List<String> order(List<String> insertionOrder) {\n  Collections.sort(insertionOrder);\n  return insertionOrder;\n}",
        "summary_tokens": [
            "sorts",
            "the",
            "elements",
            "by",
            "their",
            "natural",
            "ordering"
        ]
    },
    {
        "id": 50,
        "code": "public static Set<Feature<?>> addImpliedFeatures(Set<Feature<?>> features) {\n  Queue<Feature<?>> queue = new ArrayDeque<>(features);\n  while (!queue.isEmpty()) {\n    Feature<?> feature = queue.remove();\n    for (Feature<?> implied : feature.getImpliedFeatures()) {\n      if (features.add(implied)) {\n        queue.add(implied);\n      }\n    }\n  }\n  return features;\n}",
        "summary_tokens": [
            "given",
            "a",
            "set",
            "of",
            "features",
            "add",
            "to",
            "it",
            "all",
            "the",
            "features",
            "directly",
            "or",
            "indirectly",
            "implied",
            "by",
            "any",
            "of",
            "them",
            "and",
            "return",
            "it"
        ]
    },
    {
        "id": 51,
        "code": "public static Set<Feature<?>> impliedFeatures(Set<Feature<?>> features) {\n  Set<Feature<?>> impliedSet = new LinkedHashSet<>();\n  Queue<Feature<?>> queue = new ArrayDeque<>(features);\n  while (!queue.isEmpty()) {\n    Feature<?> feature = queue.remove();\n    for (Feature<?> implied : feature.getImpliedFeatures()) {\n      if (!features.contains(implied) && impliedSet.add(implied)) {\n        queue.add(implied);\n      }\n    }\n  }\n  return impliedSet;\n}",
        "summary_tokens": [
            "given",
            "a",
            "set",
            "of",
            "features",
            "return",
            "a",
            "new",
            "set",
            "of",
            "all",
            "features",
            "directly",
            "or",
            "indirectly",
            "implied",
            "by",
            "any",
            "of",
            "them"
        ]
    },
    {
        "id": 52,
        "code": "public static TesterRequirements getTesterRequirements(Method testerMethod)\n    throws ConflictingRequirementsException {\n  synchronized (methodTesterRequirementsCache) {\n    TesterRequirements requirements = methodTesterRequirementsCache.get(testerMethod);\n    if (requirements == null) {\n      requirements = buildTesterRequirements(testerMethod);\n      methodTesterRequirementsCache.put(testerMethod, requirements);\n    }\n    return requirements;\n  }\n}",
        "summary_tokens": [
            "get",
            "the",
            "full",
            "set",
            "of",
            "requirements",
            "for",
            "a",
            "tester",
            "class"
        ]
    },
    {
        "id": 53,
        "code": "private static TesterRequirements buildTesterRequirements(Annotation testerAnnotation)\n    throws ConflictingRequirementsException {\n  Class<? extends Annotation> annotationClass = testerAnnotation.annotationType();\n  Feature<?>[] presentFeatures;\n  Feature<?>[] absentFeatures;\n  try {\n    presentFeatures = (Feature[]) annotationClass.getMethod(\"value\").invoke(testerAnnotation);\n    absentFeatures = (Feature[]) annotationClass.getMethod(\"absent\").invoke(testerAnnotation);\n  } catch (Exception e) {\n    throw new IllegalArgumentException(\"Error extracting features from tester annotation.\", e);\n  }\n  Set<Feature<?>> allPresentFeatures =\n      addImpliedFeatures(Helpers.<Feature<?>>copyToSet(presentFeatures));\n  Set<Feature<?>> allAbsentFeatures =\n      addImpliedFeatures(Helpers.<Feature<?>>copyToSet(absentFeatures));\n  if (!Collections.disjoint(allPresentFeatures, allAbsentFeatures)) {\n    throw new ConflictingRequirementsException(\n        \"Annotation explicitly or \"\n            + \"implicitly requires one or more features to be both present \"\n            + \"and absent.\",\n        intersection(allPresentFeatures, allAbsentFeatures),\n        testerAnnotation);\n  }\n  return new TesterRequirements(allPresentFeatures, allAbsentFeatures);\n}",
        "summary_tokens": [
            "find",
            "all",
            "the",
            "constraints",
            "explicitly",
            "or",
            "implicitly",
            "specified",
            "by",
            "a",
            "single",
            "tester",
            "annotation"
        ]
    },
    {
        "id": 54,
        "code": "public static TesterRequirements buildDeclaredTesterRequirements(AnnotatedElement classOrMethod)\n    throws ConflictingRequirementsException {\n  TesterRequirements requirements = new TesterRequirements();\n\n  Iterable<Annotation> testerAnnotations = getTesterAnnotations(classOrMethod);\n  for (Annotation testerAnnotation : testerAnnotations) {\n    TesterRequirements moreRequirements = buildTesterRequirements(testerAnnotation);\n    incorporateRequirements(requirements, moreRequirements, testerAnnotation);\n  }\n\n  return requirements;\n}",
        "summary_tokens": [
            "construct",
            "the",
            "set",
            "of",
            "requirements",
            "specified",
            "by",
            "annotations",
            "directly",
            "on",
            "a",
            "tester",
            "class",
            "or",
            "method"
        ]
    },
    {
        "id": 55,
        "code": "public static Iterable<Annotation> getTesterAnnotations(AnnotatedElement classOrMethod) {\n  synchronized (annotationCache) {\n    List<Annotation> annotations = annotationCache.get(classOrMethod);\n    if (annotations == null) {\n      annotations = new ArrayList<>();\n      for (Annotation a : classOrMethod.getDeclaredAnnotations()) {\n        if (a.annotationType().isAnnotationPresent(TesterAnnotation.class)) {\n          annotations.add(a);\n        }\n      }\n      annotations = Collections.unmodifiableList(annotations);\n      annotationCache.put(classOrMethod, annotations);\n    }\n    return annotations;\n  }\n}",
        "summary_tokens": [
            "find",
            "all",
            "the",
            "tester",
            "annotations",
            "declared",
            "on",
            "a",
            "tester",
            "class",
            "or",
            "method"
        ]
    },
    {
        "id": 56,
        "code": "private static TesterRequirements incorporateRequirements(\n    TesterRequirements requirements, TesterRequirements moreRequirements, Object source)\n    throws ConflictingRequirementsException {\n  Set<Feature<?>> presentFeatures = requirements.getPresentFeatures();\n  Set<Feature<?>> absentFeatures = requirements.getAbsentFeatures();\n  Set<Feature<?>> morePresentFeatures = moreRequirements.getPresentFeatures();\n  Set<Feature<?>> moreAbsentFeatures = moreRequirements.getAbsentFeatures();\n  checkConflict(\"absent\", absentFeatures, \"present\", morePresentFeatures, source);\n  checkConflict(\"present\", presentFeatures, \"absent\", moreAbsentFeatures, source);\n  presentFeatures.addAll(morePresentFeatures);\n  absentFeatures.addAll(moreAbsentFeatures);\n  return requirements;\n}",
        "summary_tokens": [
            "incorporate",
            "additional",
            "requirements",
            "into",
            "an",
            "existing",
            "requirements",
            "object"
        ]
    },
    {
        "id": 57,
        "code": "public static <T> Set<T> intersection(Set<? extends T> set1, Set<? extends T> set2) {\n  Set<T> result = Helpers.<T>copyToSet(set1);\n  result.retainAll(set2);\n  return result;\n}",
        "summary_tokens": [
            "construct",
            "a",
            "new",
            "java"
        ]
    },
    {
        "id": 58,
        "code": "protected Entry<K, V>[] createArrayWithNullKey() {\n  Entry<K, V>[] array = createSamplesArray();\n  int nullKeyLocation = getNullLocation();\n  Entry<K, V> oldEntry = array[nullKeyLocation];\n  array[nullKeyLocation] = Helpers.mapEntry(null, oldEntry.getValue());\n  return array;\n}",
        "summary_tokens": [
            "an",
            "array",
            "of",
            "the",
            "proper",
            "size",
            "with",
            "null",
            "as",
            "the",
            "key",
            "of",
            "the",
            "middle",
            "element"
        ]
    },
    {
        "id": 59,
        "code": "protected Entry<K, V>[] createArrayWithNullValue() {\n  Entry<K, V>[] array = createSamplesArray();\n  int nullValueLocation = getNullLocation();\n  Entry<K, V> oldEntry = array[nullValueLocation];\n  array[nullValueLocation] = Helpers.mapEntry(oldEntry.getKey(), null);\n  return array;\n}",
        "summary_tokens": [
            "an",
            "array",
            "of",
            "the",
            "proper",
            "size",
            "with",
            "null",
            "as",
            "the",
            "value",
            "of",
            "the",
            "middle",
            "element"
        ]
    },
    {
        "id": 60,
        "code": "protected Entry<K, V>[] createArrayWithNullKeyAndValue() {\n  Entry<K, V>[] array = createSamplesArray();\n  int nullValueLocation = getNullLocation();\n  array[nullValueLocation] = Helpers.mapEntry(null, null);\n  return array;\n}",
        "summary_tokens": [
            "an",
            "array",
            "of",
            "the",
            "proper",
            "size",
            "with",
            "null",
            "as",
            "the",
            "key",
            "and",
            "value",
            "of",
            "the",
            "middle",
            "element"
        ]
    },
    {
        "id": 61,
        "code": "public static List<Method> getSetCountDuplicateInitializingMethods() {\n  return Arrays.asList(\n      getMethod(\"testSetCount_threeToThree_removeSupported\"),\n      getMethod(\"testSetCount_threeToZero_supported\"),\n      getMethod(\"testSetCount_threeToOne_supported\"));\n}",
        "summary_tokens": [
            "returns",
            "method",
            "instances",
            "for",
            "the",
            "set",
            "count",
            "tests",
            "that",
            "assume",
            "multisets",
            "support",
            "duplicates",
            "so",
            "that",
            "the",
            "test",
            "of",
            "multisets"
        ]
    },
    {
        "id": 62,
        "code": "public static List<Method> getInverseSameAfterSerializingMethods() {\n  return Collections.singletonList(getMethod(\"testInverseSerialization\"));\n}",
        "summary_tokens": [
            "returns",
            "method",
            "instances",
            "for",
            "the",
            "tests",
            "that",
            "assume",
            "that",
            "the",
            "inverse",
            "will",
            "be",
            "the",
            "same",
            "after",
            "serialization"
        ]
    },
    {
        "id": 63,
        "code": "public static List<Method> getCountDuplicateInitializingMethods() {\n  return Arrays.asList(Helpers.getMethod(MultisetCountTester.class, \"testCount_3\"));\n}",
        "summary_tokens": [
            "returns",
            "method",
            "instances",
            "for",
            "the",
            "read",
            "tests",
            "that",
            "assume",
            "multisets",
            "support",
            "duplicates",
            "so",
            "that",
            "the",
            "test",
            "of",
            "multisets"
        ]
    },
    {
        "id": 64,
        "code": "public static List<Method> getElementSetDuplicateInitializingMethods() {\n  return Arrays.asList(\n      Helpers.getMethod(\n          MultisetElementSetTester.class, \"testElementSetRemoveDuplicatePropagatesToMultiset\"));\n}",
        "summary_tokens": [
            "returns",
            "method",
            "instances",
            "for",
            "the",
            "read",
            "tests",
            "that",
            "assume",
            "multisets",
            "support",
            "duplicates",
            "so",
            "that",
            "the",
            "test",
            "of",
            "multisets"
        ]
    },
    {
        "id": 65,
        "code": "public static List<Method> getIteratorDuplicateInitializingMethods() {\n  return Arrays.asList(\n      Helpers.getMethod(MultisetIteratorTester.class, \"testIteratorKnownOrder\"),\n      Helpers.getMethod(MultisetIteratorTester.class, \"testIteratorUnknownOrder\"),\n      Helpers.getMethod(MultisetIteratorTester.class, \"testRemovingIteratorKnownOrder\"),\n      Helpers.getMethod(MultisetIteratorTester.class, \"testRemovingIteratorUnknownOrder\"));\n}",
        "summary_tokens": [
            "returns",
            "method",
            "instances",
            "for",
            "the",
            "tests",
            "that",
            "assume",
            "multisets",
            "support",
            "duplicates",
            "so",
            "that",
            "the",
            "test",
            "of",
            "multisets"
        ]
    },
    {
        "id": 66,
        "code": "static <T> SortedMultiset<T> cast(Multiset<T> iterable) {\n  return (SortedMultiset<T>) iterable;\n}",
        "summary_tokens": [
            "used",
            "to",
            "avoid",
            "http",
            "bugs"
        ]
    },
    {
        "id": 67,
        "code": "private void resetWithHole() {\n  List<E> container = new ArrayList<>();\n  container.addAll(Collections.nCopies(a.getCount(), a.getElement()));\n  container.addAll(Collections.nCopies(c.getCount(), c.getElement()));\n  super.resetContainer(getSubjectGenerator().create(container.toArray()));\n  sortedMultiset = (SortedMultiset<E>) getMultiset();\n}",
        "summary_tokens": [
            "resets",
            "the",
            "contents",
            "of",
            "sorted",
            "multiset",
            "to",
            "have",
            "entries",
            "a",
            "c",
            "for",
            "the",
            "navigation",
            "tests"
        ]
    },
    {
        "id": 68,
        "code": "public static List<Method> getRemoveDuplicateInitializingMethods() {\n  return Arrays.asList(\n      Helpers.getMethod(MultisetRemoveTester.class, \"testRemove_some_occurrences_present\"));\n}",
        "summary_tokens": [
            "returns",
            "method",
            "instances",
            "for",
            "the",
            "remove",
            "tests",
            "that",
            "assume",
            "multisets",
            "support",
            "duplicates",
            "so",
            "that",
            "the",
            "test",
            "of",
            "multisets"
        ]
    },
    {
        "id": 69,
        "code": "private List<String> getExtremeValues() {\n  List<String> result = new ArrayList<>();\n  result.add(\"!! a\");\n  result.add(\"!! b\");\n  result.add(\"~~ y\");\n  result.add(\"~~ z\");\n  return result;\n}",
        "summary_tokens": [
            "returns",
            "an",
            "array",
            "of",
            "four",
            "bogus",
            "elements",
            "that",
            "will",
            "always",
            "be",
            "too",
            "high",
            "or",
            "too",
            "low",
            "for",
            "the",
            "display"
        ]
    },
    {
        "id": 70,
        "code": "public List<AnEnum> order(List<AnEnum> insertionOrder) {\n  Collections.sort(insertionOrder);\n  return insertionOrder;\n}",
        "summary_tokens": [
            "sorts",
            "the",
            "enums",
            "according",
            "to",
            "their",
            "natural",
            "ordering"
        ]
    },
    {
        "id": 71,
        "code": "public Iterable<Entry<String, String>> order(List<Entry<String, String>> insertionOrder) {\n  return insertionOrder;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "original",
            "element",
            "list",
            "unchanged"
        ]
    },
    {
        "id": 72,
        "code": "public Iterable<Entry<String, String>> order(List<Entry<String, String>> insertionOrder) {\n  return insertionOrder;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "original",
            "element",
            "list",
            "unchanged"
        ]
    },
    {
        "id": 73,
        "code": "public List<String> order(List<String> insertionOrder) {\n  return insertionOrder;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "original",
            "element",
            "list",
            "unchanged"
        ]
    },
    {
        "id": 74,
        "code": "public Iterable<Entry<String, String>> order(List<Entry<String, String>> insertionOrder) {\n  return insertionOrder;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "original",
            "element",
            "list",
            "unchanged"
        ]
    },
    {
        "id": 75,
        "code": "public static void assertIteratorIsUnmodifiable(Iterator<?> iterator) {\n  while (iterator.hasNext()) {\n    iterator.next();\n    try {\n      iterator.remove();\n      fail(\"Remove on unmodifiable iterator succeeded\");\n    } catch (UnsupportedOperationException expected) {\n    }\n  }\n}",
        "summary_tokens": [
            "verifies",
            "that",
            "an",
            "iterator",
            "is",
            "unmodifiable"
        ]
    },
    {
        "id": 76,
        "code": "public static void assertIteratorsInOrder(\n    Iterator<?> expectedIterator, Iterator<?> actualIterator) {\n  int i = 0;\n  while (expectedIterator.hasNext()) {\n    Object expected = expectedIterator.next();\n\n    assertTrue(\n        \"index \" + i + \" expected <\" + expected + \"., actual is exhausted\",\n        actualIterator.hasNext());\n\n    Object actual = actualIterator.next();\n    assertEquals(\"index \" + i, expected, actual);\n    i++;\n  }\n  if (actualIterator.hasNext()) {\n    fail(\"index \" + i + \", expected is exhausted, actual <\" + actualIterator.next() + \">\");\n  }\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "two",
            "iterators",
            "contain",
            "elements",
            "in",
            "tandem"
        ]
    },
    {
        "id": 77,
        "code": "public static <E> void assertCollectionIsUnmodifiable(Collection<E> collection, E sampleElement) {\n  Collection<E> siblingCollection = new ArrayList<>();\n  siblingCollection.add(sampleElement);\n\n  Collection<E> copy = new ArrayList<>();\n    \n    \n  Iterators.addAll(copy, collection.iterator());\n\n  try {\n    collection.add(sampleElement);\n    fail(\"add succeeded on unmodifiable collection\");\n  } catch (UnsupportedOperationException expected) {\n  }\n\n  assertCollectionsAreEquivalent(copy, collection);\n\n  try {\n    collection.addAll(siblingCollection);\n    fail(\"addAll succeeded on unmodifiable collection\");\n  } catch (UnsupportedOperationException expected) {\n  }\n  assertCollectionsAreEquivalent(copy, collection);\n\n  try {\n    collection.clear();\n    fail(\"clear succeeded on unmodifiable collection\");\n  } catch (UnsupportedOperationException expected) {\n  }\n  assertCollectionsAreEquivalent(copy, collection);\n\n  assertIteratorIsUnmodifiable(collection.iterator());\n  assertCollectionsAreEquivalent(copy, collection);\n\n  try {\n    collection.remove(sampleElement);\n    fail(\"remove succeeded on unmodifiable collection\");\n  } catch (UnsupportedOperationException expected) {\n  }\n  assertCollectionsAreEquivalent(copy, collection);\n\n  try {\n    collection.removeAll(siblingCollection);\n    fail(\"removeAll succeeded on unmodifiable collection\");\n  } catch (UnsupportedOperationException expected) {\n  }\n  assertCollectionsAreEquivalent(copy, collection);\n\n  try {\n    collection.retainAll(siblingCollection);\n    fail(\"retainAll succeeded on unmodifiable collection\");\n  } catch (UnsupportedOperationException expected) {\n  }\n  assertCollectionsAreEquivalent(copy, collection);\n}",
        "summary_tokens": [
            "verifies",
            "that",
            "a",
            "collection",
            "is",
            "immutable"
        ]
    },
    {
        "id": 78,
        "code": "public static <E> void assertSetIsUnmodifiable(Set<E> set, E sampleElement) {\n  assertCollectionIsUnmodifiable(set, sampleElement);\n}",
        "summary_tokens": [
            "verifies",
            "that",
            "a",
            "set",
            "is",
            "immutable"
        ]
    },
    {
        "id": 79,
        "code": "public static <E> void assertMultisetIsUnmodifiable(Multiset<E> multiset, E sampleElement) {\n  Multiset<E> copy = LinkedHashMultiset.create(multiset);\n  assertCollectionsAreEquivalent(multiset, copy);\n\n    \n  assertCollectionIsUnmodifiable(multiset, sampleElement);\n\n  assertCollectionsAreEquivalent(multiset, copy);\n\n  try {\n    multiset.add(sampleElement, 2);\n    fail(\"add(Object, int) succeeded on unmodifiable collection\");\n  } catch (UnsupportedOperationException expected) {\n  }\n  assertCollectionsAreEquivalent(multiset, copy);\n\n  try {\n    multiset.remove(sampleElement, 2);\n    fail(\"remove(Object, int) succeeded on unmodifiable collection\");\n  } catch (UnsupportedOperationException expected) {\n  }\n  assertCollectionsAreEquivalent(multiset, copy);\n\n  assertCollectionsAreEquivalent(multiset, copy);\n\n  assertSetIsUnmodifiable(multiset.elementSet(), sampleElement);\n  assertCollectionsAreEquivalent(multiset, copy);\n\n  assertSetIsUnmodifiable(\n      multiset.entrySet(),\n      new Multiset.Entry<E>() {\n        @Override\n        public int getCount() {\n          return 1;\n        }\n\n        @Override\n        public E getElement() {\n          return sampleElement;\n        }\n      });\n  assertCollectionsAreEquivalent(multiset, copy);\n}",
        "summary_tokens": [
            "verifies",
            "that",
            "a",
            "multiset",
            "is",
            "immutable"
        ]
    },
    {
        "id": 80,
        "code": "public static <K, V> void assertMultimapIsUnmodifiable(\n    Multimap<K, V> multimap, K sampleKey, V sampleValue) {\n  List<Entry<K, V>> originalEntries =\n      Collections.unmodifiableList(Lists.newArrayList(multimap.entries()));\n\n  assertMultimapRemainsUnmodified(multimap, originalEntries);\n\n  Collection<V> sampleValueAsCollection = Collections.singleton(sampleValue);\n\n    \n  try {\n    multimap.clear();\n    fail(\"clear succeeded on unmodifiable multimap\");\n  } catch (UnsupportedOperationException expected) {\n  }\n\n  assertMultimapRemainsUnmodified(multimap, originalEntries);\n\n    \n  assertSetIsUnmodifiable(\n      multimap.asMap().entrySet(), Maps.immutableEntry(sampleKey, sampleValueAsCollection));\n\n    \n\n  assertMultimapRemainsUnmodified(multimap, originalEntries);\n  if (!multimap.isEmpty()) {\n    Collection<V> values = multimap.asMap().entrySet().iterator().next().getValue();\n\n    assertCollectionIsUnmodifiable(values, sampleValue);\n  }\n\n    \n  assertCollectionIsUnmodifiable(multimap.entries(), Maps.immutableEntry(sampleKey, sampleValue));\n  assertMultimapRemainsUnmodified(multimap, originalEntries);\n\n    \n  for (Entry<K, V> entry : multimap.entries()) {\n    assertMapEntryIsUnmodifiable(entry);\n  }\n  assertMultimapRemainsUnmodified(multimap, originalEntries);\n\n    \n  assertMultisetIsUnmodifiable(multimap.keys(), sampleKey);\n  assertMultimapRemainsUnmodified(multimap, originalEntries);\n\n    \n  assertSetIsUnmodifiable(multimap.keySet(), sampleKey);\n  assertMultimapRemainsUnmodified(multimap, originalEntries);\n\n    \n  if (!multimap.isEmpty()) {\n    K key = multimap.keySet().iterator().next();\n    assertCollectionIsUnmodifiable(multimap.get(key), sampleValue);\n    assertMultimapRemainsUnmodified(multimap, originalEntries);\n  }\n\n    \n  try {\n    multimap.put(sampleKey, sampleValue);\n    fail(\"put succeeded on unmodifiable multimap\");\n  } catch (UnsupportedOperationException expected) {\n  }\n  assertMultimapRemainsUnmodified(multimap, originalEntries);\n\n    \n  try {\n    multimap.putAll(sampleKey, sampleValueAsCollection);\n    fail(\"putAll(K, Iterable) succeeded on unmodifiable multimap\");\n  } catch (UnsupportedOperationException expected) {\n  }\n  assertMultimapRemainsUnmodified(multimap, originalEntries);\n\n    \n  Multimap<K, V> multimap2 = ArrayListMultimap.create();\n  multimap2.put(sampleKey, sampleValue);\n  try {\n    multimap.putAll(multimap2);\n    fail(\"putAll(Multimap<K, V>) succeeded on unmodifiable multimap\");\n  } catch (UnsupportedOperationException expected) {\n  }\n  assertMultimapRemainsUnmodified(multimap, originalEntries);\n\n    \n  try {\n    multimap.remove(sampleKey, sampleValue);\n    fail(\"remove succeeded on unmodifiable multimap\");\n  } catch (UnsupportedOperationException expected) {\n  }\n  assertMultimapRemainsUnmodified(multimap, originalEntries);\n\n    \n  try {\n    multimap.removeAll(sampleKey);\n    fail(\"removeAll succeeded on unmodifiable multimap\");\n  } catch (UnsupportedOperationException expected) {\n  }\n  assertMultimapRemainsUnmodified(multimap, originalEntries);\n\n    \n  try {\n    multimap.replaceValues(sampleKey, sampleValueAsCollection);\n    fail(\"replaceValues succeeded on unmodifiable multimap\");\n  } catch (UnsupportedOperationException expected) {\n  }\n  assertMultimapRemainsUnmodified(multimap, originalEntries);\n\n    \n  try {\n    multimap.asMap().remove(sampleKey);\n    fail(\"asMap().remove() succeeded on unmodifiable multimap\");\n  } catch (UnsupportedOperationException expected) {\n  }\n  assertMultimapRemainsUnmodified(multimap, originalEntries);\n\n  if (!multimap.isEmpty()) {\n    K presentKey = multimap.keySet().iterator().next();\n    try {\n      multimap.asMap().get(presentKey).remove(sampleValue);\n      fail(\"asMap().get().remove() succeeded on unmodifiable multimap\");\n    } catch (UnsupportedOperationException expected) {\n    }\n    assertMultimapRemainsUnmodified(multimap, originalEntries);\n\n    try {\n      multimap.asMap().values().iterator().next().remove(sampleValue);\n      fail(\"asMap().values().iterator().next().remove() succeeded on unmodifiable multimap\");\n    } catch (UnsupportedOperationException expected) {\n    }\n\n    try {\n      ((Collection<?>) multimap.asMap().values().toArray()[0]).clear();\n      fail(\"asMap().values().toArray()[0].clear() succeeded on unmodifiable multimap\");\n    } catch (UnsupportedOperationException expected) {\n    }\n  }\n\n  assertCollectionIsUnmodifiable(multimap.values(), sampleValue);\n  assertMultimapRemainsUnmodified(multimap, originalEntries);\n}",
        "summary_tokens": [
            "verifies",
            "that",
            "a",
            "multimap",
            "is",
            "immutable"
        ]
    },
    {
        "id": 81,
        "code": "private String reportContext(List<E> expected) {\n  return Platform.format(\n      \"expected collection %s; actual collection %s\", expected, this.collection);\n}",
        "summary_tokens": [
            "used",
            "to",
            "delay",
            "string",
            "formatting",
            "until",
            "actually",
            "required",
            "as",
            "it",
            "otherwise",
            "shows",
            "up",
            "in",
            "the",
            "test",
            "execution",
            "profile",
            "when",
            "running",
            "an",
            "extremely",
            "large",
            "numbers",
            "of",
            "tests"
        ]
    },
    {
        "id": 82,
        "code": "public static Method getAddAllNullUnsupportedMethod() {\n  return Helpers.getMethod(CollectionAddAllTester.class, \"testAddAll_nullUnsupported\");\n}",
        "summary_tokens": [
            "returns",
            "the",
            "method",
            "instance",
            "for",
            "test",
            "add",
            "all",
            "null",
            "unsupported",
            "so",
            "that",
            "tests",
            "can",
            "suppress",
            "it",
            "with",
            "feature",
            "specific",
            "test",
            "suite",
            "builder"
        ]
    },
    {
        "id": 83,
        "code": "public static Method getAddAllUnsupportedNonePresentMethod() {\n  return Helpers.getMethod(CollectionAddAllTester.class, \"testAddAll_unsupportedNonePresent\");\n}",
        "summary_tokens": [
            "returns",
            "the",
            "method",
            "instance",
            "for",
            "test",
            "add",
            "all",
            "unsupported",
            "none",
            "present",
            "so",
            "that",
            "tests",
            "can",
            "suppress",
            "it",
            "with",
            "feature",
            "specific",
            "test",
            "suite",
            "builder"
        ]
    },
    {
        "id": 84,
        "code": "public static Method getAddAllUnsupportedSomePresentMethod() {\n  return Helpers.getMethod(CollectionAddAllTester.class, \"testAddAll_unsupportedSomePresent\");\n}",
        "summary_tokens": [
            "returns",
            "the",
            "method",
            "instance",
            "for",
            "test",
            "add",
            "all",
            "unsupported",
            "some",
            "present",
            "so",
            "that",
            "tests",
            "can",
            "suppress",
            "it",
            "with",
            "feature",
            "specific",
            "test",
            "suite",
            "builder"
        ]
    },
    {
        "id": 85,
        "code": "public static Method getAddNullSupportedMethod() {\n  return Helpers.getMethod(CollectionAddTester.class, \"testAdd_nullSupported\");\n}",
        "summary_tokens": [
            "returns",
            "the",
            "method",
            "instance",
            "for",
            "test",
            "add",
            "null",
            "supported",
            "so",
            "that",
            "tests",
            "of",
            "java"
        ]
    },
    {
        "id": 86,
        "code": "public static Method getAddNullUnsupportedMethod() {\n  return Helpers.getMethod(CollectionAddTester.class, \"testAdd_nullUnsupported\");\n}",
        "summary_tokens": [
            "returns",
            "the",
            "method",
            "instance",
            "for",
            "test",
            "add",
            "null",
            "supported",
            "so",
            "that",
            "tests",
            "of",
            "java"
        ]
    },
    {
        "id": 87,
        "code": "public static Method getAddUnsupportedNotPresentMethod() {\n  return Helpers.getMethod(CollectionAddTester.class, \"testAdd_unsupportedNotPresent\");\n}",
        "summary_tokens": [
            "returns",
            "the",
            "method",
            "instance",
            "for",
            "test",
            "add",
            "unsupported",
            "not",
            "present",
            "so",
            "that",
            "tests",
            "can",
            "suppress",
            "it",
            "with",
            "feature",
            "specific",
            "test",
            "suite",
            "builder"
        ]
    },
    {
        "id": 88,
        "code": "public static Method getCreateWithNullUnsupportedMethod() {\n  return Helpers.getMethod(CollectionCreationTester.class, \"testCreateWithNull_unsupported\");\n}",
        "summary_tokens": [
            "returns",
            "the",
            "method",
            "instance",
            "for",
            "test",
            "create",
            "with",
            "null",
            "unsupported",
            "so",
            "that",
            "tests",
            "can",
            "suppress",
            "it",
            "with",
            "feature",
            "specific",
            "test",
            "suite",
            "builder"
        ]
    },
    {
        "id": 89,
        "code": "public void testToArray_isPlainObjectArray() {\n  Object[] array = collection.toArray();\n  assertEquals(Object[].class, array.getClass());\n}",
        "summary_tokens": [
            "collection",
            "to",
            "array",
            "object",
            "says",
            "note",
            "that",
            "to",
            "array",
            "new",
            "object",
            "0",
            "is",
            "identical",
            "in",
            "function",
            "to",
            "to",
            "array"
        ]
    },
    {
        "id": 90,
        "code": "public static Method getToArrayIsPlainObjectArrayMethod() {\n  return Helpers.getMethod(CollectionToArrayTester.class, \"testToArray_isPlainObjectArray\");\n}",
        "summary_tokens": [
            "returns",
            "the",
            "method",
            "instance",
            "for",
            "test",
            "to",
            "array",
            "is",
            "plain",
            "object",
            "array",
            "so",
            "that",
            "tests",
            "of",
            "arrays",
            "as",
            "list",
            "object",
            "can",
            "suppress",
            "it",
            "with",
            "feature",
            "specific",
            "test",
            "suite",
            "builder"
        ]
    },
    {
        "id": 91,
        "code": "public static Method getAddNullSupportedMethod() {\n  return Helpers.getMethod(ListAddAtIndexTester.class, \"testAddAtIndex_nullSupported\");\n}",
        "summary_tokens": [
            "returns",
            "the",
            "method",
            "instance",
            "for",
            "test",
            "add",
            "at",
            "index",
            "null",
            "supported",
            "so",
            "that",
            "tests",
            "can",
            "suppress",
            "it"
        ]
    },
    {
        "id": 92,
        "code": "public static Method getAddSupportedNullPresentMethod() {\n  return Helpers.getMethod(ListAddTester.class, \"testAdd_supportedNullPresent\");\n}",
        "summary_tokens": [
            "returns",
            "the",
            "method",
            "instance",
            "for",
            "test",
            "add",
            "supported",
            "null",
            "present",
            "so",
            "that",
            "tests",
            "can",
            "suppress",
            "it"
        ]
    },
    {
        "id": 93,
        "code": "public static Method getHashCodeMethod() {\n  return Helpers.getMethod(ListHashCodeTester.class, \"testHashCode\");\n}",
        "summary_tokens": [
            "returns",
            "the",
            "method",
            "instance",
            "for",
            "test",
            "hash",
            "code",
            "so",
            "that",
            "list",
            "tests",
            "on",
            "unhashable",
            "objects",
            "can",
            "suppress",
            "it",
            "with",
            "feature",
            "specific",
            "test",
            "suite",
            "builder"
        ]
    },
    {
        "id": 94,
        "code": "public static Method getListIteratorFullyModifiableMethod() {\n  return Helpers.getMethod(ListListIteratorTester.class, \"testListIterator_fullyModifiable\");\n}",
        "summary_tokens": [
            "returns",
            "the",
            "method",
            "instance",
            "for",
            "test",
            "list",
            "iterator",
            "fully",
            "modifiable",
            "so",
            "that",
            "tests",
            "of",
            "copy",
            "on",
            "write",
            "array",
            "set",
            "can",
            "suppress",
            "it",
            "with",
            "feature",
            "specific",
            "test",
            "suite",
            "builder"
        ]
    },
    {
        "id": 95,
        "code": "public static Method getListIteratorUnmodifiableMethod() {\n  return Helpers.getMethod(ListListIteratorTester.class, \"testListIterator_unmodifiable\");\n}",
        "summary_tokens": [
            "returns",
            "the",
            "method",
            "instance",
            "for",
            "test",
            "list",
            "iterator",
            "unmodifiable",
            "so",
            "that",
            "it",
            "can",
            "be",
            "suppressed",
            "in",
            "gwt",
            "tests"
        ]
    },
    {
        "id": 96,
        "code": "public static Method getSubListOriginalListSetAffectsSubListMethod() {\n  return getMethod(ListSubListTester.class, \"testSubList_originalListSetAffectsSubList\");\n}",
        "summary_tokens": [
            "returns",
            "the",
            "method",
            "instance",
            "for",
            "test",
            "sub",
            "list",
            "original",
            "list",
            "set",
            "affects",
            "sub",
            "list",
            "so",
            "that",
            "tests",
            "of",
            "copy",
            "on",
            "write",
            "array",
            "list",
            "can",
            "suppress",
            "them",
            "with",
            "feature",
            "specific",
            "test",
            "suite",
            "builder"
        ]
    },
    {
        "id": 97,
        "code": "public static Method getSubListOriginalListSetAffectsSubListLargeListMethod() {\n  return getMethod(ListSubListTester.class, \"testSubList_originalListSetAffectsSubListLargeList\");\n}",
        "summary_tokens": [
            "returns",
            "the",
            "method",
            "instance",
            "for",
            "test",
            "sub",
            "list",
            "original",
            "list",
            "set",
            "affects",
            "sub",
            "list",
            "large",
            "list",
            "so",
            "that",
            "tests",
            "of",
            "copy",
            "on",
            "write",
            "array",
            "list",
            "can",
            "suppress",
            "them",
            "with",
            "feature",
            "specific",
            "test",
            "suite",
            "builder"
        ]
    },
    {
        "id": 98,
        "code": "public static Method getSubListSubListRemoveAffectsOriginalLargeListMethod() {\n  return getMethod(ListSubListTester.class, \"testSubList_subListRemoveAffectsOriginalLargeList\");\n}",
        "summary_tokens": [
            "returns",
            "the",
            "method",
            "instance",
            "for",
            "test",
            "sub",
            "list",
            "sub",
            "list",
            "remove",
            "affects",
            "original",
            "large",
            "list",
            "so",
            "that",
            "tests",
            "of",
            "copy",
            "on",
            "write",
            "array",
            "list",
            "can",
            "suppress",
            "it",
            "with",
            "feature",
            "specific",
            "test",
            "suite",
            "builder"
        ]
    },
    {
        "id": 99,
        "code": "public static Method getCreateWithNullKeyUnsupportedMethod() {\n  return Helpers.getMethod(MapCreationTester.class, \"testCreateWithNullKeyUnsupported\");\n}",
        "summary_tokens": [
            "returns",
            "the",
            "method",
            "instance",
            "for",
            "test",
            "create",
            "with",
            "null",
            "key",
            "unsupported",
            "so",
            "that",
            "tests",
            "can",
            "suppress",
            "it",
            "with",
            "feature",
            "specific",
            "test",
            "suite",
            "builder"
        ]
    },
    {
        "id": 100,
        "code": "public static Method getPutAllNullKeyUnsupportedMethod() {\n  return Helpers.getMethod(MapPutAllTester.class, \"testPutAll_nullKeyUnsupported\");\n}",
        "summary_tokens": [
            "returns",
            "the",
            "method",
            "instance",
            "for",
            "test",
            "put",
            "all",
            "null",
            "key",
            "unsupported",
            "so",
            "that",
            "tests",
            "can",
            "suppress",
            "it",
            "with",
            "feature",
            "specific",
            "test",
            "suite",
            "builder"
        ]
    },
    {
        "id": 101,
        "code": "public static Method getPutNullKeyUnsupportedMethod() {\n  return Helpers.getMethod(MapPutTester.class, \"testPut_nullKeyUnsupported\");\n}",
        "summary_tokens": [
            "returns",
            "the",
            "method",
            "instance",
            "for",
            "test",
            "put",
            "null",
            "key",
            "unsupported",
            "so",
            "that",
            "tests",
            "of",
            "java"
        ]
    },
    {
        "id": 102,
        "code": "private void resetWithHole() {\n  Entry<K, V>[] entries = new Entry[] {a, c};\n  super.resetMap(entries);\n  navigableMap = (NavigableMap<K, V>) getMap();\n}",
        "summary_tokens": [
            "resets",
            "the",
            "contents",
            "of",
            "navigable",
            "map",
            "to",
            "have",
            "entries",
            "a",
            "c",
            "for",
            "the",
            "navigation",
            "tests"
        ]
    },
    {
        "id": 103,
        "code": "protected void resetWithHole() {\n  super.resetContainer(getSubjectGenerator().create(a, c));\n  navigableSet = (NavigableSet<E>) getSet();\n}",
        "summary_tokens": [
            "resets",
            "the",
            "contents",
            "of",
            "navigable",
            "set",
            "to",
            "have",
            "elements",
            "a",
            "c",
            "for",
            "the",
            "navigation",
            "tests"
        ]
    },
    {
        "id": 104,
        "code": "public static Method[] getHoleMethods() {\n  return new Method[] {\n    Helpers.getMethod(NavigableSetNavigationTester.class, \"testLowerHole\"),\n    Helpers.getMethod(NavigableSetNavigationTester.class, \"testFloorHole\"),\n    Helpers.getMethod(NavigableSetNavigationTester.class, \"testCeilingHole\"),\n    Helpers.getMethod(NavigableSetNavigationTester.class, \"testHigherHole\"),\n  };\n}",
        "summary_tokens": [
            "returns",
            "the",
            "method",
            "instances",
            "for",
            "the",
            "test",
            "methods",
            "in",
            "this",
            "class",
            "that",
            "create",
            "a",
            "set",
            "with",
            "a",
            "hole",
            "in",
            "it",
            "so",
            "that",
            "set",
            "tests",
            "of",
            "contiguous",
            "set",
            "can",
            "suppress",
            "them",
            "with",
            "feature",
            "specific",
            "test",
            "suite",
            "builder"
        ]
    },
    {
        "id": 105,
        "code": "static String format(String template, Object... args) {\n  return String.format(Locale.ROOT, template, args);\n}",
        "summary_tokens": [
            "format",
            "the",
            "template",
            "with",
            "args",
            "only",
            "supports",
            "the",
            "placeholder",
            "s"
        ]
    },
    {
        "id": 106,
        "code": "static int listListIteratorTesterNumIterations() {\n  return 4;\n}",
        "summary_tokens": [
            "see",
            "list",
            "list",
            "iterator",
            "tester"
        ]
    },
    {
        "id": 107,
        "code": "static int collectionIteratorTesterNumIterations() {\n  return 5;\n}",
        "summary_tokens": [
            "see",
            "collection",
            "iterator",
            "tester"
        ]
    },
    {
        "id": 108,
        "code": "public static Method getAddSupportedNullPresentMethod() {\n  return Helpers.getMethod(SetAddTester.class, \"testAdd_supportedNullPresent\");\n}",
        "summary_tokens": [
            "returns",
            "the",
            "method",
            "instance",
            "for",
            "test",
            "add",
            "supported",
            "null",
            "present",
            "so",
            "that",
            "tests",
            "can",
            "suppress",
            "it"
        ]
    },
    {
        "id": 109,
        "code": "public static Method[] getHashCodeMethods() {\n  return new Method[] {\n    Helpers.getMethod(SetHashCodeTester.class, \"testHashCode\"),\n    Helpers.getMethod(SetHashCodeTester.class, \"testHashCode_containingNull\")\n  };\n}",
        "summary_tokens": [
            "returns",
            "the",
            "method",
            "instances",
            "for",
            "the",
            "test",
            "methods",
            "in",
            "this",
            "class",
            "which",
            "call",
            "hash",
            "code",
            "on",
            "the",
            "set",
            "values",
            "so",
            "that",
            "set",
            "tests",
            "on",
            "unhashable",
            "objects",
            "can",
            "suppress",
            "it",
            "with",
            "feature",
            "specific",
            "test",
            "suite",
            "builder"
        ]
    },
    {
        "id": 110,
        "code": "public static void assertBasic(Escaper escaper) throws IOException {\n    \n  Assert.assertEquals(\"\", escaper.escape(\"\"));\n    \n  try {\n    escaper.escape((String) null);\n    Assert.fail(\"exception not thrown when escaping a null string\");\n  } catch (NullPointerException e) {\n      \n  }\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "an",
            "escaper",
            "behaves",
            "correctly",
            "with",
            "respect",
            "to",
            "null",
            "inputs"
        ]
    },
    {
        "id": 111,
        "code": "public static void assertEscaping(UnicodeEscaper escaper, String expected, int cp) {\n\n  String escaped = computeReplacement(escaper, cp);\n  Assert.assertNotNull(escaped);\n  Assert.assertEquals(expected, escaped);\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "a",
            "unicode",
            "escaper",
            "escapes",
            "the",
            "given",
            "code",
            "point",
            "into",
            "the",
            "expected",
            "string"
        ]
    },
    {
        "id": 112,
        "code": "public static void assertUnescaped(UnicodeEscaper escaper, int cp) {\n  Assert.assertNull(computeReplacement(escaper, cp));\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "a",
            "unicode",
            "escaper",
            "does",
            "not",
            "escape",
            "the",
            "given",
            "character"
        ]
    },
    {
        "id": 113,
        "code": "public static void assertUnicodeEscaping(\n    UnicodeEscaper escaper, String expected, char hi, char lo) {\n\n  int cp = Character.toCodePoint(hi, lo);\n  String escaped = computeReplacement(escaper, cp);\n  Assert.assertNotNull(escaped);\n  Assert.assertEquals(expected, escaped);\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "a",
            "unicode",
            "escaper",
            "escapes",
            "the",
            "given",
            "hi",
            "lo",
            "surrogate",
            "pair",
            "into",
            "the",
            "expected",
            "string"
        ]
    },
    {
        "id": 114,
        "code": "protected final void publicApiOnly() {\n  visibility = Visibility.PUBLIC;\n}",
        "summary_tokens": [
            "restricts",
            "the",
            "sanity",
            "tests",
            "for",
            "public",
            "api",
            "only"
        ]
    },
    {
        "id": 115,
        "code": "public void testSerializable() throws Exception {\n    \n  for (Class<?> classToTest :\n      findClassesToTest(loadClassesInPackage(), SERIALIZABLE_TEST_METHOD_NAMES)) {\n    if (Serializable.class.isAssignableFrom(classToTest)) {\n      try {\n        Object instance = tester.instantiate(classToTest);\n        if (instance != null) {\n          if (isEqualsDefined(classToTest)) {\n            SerializableTester.reserializeAndAssert(instance);\n          } else {\n            SerializableTester.reserialize(instance);\n          }\n        }\n      } catch (Throwable e) {\n        throw sanityError(classToTest, SERIALIZABLE_TEST_METHOD_NAMES, \"serializable test\", e);\n      }\n    }\n  }\n}",
        "summary_tokens": [
            "tests",
            "all",
            "top",
            "level",
            "serializable",
            "classes",
            "in",
            "the",
            "package"
        ]
    },
    {
        "id": 116,
        "code": "public void testNulls() throws Exception {\n  for (Class<?> classToTest : findClassesToTest(loadClassesInPackage(), NULL_TEST_METHOD_NAMES)) {\n    try {\n      tester.doTestNulls(classToTest, visibility);\n    } catch (Throwable e) {\n      throw sanityError(classToTest, NULL_TEST_METHOD_NAMES, \"nulls test\", e);\n    }\n  }\n}",
        "summary_tokens": [
            "performs",
            "null",
            "pointer",
            "tester",
            "checks",
            "for",
            "all",
            "top",
            "level",
            "classes",
            "in",
            "the",
            "package"
        ]
    },
    {
        "id": 117,
        "code": "public void testEquals() throws Exception {\n  for (Class<?> classToTest :\n      findClassesToTest(loadClassesInPackage(), EQUALS_TEST_METHOD_NAMES)) {\n    if (!classToTest.isEnum() && isEqualsDefined(classToTest)) {\n      try {\n        tester.doTestEquals(classToTest);\n      } catch (Throwable e) {\n        throw sanityError(classToTest, EQUALS_TEST_METHOD_NAMES, \"equals test\", e);\n      }\n    }\n  }\n}",
        "summary_tokens": [
            "tests",
            "equals",
            "and",
            "hash",
            "code",
            "implementations",
            "for",
            "every",
            "top",
            "level",
            "class",
            "in",
            "the",
            "package",
            "that",
            "explicitly",
            "implements",
            "object",
            "equals"
        ]
    },
    {
        "id": 118,
        "code": "protected final <T> void setDefault(Class<T> type, T value) {\n  tester.setDefault(type, value);\n}",
        "summary_tokens": [
            "sets",
            "the",
            "default",
            "value",
            "for",
            "type",
            "when",
            "dummy",
            "value",
            "for",
            "a",
            "parameter",
            "of",
            "the",
            "same",
            "type",
            "needs",
            "to",
            "be",
            "created",
            "in",
            "order",
            "to",
            "invoke",
            "a",
            "method",
            "or",
            "constructor"
        ]
    },
    {
        "id": 119,
        "code": "protected final <T> void setDistinctValues(Class<T> type, T value1, T value2) {\n  tester.setDistinctValues(type, value1, value2);\n}",
        "summary_tokens": [
            "sets",
            "two",
            "distinct",
            "values",
            "for",
            "type"
        ]
    },
    {
        "id": 120,
        "code": "protected final void ignoreClasses(Predicate<? super Class<?>> condition) {\n  this.classFilter = and(this.classFilter, not(condition));\n}",
        "summary_tokens": [
            "specifies",
            "that",
            "classes",
            "that",
            "satisfy",
            "the",
            "given",
            "predicate",
            "aren",
            "t",
            "tested",
            "for",
            "sanity"
        ]
    },
    {
        "id": 121,
        "code": "List<Class<?>> findClassesToTest(\n    Iterable<? extends Class<?>> classes, Iterable<String> explicitTestNames) {\n    \n  TreeMap<String, Class<?>> classMap = Maps.newTreeMap();\n  for (Class<?> cls : classes) {\n    classMap.put(cls.getName(), cls);\n  }\n    \n  Multimap<Class<?>, Class<?>> testClasses = HashMultimap.create();\n  LinkedHashSet<Class<?>> candidateClasses = Sets.newLinkedHashSet();\n  for (Class<?> cls : classes) {\n    Optional<String> testedClassName = TEST_SUFFIX.chop(cls.getName());\n    if (testedClassName.isPresent()) {\n      Class<?> testedClass = classMap.get(testedClassName.get());\n      if (testedClass != null) {\n        testClasses.put(testedClass, cls);\n      }\n    } else {\n      candidateClasses.add(cls);\n    }\n  }\n  List<Class<?>> result = Lists.newArrayList();\n  NEXT_CANDIDATE:\n  for (Class<?> candidate : Iterables.filter(candidateClasses, classFilter)) {\n    for (Class<?> testClass : testClasses.get(candidate)) {\n      if (hasTest(testClass, explicitTestNames)) {\n          \n        continue NEXT_CANDIDATE;\n      }\n    }\n    result.add(candidate);\n  }\n  return result;\n}",
        "summary_tokens": [
            "finds",
            "the",
            "classes",
            "not",
            "ending",
            "with",
            "a",
            "test",
            "suffix",
            "and",
            "not",
            "covered",
            "by",
            "an",
            "explicit",
            "test",
            "whose",
            "name",
            "is",
            "explicit",
            "test",
            "name"
        ]
    },
    {
        "id": 122,
        "code": "private static MatchResult newMatchResult() {\n  Matcher matcher = Pattern.compile(\".\").matcher(\"X\");\n  matcher.find();\n  return matcher.toMatchResult();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "match",
            "result",
            "that",
            "corresponds",
            "to",
            "a",
            "successful",
            "match"
        ]
    },
    {
        "id": 123,
        "code": "public static <T> T get(Class<T> type) {\n  T defaultValue = DEFAULTS.getInstance(type);\n  if (defaultValue != null) {\n    return defaultValue;\n  }\n  Class<? extends T> implementation = getImplementation(type);\n  if (implementation != null) {\n    return get(implementation);\n  }\n  if (type.isEnum()) {\n    T[] enumConstants = type.getEnumConstants();\n    return (enumConstants.length == 0) ? null : enumConstants[0];\n  }\n  if (type.isArray()) {\n    return createEmptyArray(type);\n  }\n  T jvmDefault = Defaults.defaultValue(Primitives.unwrap(type));\n  if (jvmDefault != null) {\n    return jvmDefault;\n  }\n  if (Modifier.isAbstract(type.getModifiers()) || !Modifier.isPublic(type.getModifiers())) {\n    return arbitraryConstantInstanceOrNull(type);\n  }\n  final Constructor<T> constructor;\n  try {\n    constructor = type.getConstructor();\n  } catch (NoSuchMethodException e) {\n    return arbitraryConstantInstanceOrNull(type);\n  }\n  constructor.setAccessible(true); \n  try {\n    return constructor.newInstance();\n      \n  } catch (InstantiationException impossible) {\n    throw new AssertionError(impossible);\n  } catch (IllegalAccessException impossible) {\n    throw new AssertionError(impossible);\n  } catch (InvocationTargetException e) {\n    logger.log(Level.WARNING, \"Exception while invoking default constructor.\", e.getCause());\n    return arbitraryConstantInstanceOrNull(type);\n  }\n}",
        "summary_tokens": [
            "returns",
            "an",
            "arbitrary",
            "instance",
            "for",
            "type",
            "or",
            "null",
            "if",
            "no",
            "arbitrary",
            "instance",
            "can",
            "be",
            "determined"
        ]
    },
    {
        "id": 124,
        "code": "public <T> ClassSanityTester setDefault(Class<T> type, T value) {\n  nullPointerTester.setDefault(type, value);\n  defaultValues.putInstance(type, value);\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "default",
            "value",
            "for",
            "type"
        ]
    },
    {
        "id": 125,
        "code": "public <T> ClassSanityTester setDistinctValues(Class<T> type, T value1, T value2) {\n  checkNotNull(type);\n  checkNotNull(value1);\n  checkNotNull(value2);\n  checkArgument(!Objects.equal(value1, value2), \"Duplicate value provided.\");\n  distinctValues.replaceValues(type, ImmutableList.of(value1, value2));\n  setDefault(type, value1);\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "distinct",
            "values",
            "for",
            "type",
            "so",
            "that",
            "when",
            "a",
            "class",
            "foo",
            "is",
            "tested",
            "for",
            "object",
            "equals",
            "and",
            "object",
            "hash",
            "code",
            "and",
            "its",
            "construction",
            "requires",
            "a",
            "parameter",
            "of",
            "type",
            "the",
            "distinct",
            "values",
            "of",
            "type",
            "can",
            "be",
            "passed",
            "as",
            "parameters",
            "to",
            "create",
            "foo",
            "instances",
            "that",
            "are",
            "unequal"
        ]
    },
    {
        "id": 126,
        "code": "public void testNulls(Class<?> cls) {\n  try {\n    doTestNulls(cls, Visibility.PACKAGE);\n  } catch (Exception e) {\n    throwIfUnchecked(e);\n    throw new RuntimeException(e);\n  }\n}",
        "summary_tokens": [
            "tests",
            "that",
            "cls",
            "properly",
            "checks",
            "null",
            "on",
            "all",
            "constructor",
            "and",
            "method",
            "parameters",
            "that",
            "aren",
            "t",
            "annotated",
            "nullable",
            "according",
            "to",
            "the",
            "rules",
            "of",
            "null",
            "pointer",
            "tester"
        ]
    },
    {
        "id": 127,
        "code": "public void testEquals(Class<?> cls) {\n  try {\n    doTestEquals(cls);\n  } catch (Exception e) {\n    throwIfUnchecked(e);\n    throw new RuntimeException(e);\n  }\n}",
        "summary_tokens": [
            "tests",
            "the",
            "object",
            "equals",
            "and",
            "object",
            "hash",
            "code",
            "of",
            "cls"
        ]
    },
    {
        "id": 128,
        "code": "<T> T instantiate(Class<T> cls)\n    throws ParameterNotInstantiableException, IllegalAccessException, InvocationTargetException,\n        FactoryMethodReturnsNullException {\n  if (cls.isEnum()) {\n    T[] constants = cls.getEnumConstants();\n    if (constants.length > 0) {\n      return constants[0];\n    } else {\n      return null;\n    }\n  }\n  TypeToken<T> type = TypeToken.of(cls);\n  List<ParameterNotInstantiableException> paramErrors = Lists.newArrayList();\n  List<InvocationTargetException> instantiationExceptions = Lists.newArrayList();\n  List<FactoryMethodReturnsNullException> nullErrors = Lists.newArrayList();\n  for (Invokable<?, ? extends T> factory : getFactories(type)) {\n    T instance;\n    try {\n      instance = instantiate(factory);\n    } catch (ParameterNotInstantiableException e) {\n      paramErrors.add(e);\n      continue;\n    } catch (InvocationTargetException e) {\n      instantiationExceptions.add(e);\n      continue;\n    }\n    if (instance == null) {\n      nullErrors.add(new FactoryMethodReturnsNullException(factory));\n    } else {\n      return instance;\n    }\n  }\n  throwFirst(paramErrors);\n  throwFirst(instantiationExceptions);\n  throwFirst(nullErrors);\n  return null;\n}",
        "summary_tokens": [
            "instantiates",
            "cls",
            "by",
            "invoking",
            "one",
            "of",
            "its",
            "non",
            "private",
            "constructors",
            "or",
            "non",
            "private",
            "static",
            "factory",
            "methods",
            "with",
            "the",
            "parameters",
            "automatically",
            "provided",
            "using",
            "dummy",
            "values"
        ]
    },
    {
        "id": 129,
        "code": "public FactoryMethodReturnValueTester forAllPublicStaticMethods(Class<?> cls) {\n  ImmutableList.Builder<Invokable<?, ?>> builder = ImmutableList.builder();\n  for (Method method : cls.getDeclaredMethods()) {\n    Invokable<?, ?> invokable = Invokable.from(method);\n    invokable.setAccessible(true);\n    if (invokable.isPublic() && invokable.isStatic() && !invokable.isSynthetic()) {\n      builder.add(invokable);\n    }\n  }\n  return new FactoryMethodReturnValueTester(cls, builder.build(), \"public static methods\");\n}",
        "summary_tokens": [
            "returns",
            "an",
            "object",
            "responsible",
            "for",
            "performing",
            "sanity",
            "tests",
            "against",
            "the",
            "return",
            "values",
            "of",
            "all",
            "public",
            "static",
            "methods",
            "declared",
            "by",
            "cls",
            "excluding",
            "superclasses"
        ]
    },
    {
        "id": 130,
        "code": "private List<Object> generateEqualFactoryArguments(\n    Invokable<?, ?> factory, List<Parameter> params, List<Object> args)\n    throws ParameterNotInstantiableException, FactoryMethodReturnsNullException,\n        InvocationTargetException, IllegalAccessException {\n  List<Object> equalArgs = Lists.newArrayList(args);\n  for (int i = 0; i < args.size(); i++) {\n    Parameter param = params.get(i);\n    Object arg = args.get(i);\n      \n      \n    Object shouldBeEqualArg = generateDummyArg(param, newFreshValueGenerator());\n    if (arg != shouldBeEqualArg\n        && Objects.equal(arg, shouldBeEqualArg)\n        && hashCodeInsensitiveToArgReference(factory, args, i, shouldBeEqualArg)\n        && hashCodeInsensitiveToArgReference(\n            factory, args, i, generateDummyArg(param, newFreshValueGenerator()))) {\n        \n        \n        \n      equalArgs.set(i, shouldBeEqualArg);\n    }\n  }\n  return equalArgs;\n}",
        "summary_tokens": [
            "returns",
            "dummy",
            "factory",
            "arguments",
            "that",
            "are",
            "equal",
            "to",
            "args",
            "but",
            "may",
            "be",
            "different",
            "instances",
            "to",
            "be",
            "used",
            "to",
            "construct",
            "a",
            "second",
            "instance",
            "of",
            "the",
            "same",
            "equality",
            "group"
        ]
    },
    {
        "id": 131,
        "code": "private static <T> ImmutableList<Invokable<?, ? extends T>> getFactories(TypeToken<T> type) {\n  List<Invokable<?, ? extends T>> factories = Lists.newArrayList();\n  for (Method method : type.getRawType().getDeclaredMethods()) {\n    Invokable<?, ?> invokable = type.method(method);\n    if (!invokable.isPrivate()\n        && !invokable.isSynthetic()\n        && invokable.isStatic()\n        && type.isSupertypeOf(invokable.getReturnType())) {\n      @SuppressWarnings(\"unchecked\") \n      Invokable<?, ? extends T> factory = (Invokable<?, ? extends T>) invokable;\n      factories.add(factory);\n    }\n  }\n  if (!Modifier.isAbstract(type.getRawType().getModifiers())) {\n    for (Constructor<?> constructor : type.getRawType().getDeclaredConstructors()) {\n      Invokable<T, T> invokable = type.constructor(constructor);\n      if (!invokable.isPrivate() && !invokable.isSynthetic()) {\n        factories.add(invokable);\n      }\n    }\n  }\n  for (Invokable<?, ?> factory : factories) {\n    factory.setAccessible(true);\n  }\n    \n    \n    \n  return BY_NUMBER_OF_PARAMETERS\n      .compound(BY_METHOD_NAME)\n      .compound(BY_PARAMETERS)\n      .immutableSortedCopy(factories);\n}",
        "summary_tokens": [
            "factories",
            "with",
            "the",
            "least",
            "number",
            "of",
            "parameters",
            "are",
            "listed",
            "first"
        ]
    },
    {
        "id": 132,
        "code": "public static RuntimeException create(Collection<? extends Throwable> exceptions) {\n  if (exceptions.size() == 0) {\n    throw new IllegalArgumentException(\"Can't create an ExceptionCollection with no exceptions\");\n  }\n  if (exceptions.size() == 1) {\n    Throwable temp = exceptions.iterator().next();\n    if (temp instanceof RuntimeException) {\n      return (RuntimeException) temp;\n    } else {\n      return new RuntimeException(temp);\n    }\n  }\n  return new ClusterException(exceptions);\n}",
        "summary_tokens": [
            "given",
            "a",
            "collection",
            "of",
            "exceptions",
            "returns",
            "a",
            "runtime",
            "exception",
            "with",
            "the",
            "following",
            "rules"
        ]
    },
    {
        "id": 133,
        "code": "final <T> T newProxy(TypeToken<T> interfaceType) {\n  Set<Class<?>> interfaceClasses = Sets.newLinkedHashSet();\n  interfaceClasses.addAll(interfaceType.getTypes().interfaces().rawTypes());\n    \n  interfaceClasses.add(Serializable.class);\n  Object dummy =\n      Proxy.newProxyInstance(\n          interfaceClasses.iterator().next().getClassLoader(),\n          interfaceClasses.toArray(new Class<?>[interfaceClasses.size()]),\n          new DummyHandler(interfaceType));\n  @SuppressWarnings(\"unchecked\") \n  T result = (T) dummy;\n  return result;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "proxy",
            "for",
            "interface",
            "type"
        ]
    },
    {
        "id": 134,
        "code": "public EqualsTester addEqualityGroup(Object... equalityGroup) {\n  checkNotNull(equalityGroup);\n  equalityGroups.add(ImmutableList.copyOf(equalityGroup));\n  return this;\n}",
        "summary_tokens": [
            "adds",
            "equality",
            "group",
            "with",
            "objects",
            "that",
            "are",
            "supposed",
            "to",
            "be",
            "equal",
            "to",
            "each",
            "other",
            "and",
            "not",
            "equal",
            "to",
            "any",
            "other",
            "equality",
            "groups",
            "added",
            "to",
            "this",
            "tester"
        ]
    },
    {
        "id": 135,
        "code": "public EqualsTester testEquals() {\n  RelationshipTester<Object> delegate =\n      new RelationshipTester<>(\n          Equivalence.equals(), \"Object#equals\", \"Object#hashCode\", itemReporter);\n  for (List<Object> group : equalityGroups) {\n    delegate.addRelatedGroup(group);\n  }\n  for (int run = 0; run < REPETITIONS; run++) {\n    testItems();\n    delegate.test();\n  }\n  return this;\n}",
        "summary_tokens": [
            "run",
            "tests",
            "on",
            "equals",
            "method",
            "throwing",
            "a",
            "failure",
            "on",
            "an",
            "invalid",
            "test"
        ]
    },
    {
        "id": 136,
        "code": "public EquivalenceTester<T> addEquivalenceGroup(T first, T... rest) {\n  addEquivalenceGroup(Lists.asList(first, rest));\n  return this;\n}",
        "summary_tokens": [
            "adds",
            "a",
            "group",
            "of",
            "objects",
            "that",
            "are",
            "supposed",
            "to",
            "be",
            "equivalent",
            "to",
            "each",
            "other",
            "and",
            "not",
            "equivalent",
            "to",
            "objects",
            "in",
            "any",
            "other",
            "equivalence",
            "group",
            "added",
            "to",
            "this",
            "tester"
        ]
    },
    {
        "id": 137,
        "code": "public EquivalenceTester<T> test() {\n  for (int run = 0; run < REPETITIONS; run++) {\n    testItems();\n    delegate.test();\n  }\n  return this;\n}",
        "summary_tokens": [
            "run",
            "tests",
            "on",
            "equivalence",
            "methods",
            "throwing",
            "a",
            "failure",
            "on",
            "an",
            "invalid",
            "test"
        ]
    },
    {
        "id": 138,
        "code": "public FakeTicker advance(java.time.Duration duration) {\n  return advance(duration.toNanos());\n}",
        "summary_tokens": [
            "advances",
            "the",
            "ticker",
            "value",
            "by",
            "duration"
        ]
    },
    {
        "id": 139,
        "code": "public FakeTicker setAutoIncrementStep(java.time.Duration autoIncrementStep) {\n  return setAutoIncrementStep(autoIncrementStep.toNanos(), TimeUnit.NANOSECONDS);\n}",
        "summary_tokens": [
            "sets",
            "the",
            "increment",
            "applied",
            "to",
            "the",
            "ticker",
            "whenever",
            "it",
            "is",
            "queried"
        ]
    },
    {
        "id": 140,
        "code": "public ForwardingWrapperTester includingEquals() {\n  this.testsEquals = true;\n  return this;\n}",
        "summary_tokens": [
            "asks",
            "for",
            "object",
            "equals",
            "and",
            "object",
            "hash",
            "code",
            "to",
            "be",
            "tested"
        ]
    },
    {
        "id": 141,
        "code": "public <T> void testForwarding(\n    Class<T> interfaceType, Function<? super T, ? extends T> wrapperFunction) {\n  checkNotNull(wrapperFunction);\n  checkArgument(interfaceType.isInterface(), \"%s isn't an interface\", interfaceType);\n  Method[] methods = getMostConcreteMethods(interfaceType);\n  AccessibleObject.setAccessible(methods, true);\n  for (Method method : methods) {\n      \n      \n      \n    if (!Modifier.isAbstract(method.getModifiers())) {\n      continue;\n    }\n      \n      \n    if (method.getName().equals(\"equals\")\n        && method.getParameterTypes().length == 1\n        && method.getParameterTypes()[0] == Object.class) {\n      continue;\n    }\n    if (method.getName().equals(\"hashCode\") && method.getParameterTypes().length == 0) {\n      continue;\n    }\n    if (method.getName().equals(\"toString\") && method.getParameterTypes().length == 0) {\n      continue;\n    }\n    testSuccessfulForwarding(interfaceType, method, wrapperFunction);\n    testExceptionPropagation(interfaceType, method, wrapperFunction);\n  }\n  if (testsEquals) {\n    testEquals(interfaceType, wrapperFunction);\n  }\n  testToString(interfaceType, wrapperFunction);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "the",
            "forwarding",
            "wrapper",
            "returned",
            "by",
            "wrapper",
            "function",
            "properly",
            "forwards",
            "method",
            "calls",
            "with",
            "parameters",
            "passed",
            "as",
            "is",
            "return",
            "value",
            "returned",
            "as",
            "is",
            "and",
            "exceptions",
            "propagated",
            "as",
            "is"
        ]
    },
    {
        "id": 142,
        "code": "private static Method[] getMostConcreteMethods(Class<?> type) {\n  Method[] methods = type.getMethods();\n  for (int i = 0; i < methods.length; i++) {\n    try {\n      methods[i] = type.getMethod(methods[i].getName(), methods[i].getParameterTypes());\n    } catch (Exception e) {\n      throwIfUnchecked(e);\n      throw new RuntimeException(e);\n    }\n  }\n  return methods;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "most",
            "concrete",
            "public",
            "methods",
            "from",
            "type"
        ]
    },
    {
        "id": 143,
        "code": "final Object generateFresh(TypeToken<?> type) {\n  Object generated = generate(type);\n  if (generated != null) {\n    freshness.incrementAndGet();\n  }\n  return generated;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "fresh",
            "instance",
            "for",
            "type",
            "if",
            "possible"
        ]
    },
    {
        "id": 144,
        "code": "private Object generate(TypeToken<?> type) {\n  Class<?> rawType = type.getRawType();\n  List<Object> samples = sampleInstances.get(rawType);\n  Object sample = pickInstance(samples, null);\n  if (sample != null) {\n    return sample;\n  }\n  if (rawType.isEnum()) {\n    return pickInstance(rawType.getEnumConstants(), null);\n  }\n  if (type.isArray()) {\n    TypeToken<?> componentType = type.getComponentType();\n    Object array = Array.newInstance(componentType.getRawType(), 1);\n    Array.set(array, 0, generate(componentType));\n    return array;\n  }\n  Method emptyGenerate = EMPTY_GENERATORS.get(rawType);\n  if (emptyGenerate != null) {\n    if (emptyInstanceGenerated.containsKey(type.getType())) {\n        \n      if (emptyInstanceGenerated.get(type.getType()).intValue() == freshness.get()) {\n          \n        return invokeGeneratorMethod(emptyGenerate);\n      } else {\n          \n      }\n    } else {\n        \n      Object emptyInstance = invokeGeneratorMethod(emptyGenerate);\n      emptyInstanceGenerated.put(type.getType(), freshness.get());\n      return emptyInstance;\n    }\n  }\n  Method generate = GENERATORS.get(rawType);\n  if (generate != null) {\n    ImmutableList<Parameter> params = Invokable.from(generate).getParameters();\n    List<Object> args = Lists.newArrayListWithCapacity(params.size());\n    TypeVariable<?>[] typeVars = rawType.getTypeParameters();\n    for (int i = 0; i < params.size(); i++) {\n      TypeToken<?> paramType = type.resolveType(typeVars[i]);\n        \n        \n      Object argValue = generate(paramType);\n      if (argValue == null) {\n          \n          \n          \n          \n        return null;\n      }\n      args.add(argValue);\n    }\n    return invokeGeneratorMethod(generate, args.toArray());\n  }\n  return defaultGenerate(rawType);\n}",
        "summary_tokens": [
            "generates",
            "an",
            "instance",
            "for",
            "type",
            "using",
            "the",
            "current",
            "freshness"
        ]
    },
    {
        "id": 145,
        "code": "Object interfaceMethodCalled(Class<?> interfaceType, Method method) {\n  throw new UnsupportedOperationException();\n}",
        "summary_tokens": [
            "subclasses",
            "can",
            "override",
            "to",
            "provide",
            "different",
            "return",
            "value",
            "for",
            "proxied",
            "interface",
            "methods"
        ]
    },
    {
        "id": 146,
        "code": "private static long timeoutSeconds() {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n  return Math.max(10L, Runtime.getRuntime().totalMemory() / (32L * 1024L * 1024L));\n}",
        "summary_tokens": [
            "0",
            "seconds",
            "ought",
            "to",
            "be",
            "long",
            "enough",
            "for",
            "any",
            "object",
            "to",
            "be",
            "gc",
            "ed",
            "and",
            "finalized"
        ]
    },
    {
        "id": 147,
        "code": "public static void awaitDone(FinalizationPredicate predicate) {\n  if (predicate.isDone()) {\n    return;\n  }\n  long timeoutSeconds = timeoutSeconds();\n  long deadline = System.nanoTime() + SECONDS.toNanos(timeoutSeconds);\n  do {\n    System.runFinalization();\n    if (predicate.isDone()) {\n      return;\n    }\n    CountDownLatch done = new CountDownLatch(1);\n    createUnreachableLatchFinalizer(done);\n    await(done);\n    if (predicate.isDone()) {\n      return;\n    }\n  } while (System.nanoTime() - deadline < 0);\n  throw formatRuntimeException(\n      \"Predicate did not become true within %d second timeout\", timeoutSeconds);\n}",
        "summary_tokens": [
            "waits",
            "until",
            "the",
            "given",
            "predicate",
            "returns",
            "true",
            "invoking",
            "the",
            "garbage",
            "collector",
            "as",
            "necessary",
            "to",
            "try",
            "to",
            "ensure",
            "that",
            "this",
            "will",
            "happen"
        ]
    },
    {
        "id": 148,
        "code": "public static void await(CountDownLatch latch) {\n  if (latch.getCount() == 0) {\n    return;\n  }\n  long timeoutSeconds = timeoutSeconds();\n  long deadline = System.nanoTime() + SECONDS.toNanos(timeoutSeconds);\n  do {\n    System.runFinalization();\n    if (latch.getCount() == 0) {\n      return;\n    }\n    System.gc();\n    try {\n      if (latch.await(1L, SECONDS)) {\n        return;\n      }\n    } catch (InterruptedException ie) {\n      throw new RuntimeException(\"Unexpected interrupt while waiting for latch\", ie);\n    }\n  } while (System.nanoTime() - deadline < 0);\n  throw formatRuntimeException(\n      \"Latch failed to count down within %d second timeout\", timeoutSeconds);\n}",
        "summary_tokens": [
            "waits",
            "until",
            "the",
            "given",
            "latch",
            "has",
            "count",
            "down",
            "latch",
            "count",
            "down",
            "counted",
            "down",
            "to",
            "zero",
            "invoking",
            "the",
            "garbage",
            "collector",
            "as",
            "necessary",
            "to",
            "try",
            "to",
            "ensure",
            "that",
            "this",
            "will",
            "happen"
        ]
    },
    {
        "id": 149,
        "code": "private static void createUnreachableLatchFinalizer(CountDownLatch latch) {\n  new Object() {\n    @Override\n    protected void finalize() {\n      latch.countDown();\n    }\n  };\n}",
        "summary_tokens": [
            "creates",
            "a",
            "garbage",
            "object",
            "that",
            "counts",
            "down",
            "the",
            "latch",
            "in",
            "its",
            "finalizer"
        ]
    },
    {
        "id": 150,
        "code": "public static void awaitClear(WeakReference<?> ref) {\n  awaitDone(\n      new FinalizationPredicate() {\n        @Override\n        public boolean isDone() {\n          return ref.get() == null;\n        }\n      });\n}",
        "summary_tokens": [
            "waits",
            "until",
            "the",
            "given",
            "weak",
            "reference",
            "is",
            "cleared",
            "invoking",
            "the",
            "garbage",
            "collector",
            "as",
            "necessary",
            "to",
            "try",
            "to",
            "ensure",
            "that",
            "this",
            "will",
            "happen"
        ]
    },
    {
        "id": 151,
        "code": "public static void awaitFullGc() {\n  CountDownLatch finalizerRan = new CountDownLatch(1);\n  WeakReference<Object> ref =\n      new WeakReference<>(\n          new Object() {\n            @Override\n            protected void finalize() {\n              finalizerRan.countDown();\n            }\n          });\n\n  await(finalizerRan);\n  awaitClear(ref);\n\n    \n  System.runFinalization();\n}",
        "summary_tokens": [
            "tries",
            "to",
            "perform",
            "a",
            "full",
            "garbage",
            "collection",
            "cycle",
            "including",
            "processing",
            "of",
            "weak",
            "references",
            "and",
            "invocation",
            "of",
            "finalize",
            "methods",
            "and",
            "waits",
            "for",
            "it",
            "to",
            "complete"
        ]
    },
    {
        "id": 152,
        "code": "public <T> NullPointerTester setDefault(Class<T> type, T value) {\n  defaults.putInstance(type, checkNotNull(value));\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "a",
            "default",
            "value",
            "that",
            "can",
            "be",
            "used",
            "for",
            "any",
            "parameter",
            "of",
            "type",
            "type"
        ]
    },
    {
        "id": 153,
        "code": "public NullPointerTester ignore(Constructor<?> constructor) {\n  ignoredMembers.add(checkNotNull(constructor));\n  return this;\n}",
        "summary_tokens": [
            "ignore",
            "constructor",
            "in",
            "the",
            "tests",
            "that",
            "follow"
        ]
    },
    {
        "id": 154,
        "code": "public void testConstructors(Class<?> c, Visibility minimalVisibility) {\n  for (Constructor<?> constructor : c.getDeclaredConstructors()) {\n    if (minimalVisibility.isVisible(constructor) && !isIgnored(constructor)) {\n      testConstructor(constructor);\n    }\n  }\n}",
        "summary_tokens": [
            "runs",
            "test",
            "constructor",
            "on",
            "every",
            "constructor",
            "in",
            "class",
            "c",
            "that",
            "has",
            "at",
            "least",
            "minimal",
            "visibility"
        ]
    },
    {
        "id": 155,
        "code": "public void testAllPublicConstructors(Class<?> c) {\n  testConstructors(c, Visibility.PUBLIC);\n}",
        "summary_tokens": [
            "runs",
            "test",
            "constructor",
            "on",
            "every",
            "public",
            "constructor",
            "in",
            "class",
            "c"
        ]
    },
    {
        "id": 156,
        "code": "public void testStaticMethods(Class<?> c, Visibility minimalVisibility) {\n  for (Method method : minimalVisibility.getStaticMethods(c)) {\n    if (!isIgnored(method)) {\n      testMethod(null, method);\n    }\n  }\n}",
        "summary_tokens": [
            "runs",
            "test",
            "method",
            "on",
            "every",
            "static",
            "method",
            "of",
            "class",
            "c",
            "that",
            "has",
            "at",
            "least",
            "minimal",
            "visibility",
            "including",
            "those",
            "inherited",
            "from",
            "superclasses",
            "of",
            "the",
            "same",
            "package"
        ]
    },
    {
        "id": 157,
        "code": "public void testAllPublicStaticMethods(Class<?> c) {\n  testStaticMethods(c, Visibility.PUBLIC);\n}",
        "summary_tokens": [
            "runs",
            "test",
            "method",
            "on",
            "every",
            "public",
            "static",
            "method",
            "of",
            "class",
            "c",
            "including",
            "those",
            "inherited",
            "from",
            "superclasses",
            "of",
            "the",
            "same",
            "package"
        ]
    },
    {
        "id": 158,
        "code": "public void testInstanceMethods(Object instance, Visibility minimalVisibility) {\n  for (Method method : getInstanceMethodsToTest(instance.getClass(), minimalVisibility)) {\n    testMethod(instance, method);\n  }\n}",
        "summary_tokens": [
            "runs",
            "test",
            "method",
            "on",
            "every",
            "instance",
            "method",
            "of",
            "the",
            "class",
            "of",
            "instance",
            "with",
            "at",
            "least",
            "minimal",
            "visibility",
            "including",
            "those",
            "inherited",
            "from",
            "superclasses",
            "of",
            "the",
            "same",
            "package"
        ]
    },
    {
        "id": 159,
        "code": "public void testAllPublicInstanceMethods(Object instance) {\n  testInstanceMethods(instance, Visibility.PUBLIC);\n}",
        "summary_tokens": [
            "runs",
            "test",
            "method",
            "on",
            "every",
            "public",
            "instance",
            "method",
            "of",
            "the",
            "class",
            "of",
            "instance",
            "including",
            "those",
            "inherited",
            "from",
            "superclasses",
            "of",
            "the",
            "same",
            "package"
        ]
    },
    {
        "id": 160,
        "code": "public void testMethod(@Nullable Object instance, Method method) {\n  Class<?>[] types = method.getParameterTypes();\n  for (int nullIndex = 0; nullIndex < types.length; nullIndex++) {\n    testMethodParameter(instance, method, nullIndex);\n  }\n}",
        "summary_tokens": [
            "verifies",
            "that",
            "method",
            "produces",
            "a",
            "null",
            "pointer",
            "exception",
            "or",
            "unsupported",
            "operation",
            "exception",
            "whenever",
            "i",
            "any",
            "i",
            "of",
            "its",
            "non",
            "nullable",
            "parameters",
            "are",
            "null"
        ]
    },
    {
        "id": 161,
        "code": "public void testConstructor(Constructor<?> ctor) {\n  Class<?> declaringClass = ctor.getDeclaringClass();\n  checkArgument(\n      Modifier.isStatic(declaringClass.getModifiers())\n          || declaringClass.getEnclosingClass() == null,\n      \"Cannot test constructor of non-static inner class: %s\",\n      declaringClass.getName());\n  Class<?>[] types = ctor.getParameterTypes();\n  for (int nullIndex = 0; nullIndex < types.length; nullIndex++) {\n    testConstructorParameter(ctor, nullIndex);\n  }\n}",
        "summary_tokens": [
            "verifies",
            "that",
            "ctor",
            "produces",
            "a",
            "null",
            "pointer",
            "exception",
            "or",
            "unsupported",
            "operation",
            "exception",
            "whenever",
            "i",
            "any",
            "i",
            "of",
            "its",
            "non",
            "nullable",
            "parameters",
            "are",
            "null"
        ]
    },
    {
        "id": 162,
        "code": "public void testMethodParameter(\n    @Nullable final Object instance, final Method method, int paramIndex) {\n  method.setAccessible(true);\n  testParameter(instance, invokable(instance, method), paramIndex, method.getDeclaringClass());\n}",
        "summary_tokens": [
            "verifies",
            "that",
            "method",
            "produces",
            "a",
            "null",
            "pointer",
            "exception",
            "or",
            "unsupported",
            "operation",
            "exception",
            "when",
            "the",
            "parameter",
            "in",
            "position",
            "param",
            "index",
            "is",
            "null"
        ]
    },
    {
        "id": 163,
        "code": "public void testConstructorParameter(Constructor<?> ctor, int paramIndex) {\n  ctor.setAccessible(true);\n  testParameter(null, Invokable.from(ctor), paramIndex, ctor.getDeclaringClass());\n}",
        "summary_tokens": [
            "verifies",
            "that",
            "ctor",
            "produces",
            "a",
            "null",
            "pointer",
            "exception",
            "or",
            "unsupported",
            "operation",
            "exception",
            "when",
            "the",
            "parameter",
            "in",
            "position",
            "param",
            "index",
            "is",
            "null"
        ]
    },
    {
        "id": 164,
        "code": "private void testParameter(\n    Object instance, Invokable<?, ?> invokable, int paramIndex, Class<?> testedClass) {\n  if (isPrimitiveOrNullable(invokable.getParameters().get(paramIndex))) {\n    return; \n  }\n  Object[] params = buildParamList(invokable, paramIndex);\n  try {\n    @SuppressWarnings(\"unchecked\") \n    Invokable<Object, ?> unsafe = (Invokable<Object, ?>) invokable;\n    unsafe.invoke(instance, params);\n    Assert.fail(\n        \"No exception thrown for parameter at index \"\n            + paramIndex\n            + \" from \"\n            + invokable\n            + Arrays.toString(params)\n            + \" for \"\n            + testedClass);\n  } catch (InvocationTargetException e) {\n    Throwable cause = e.getCause();\n    if (policy.isExpectedType(cause)) {\n      return;\n    }\n    AssertionFailedError error =\n        new AssertionFailedError(\n            String.format(\n                \"wrong exception thrown from %s when passing null to %s parameter at index %s.%n\"\n                    + \"Full parameters: %s%n\"\n                    + \"Actual exception message: %s\",\n                invokable,\n                invokable.getParameters().get(paramIndex).getType(),\n                paramIndex,\n                Arrays.toString(params),\n                cause));\n    error.initCause(cause);\n    throw error;\n  } catch (IllegalAccessException e) {\n    throw new RuntimeException(e);\n  }\n}",
        "summary_tokens": [
            "verifies",
            "that",
            "invokable",
            "produces",
            "a",
            "null",
            "pointer",
            "exception",
            "or",
            "unsupported",
            "operation",
            "exception",
            "when",
            "the",
            "parameter",
            "in",
            "position",
            "param",
            "index",
            "is",
            "null"
        ]
    },
    {
        "id": 165,
        "code": "private static boolean isEquals(Member member) {\n  if (!(member instanceof Method)) {\n    return false;\n  }\n  Method method = (Method) member;\n  if (!method.getName().contentEquals(\"equals\")) {\n    return false;\n  }\n  Class<?>[] parameters = method.getParameterTypes();\n  if (parameters.length != 1) {\n    return false;\n  }\n  if (!parameters[0].equals(Object.class)) {\n    return false;\n  }\n  return true;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "the",
            "given",
            "member",
            "is",
            "a",
            "method",
            "that",
            "overrides",
            "object",
            "equals",
            "object"
        ]
    },
    {
        "id": 166,
        "code": "static <T> T reserialize(T object) {\n  checkNotNull(object);\n  ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n  try {\n    ObjectOutputStream out = new ObjectOutputStream(bytes);\n    out.writeObject(object);\n    ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(bytes.toByteArray()));\n    return (T) in.readObject();\n  } catch (IOException | ClassNotFoundException e) {\n    throw new RuntimeException(e);\n  }\n}",
        "summary_tokens": [
            "serializes",
            "and",
            "deserializes",
            "the",
            "specified",
            "object"
        ]
    },
    {
        "id": 167,
        "code": "public static <T> T reserialize(T object) {\n  return Platform.reserialize(object);\n}",
        "summary_tokens": [
            "serializes",
            "and",
            "deserializes",
            "the",
            "specified",
            "object"
        ]
    },
    {
        "id": 168,
        "code": "public static <T> T reserializeAndAssert(T object) {\n  T copy = reserialize(object);\n  new EqualsTester().addEqualityGroup(object, copy).testEquals();\n  Assert.assertEquals(object.getClass(), copy.getClass());\n  return copy;\n}",
        "summary_tokens": [
            "serializes",
            "and",
            "deserializes",
            "the",
            "specified",
            "object",
            "and",
            "verifies",
            "that",
            "the",
            "re",
            "serialized",
            "object",
            "is",
            "equal",
            "to",
            "the",
            "provided",
            "object",
            "that",
            "the",
            "hashcodes",
            "are",
            "identical",
            "and",
            "that",
            "the",
            "class",
            "of",
            "the",
            "re",
            "serialized",
            "object",
            "is",
            "identical",
            "to",
            "that",
            "of",
            "the",
            "original"
        ]
    },
    {
        "id": 169,
        "code": "public final void runTearDown() {\n  List<Throwable> exceptions = new ArrayList<>();\n  List<TearDown> stackCopy;\n  synchronized (stack) {\n    stackCopy = Lists.newArrayList(stack);\n    stack.clear();\n  }\n  for (TearDown tearDown : stackCopy) {\n    try {\n      tearDown.tearDown();\n    } catch (Throwable t) {\n      if (suppressThrows) {\n        logger.log(Level.INFO, \"exception thrown during tearDown\", t);\n      } else {\n        exceptions.add(t);\n      }\n    }\n  }\n  if (!suppressThrows && (exceptions.size() > 0)) {\n    throw ClusterException.create(exceptions);\n  }\n}",
        "summary_tokens": [
            "causes",
            "teardown",
            "to",
            "execute"
        ]
    },
    {
        "id": 170,
        "code": "public synchronized void publish(@Nullable LogRecord record) {\n  list.add(record);\n}",
        "summary_tokens": [
            "adds",
            "the",
            "most",
            "recently",
            "logged",
            "record",
            "to",
            "our",
            "list"
        ]
    },
    {
        "id": 171,
        "code": "public synchronized List<LogRecord> getStoredLogRecords() {\n  List<LogRecord> result = new ArrayList<>(list);\n  return Collections.unmodifiableList(result);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "snapshot",
            "of",
            "the",
            "logged",
            "records"
        ]
    },
    {
        "id": 172,
        "code": "public void testGetBlocksUntilValueAvailable() throws Throwable {\n\n  assertFalse(future.isDone());\n  assertFalse(future.isCancelled());\n\n  CountDownLatch successLatch = new CountDownLatch(1);\n  Throwable[] badness = new Throwable[1];\n\n    \n  new Thread(\n          () -> {\n            try {\n              assertSame(Boolean.TRUE, future.get());\n              successLatch.countDown();\n            } catch (Throwable t) {\n              t.printStackTrace();\n              badness[0] = t;\n            }\n          })\n      .start();\n\n    \n  latch.countDown();\n\n  assertTrue(successLatch.await(10, SECONDS));\n\n  if (badness[0] != null) {\n    throw badness[0];\n  }\n\n  assertTrue(future.isDone());\n  assertFalse(future.isCancelled());\n}",
        "summary_tokens": [
            "tests",
            "that",
            "the",
            "future",
            "get",
            "method",
            "blocks",
            "until",
            "a",
            "value",
            "is",
            "available"
        ]
    },
    {
        "id": 173,
        "code": "public void testTimeoutOnGetWorksCorrectly() throws InterruptedException, ExecutionException {\n\n    \n  try {\n    future.get(20, MILLISECONDS);\n    fail(\"Should have timed out trying to get the value.\");\n  } catch (TimeoutException expected) {\n  } finally {\n    latch.countDown();\n  }\n}",
        "summary_tokens": [
            "tests",
            "that",
            "the",
            "future",
            "get",
            "long",
            "time",
            "unit",
            "method",
            "times",
            "out",
            "correctly"
        ]
    },
    {
        "id": 174,
        "code": "public void testCanceledFutureThrowsCancellation() throws Exception {\n\n  assertFalse(future.isDone());\n  assertFalse(future.isCancelled());\n\n  CountDownLatch successLatch = new CountDownLatch(1);\n\n    \n  new Thread(\n          () -> {\n            try {\n              future.get();\n            } catch (CancellationException expected) {\n              successLatch.countDown();\n            } catch (Exception ignored) {\n                \n            }\n          })\n      .start();\n\n  assertFalse(future.isDone());\n  assertFalse(future.isCancelled());\n\n  future.cancel(true);\n\n  assertTrue(future.isDone());\n  assertTrue(future.isCancelled());\n\n  assertTrue(successLatch.await(200, MILLISECONDS));\n\n  latch.countDown();\n}",
        "summary_tokens": [
            "tests",
            "that",
            "a",
            "canceled",
            "future",
            "throws",
            "a",
            "cancellation",
            "exception"
        ]
    },
    {
        "id": 175,
        "code": "public void testAllListenersCompleteSuccessfully()\n    throws InterruptedException, ExecutionException {\n\n  ExecutorService exec = Executors.newCachedThreadPool();\n\n  int listenerCount = 20;\n  CountDownLatch listenerLatch = new CountDownLatch(listenerCount);\n\n    \n    \n  for (int i = 0; i < 20; i++) {\n\n      \n    if (i == 10) {\n      new Thread(() -> latch.countDown()).start();\n    }\n\n    future.addListener(listenerLatch::countDown, exec);\n  }\n\n  assertSame(Boolean.TRUE, future.get());\n    \n  listenerLatch.await(500, MILLISECONDS);\n\n  exec.shutdown();\n  exec.awaitTermination(500, MILLISECONDS);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "all",
            "listeners",
            "complete",
            "even",
            "if",
            "they",
            "were",
            "added",
            "before",
            "or",
            "after",
            "the",
            "future",
            "was",
            "finishing"
        ]
    },
    {
        "id": 176,
        "code": "public void assertSuccess(Object expectedData) throws Throwable {\n    \n  Assert.assertTrue(countDownLatch.await(1L, SECONDS));\n\n  try {\n    Assert.assertEquals(expectedData, future.get());\n  } catch (ExecutionException e) {\n    throw e.getCause();\n  }\n}",
        "summary_tokens": [
            "verify",
            "that",
            "the",
            "listener",
            "completes",
            "in",
            "a",
            "reasonable",
            "amount",
            "of",
            "time",
            "and",
            "asserts",
            "that",
            "the",
            "future",
            "returns",
            "the",
            "expected",
            "data"
        ]
    },
    {
        "id": 177,
        "code": "public void assertException(Throwable expectedCause) throws Exception {\n    \n  Assert.assertTrue(countDownLatch.await(1L, SECONDS));\n\n  try {\n    future.get();\n    Assert.fail(\"This call was supposed to throw an ExecutionException\");\n  } catch (ExecutionException expected) {\n    Assert.assertSame(expectedCause, expected.getCause());\n  }\n}",
        "summary_tokens": [
            "verify",
            "that",
            "the",
            "listener",
            "completes",
            "in",
            "a",
            "reasonable",
            "amount",
            "of",
            "time",
            "and",
            "asserts",
            "that",
            "the",
            "future",
            "throws",
            "an",
            "executable",
            "exception",
            "and",
            "that",
            "the",
            "cause",
            "of",
            "the",
            "executable",
            "exception",
            "is",
            "expected",
            "cause"
        ]
    },
    {
        "id": 178,
        "code": "public static ListeningScheduledExecutorService noOpScheduledExecutor() {\n  return new NoOpScheduledExecutorService();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "scheduled",
            "executor",
            "service",
            "that",
            "never",
            "executes",
            "anything"
        ]
    },
    {
        "id": 179,
        "code": "public static SameThreadScheduledExecutorService sameThreadScheduledExecutor() {\n  return new SameThreadScheduledExecutorService();\n}",
        "summary_tokens": [
            "creates",
            "a",
            "scheduled",
            "executor",
            "service",
            "that",
            "runs",
            "each",
            "task",
            "in",
            "the",
            "thread",
            "that",
            "invokes",
            "execute",
            "submit",
            "schedule",
            "as",
            "in",
            "caller",
            "runs",
            "policy"
        ]
    },
    {
        "id": 180,
        "code": "private static Test testsForSetUpTearDown() {\n  final AtomicBoolean setUpRan = new AtomicBoolean();\n  Runnable setUp =\n      new Runnable() {\n        @Override\n        public void run() {\n          assertFalse(\"previous tearDown should have run before setUp\", setUpRan.getAndSet(true));\n        }\n      };\n  Runnable tearDown =\n      new Runnable() {\n        @Override\n        public void run() {\n          assertTrue(\"setUp should have run\", setUpRan.getAndSet(false));\n        }\n      };\n  return MapTestSuiteBuilder.using(new CheckSetUpHashMapGenerator(setUpRan))\n      .named(\"setUpTearDown\")\n      .withFeatures(\n          MapFeature.GENERAL_PURPOSE,\n          MapFeature.ALLOWS_NULL_KEYS,\n          MapFeature.ALLOWS_NULL_VALUES,\n          CollectionFeature.SERIALIZABLE,\n          CollectionFeature.SUPPORTS_ITERATOR_REMOVE,\n          CollectionSize.ANY)\n      .withSetUp(setUp)\n      .withTearDown(tearDown)\n      .createTestSuite();\n}",
        "summary_tokens": [
            "verifies",
            "that",
            "set",
            "up",
            "and",
            "tear",
            "down",
            "are",
            "called",
            "in",
            "all",
            "map",
            "test",
            "cases"
        ]
    },
    {
        "id": 181,
        "code": "public void testAddNullReference() {\n  try {\n    equalsTester.addEqualityGroup((Object) null);\n    fail(\"Should fail on null reference\");\n  } catch (NullPointerException e) {\n  }\n}",
        "summary_tokens": [
            "test",
            "null",
            "reference",
            "yields",
            "error"
        ]
    },
    {
        "id": 182,
        "code": "public void testAddTwoEqualObjectsAtOnceWithNull() {\n  try {\n    equalsTester.addEqualityGroup(reference, equalObject1, null);\n    fail(\"Should fail on null equal object\");\n  } catch (NullPointerException e) {\n  }\n}",
        "summary_tokens": [
            "test",
            "equal",
            "objects",
            "after",
            "adding",
            "multiple",
            "instances",
            "at",
            "once",
            "with",
            "a",
            "null"
        ]
    },
    {
        "id": 183,
        "code": "public void testAddNullEqualObject() {\n  try {\n    equalsTester.addEqualityGroup(reference, (Object[]) null);\n    fail(\"Should fail on null equal object\");\n  } catch (NullPointerException e) {\n  }\n}",
        "summary_tokens": [
            "test",
            "adding",
            "null",
            "equal",
            "object",
            "yields",
            "error"
        ]
    },
    {
        "id": 184,
        "code": "public void testAddEqualObjectWithOArgConstructor() {\n  equalsTester.addEqualityGroup(equalObject1, notEqualObject1);\n  try {\n    equalsTester.testEquals();\n  } catch (AssertionFailedError e) {\n    assertErrorMessage(\n        e,\n        equalObject1\n            + \" [group 1, item 1] must be Object#equals to \"\n            + notEqualObject1\n            + \" [group 1, item 2]\");\n    return;\n  }\n  fail(\"Should get not equal to equal object error\");\n}",
        "summary_tokens": [
            "test",
            "adding",
            "objects",
            "only",
            "by",
            "add",
            "equality",
            "group",
            "with",
            "no",
            "reference",
            "object",
            "specified",
            "in",
            "the",
            "constructor"
        ]
    },
    {
        "id": 185,
        "code": "public void testTestEqualsEmptyLists() {\n  equalsTester.addEqualityGroup(reference);\n  equalsTester.testEquals();\n}",
        "summary_tokens": [
            "test",
            "equals",
            "tester",
            "with",
            "no",
            "equals",
            "or",
            "not",
            "equals",
            "objects"
        ]
    },
    {
        "id": 186,
        "code": "public void testTestEqualsEqualsObjects() {\n  equalsTester.addEqualityGroup(reference, equalObject1, equalObject2);\n  equalsTester.testEquals();\n}",
        "summary_tokens": [
            "test",
            "equals",
            "tester",
            "after",
            "populating",
            "equal",
            "objects"
        ]
    },
    {
        "id": 187,
        "code": "public void testNonreflexiveEquals() {\n  Object obj = new NonReflexiveObject();\n  equalsTester.addEqualityGroup(obj);\n  try {\n    equalsTester.testEquals();\n  } catch (AssertionFailedError e) {\n    assertErrorMessage(e, obj + \" must be Object#equals to itself\");\n    return;\n  }\n  fail(\"Should get non-reflexive error\");\n}",
        "summary_tokens": [
            "test",
            "proper",
            "handling",
            "of",
            "case",
            "where",
            "an",
            "object",
            "is",
            "not",
            "equal",
            "to",
            "itself"
        ]
    },
    {
        "id": 188,
        "code": "public void testInvalidEqualsNull() {\n  Object obj = new InvalidEqualsNullObject();\n  equalsTester.addEqualityGroup(obj);\n  try {\n    equalsTester.testEquals();\n  } catch (AssertionFailedError e) {\n    assertErrorMessage(e, obj + \" must not be Object#equals to null\");\n    return;\n  }\n  fail(\"Should get equal to null error\");\n}",
        "summary_tokens": [
            "test",
            "proper",
            "handling",
            "where",
            "an",
            "object",
            "tests",
            "equal",
            "to",
            "null"
        ]
    },
    {
        "id": 189,
        "code": "public void testInvalidEqualsIncompatibleClass() {\n  Object obj = new InvalidEqualsIncompatibleClassObject();\n  equalsTester.addEqualityGroup(obj);\n  try {\n    equalsTester.testEquals();\n  } catch (AssertionFailedError e) {\n    assertErrorMessage(\n        e, obj + \" must not be Object#equals to an arbitrary object of another class\");\n    return;\n  }\n  fail(\"Should get equal to incompatible class error\");\n}",
        "summary_tokens": [
            "test",
            "proper",
            "handling",
            "where",
            "an",
            "object",
            "incorrectly",
            "tests",
            "for",
            "an",
            "incompatible",
            "class"
        ]
    },
    {
        "id": 190,
        "code": "public void testInvalidNotEqualsEqualObject() {\n  equalsTester.addEqualityGroup(reference, notEqualObject1);\n  try {\n    equalsTester.testEquals();\n  } catch (AssertionFailedError e) {\n    assertErrorMessage(e, reference + \" [group 1, item 1]\");\n    assertErrorMessage(e, notEqualObject1 + \" [group 1, item 2]\");\n    return;\n  }\n  fail(\"Should get not equal to equal object error\");\n}",
        "summary_tokens": [
            "test",
            "proper",
            "handling",
            "where",
            "an",
            "object",
            "is",
            "not",
            "equal",
            "to",
            "one",
            "the",
            "user",
            "has",
            "said",
            "should",
            "be",
            "equal"
        ]
    },
    {
        "id": 191,
        "code": "public void testInvalidHashCode() {\n  Object a = new InvalidHashCodeObject(1, 2);\n  Object b = new InvalidHashCodeObject(1, 2);\n  equalsTester.addEqualityGroup(a, b);\n  try {\n    equalsTester.testEquals();\n  } catch (AssertionFailedError e) {\n    assertErrorMessage(\n        e,\n        \"the Object#hashCode (\"\n            + a.hashCode()\n            + \") of \"\n            + a\n            + \" [group 1, item 1] must be equal to the Object#hashCode (\"\n            + b.hashCode()\n            + \") of \"\n            + b);\n    return;\n  }\n  fail(\"Should get invalid hashCode error\");\n}",
        "summary_tokens": [
            "test",
            "for",
            "an",
            "invalid",
            "hash",
            "code",
            "method",
            "i"
        ]
    },
    {
        "id": 192,
        "code": "public void testOf_NullPointerException() {\n  try {\n    EquivalenceTester.of(null);\n    fail(\"Should fail on null reference\");\n  } catch (NullPointerException expected) {\n  }\n}",
        "summary_tokens": [
            "test",
            "null",
            "reference",
            "yields",
            "error"
        ]
    },
    {
        "id": 193,
        "code": "private void runConcurrentTest(int numberOfThreads, final Callable<Void> callable)\n    throws Exception {\n  ExecutorService executorService = Executors.newFixedThreadPool(numberOfThreads);\n  final CountDownLatch startLatch = new CountDownLatch(numberOfThreads);\n  final CountDownLatch doneLatch = new CountDownLatch(numberOfThreads);\n  for (int i = numberOfThreads; i > 0; i--) {\n    @SuppressWarnings(\"unused\") \n    Future<?> possiblyIgnoredError =\n        executorService.submit(\n            new Callable<Void>() {\n              @Override\n              public Void call() throws Exception {\n                startLatch.countDown();\n                startLatch.await();\n                callable.call();\n                doneLatch.countDown();\n                return null;\n              }\n            });\n  }\n  doneLatch.await();\n}",
        "summary_tokens": [
            "runs",
            "callable",
            "concurrently",
            "number",
            "of",
            "threads",
            "times"
        ]
    },
    {
        "id": 194,
        "code": "public void testAwaitFullGc() {\n  final CountDownLatch finalizerRan = new CountDownLatch(1);\n  final WeakReference<Object> ref =\n      new WeakReference<Object>(\n          new Object() {\n            @Override\n            protected void finalize() {\n              finalizerRan.countDown();\n            }\n          });\n\n    \n    \n  GcFinalization.awaitFullGc();\n\n    \n    \n\n  assertEquals(0, finalizerRan.getCount());\n  assertNull(ref.get());\n}",
        "summary_tokens": [
            "await",
            "full",
            "gc",
            "is",
            "not",
            "quite",
            "as",
            "reliable",
            "a",
            "way",
            "to",
            "ensure",
            "calling",
            "of",
            "a",
            "specific",
            "finalize",
            "method",
            "as",
            "the",
            "more",
            "direct",
            "await",
            "methods",
            "but",
            "should",
            "be",
            "reliable",
            "enough",
            "in",
            "practice",
            "to",
            "avoid",
            "flakiness",
            "of",
            "this",
            "test"
        ]
    },
    {
        "id": 195,
        "code": "private TearDownStack buildTearDownStack() {\n  final TearDownStack result = new TearDownStack();\n  tearDownStack.addTearDown(\n      new TearDown() {\n\n        @Override\n        public void tearDown() throws Exception {\n          synchronized (result.stack) {\n            assertEquals(\n                \"The test should have cleared the stack (say, by virtue of running runTearDown)\",\n                0,\n                result.stack.size());\n          }\n        }\n      });\n  return result;\n}",
        "summary_tokens": [
            "builds",
            "a",
            "tear",
            "down",
            "stack",
            "that",
            "makes",
            "sure",
            "it",
            "s",
            "clear",
            "by",
            "the",
            "end",
            "of",
            "this",
            "test"
        ]
    },
    {
        "id": 196,
        "code": "int joinerWithStringDelimiter(int reps) {\n  int dummy = 0;\n  for (int i = 0; i < reps; i++) {\n    dummy ^= JOINER_ON_STRING.join(components).length();\n  }\n  return dummy;\n}",
        "summary_tokens": [
            "joiner",
            "with",
            "a",
            "string",
            "delimiter"
        ]
    },
    {
        "id": 197,
        "code": "int joinerWithCharacterDelimiter(int reps) {\n  int dummy = 0;\n  for (int i = 0; i < reps; i++) {\n    dummy ^= JOINER_ON_CHARACTER.join(components).length();\n  }\n  return dummy;\n}",
        "summary_tokens": [
            "joiner",
            "with",
            "a",
            "character",
            "delimiter"
        ]
    },
    {
        "id": 198,
        "code": "int joinerInlined(int reps) {\n  int dummy = 0;\n  for (int i = 0; i < reps; i++) {\n    StringBuilder sb = new StringBuilder();\n    Iterator<String> iterator = components.iterator();\n    if (iterator.hasNext()) {\n      sb.append(iterator.next().toString());\n      while (iterator.hasNext()) {\n        sb.append(DELIMITER_STRING);\n        sb.append(iterator.next());\n      }\n    }\n    dummy ^= sb.toString().length();\n  }\n  return dummy;\n}",
        "summary_tokens": [
            "mimics",
            "what",
            "the",
            "joiner",
            "class",
            "does",
            "internally",
            "when",
            "no",
            "extra",
            "options",
            "like",
            "ignoring",
            "null",
            "values",
            "are",
            "used"
        ]
    },
    {
        "id": 199,
        "code": "int stringBuilderIsEmpty(int reps) {\n  int dummy = 0;\n  for (int i = 0; i < reps; i++) {\n    StringBuilder sb = new StringBuilder();\n    for (String comp : components) {\n      if (sb.length() > 0) {\n        sb.append(DELIMITER_STRING);\n      }\n      sb.append(comp);\n    }\n    dummy ^= sb.toString().length();\n  }\n  return dummy;\n}",
        "summary_tokens": [
            "only",
            "appends",
            "delimiter",
            "if",
            "the",
            "accumulated",
            "string",
            "is",
            "non",
            "empty"
        ]
    },
    {
        "id": 200,
        "code": "int booleanIfFirst(int reps) {\n  int dummy = 0;\n  for (int i = 0; i < reps; i++) {\n    StringBuilder sb = new StringBuilder();\n    boolean append = false;\n    for (String comp : components) {\n      if (append) {\n        sb.append(DELIMITER_STRING);\n      }\n      sb.append(comp);\n      append = true;\n    }\n    dummy ^= sb.toString().length();\n  }\n  return dummy;\n}",
        "summary_tokens": [
            "similar",
            "to",
            "the",
            "above",
            "but",
            "keeps",
            "a",
            "boolean",
            "flag",
            "rather",
            "than",
            "checking",
            "for",
            "the",
            "string",
            "accumulated",
            "so",
            "far",
            "being",
            "empty"
        ]
    },
    {
        "id": 201,
        "code": "int assignDelimiter(int reps) {\n  int dummy = 0;\n  for (int i = 0; i < reps; i++) {\n    StringBuilder sb = new StringBuilder();\n    String delim = \"\";\n    for (String comp : components) {\n      sb.append(delim);\n      sb.append(comp);\n      delim = DELIMITER_STRING;\n    }\n    dummy ^= sb.toString().length();\n  }\n  return dummy;\n}",
        "summary_tokens": [
            "starts",
            "with",
            "an",
            "empty",
            "delimiter",
            "and",
            "changes",
            "to",
            "the",
            "desired",
            "value",
            "at",
            "the",
            "end",
            "of",
            "the",
            "iteration"
        ]
    },
    {
        "id": 202,
        "code": "int alwaysAppendThenBackUp(int reps) {\n  int dummy = 0;\n  for (int i = 0; i < reps; i++) {\n    StringBuilder sb = new StringBuilder();\n    for (String comp : components) {\n      sb.append(comp);\n      sb.append(DELIMITER_STRING);\n    }\n    if (sb.length() > 0) {\n      sb.setLength(sb.length() - DELIMITER_STRING.length());\n    }\n    dummy ^= sb.toString().length();\n  }\n  return dummy;\n}",
        "summary_tokens": [
            "always",
            "append",
            "the",
            "delimiter",
            "after",
            "the",
            "component",
            "and",
            "in",
            "the",
            "very",
            "end",
            "shortens",
            "the",
            "buffer",
            "to",
            "get",
            "rid",
            "of",
            "the",
            "extra",
            "trailing",
            "delimiter"
        ]
    },
    {
        "id": 203,
        "code": "void setUp() {\n  final long seed = 99;\n  final Random rnd = new Random(seed);\n  strings = new String[SAMPLES];\n  for (int i = 0; i < SAMPLES; i++) {\n    StringBuilder sb = new StringBuilder();\n    for (int j = 0; j < charCount; j++) {\n      int codePoint;\n        \n      do {\n        codePoint = rnd.nextInt(maxCodePoint.value);\n      } while (Character.isSurrogate((char) codePoint));\n      sb.appendCodePoint(codePoint);\n    }\n    strings[i] = sb.toString();\n  }\n}",
        "summary_tokens": [
            "compute",
            "arrays",
            "of",
            "valid",
            "unicode",
            "text",
            "and",
            "store",
            "it",
            "in",
            "0",
            "forms",
            "byte",
            "arrays",
            "strings",
            "and",
            "string",
            "builders",
            "in",
            "a",
            "char",
            "sequence",
            "to",
            "make",
            "it",
            "a",
            "little",
            "harder",
            "for",
            "the",
            "jvm"
        ]
    },
    {
        "id": 204,
        "code": "private static BigInteger oldSlowFactorial(int n1, int n2) {\n  assert n1 <= n2;\n  if (IntMath.log2(n2, CEILING) * (n2 - n1) < Long.SIZE - 1) {\n      \n    long result = 1;\n    for (int i = n1 + 1; i <= n2; i++) {\n      result *= i;\n    }\n    return BigInteger.valueOf(result);\n  }\n\n    \n  int mid = (n1 + n2) >>> 1;\n  return oldSlowFactorial(n1, mid).multiply(oldSlowFactorial(mid, n2));\n}",
        "summary_tokens": [
            "returns",
            "the",
            "product",
            "of",
            "n",
            "0",
            "exclusive",
            "through",
            "n",
            "0",
            "inclusive"
        ]
    },
    {
        "id": 205,
        "code": "private void insert(E x) {\n  items[putIndex] = x;\n  putIndex = inc(putIndex);\n  ++count;\n}",
        "summary_tokens": [
            "inserts",
            "element",
            "at",
            "current",
            "put",
            "position",
            "advances",
            "and",
            "signals"
        ]
    },
    {
        "id": 206,
        "code": "private E extract() {\n  final E[] items = this.items;\n  E x = items[takeIndex];\n  items[takeIndex] = null;\n  takeIndex = inc(takeIndex);\n  --count;\n  return x;\n}",
        "summary_tokens": [
            "extracts",
            "element",
            "at",
            "current",
            "take",
            "position",
            "advances",
            "and",
            "signals"
        ]
    },
    {
        "id": 207,
        "code": "void removeAt(int i) {\n  final E[] items = this.items;\n    \n  if (i == takeIndex) {\n    items[takeIndex] = null;\n    takeIndex = inc(takeIndex);\n  } else {\n      \n    for (; ; ) {\n      int nexti = inc(i);\n      if (nexti != putIndex) {\n        items[i] = items[nexti];\n        i = nexti;\n      } else {\n        items[i] = null;\n        putIndex = i;\n        break;\n      }\n    }\n  }\n  --count;\n}",
        "summary_tokens": [
            "utility",
            "for",
            "remove",
            "and",
            "iterator"
        ]
    },
    {
        "id": 208,
        "code": "public boolean add(E e) {\n  return super.add(e);\n}",
        "summary_tokens": [
            "inserts",
            "the",
            "specified",
            "element",
            "at",
            "the",
            "tail",
            "of",
            "this",
            "queue",
            "if",
            "it",
            "is",
            "possible",
            "to",
            "do",
            "so",
            "immediately",
            "without",
            "exceeding",
            "the",
            "queue",
            "s",
            "capacity",
            "returning",
            "true",
            "upon",
            "success",
            "and",
            "throwing",
            "an",
            "illegal",
            "state",
            "exception",
            "if",
            "this",
            "queue",
            "is",
            "full"
        ]
    },
    {
        "id": 209,
        "code": "public boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException {\n\n  if (e == null) throw new NullPointerException();\n  final Monitor monitor = this.monitor;\n  if (monitor.enterWhen(notFull, timeout, unit)) {\n    try {\n      insert(e);\n      return true;\n    } finally {\n      monitor.leave();\n    }\n  } else {\n    return false;\n  }\n}",
        "summary_tokens": [
            "inserts",
            "the",
            "specified",
            "element",
            "at",
            "the",
            "tail",
            "of",
            "this",
            "queue",
            "waiting",
            "up",
            "to",
            "the",
            "specified",
            "wait",
            "time",
            "for",
            "space",
            "to",
            "become",
            "available",
            "if",
            "the",
            "queue",
            "is",
            "full"
        ]
    },
    {
        "id": 210,
        "code": "public void put(E e) throws InterruptedException {\n  if (e == null) throw new NullPointerException();\n  final Monitor monitor = this.monitor;\n  monitor.enterWhen(notFull);\n  try {\n    insert(e);\n  } finally {\n    monitor.leave();\n  }\n}",
        "summary_tokens": [
            "inserts",
            "the",
            "specified",
            "element",
            "at",
            "the",
            "tail",
            "of",
            "this",
            "queue",
            "waiting",
            "for",
            "space",
            "to",
            "become",
            "available",
            "if",
            "the",
            "queue",
            "is",
            "full"
        ]
    },
    {
        "id": 211,
        "code": "public int size() {\n  final Monitor monitor = this.monitor;\n  monitor.enter();\n  try {\n    return count;\n  } finally {\n    monitor.leave();\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "elements",
            "in",
            "this",
            "queue"
        ]
    },
    {
        "id": 212,
        "code": "public int remainingCapacity() {\n  final Monitor monitor = this.monitor;\n  monitor.enter();\n  try {\n    return items.length - count;\n  } finally {\n    monitor.leave();\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "additional",
            "elements",
            "that",
            "this",
            "queue",
            "can",
            "ideally",
            "in",
            "the",
            "absence",
            "of",
            "memory",
            "or",
            "resource",
            "constraints",
            "accept",
            "without",
            "blocking"
        ]
    },
    {
        "id": 213,
        "code": "public boolean remove(@Nullable Object o) {\n  if (o == null) return false;\n  final E[] items = this.items;\n  final Monitor monitor = this.monitor;\n  monitor.enter();\n  try {\n    int i = takeIndex;\n    int k = 0;\n    for (; ; ) {\n      if (k++ >= count) return false;\n      if (o.equals(items[i])) {\n        removeAt(i);\n        return true;\n      }\n      i = inc(i);\n    }\n  } finally {\n    monitor.leave();\n  }\n}",
        "summary_tokens": [
            "removes",
            "a",
            "single",
            "instance",
            "of",
            "the",
            "specified",
            "element",
            "from",
            "this",
            "queue",
            "if",
            "it",
            "is",
            "present"
        ]
    },
    {
        "id": 214,
        "code": "public boolean contains(@Nullable Object o) {\n  if (o == null) return false;\n  final E[] items = this.items;\n  final Monitor monitor = this.monitor;\n  monitor.enter();\n  try {\n    int i = takeIndex;\n    int k = 0;\n    while (k++ < count) {\n      if (o.equals(items[i])) return true;\n      i = inc(i);\n    }\n    return false;\n  } finally {\n    monitor.leave();\n  }\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "this",
            "queue",
            "contains",
            "the",
            "specified",
            "element"
        ]
    },
    {
        "id": 215,
        "code": "public <T> T[] toArray(T[] a) {\n  final E[] items = this.items;\n  final Monitor monitor = this.monitor;\n  monitor.enter();\n  try {\n    if (a.length < count) a = ObjectArrays.newArray(a, count);\n\n    int k = 0;\n    int i = takeIndex;\n    while (k < count) {\n        \n        \n        \n        \n      @SuppressWarnings(\"unchecked\")\n      T t = (T) items[i];\n      a[k++] = t;\n      i = inc(i);\n    }\n    if (a.length > count) a[count] = null;\n    return a;\n  } finally {\n    monitor.leave();\n  }\n}",
        "summary_tokens": [
            "returns",
            "an",
            "array",
            "containing",
            "all",
            "of",
            "the",
            "elements",
            "in",
            "this",
            "queue",
            "in",
            "proper",
            "sequence",
            "the",
            "runtime",
            "type",
            "of",
            "the",
            "returned",
            "array",
            "is",
            "that",
            "of",
            "the",
            "specified",
            "array"
        ]
    },
    {
        "id": 216,
        "code": "public void clear() {\n  final E[] items = this.items;\n  final Monitor monitor = this.monitor;\n  monitor.enter();\n  try {\n    int i = takeIndex;\n    int k = count;\n    while (k-- > 0) {\n      items[i] = null;\n      i = inc(i);\n    }\n    count = 0;\n    putIndex = 0;\n    takeIndex = 0;\n  } finally {\n    monitor.leave();\n  }\n}",
        "summary_tokens": [
            "atomically",
            "removes",
            "all",
            "of",
            "the",
            "elements",
            "from",
            "this",
            "queue"
        ]
    },
    {
        "id": 217,
        "code": "public int drainTo(Collection<? super E> c, int maxElements) {\n  if (c == null) throw new NullPointerException();\n  if (c == this) throw new IllegalArgumentException();\n  if (maxElements <= 0) return 0;\n  final E[] items = this.items;\n  final Monitor monitor = this.monitor;\n  monitor.enter();\n  try {\n    int i = takeIndex;\n    int n = 0;\n    int max = (maxElements < count) ? maxElements : count;\n    while (n < max) {\n      c.add(items[i]);\n      items[i] = null;\n      i = inc(i);\n      ++n;\n    }\n    if (n > 0) {\n      count -= n;\n      takeIndex = i;\n    }\n    return n;\n  } finally {\n    monitor.leave();\n  }\n}",
        "summary_tokens": [
            "unsupported",
            "operation",
            "exception",
            "class",
            "cast",
            "exception",
            "null",
            "pointer",
            "exception",
            "illegal",
            "argument",
            "exception"
        ]
    },
    {
        "id": 218,
        "code": "public Iterator<E> iterator() {\n  final Monitor monitor = this.monitor;\n  monitor.enter();\n  try {\n    return new Itr();\n  } finally {\n    monitor.leave();\n  }\n}",
        "summary_tokens": [
            "returns",
            "an",
            "iterator",
            "over",
            "the",
            "elements",
            "in",
            "this",
            "queue",
            "in",
            "proper",
            "sequence"
        ]
    },
    {
        "id": 219,
        "code": "public boolean add(E e) {\n  return offer(e);\n}",
        "summary_tokens": [
            "inserts",
            "the",
            "specified",
            "element",
            "into",
            "this",
            "priority",
            "queue"
        ]
    },
    {
        "id": 220,
        "code": "public boolean offer(E e, long timeout, TimeUnit unit) {\n  checkNotNull(unit);\n  return offer(e); \n}",
        "summary_tokens": [
            "inserts",
            "the",
            "specified",
            "element",
            "into",
            "this",
            "priority",
            "queue"
        ]
    },
    {
        "id": 221,
        "code": "public void put(E e) {\n  offer(e); \n}",
        "summary_tokens": [
            "inserts",
            "the",
            "specified",
            "element",
            "into",
            "this",
            "priority",
            "queue"
        ]
    },
    {
        "id": 222,
        "code": "public Comparator<? super E> comparator() {\n  return q.comparator();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "comparator",
            "used",
            "to",
            "order",
            "the",
            "elements",
            "in",
            "this",
            "queue",
            "or",
            "null",
            "if",
            "this",
            "queue",
            "uses",
            "the",
            "comparable",
            "natural",
            "ordering",
            "of",
            "its",
            "elements"
        ]
    },
    {
        "id": 223,
        "code": "public boolean remove(@Nullable Object o) {\n  final Monitor monitor = this.monitor;\n  monitor.enter();\n  try {\n    return q.remove(o);\n  } finally {\n    monitor.leave();\n  }\n}",
        "summary_tokens": [
            "removes",
            "a",
            "single",
            "instance",
            "of",
            "the",
            "specified",
            "element",
            "from",
            "this",
            "queue",
            "if",
            "it",
            "is",
            "present"
        ]
    },
    {
        "id": 224,
        "code": "public boolean contains(@Nullable Object o) {\n  final Monitor monitor = this.monitor;\n  monitor.enter();\n  try {\n    return q.contains(o);\n  } finally {\n    monitor.leave();\n  }\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "this",
            "queue",
            "contains",
            "the",
            "specified",
            "element"
        ]
    },
    {
        "id": 225,
        "code": "public <T> T[] toArray(T[] a) {\n  final Monitor monitor = this.monitor;\n  monitor.enter();\n  try {\n    return q.toArray(a);\n  } finally {\n    monitor.leave();\n  }\n}",
        "summary_tokens": [
            "returns",
            "an",
            "array",
            "containing",
            "all",
            "of",
            "the",
            "elements",
            "in",
            "this",
            "queue",
            "the",
            "runtime",
            "type",
            "of",
            "the",
            "returned",
            "array",
            "is",
            "that",
            "of",
            "the",
            "specified",
            "array"
        ]
    },
    {
        "id": 226,
        "code": "public int drainTo(Collection<? super E> c, int maxElements) {\n  if (c == null) throw new NullPointerException();\n  if (c == this) throw new IllegalArgumentException();\n  if (maxElements <= 0) return 0;\n  final Monitor monitor = this.monitor;\n  monitor.enter();\n  try {\n    int n = 0;\n    E e;\n    while (n < maxElements && (e = q.poll()) != null) {\n      c.add(e);\n      ++n;\n    }\n    return n;\n  } finally {\n    monitor.leave();\n  }\n}",
        "summary_tokens": [
            "unsupported",
            "operation",
            "exception",
            "class",
            "cast",
            "exception",
            "null",
            "pointer",
            "exception",
            "illegal",
            "argument",
            "exception"
        ]
    },
    {
        "id": 227,
        "code": "public void clear() {\n  final Monitor monitor = this.monitor;\n  monitor.enter();\n  try {\n    q.clear();\n  } finally {\n    monitor.leave();\n  }\n}",
        "summary_tokens": [
            "atomically",
            "removes",
            "all",
            "of",
            "the",
            "elements",
            "from",
            "this",
            "queue"
        ]
    },
    {
        "id": 228,
        "code": "public Iterator<E> iterator() {\n  return new Itr(toArray());\n}",
        "summary_tokens": [
            "returns",
            "an",
            "iterator",
            "over",
            "the",
            "elements",
            "in",
            "this",
            "queue"
        ]
    },
    {
        "id": 229,
        "code": "private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException {\n  monitor.enter();\n  try {\n    s.defaultWriteObject();\n  } finally {\n    monitor.leave();\n  }\n}",
        "summary_tokens": [
            "saves",
            "the",
            "state",
            "to",
            "a",
            "stream",
            "that",
            "is",
            "serializes",
            "it"
        ]
    },
    {
        "id": 230,
        "code": "private static void sneakyThrow(Throwable t) {\n  class SneakyThrower<T extends Throwable> {\n    @SuppressWarnings(\"unchecked\") \n    void throwIt(Throwable t) throws T {\n      throw (T) t;\n    }\n  }\n  new SneakyThrower<Error>().throwIt(t);\n}",
        "summary_tokens": [
            "throws",
            "an",
            "undeclared",
            "checked",
            "exception"
        ]
    },
    {
        "id": 231,
        "code": "private void assertEqualsSame(String expected, String in, String out) {\n  if (expected.equals(in)) {\n    assertSame(in, out);\n  } else {\n    assertEquals(expected, out);\n  }\n}",
        "summary_tokens": [
            "checks",
            "that",
            "expected",
            "is",
            "equals",
            "to",
            "out",
            "and",
            "further",
            "if",
            "in",
            "is",
            "equals",
            "to",
            "expected",
            "then",
            "out",
            "is",
            "successfully",
            "optimized",
            "to",
            "be",
            "identical",
            "to",
            "in",
            "i"
        ]
    },
    {
        "id": 232,
        "code": "private static ImmutableList<URL> parseJavaClassPath() {\n  ImmutableList.Builder<URL> urls = ImmutableList.builder();\n  for (String entry : Splitter.on(PATH_SEPARATOR.value()).split(JAVA_CLASS_PATH.value())) {\n    try {\n      try {\n        urls.add(new File(entry).toURI().toURL());\n      } catch (SecurityException e) { \n        urls.add(new URL(\"file\", null, new File(entry).getAbsolutePath()));\n      }\n    } catch (MalformedURLException e) {\n      AssertionError error = new AssertionError(\"malformed class path entry: \" + entry);\n      error.initCause(e);\n      throw error;\n    }\n  }\n  return urls.build();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "urls",
            "in",
            "the",
            "class",
            "path",
            "specified",
            "by",
            "the",
            "java"
        ]
    },
    {
        "id": 233,
        "code": "public void testUnloadableWithoutSecurityManager() throws Exception {\n  if (isJdk9OrHigher()) {\n    return;\n  }\n  SecurityManager oldSecurityManager = System.getSecurityManager();\n  try {\n    System.setSecurityManager(null);\n    doTestUnloadable();\n  } finally {\n    System.setSecurityManager(oldSecurityManager);\n  }\n}",
        "summary_tokens": [
            "tests",
            "that",
            "the",
            "use",
            "of",
            "a",
            "finalizable",
            "reference",
            "queue",
            "does",
            "not",
            "subsequently",
            "prevent",
            "the",
            "loader",
            "of",
            "that",
            "class",
            "from",
            "being",
            "garbage",
            "collected"
        ]
    },
    {
        "id": 234,
        "code": "public void testUnloadableWithSecurityManager() throws Exception {\n  if (isJdk9OrHigher()) {\n    return;\n  }\n  Policy oldPolicy = Policy.getPolicy();\n  SecurityManager oldSecurityManager = System.getSecurityManager();\n  try {\n    Policy.setPolicy(new PermissivePolicy());\n    System.setSecurityManager(new SecurityManager());\n    doTestUnloadable();\n  } finally {\n    System.setSecurityManager(oldSecurityManager);\n    Policy.setPolicy(oldPolicy);\n  }\n}",
        "summary_tokens": [
            "tests",
            "that",
            "the",
            "use",
            "of",
            "a",
            "finalizable",
            "reference",
            "queue",
            "does",
            "not",
            "subsequently",
            "prevent",
            "the",
            "loader",
            "of",
            "that",
            "class",
            "from",
            "being",
            "garbage",
            "collected",
            "even",
            "if",
            "there",
            "is",
            "a",
            "security",
            "manager"
        ]
    },
    {
        "id": 235,
        "code": "private static ImmutableList<URL> parseJavaClassPath() {\n  ImmutableList.Builder<URL> urls = ImmutableList.builder();\n  for (String entry : Splitter.on(PATH_SEPARATOR.value()).split(JAVA_CLASS_PATH.value())) {\n    try {\n      try {\n        urls.add(new File(entry).toURI().toURL());\n      } catch (SecurityException e) { \n        urls.add(new URL(\"file\", null, new File(entry).getAbsolutePath()));\n      }\n    } catch (MalformedURLException e) {\n      AssertionError error = new AssertionError(\"malformed class path entry: \" + entry);\n      error.initCause(e);\n      throw error;\n    }\n  }\n  return urls.build();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "urls",
            "in",
            "the",
            "class",
            "path",
            "specified",
            "by",
            "the",
            "java"
        ]
    },
    {
        "id": 236,
        "code": "private static boolean isJdk9OrHigher() {\n  return JAVA_SPECIFICATION_VERSION.value().startsWith(\"9\")\n      || JAVA_SPECIFICATION_VERSION.value().startsWith(\"10\");\n}",
        "summary_tokens": [
            "these",
            "tests",
            "fail",
            "in",
            "jdk",
            "0",
            "and",
            "jdk",
            "0",
            "for",
            "an",
            "unknown",
            "reason"
        ]
    },
    {
        "id": 237,
        "code": "private void weaklyReferenceQueue() {\n  frq = new FinalizableReferenceQueue();\n  queueReference = new WeakReference<>(frq.queue);\n\n    \n  reference =\n      new FinalizableWeakReference<Object>(new Object(), frq) {\n        @Override\n        public void finalizeReferent() {\n          reference = null;\n          frq = null;\n        }\n      };\n}",
        "summary_tokens": [
            "create",
            "the",
            "frq",
            "in",
            "a",
            "method",
            "that",
            "goes",
            "out",
            "of",
            "scope",
            "so",
            "that",
            "we",
            "re",
            "sure",
            "it",
            "will",
            "be",
            "reclaimed"
        ]
    },
    {
        "id": 238,
        "code": "private void assertFailureCause(\n    Throwable throwable, Class<? extends Throwable> clazz, Object[] params) {\n  assertThat(throwable).isInstanceOf(clazz);\n  if (params.length == 1) {\n    assertThat(throwable).hasMessageThat().isNull();\n  } else if (params.length == 2) {\n    assertThat(throwable).hasMessageThat().isEmpty();\n  } else {\n    assertThat(throwable)\n        .hasMessageThat()\n        .isEqualTo(Strings.lenientFormat(\"\", Arrays.copyOfRange(params, 2, params.length)));\n  }\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "the",
            "given",
            "throwable",
            "has",
            "the",
            "given",
            "class",
            "and",
            "then",
            "asserts",
            "on",
            "the",
            "message",
            "as",
            "using",
            "the",
            "full",
            "set",
            "of",
            "method",
            "parameters"
        ]
    },
    {
        "id": 239,
        "code": "private Object[] getParametersForSignature(Object firstParam, ImmutableList<Class<?>> sig) {\n  Object[] params = new Object[sig.size()];\n  params[0] = firstParam;\n  if (params.length > 1) {\n    params[1] = \"\";\n    if (params.length > 2) {\n        \n      for (int i = 2; i < params.length; i++) {\n        params[i] = ArbitraryInstances.get(sig.get(i));\n      }\n    }\n  }\n  return params;\n}",
        "summary_tokens": [
            "returns",
            "an",
            "array",
            "containing",
            "parameters",
            "for",
            "invoking",
            "a",
            "check",
            "argument",
            "check",
            "not",
            "null",
            "or",
            "check",
            "state",
            "method",
            "reflectively"
        ]
    },
    {
        "id": 240,
        "code": "private static ImmutableList<ImmutableList<Class<?>>> allSignatures(Class<?> predicateType) {\n  ImmutableSet.Builder<ImmutableList<Class<?>>> allOverloads = ImmutableSet.builder();\n    \n    \n  allOverloads.add(ImmutableList.<Class<?>>of(predicateType));\n  allOverloads.add(ImmutableList.<Class<?>>of(predicateType, Object.class));\n\n  List<List<Class<?>>> typesLists = new ArrayList<>();\n  for (int i = 0; i < 2; i++) {\n    typesLists.add(possibleParamTypes);\n    for (List<Class<?>> curr : Lists.cartesianProduct(typesLists)) {\n      allOverloads.add(\n          ImmutableList.<Class<?>>builder()\n              .add(predicateType)\n              .add(String.class) \n              .addAll(curr)\n              .build());\n    }\n  }\n  return allOverloads.build().asList();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "list",
            "of",
            "parameters",
            "for",
            "invoking",
            "an",
            "overload",
            "of",
            "check",
            "state",
            "check",
            "argument",
            "or",
            "check",
            "not",
            "null"
        ]
    },
    {
        "id": 241,
        "code": "private static IsOdd isOdd() {\n  return new IsOdd();\n}",
        "summary_tokens": [
            "generates",
            "a",
            "new",
            "predicate",
            "per",
            "call"
        ]
    },
    {
        "id": 242,
        "code": "public void testCharacterSimpleSplitToList() {\n  String simple = \"a,b,c\";\n  List<String> letters = COMMA_SPLITTER.splitToList(simple);\n  assertThat(letters).containsExactly(\"a\", \"b\", \"c\").inOrder();\n}",
        "summary_tokens": [
            "all",
            "of",
            "the",
            "infrastructure",
            "of",
            "split",
            "and",
            "split",
            "to",
            "string",
            "is",
            "identical",
            "so",
            "we",
            "do",
            "one",
            "test",
            "of",
            "split",
            "to",
            "string"
        ]
    },
    {
        "id": 243,
        "code": "private void assertSplitterIterableIsLazy(Splitter splitter) {\n  StringBuilder builder = new StringBuilder();\n  Iterator<String> iterator = splitter.split(builder).iterator();\n\n  builder.append(\"A,\");\n  assertEquals(\"A\", iterator.next());\n  builder.append(\"B,\");\n  assertEquals(\"B\", iterator.next());\n  builder.append(\"C\");\n  assertEquals(\"C\", iterator.next());\n  assertFalse(iterator.hasNext());\n}",
        "summary_tokens": [
            "this",
            "test",
            "really",
            "pushes",
            "the",
            "boundaries",
            "of",
            "what",
            "we",
            "support"
        ]
    },
    {
        "id": 244,
        "code": "public void testMapSplitter_extraValueDelimiter() {\n  try {\n    COMMA_SPLITTER.withKeyValueSeparator(\"=\").split(\"a=1,c=2=\");\n    fail();\n  } catch (IllegalArgumentException expected) {\n  }\n}",
        "summary_tokens": [
            "testing",
            "the",
            "behavior",
            "in",
            "https",
            "github"
        ]
    },
    {
        "id": 245,
        "code": "public void testIsWellFormed_1Byte() {\n  testBytes(1, EXPECTED_ONE_BYTE_ROUNDTRIPPABLE_COUNT);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "round",
            "tripping",
            "of",
            "all",
            "two",
            "byte",
            "permutations",
            "work"
        ]
    },
    {
        "id": 246,
        "code": "public void testIsWellFormed_2Bytes() {\n  testBytes(2, EXPECTED_TWO_BYTE_ROUNDTRIPPABLE_COUNT);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "round",
            "tripping",
            "of",
            "all",
            "two",
            "byte",
            "permutations",
            "work"
        ]
    },
    {
        "id": 247,
        "code": "public void testIsWellFormed_3Bytes() {\n  testBytes(3, EXPECTED_THREE_BYTE_ROUNDTRIPPABLE_COUNT);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "round",
            "tripping",
            "of",
            "all",
            "three",
            "byte",
            "permutations",
            "work"
        ]
    },
    {
        "id": 248,
        "code": "public void testIsWellFormed_4BytesSamples() {\n    \n  assertWellFormed(0xF0, 0xA4, 0xAD, 0xA2);\n    \n  assertNotWellFormed(0xF0, 0xA4, 0xAD, 0x7F);\n  assertNotWellFormed(0xF0, 0xA4, 0xAD, 0xC0);\n    \n  assertNotWellFormed(0xF0, 0x8F, 0xAD, 0xA2);\n  assertNotWellFormed(0xF4, 0x90, 0xAD, 0xA2);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "round",
            "tripping",
            "of",
            "a",
            "sample",
            "of",
            "four",
            "byte",
            "permutations",
            "work"
        ]
    },
    {
        "id": 249,
        "code": "public void testSomeSequences() {\n    \n  assertWellFormed();\n    \n  assertWellFormed(0x00, 0x61, 0x62, 0x63, 0x7F); \n    \n  assertWellFormed(0xC2, 0xA2, 0xC2, 0xA2); \n    \n  assertWellFormed(0xc8, 0x8a, 0x63, 0xc8, 0x8a, 0x63); \n    \n    \n  assertWellFormed(0xc9, 0x8b, 0x36, 0x32, 0xc9, 0x8b, 0x36, 0x32);\n    \n    \n  assertWellFormed(\n      0x61, 0xc8, 0x8a, 0x63, 0xc2, 0xa2, 0x62, 0x5c, 0x75, 0x30, 0x32, 0x34, 0x42, 0x36, 0x32,\n      0x75, 0x30, 0x32, 0x30, 0x61, 0x63, 0x63, 0xc2, 0xa2, 0x64, 0x65, 0xc9, 0x8b, 0x36, 0x32);\n    \n  assertNotWellFormed(-1, 0, -1, 0);\n}",
        "summary_tokens": [
            "tests",
            "some",
            "hard",
            "coded",
            "test",
            "cases"
        ]
    },
    {
        "id": 250,
        "code": "private static void testBytes(int numBytes, long expectedCount, long start, long lim) {\n  byte[] bytes = new byte[numBytes];\n  if (lim == -1) {\n    lim = 1L << (numBytes * 8);\n  }\n  long countRoundTripped = 0;\n  for (long byteChar = start; byteChar < lim; byteChar++) {\n    long tmpByteChar = byteChar;\n    for (int i = 0; i < numBytes; i++) {\n      bytes[bytes.length - i - 1] = (byte) tmpByteChar;\n      tmpByteChar = tmpByteChar >> 8;\n    }\n    boolean isRoundTrippable = Utf8.isWellFormed(bytes);\n    assertEquals(isRoundTrippable, Utf8.isWellFormed(bytes, 0, numBytes));\n    String s = new String(bytes, Charsets.UTF_8);\n    byte[] bytesReencoded = s.getBytes(Charsets.UTF_8);\n    boolean bytesEqual = Arrays.equals(bytes, bytesReencoded);\n\n    if (bytesEqual != isRoundTrippable) {\n      fail();\n    }\n    if (isRoundTrippable) {\n      countRoundTripped++;\n    }\n  }\n  assertEquals(expectedCount, countRoundTripped);\n}",
        "summary_tokens": [
            "helper",
            "to",
            "run",
            "the",
            "loop",
            "to",
            "test",
            "all",
            "the",
            "permutations",
            "for",
            "the",
            "number",
            "of",
            "bytes",
            "specified"
        ]
    },
    {
        "id": 251,
        "code": "public void testRemovalNotification_clear_basher() throws InterruptedException {\n    \n    \n    \n    \n  AtomicBoolean computationShouldWait = new AtomicBoolean();\n  CountDownLatch computationLatch = new CountDownLatch(1);\n  QueuingRemovalListener<String, String> listener = queuingRemovalListener();\n  final LoadingCache<String, String> cache =\n      CacheBuilder.newBuilder()\n          .removalListener(listener)\n          .concurrencyLevel(20)\n          .build(new DelayingIdentityLoader<String>(computationShouldWait, computationLatch));\n\n  int nThreads = 100;\n  int nTasks = 1000;\n  int nSeededEntries = 100;\n  Set<String> expectedKeys = Sets.newHashSetWithExpectedSize(nTasks + nSeededEntries);\n    \n    \n  for (int i = 0; i < nSeededEntries; i++) {\n    String s = \"b\" + i;\n    cache.getUnchecked(s);\n    expectedKeys.add(s);\n  }\n  computationShouldWait.set(true);\n\n  final AtomicInteger computedCount = new AtomicInteger();\n  ExecutorService threadPool = Executors.newFixedThreadPool(nThreads);\n  final CountDownLatch tasksFinished = new CountDownLatch(nTasks);\n  for (int i = 0; i < nTasks; i++) {\n    final String s = \"a\" + i;\n    @SuppressWarnings(\"unused\") \n    Future<?> possiblyIgnoredError =\n        threadPool.submit(\n            new Runnable() {\n              @Override\n              public void run() {\n                cache.getUnchecked(s);\n                computedCount.incrementAndGet();\n                tasksFinished.countDown();\n              }\n            });\n    expectedKeys.add(s);\n  }\n\n  computationLatch.countDown();\n    \n  while (computedCount.get() < nThreads) {\n    Thread.yield();\n  }\n  cache.invalidateAll();\n  tasksFinished.await();\n\n    \n    \n    \n  Map<String, String> removalNotifications = Maps.newHashMap();\n  for (RemovalNotification<String, String> notification : listener) {\n    removalNotifications.put(notification.getKey(), notification.getValue());\n    assertEquals(\n        \"Unexpected key/value pair passed to removalListener\",\n        notification.getKey(),\n        notification.getValue());\n  }\n\n    \n    \n  for (int i = 0; i < nSeededEntries; i++) {\n    assertEquals(\"b\" + i, removalNotifications.get(\"b\" + i));\n  }\n\n    \n    \n  assertEquals(expectedKeys, Sets.union(cache.asMap().keySet(), removalNotifications.keySet()));\n  assertTrue(Sets.intersection(cache.asMap().keySet(), removalNotifications.keySet()).isEmpty());\n}",
        "summary_tokens": [
            "this",
            "is",
            "a",
            "less",
            "carefully",
            "controlled",
            "version",
            "of",
            "test",
            "removal",
            "notification",
            "clear",
            "this",
            "is",
            "a",
            "black",
            "box",
            "test",
            "that",
            "tries",
            "to",
            "create",
            "lots",
            "of",
            "different",
            "thread",
            "interleavings",
            "and",
            "asserts",
            "that",
            "each",
            "computation",
            "is",
            "affected",
            "by",
            "a",
            "call",
            "to",
            "clear",
            "and",
            "therefore",
            "gets",
            "passed",
            "to",
            "the",
            "removal",
            "listener",
            "or",
            "else",
            "is",
            "not",
            "affected",
            "by",
            "the",
            "clear",
            "and",
            "therefore",
            "exists",
            "in",
            "the",
            "cache",
            "afterward"
        ]
    },
    {
        "id": 252,
        "code": "public void testRemovalNotification_get_basher() throws InterruptedException {\n  int nTasks = 1000;\n  int nThreads = 100;\n  final int getsPerTask = 1000;\n  final int nUniqueKeys = 10000;\n  final Random random = new Random(); \n\n  QueuingRemovalListener<String, String> removalListener = queuingRemovalListener();\n  final AtomicInteger computeCount = new AtomicInteger();\n  final AtomicInteger exceptionCount = new AtomicInteger();\n  final AtomicInteger computeNullCount = new AtomicInteger();\n  CacheLoader<String, String> countingIdentityLoader =\n      new CacheLoader<String, String>() {\n        @Override\n        public String load(String key) throws InterruptedException {\n          int behavior = random.nextInt(4);\n          if (behavior == 0) { \n            exceptionCount.incrementAndGet();\n            throw new RuntimeException(\"fake exception for test\");\n          } else if (behavior == 1) { \n            computeNullCount.incrementAndGet();\n            return null;\n          } else if (behavior == 2) { \n            Thread.sleep(5);\n            computeCount.incrementAndGet();\n            return key;\n          } else {\n            computeCount.incrementAndGet();\n            return key;\n          }\n        }\n      };\n  final LoadingCache<String, String> cache =\n      CacheBuilder.newBuilder()\n          .recordStats()\n          .concurrencyLevel(2)\n          .expireAfterWrite(100, MILLISECONDS)\n          .removalListener(removalListener)\n          .maximumSize(5000)\n          .build(countingIdentityLoader);\n\n  ExecutorService threadPool = Executors.newFixedThreadPool(nThreads);\n  for (int i = 0; i < nTasks; i++) {\n    @SuppressWarnings(\"unused\") \n    Future<?> possiblyIgnoredError =\n        threadPool.submit(\n            new Runnable() {\n              @Override\n              public void run() {\n                for (int j = 0; j < getsPerTask; j++) {\n                  try {\n                    cache.getUnchecked(\"key\" + random.nextInt(nUniqueKeys));\n                  } catch (RuntimeException e) {\n                  }\n                }\n              }\n            });\n  }\n\n  threadPool.shutdown();\n  threadPool.awaitTermination(300, SECONDS);\n\n    \n    \n\n    \n  for (RemovalNotification<String, String> notification : removalListener) {\n    assertEquals(\"Invalid removal notification\", notification.getKey(), notification.getValue());\n  }\n\n  CacheStats stats = cache.stats();\n  assertEquals(removalListener.size(), stats.evictionCount());\n  assertEquals(computeCount.get(), stats.loadSuccessCount());\n  assertEquals(exceptionCount.get() + computeNullCount.get(), stats.loadExceptionCount());\n    \n  assertEquals(computeCount.get(), cache.size() + removalListener.size());\n}",
        "summary_tokens": [
            "calls",
            "get",
            "repeatedly",
            "from",
            "many",
            "different",
            "threads",
            "and",
            "tests",
            "that",
            "all",
            "of",
            "the",
            "removed",
            "entries",
            "removed",
            "because",
            "of",
            "size",
            "limits",
            "or",
            "expiration",
            "trigger",
            "appropriate",
            "removal",
            "notifications"
        ]
    },
    {
        "id": 253,
        "code": "public void testEviction_maxWeight_zero() {\n  CountingRemovalListener<Integer, Integer> removalListener = countingRemovalListener();\n  IdentityLoader<Integer> loader = identityLoader();\n\n    \n  Weigher<Integer, Integer> evensOnly =\n      new Weigher<Integer, Integer>() {\n        @Override\n        public int weigh(Integer k, Integer v) {\n          return k % 2;\n        }\n      };\n\n  LoadingCache<Integer, Integer> cache =\n      CacheBuilder.newBuilder()\n          .concurrencyLevel(1)\n          .maximumWeight(0)\n          .weigher(evensOnly)\n          .removalListener(removalListener)\n          .build(loader);\n\n    \n  assertThat(cache.getUnchecked(1)).isEqualTo(1);\n  assertThat(cache.asMap().keySet()).isEmpty();\n\n  CacheTesting.processPendingNotifications(cache);\n  assertThat(removalListener.getCount()).isEqualTo(1);\n\n    \n  assertThat(cache.getUnchecked(2)).isEqualTo(2);\n  assertThat(cache.asMap().keySet()).containsExactly(2);\n\n  CacheTesting.processPendingNotifications(cache);\n  CacheTesting.checkValidState(cache);\n  assertThat(removalListener.getCount()).isEqualTo(1);\n\n    \n  assertThat(cache.getUnchecked(4)).isEqualTo(4);\n  assertThat(cache.asMap().keySet()).containsExactly(2, 4);\n\n  CacheTesting.processPendingNotifications(cache);\n  assertThat(removalListener.getCount()).isEqualTo(1);\n\n    \n  assertThat(cache.getUnchecked(5)).isEqualTo(5);\n  assertThat(cache.asMap().keySet()).containsExactly(2, 4);\n\n  CacheTesting.processPendingNotifications(cache);\n  assertThat(removalListener.getCount()).isEqualTo(2);\n\n    \n  CacheTesting.checkValidState(cache);\n}",
        "summary_tokens": [
            "with",
            "an",
            "unlimited",
            "size",
            "cache",
            "with",
            "max",
            "weight",
            "of",
            "0",
            "entries",
            "weighing",
            "0",
            "should",
            "still",
            "be",
            "cached"
        ]
    },
    {
        "id": 254,
        "code": "public void testEviction_maxWeight_entryTooBig() {\n  CountingRemovalListener<Integer, Integer> removalListener = countingRemovalListener();\n  IdentityLoader<Integer> loader = identityLoader();\n\n  LoadingCache<Integer, Integer> cache =\n      CacheBuilder.newBuilder()\n          .concurrencyLevel(1)\n          .maximumWeight(4)\n          .weigher(intValueWeigher())\n          .removalListener(removalListener)\n          .build(loader);\n\n    \n  assertThat(cache.getUnchecked(2)).isEqualTo(2);\n  assertThat(cache.asMap().keySet()).containsExactly(2);\n\n  CacheTesting.processPendingNotifications(cache);\n  assertThat(removalListener.getCount()).isEqualTo(0);\n\n    \n  assertThat(cache.getUnchecked(3)).isEqualTo(3);\n  assertThat(cache.asMap().keySet()).containsExactly(3);\n\n  CacheTesting.processPendingNotifications(cache);\n  assertThat(removalListener.getCount()).isEqualTo(1);\n\n    \n  assertThat(cache.getUnchecked(5)).isEqualTo(5);\n  assertThat(cache.asMap().keySet()).containsExactly(3);\n\n  CacheTesting.processPendingNotifications(cache);\n  assertThat(removalListener.getCount()).isEqualTo(2);\n\n    \n  assertThat(cache.getUnchecked(1)).isEqualTo(1);\n  assertThat(cache.asMap().keySet()).containsExactly(3, 1);\n\n  CacheTesting.processPendingNotifications(cache);\n  assertThat(removalListener.getCount()).isEqualTo(2);\n\n    \n  assertThat(cache.getUnchecked(4)).isEqualTo(4);\n  assertThat(cache.asMap().keySet()).containsExactly(4);\n\n  CacheTesting.processPendingNotifications(cache);\n  assertThat(removalListener.getCount()).isEqualTo(4);\n\n    \n  CacheTesting.checkValidState(cache);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "when",
            "a",
            "single",
            "entry",
            "exceeds",
            "the",
            "segment",
            "s",
            "max",
            "weight",
            "the",
            "new",
            "entry",
            "is",
            "immediately",
            "evicted",
            "and",
            "nothing",
            "else"
        ]
    },
    {
        "id": 255,
        "code": "public void testLoadingExceptionWithCause() {\n  final Exception cause = new Exception();\n  final UncheckedExecutionException uee = new UncheckedExecutionException(cause);\n  final ExecutionException ee = new ExecutionException(cause);\n\n  LoadingCache<Object, Object> cacheUnchecked =\n      CacheBuilder.newBuilder().build(exceptionLoader(uee));\n  LoadingCache<Object, Object> cacheChecked =\n      CacheBuilder.newBuilder().build(exceptionLoader(ee));\n\n  try {\n    cacheUnchecked.get(new Object());\n    fail();\n  } catch (ExecutionException e) {\n    fail();\n  } catch (UncheckedExecutionException caughtEe) {\n    assertThat(caughtEe).hasCauseThat().isSameInstanceAs(uee);\n  }\n\n  try {\n    cacheUnchecked.getUnchecked(new Object());\n    fail();\n  } catch (UncheckedExecutionException caughtUee) {\n    assertThat(caughtUee).hasCauseThat().isSameInstanceAs(uee);\n  }\n\n  cacheUnchecked.refresh(new Object());\n  checkLoggedCause(uee);\n\n  try {\n    cacheUnchecked.getAll(asList(new Object()));\n    fail();\n  } catch (ExecutionException e) {\n    fail();\n  } catch (UncheckedExecutionException caughtEe) {\n    assertThat(caughtEe).hasCauseThat().isSameInstanceAs(uee);\n  }\n\n  try {\n    cacheChecked.get(new Object());\n    fail();\n  } catch (ExecutionException caughtEe) {\n    assertThat(caughtEe).hasCauseThat().isSameInstanceAs(ee);\n  }\n\n  try {\n    cacheChecked.getUnchecked(new Object());\n    fail();\n  } catch (UncheckedExecutionException caughtUee) {\n    assertThat(caughtUee).hasCauseThat().isSameInstanceAs(ee);\n  }\n\n  cacheChecked.refresh(new Object());\n  checkLoggedCause(ee);\n\n  try {\n    cacheChecked.getAll(asList(new Object()));\n    fail();\n  } catch (ExecutionException caughtEe) {\n    assertThat(caughtEe).hasCauseThat().isSameInstanceAs(ee);\n  }\n}",
        "summary_tokens": [
            "make",
            "sure",
            "loading",
            "cache",
            "correctly",
            "wraps",
            "execution",
            "exceptions",
            "and",
            "unchecked",
            "execution",
            "exceptions"
        ]
    },
    {
        "id": 256,
        "code": "private static void testConcurrentLoadingDefault(CacheBuilder<Object, Object> builder)\n    throws InterruptedException {\n\n  int count = 10;\n  final AtomicInteger callCount = new AtomicInteger();\n  final CountDownLatch startSignal = new CountDownLatch(count + 1);\n  final Object result = new Object();\n\n  LoadingCache<String, Object> cache =\n      builder.build(\n          new CacheLoader<String, Object>() {\n            @Override\n            public Object load(String key) throws InterruptedException {\n              callCount.incrementAndGet();\n              startSignal.await();\n              return result;\n            }\n          });\n\n  List<Object> resultArray = doConcurrentGet(cache, \"bar\", count, startSignal);\n\n  assertEquals(1, callCount.get());\n  for (int i = 0; i < count; i++) {\n    assertSame(\"result(\" + i + \") didn't match expected\", result, resultArray.get(i));\n  }\n}",
        "summary_tokens": [
            "on",
            "a",
            "successful",
            "concurrent",
            "computation",
            "only",
            "one",
            "thread",
            "does",
            "the",
            "work",
            "but",
            "all",
            "the",
            "threads",
            "get",
            "the",
            "same",
            "result"
        ]
    },
    {
        "id": 257,
        "code": "private static void testConcurrentLoadingNull(CacheBuilder<Object, Object> builder)\n    throws InterruptedException {\n\n  int count = 10;\n  final AtomicInteger callCount = new AtomicInteger();\n  final CountDownLatch startSignal = new CountDownLatch(count + 1);\n\n  LoadingCache<String, String> cache =\n      builder.build(\n          new CacheLoader<String, String>() {\n            @Override\n            public String load(String key) throws InterruptedException {\n              callCount.incrementAndGet();\n              startSignal.await();\n              return null;\n            }\n          });\n\n  List<Object> result = doConcurrentGet(cache, \"bar\", count, startSignal);\n\n  assertEquals(1, callCount.get());\n  for (int i = 0; i < count; i++) {\n    assertThat(result.get(i)).isInstanceOf(InvalidCacheLoadException.class);\n  }\n\n    \n  try {\n    cache.getUnchecked(\"bar\");\n    fail();\n  } catch (InvalidCacheLoadException expected) {\n  }\n  assertEquals(2, callCount.get());\n}",
        "summary_tokens": [
            "on",
            "a",
            "concurrent",
            "computation",
            "that",
            "returns",
            "null",
            "all",
            "threads",
            "should",
            "get",
            "an",
            "invalid",
            "cache",
            "load",
            "exception",
            "with",
            "the",
            "loader",
            "only",
            "called",
            "once"
        ]
    },
    {
        "id": 258,
        "code": "private static void testConcurrentLoadingUncheckedException(CacheBuilder<Object, Object> builder)\n    throws InterruptedException {\n\n  int count = 10;\n  final AtomicInteger callCount = new AtomicInteger();\n  final CountDownLatch startSignal = new CountDownLatch(count + 1);\n  final RuntimeException e = new RuntimeException();\n\n  LoadingCache<String, String> cache =\n      builder.build(\n          new CacheLoader<String, String>() {\n            @Override\n            public String load(String key) throws InterruptedException {\n              callCount.incrementAndGet();\n              startSignal.await();\n              throw e;\n            }\n          });\n\n  List<Object> result = doConcurrentGet(cache, \"bar\", count, startSignal);\n\n  assertEquals(1, callCount.get());\n  for (int i = 0; i < count; i++) {\n      \n      \n    assertThat(result.get(i)).isInstanceOf(UncheckedExecutionException.class);\n    assertThat(((UncheckedExecutionException) result.get(i))).hasCauseThat().isSameInstanceAs(e);\n  }\n\n    \n  try {\n    cache.getUnchecked(\"bar\");\n    fail();\n  } catch (UncheckedExecutionException expected) {\n  }\n  assertEquals(2, callCount.get());\n}",
        "summary_tokens": [
            "on",
            "a",
            "concurrent",
            "computation",
            "that",
            "throws",
            "an",
            "unchecked",
            "exception",
            "all",
            "threads",
            "should",
            "get",
            "the",
            "wrapped",
            "exception",
            "with",
            "the",
            "loader",
            "called",
            "only",
            "once"
        ]
    },
    {
        "id": 259,
        "code": "private static void testConcurrentLoadingCheckedException(CacheBuilder<Object, Object> builder)\n    throws InterruptedException {\n\n  int count = 10;\n  final AtomicInteger callCount = new AtomicInteger();\n  final CountDownLatch startSignal = new CountDownLatch(count + 1);\n  final IOException e = new IOException();\n\n  LoadingCache<String, String> cache =\n      builder.build(\n          new CacheLoader<String, String>() {\n            @Override\n            public String load(String key) throws IOException, InterruptedException {\n              callCount.incrementAndGet();\n              startSignal.await();\n              throw e;\n            }\n          });\n\n  List<Object> result = doConcurrentGet(cache, \"bar\", count, startSignal);\n\n  assertEquals(1, callCount.get());\n  for (int i = 0; i < count; i++) {\n      \n      \n      \n    int mod = i % 3;\n    if (mod == 0 || mod == 2) {\n      assertThat(result.get(i)).isInstanceOf(ExecutionException.class);\n      assertThat((ExecutionException) result.get(i)).hasCauseThat().isSameInstanceAs(e);\n    } else {\n      assertThat(result.get(i)).isInstanceOf(UncheckedExecutionException.class);\n      assertThat((UncheckedExecutionException) result.get(i)).hasCauseThat().isSameInstanceAs(e);\n    }\n  }\n\n    \n  try {\n    cache.getUnchecked(\"bar\");\n    fail();\n  } catch (UncheckedExecutionException expected) {\n  }\n  assertEquals(2, callCount.get());\n}",
        "summary_tokens": [
            "on",
            "a",
            "concurrent",
            "computation",
            "that",
            "throws",
            "a",
            "checked",
            "exception",
            "all",
            "threads",
            "should",
            "get",
            "the",
            "wrapped",
            "exception",
            "with",
            "the",
            "loader",
            "called",
            "only",
            "once"
        ]
    },
    {
        "id": 260,
        "code": "private static <K> List<Object> doConcurrentGet(\n    final LoadingCache<K, ?> cache,\n    final K key,\n    int nThreads,\n    final CountDownLatch gettersStartedSignal)\n    throws InterruptedException {\n\n  final AtomicReferenceArray<Object> result = new AtomicReferenceArray<>(nThreads);\n  final CountDownLatch gettersComplete = new CountDownLatch(nThreads);\n  for (int i = 0; i < nThreads; i++) {\n    final int index = i;\n    Thread thread =\n        new Thread(\n            new Runnable() {\n              @Override\n              public void run() {\n                gettersStartedSignal.countDown();\n                Object value = null;\n                try {\n                  int mod = index % 3;\n                  if (mod == 0) {\n                    value = cache.get(key);\n                  } else if (mod == 1) {\n                    value = cache.getUnchecked(key);\n                  } else {\n                    cache.refresh(key);\n                    value = cache.get(key);\n                  }\n                  result.set(index, value);\n                } catch (Throwable t) {\n                  result.set(index, t);\n                }\n                gettersComplete.countDown();\n              }\n            });\n    thread.start();\n      \n      \n    while (thread.isAlive() && thread.getState() != Thread.State.WAITING) {\n      Thread.yield();\n    }\n  }\n  gettersStartedSignal.countDown();\n  gettersComplete.await();\n\n  List<Object> resultList = Lists.newArrayListWithExpectedSize(nThreads);\n  for (int i = 0; i < nThreads; i++) {\n    resultList.add(result.get(i));\n  }\n  return resultList;\n}",
        "summary_tokens": [
            "test",
            "helper",
            "method",
            "that",
            "performs",
            "n",
            "threads",
            "concurrent",
            "calls",
            "to",
            "cache"
        ]
    },
    {
        "id": 261,
        "code": "static <K, V> void simulateValueReclamation(Cache<K, V> cache, K key) {\n  ReferenceEntry<K, V> entry = getReferenceEntry(cache, key);\n  if (entry != null) {\n    ValueReference<K, V> valueRef = entry.getValueReference();\n      \n    Preconditions.checkState(valueRef instanceof Reference);\n    Reference<V> ref = (Reference<V>) valueRef;\n    if (ref != null) {\n      ref.clear();\n    }\n  }\n}",
        "summary_tokens": [
            "poke",
            "into",
            "the",
            "cache",
            "internals",
            "to",
            "simulate",
            "garbage",
            "collection",
            "of",
            "the",
            "value",
            "associated",
            "with",
            "the",
            "given",
            "key"
        ]
    },
    {
        "id": 262,
        "code": "static <K, V> void simulateKeyReclamation(Cache<K, V> cache, K key) {\n  ReferenceEntry<K, V> entry = getReferenceEntry(cache, key);\n\n  Preconditions.checkState(entry instanceof Reference);\n  Reference<?> ref = (Reference<?>) entry;\n  if (ref != null) {\n    ref.clear();\n  }\n}",
        "summary_tokens": [
            "poke",
            "into",
            "the",
            "cache",
            "internals",
            "to",
            "simulate",
            "garbage",
            "collection",
            "of",
            "the",
            "given",
            "key"
        ]
    },
    {
        "id": 263,
        "code": "static <K, V> void forceExpandSegment(Cache<K, V> cache, K key) {\n  checkNotNull(cache);\n  checkNotNull(key);\n  LocalCache<K, V> map = toLocalCache(cache);\n  int hash = map.hash(key);\n  Segment<K, V> segment = map.segmentFor(hash);\n  segment.expand();\n}",
        "summary_tokens": [
            "forces",
            "the",
            "segment",
            "containing",
            "the",
            "given",
            "key",
            "to",
            "expand",
            "see",
            "segment",
            "expand"
        ]
    },
    {
        "id": 264,
        "code": "static <K, V> LocalCache<K, V> toLocalCache(Cache<K, V> cache) {\n  if (cache instanceof LocalLoadingCache) {\n    return ((LocalLoadingCache<K, V>) cache).localCache;\n  }\n  throw new IllegalArgumentException(\n      \"Cache of type \" + cache.getClass() + \" doesn't have a LocalCache.\");\n}",
        "summary_tokens": [
            "gets",
            "the",
            "local",
            "cache",
            "used",
            "by",
            "the",
            "given",
            "cache",
            "if",
            "any",
            "or",
            "throws",
            "an",
            "illegal",
            "argument",
            "exception",
            "if",
            "this",
            "is",
            "a",
            "cache",
            "type",
            "that",
            "doesn",
            "t",
            "have",
            "a",
            "local",
            "cache"
        ]
    },
    {
        "id": 265,
        "code": "static boolean hasLocalCache(Cache<?, ?> cache) {\n  return (checkNotNull(cache) instanceof LocalLoadingCache);\n}",
        "summary_tokens": [
            "determines",
            "whether",
            "the",
            "given",
            "cache",
            "can",
            "be",
            "converted",
            "to",
            "a",
            "local",
            "cache",
            "by",
            "to",
            "local",
            "cache",
            "without",
            "throwing",
            "an",
            "exception"
        ]
    },
    {
        "id": 266,
        "code": "static void checkValidState(Cache<?, ?> cache) {\n  if (hasLocalCache(cache)) {\n    checkValidState(toLocalCache(cache));\n  }\n}",
        "summary_tokens": [
            "peeks",
            "into",
            "the",
            "cache",
            "s",
            "internals",
            "to",
            "check",
            "its",
            "internal",
            "consistency"
        ]
    },
    {
        "id": 267,
        "code": "static void checkExpiration(Cache<?, ?> cache) {\n  if (hasLocalCache(cache)) {\n    checkExpiration(toLocalCache(cache));\n  }\n}",
        "summary_tokens": [
            "peeks",
            "into",
            "the",
            "cache",
            "s",
            "internals",
            "to",
            "verify",
            "that",
            "its",
            "expiration",
            "queue",
            "is",
            "consistent"
        ]
    },
    {
        "id": 268,
        "code": "static void checkEviction(Cache<?, ?> cache) {\n  if (hasLocalCache(cache)) {\n    checkEviction(toLocalCache(cache));\n  }\n}",
        "summary_tokens": [
            "peeks",
            "into",
            "the",
            "cache",
            "s",
            "internals",
            "to",
            "verify",
            "that",
            "its",
            "eviction",
            "queue",
            "is",
            "consistent"
        ]
    },
    {
        "id": 269,
        "code": "static void checkRecency(\n    LoadingCache<Integer, Integer> cache,\n    int maxSize,\n    Receiver<ReferenceEntry<Integer, Integer>> operation) {\n  checkNotNull(operation);\n  if (hasLocalCache(cache)) {\n    warmUp(cache, 0, 2 * maxSize);\n\n    LocalCache<Integer, Integer> cchm = toLocalCache(cache);\n    Segment<?, ?> segment = cchm.segments[0];\n    drainRecencyQueue(segment);\n    assertEquals(maxSize, accessQueueSize(cache));\n    assertEquals(maxSize, cache.size());\n\n    ReferenceEntry<?, ?> originalHead = segment.accessQueue.peek();\n    @SuppressWarnings(\"unchecked\")\n    ReferenceEntry<Integer, Integer> entry = (ReferenceEntry<Integer, Integer>) originalHead;\n    operation.accept(entry);\n    drainRecencyQueue(segment);\n\n    assertNotSame(originalHead, segment.accessQueue.peek());\n    assertEquals(cache.size(), accessQueueSize(cache));\n  }\n}",
        "summary_tokens": [
            "assuming",
            "the",
            "given",
            "cache",
            "has",
            "maximum",
            "size",
            "max",
            "size",
            "this",
            "method",
            "populates",
            "the",
            "cache",
            "by",
            "getting",
            "a",
            "bunch",
            "of",
            "different",
            "keys",
            "then",
            "makes",
            "sure",
            "all",
            "the",
            "items",
            "in",
            "the",
            "cache",
            "are",
            "also",
            "in",
            "the",
            "eviction",
            "queue"
        ]
    },
    {
        "id": 270,
        "code": "static void warmUp(LoadingCache<Integer, Integer> map, int start, int end) {\n  checkNotNull(map);\n  for (int i = start; i < end; i++) {\n    map.getUnchecked(i);\n  }\n}",
        "summary_tokens": [
            "warms",
            "the",
            "given",
            "cache",
            "by",
            "getting",
            "all",
            "values",
            "in",
            "start",
            "end",
            "in",
            "order"
        ]
    },
    {
        "id": 271,
        "code": "private Iterable<LoadingCache<Object, Object>> caches() {\n    \n  CacheBuilderFactory factory = cacheFactory();\n  return Iterables.transform(\n      factory.buildAllPermutations(),\n      new Function<CacheBuilder<Object, Object>, LoadingCache<Object, Object>>() {\n        @Override\n        public LoadingCache<Object, Object> apply(CacheBuilder<Object, Object> builder) {\n          return builder.build(identityLoader());\n        }\n      });\n}",
        "summary_tokens": [
            "most",
            "of",
            "the",
            "tests",
            "in",
            "this",
            "class",
            "run",
            "against",
            "every",
            "one",
            "of",
            "these",
            "caches"
        ]
    },
    {
        "id": 272,
        "code": "private static Iterable<CacheBuilder<Object, Object>> allEntryTypeMakers() {\n  List<CacheBuilder<Object, Object>> result = newArrayList(allKeyValueStrengthMakers());\n  for (CacheBuilder<Object, Object> builder : allKeyValueStrengthMakers()) {\n    result.add(builder.maximumSize(SMALL_MAX_SIZE));\n  }\n  for (CacheBuilder<Object, Object> builder : allKeyValueStrengthMakers()) {\n    result.add(builder.expireAfterAccess(99999, SECONDS));\n  }\n  for (CacheBuilder<Object, Object> builder : allKeyValueStrengthMakers()) {\n    result.add(builder.expireAfterWrite(99999, SECONDS));\n  }\n  for (CacheBuilder<Object, Object> builder : allKeyValueStrengthMakers()) {\n    result.add(builder.maximumSize(SMALL_MAX_SIZE).expireAfterAccess(99999, SECONDS));\n  }\n  for (CacheBuilder<Object, Object> builder : allKeyValueStrengthMakers()) {\n    result.add(builder.maximumSize(SMALL_MAX_SIZE).expireAfterWrite(99999, SECONDS));\n  }\n  return result;\n}",
        "summary_tokens": [
            "returns",
            "an",
            "iterable",
            "containing",
            "all",
            "combinations",
            "of",
            "maximum",
            "size",
            "expire",
            "after",
            "access",
            "write",
            "weak",
            "keys",
            "and",
            "weak",
            "soft",
            "values"
        ]
    },
    {
        "id": 273,
        "code": "static Iterable<CacheBuilder<Object, Object>> allEvictingMakers() {\n  return ImmutableList.of(\n      createCacheBuilder().maximumSize(SMALL_MAX_SIZE),\n      createCacheBuilder().expireAfterAccess(99999, SECONDS),\n      createCacheBuilder().expireAfterWrite(99999, SECONDS),\n      createCacheBuilder()\n          .maximumSize(SMALL_MAX_SIZE)\n          .expireAfterAccess(SMALL_MAX_SIZE, TimeUnit.SECONDS),\n      createCacheBuilder()\n          .maximumSize(SMALL_MAX_SIZE)\n          .expireAfterWrite(SMALL_MAX_SIZE, TimeUnit.SECONDS));\n}",
        "summary_tokens": [
            "returns",
            "an",
            "iterable",
            "containing",
            "all",
            "combinations",
            "of",
            "maximum",
            "size",
            "and",
            "expire",
            "after",
            "access",
            "write"
        ]
    },
    {
        "id": 274,
        "code": "private static Iterable<CacheBuilder<Object, Object>> allKeyValueStrengthMakers() {\n  return ImmutableList.of(\n      createCacheBuilder(),\n      createCacheBuilder().weakValues(),\n      createCacheBuilder().softValues(),\n      createCacheBuilder().weakKeys(),\n      createCacheBuilder().weakKeys().weakValues(),\n      createCacheBuilder().weakKeys().softValues());\n}",
        "summary_tokens": [
            "returns",
            "an",
            "iterable",
            "containing",
            "all",
            "combinations",
            "weak",
            "keys",
            "and",
            "weak",
            "soft",
            "values"
        ]
    },
    {
        "id": 275,
        "code": "public void testAsMapRecency() {\n  CacheBuilder<Object, Object> builder =\n      createCacheBuilder().concurrencyLevel(1).maximumSize(SMALL_MAX_SIZE);\n  LocalLoadingCache<Object, Object> cache = makeCache(builder, identityLoader());\n  Segment<Object, Object> segment = cache.localCache.segments[0];\n  ConcurrentMap<Object, Object> map = cache.asMap();\n\n  Object one = new Object();\n  assertSame(one, cache.getUnchecked(one));\n  assertTrue(segment.recencyQueue.isEmpty());\n  assertSame(one, map.get(one));\n  assertSame(one, segment.recencyQueue.peek().getKey());\n  assertSame(one, cache.getUnchecked(one));\n  assertFalse(segment.recencyQueue.isEmpty());\n}",
        "summary_tokens": [
            "lookups",
            "on",
            "the",
            "map",
            "view",
            "shouldn",
            "t",
            "impact",
            "the",
            "recency",
            "queue"
        ]
    },
    {
        "id": 276,
        "code": "public void testNulls() {}",
        "summary_tokens": [
            "no",
            "op",
            "null",
            "pointer",
            "test",
            "for",
            "long",
            "adder",
            "to",
            "override",
            "the",
            "package",
            "sanity",
            "tests",
            "version",
            "which",
            "checks",
            "package",
            "private",
            "methods",
            "that",
            "we",
            "don",
            "t",
            "want",
            "to",
            "have",
            "to",
            "annotate",
            "as",
            "nullable",
            "because",
            "we",
            "don",
            "t",
            "want",
            "diffs",
            "from",
            "jsr",
            "0",
            "e"
        ]
    },
    {
        "id": 277,
        "code": "private Iterable<LoadingCache<Object, Object>> caches() {\n    \n  CacheBuilderFactory factory = cacheFactory();\n  return Iterables.transform(\n      factory.buildAllPermutations(),\n      new Function<CacheBuilder<Object, Object>, LoadingCache<Object, Object>>() {\n        @Override\n        public LoadingCache<Object, Object> apply(CacheBuilder<Object, Object> builder) {\n          return builder.recordStats().build(identityLoader());\n        }\n      });\n}",
        "summary_tokens": [
            "most",
            "of",
            "the",
            "tests",
            "in",
            "this",
            "class",
            "run",
            "against",
            "every",
            "one",
            "of",
            "these",
            "caches"
        ]
    },
    {
        "id": 278,
        "code": "private List<Entry<Object, Object>> warmUp(\n    LoadingCache<Object, Object> cache, int minimum, int maximum) {\n\n  List<Entry<Object, Object>> entries = Lists.newArrayList();\n  for (int i = minimum; i < maximum; i++) {\n    Object key = i;\n    Object value = cache.getUnchecked(key);\n    entries.add(entryOf(key, value));\n  }\n  return entries;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "entries",
            "that",
            "were",
            "added",
            "to",
            "the",
            "map",
            "so",
            "they",
            "won",
            "t",
            "fall",
            "out",
            "of",
            "a",
            "map",
            "with",
            "weak",
            "or",
            "soft",
            "references",
            "until",
            "the",
            "caller",
            "drops",
            "the",
            "reference",
            "to",
            "the",
            "returned",
            "entries"
        ]
    },
    {
        "id": 279,
        "code": "static <K, V> CacheLoader<K, V> bulkLoader(final CacheLoader<K, V> loader) {\n  checkNotNull(loader);\n  return new CacheLoader<K, V>() {\n    @Override\n    public V load(K key) throws Exception {\n      return loader.load(key);\n    }\n\n    @Override\n    public Map<K, V> loadAll(Iterable<? extends K> keys) throws Exception {\n      Map<K, V> result = Maps.newHashMap(); \n      for (K key : keys) {\n        result.put(key, load(key));\n      }\n      return result;\n    }\n  };\n}",
        "summary_tokens": [
            "returns",
            "a",
            "cache",
            "loader",
            "that",
            "implements",
            "a",
            "naive",
            "cache",
            "loader",
            "load",
            "all",
            "delegating",
            "cache",
            "loader",
            "load",
            "calls",
            "to",
            "loader"
        ]
    },
    {
        "id": 280,
        "code": "static <K, V> ConstantLoader<K, V> constantLoader(@Nullable V constant) {\n  return new ConstantLoader<>(constant);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "cache",
            "loader",
            "that",
            "returns",
            "the",
            "given",
            "constant",
            "for",
            "every",
            "request"
        ]
    },
    {
        "id": 281,
        "code": "static IncrementingLoader incrementingLoader() {\n  return new IncrementingLoader();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "cache",
            "loader",
            "that",
            "returns",
            "the",
            "given",
            "constant",
            "for",
            "every",
            "request"
        ]
    },
    {
        "id": 282,
        "code": "static <K, V> CacheLoader<K, V> errorLoader(final Error e) {\n  checkNotNull(e);\n  return new CacheLoader<K, V>() {\n    @Override\n    public V load(K key) {\n      throw e;\n    }\n  };\n}",
        "summary_tokens": [
            "returns",
            "a",
            "cache",
            "loader",
            "that",
            "throws",
            "the",
            "given",
            "error",
            "for",
            "every",
            "request"
        ]
    },
    {
        "id": 283,
        "code": "static <K, V> CacheLoader<K, V> exceptionLoader(final Exception e) {\n  checkNotNull(e);\n  return new CacheLoader<K, V>() {\n    @Override\n    public V load(K key) throws Exception {\n      throw e;\n    }\n  };\n}",
        "summary_tokens": [
            "returns",
            "a",
            "cache",
            "loader",
            "that",
            "throws",
            "the",
            "given",
            "exception",
            "for",
            "every",
            "request"
        ]
    },
    {
        "id": 284,
        "code": "static <T> IdentityLoader<T> identityLoader() {\n  return new IdentityLoader<T>();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "cache",
            "loader",
            "that",
            "returns",
            "the",
            "key",
            "for",
            "every",
            "request"
        ]
    },
    {
        "id": 285,
        "code": "static <K, V> NullRemovalListener<K, V> nullRemovalListener() {\n  return new NullRemovalListener<>();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "no",
            "op",
            "removal",
            "listener"
        ]
    },
    {
        "id": 286,
        "code": "static <K, V> QueuingRemovalListener<K, V> queuingRemovalListener() {\n  return new QueuingRemovalListener<>();\n}",
        "summary_tokens": [
            "type",
            "inferring",
            "factory",
            "method",
            "for",
            "creating",
            "a",
            "queuing",
            "removal",
            "listener"
        ]
    },
    {
        "id": 287,
        "code": "static <K, V> CountingRemovalListener<K, V> countingRemovalListener() {\n  return new CountingRemovalListener<>();\n}",
        "summary_tokens": [
            "type",
            "inferring",
            "factory",
            "method",
            "for",
            "creating",
            "a",
            "counting",
            "removal",
            "listener"
        ]
    },
    {
        "id": 288,
        "code": "static Weigher<Object, Object> constantWeigher(int constant) {\n  return new ConstantWeigher(constant);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "weigher",
            "that",
            "returns",
            "the",
            "given",
            "constant",
            "for",
            "every",
            "request"
        ]
    },
    {
        "id": 289,
        "code": "static Weigher<Integer, Object> intKeyWeigher() {\n  return new IntKeyWeigher();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "weigher",
            "that",
            "uses",
            "the",
            "integer",
            "key",
            "as",
            "the",
            "weight"
        ]
    },
    {
        "id": 290,
        "code": "static Weigher<Object, Integer> intValueWeigher() {\n  return new IntValueWeigher();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "weigher",
            "that",
            "uses",
            "the",
            "integer",
            "value",
            "as",
            "the",
            "weight"
        ]
    },
    {
        "id": 291,
        "code": "void verifyThreadSafe() {\n  List<String> sample = Lists.newArrayList(\"a\", \"b\", \"c\");\n  for (int delta : new int[] {-1, 0, 1}) {\n    for (int i = 0; i < sample.size(); i++) {\n      Collection<String> misleading = Helpers.misleadingSizeCollection(delta);\n      List<String> expected = sample.subList(0, i);\n      misleading.addAll(expected);\n      assertEquals(\n          \"delta: \" + delta + \" sample size: \" + i,\n          Sets.newHashSet(expected),\n          copyOf(misleading));\n    }\n  }\n}",
        "summary_tokens": [
            "verify",
            "thread",
            "safety",
            "by",
            "using",
            "a",
            "collection",
            "whose",
            "size",
            "may",
            "be",
            "inconsistent",
            "with",
            "the",
            "actual",
            "number",
            "of",
            "elements"
        ]
    },
    {
        "id": 292,
        "code": "private static void sneakyThrow(Throwable t) {\n  class SneakyThrower<T extends Throwable> {\n    @SuppressWarnings(\"unchecked\") \n    void throwIt(Throwable t) throws T {\n      throw (T) t;\n    }\n  }\n  new SneakyThrower<Error>().throwIt(t);\n}",
        "summary_tokens": [
            "throws",
            "a",
            "undeclared",
            "checked",
            "exception"
        ]
    },
    {
        "id": 293,
        "code": "public void testRemove() {\n  final Map<String, Collection<Integer>> map;\n  final String keyToRemove;\n  try {\n    map = makePopulatedMap();\n  } catch (UnsupportedOperationException e) {\n    return;\n  }\n  keyToRemove = map.keySet().iterator().next();\n  if (supportsRemove) {\n    int initialSize = map.size();\n    map.get(keyToRemove);\n    map.remove(keyToRemove);\n      \n      \n    assertFalse(map.containsKey(keyToRemove));\n    assertEquals(initialSize - 1, map.size());\n  } else {\n    try {\n      map.remove(keyToRemove);\n      fail(\"Expected UnsupportedOperationException.\");\n    } catch (UnsupportedOperationException expected) {\n    }\n  }\n  assertInvariants(map);\n}",
        "summary_tokens": [
            "the",
            "version",
            "of",
            "this",
            "test",
            "supplied",
            "by",
            "map",
            "interface",
            "test",
            "fails",
            "for",
            "this",
            "particular",
            "map",
            "implementation",
            "because",
            "map"
        ]
    },
    {
        "id": 294,
        "code": "public void testGetRandomAccess() {\n  Multimap<String, Integer> multimap = create();\n  multimap.put(\"foo\", 1);\n  multimap.put(\"foo\", 3);\n  assertTrue(multimap.get(\"foo\") instanceof RandomAccess);\n  assertTrue(multimap.get(\"bar\") instanceof RandomAccess);\n}",
        "summary_tokens": [
            "confirm",
            "that",
            "get",
            "returns",
            "a",
            "list",
            "implementing",
            "random",
            "access"
        ]
    },
    {
        "id": 295,
        "code": "public void testRemoveAllRandomAccess() {\n  Multimap<String, Integer> multimap = create();\n  multimap.put(\"foo\", 1);\n  multimap.put(\"foo\", 3);\n  assertTrue(multimap.removeAll(\"foo\") instanceof RandomAccess);\n  assertTrue(multimap.removeAll(\"bar\") instanceof RandomAccess);\n}",
        "summary_tokens": [
            "confirm",
            "that",
            "remove",
            "all",
            "returns",
            "a",
            "list",
            "implementing",
            "random",
            "access"
        ]
    },
    {
        "id": 296,
        "code": "public void testReplaceValuesRandomAccess() {\n  Multimap<String, Integer> multimap = create();\n  multimap.put(\"foo\", 1);\n  multimap.put(\"foo\", 3);\n  assertTrue(multimap.replaceValues(\"foo\", asList(2, 4)) instanceof RandomAccess);\n  assertTrue(multimap.replaceValues(\"bar\", asList(2, 4)) instanceof RandomAccess);\n}",
        "summary_tokens": [
            "confirm",
            "that",
            "replace",
            "values",
            "returns",
            "a",
            "list",
            "implementing",
            "random",
            "access"
        ]
    },
    {
        "id": 297,
        "code": "public void testSublistConcurrentModificationException() {\n  ListMultimap<String, Integer> multimap = create();\n  multimap.putAll(\"foo\", asList(1, 2, 3, 4, 5));\n  List<Integer> list = multimap.get(\"foo\");\n  assertThat(multimap.get(\"foo\")).containsExactly(1, 2, 3, 4, 5).inOrder();\n  List<Integer> sublist = list.subList(0, 5);\n  assertThat(sublist).containsExactly(1, 2, 3, 4, 5).inOrder();\n\n  sublist.clear();\n  assertTrue(sublist.isEmpty());\n  multimap.put(\"foo\", 6);\n\n  try {\n    sublist.isEmpty();\n    fail(\"Expected ConcurrentModificationException\");\n  } catch (ConcurrentModificationException expected) {\n  }\n}",
        "summary_tokens": [
            "test",
            "throwing",
            "concurrent",
            "modification",
            "exception",
            "when",
            "a",
            "sublist",
            "s",
            "ancestor",
            "s",
            "delegate",
            "changes"
        ]
    },
    {
        "id": 298,
        "code": "public void testAdd_withFailures() {\n  AtomicInteger existing = new AtomicInteger(12);\n  AtomicInteger existingZero = new AtomicInteger(0);\n\n    \n  when(backingMap.get(KEY)).thenReturn(null);\n    \n  when(backingMap.putIfAbsent(eq(KEY), isA(AtomicInteger.class))).thenReturn(existingZero);\n    \n  when(backingMap.replace(eq(KEY), eq(existingZero), isA(AtomicInteger.class))).thenReturn(false);\n    \n  when(backingMap.putIfAbsent(eq(KEY), isA(AtomicInteger.class))).thenReturn(existing);\n\n    \n  when(backingMap.get(KEY)).thenReturn(existingZero);\n    \n  when(backingMap.replace(eq(KEY), eq(existingZero), isA(AtomicInteger.class))).thenReturn(false);\n  when(backingMap.putIfAbsent(eq(KEY), isA(AtomicInteger.class))).thenReturn(existing);\n\n    \n  when(backingMap.get(KEY)).thenReturn(existing);\n    \n\n  assertEquals(12, multiset.add(KEY, 3));\n  assertEquals(15, existing.get());\n}",
        "summary_tokens": [
            "simulate",
            "some",
            "of",
            "the",
            "races",
            "that",
            "can",
            "happen",
            "on",
            "add"
        ]
    },
    {
        "id": 299,
        "code": "public void testNoop() {}",
        "summary_tokens": [
            "no",
            "op",
            "test",
            "so",
            "that",
            "the",
            "class",
            "has",
            "at",
            "least",
            "one",
            "method",
            "making",
            "maven",
            "s",
            "test",
            "runner",
            "happy"
        ]
    },
    {
        "id": 300,
        "code": "public void testConcatIntersectionType() {\n  Iterable<A> aIterable = ImmutableList.of();\n  Iterable<B> bIterable = ImmutableList.of();\n\n  Predicate<X> xPredicate = Predicates.alwaysTrue();\n  Predicate<Y> yPredicate = Predicates.alwaysTrue();\n\n  FluentIterable<?> unused =\n      FluentIterable.concat(aIterable, bIterable).filter(xPredicate).filter(yPredicate);\n\n    \n    \n\n    \n    \n}",
        "summary_tokens": [
            "this",
            "test",
            "passes",
            "if",
            "the",
            "concat"
        ]
    },
    {
        "id": 301,
        "code": "public void testNoop() {}",
        "summary_tokens": [
            "no",
            "op",
            "test",
            "so",
            "that",
            "the",
            "class",
            "has",
            "at",
            "least",
            "one",
            "method",
            "making",
            "maven",
            "s",
            "test",
            "runner",
            "happy"
        ]
    },
    {
        "id": 302,
        "code": "private static Iterable<String> create(String... strings) {\n  final List<String> list = asList(strings);\n  return new FluentIterable<String>() {\n    @Override\n    public Iterator<String> iterator() {\n      return list.iterator();\n    }\n  };\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "iterable",
            "over",
            "the",
            "specified",
            "strings"
        ]
    },
    {
        "id": 303,
        "code": "public void testConcatContainingNull() {\n  @SuppressWarnings(\"unchecked\")\n  Iterator<Iterator<Integer>> input = asList(iterateOver(1, 2), null, iterateOver(3)).iterator();\n  Iterator<Integer> result = Iterators.concat(input);\n  assertEquals(1, (int) result.next());\n  assertEquals(2, (int) result.next());\n  try {\n    result.hasNext();\n    fail(\"no exception thrown\");\n  } catch (NullPointerException e) {\n  }\n  try {\n    result.next();\n    fail(\"no exception thrown\");\n  } catch (NullPointerException e) {\n  }\n    \n}",
        "summary_tokens": [
            "illustrates",
            "the",
            "somewhat",
            "bizarre",
            "behavior",
            "when",
            "a",
            "null",
            "is",
            "passed",
            "in"
        ]
    },
    {
        "id": 304,
        "code": "public void testGetRandomAccess() {\n  Multimap<String, Integer> multimap = create();\n  multimap.put(\"foo\", 1);\n  multimap.put(\"foo\", 3);\n  assertFalse(multimap.get(\"foo\") instanceof RandomAccess);\n  assertFalse(multimap.get(\"bar\") instanceof RandomAccess);\n}",
        "summary_tokens": [
            "confirm",
            "that",
            "get",
            "returns",
            "a",
            "list",
            "that",
            "doesn",
            "t",
            "implement",
            "random",
            "access"
        ]
    },
    {
        "id": 305,
        "code": "public void testRemoveAllRandomAccess() {\n  Multimap<String, Integer> multimap = create();\n  multimap.put(\"foo\", 1);\n  multimap.put(\"foo\", 3);\n  assertTrue(multimap.removeAll(\"foo\") instanceof RandomAccess);\n  assertTrue(multimap.removeAll(\"bar\") instanceof RandomAccess);\n}",
        "summary_tokens": [
            "confirm",
            "that",
            "remove",
            "all",
            "returns",
            "a",
            "list",
            "that",
            "implements",
            "random",
            "access",
            "even",
            "though",
            "get",
            "doesn",
            "t"
        ]
    },
    {
        "id": 306,
        "code": "public void testReplaceValuesRandomAccess() {\n  Multimap<String, Integer> multimap = create();\n  multimap.put(\"foo\", 1);\n  multimap.put(\"foo\", 3);\n  assertTrue(multimap.replaceValues(\"foo\", Arrays.asList(2, 4)) instanceof RandomAccess);\n  assertTrue(multimap.replaceValues(\"bar\", Arrays.asList(2, 4)) instanceof RandomAccess);\n}",
        "summary_tokens": [
            "confirm",
            "that",
            "replace",
            "values",
            "returns",
            "a",
            "list",
            "that",
            "implements",
            "random",
            "access",
            "even",
            "though",
            "get",
            "doesn",
            "t"
        ]
    },
    {
        "id": 307,
        "code": "public void testArraysAsList() {\n  List<String> ourWay = Lists.newArrayList(\"foo\", \"bar\", \"baz\");\n  List<String> otherWay = asList(\"foo\", \"bar\", \"baz\");\n\n    \n  assertEquals(ourWay, otherWay);\n\n    \n  otherWay.set(0, \"FOO\");\n  assertEquals(\"FOO\", otherWay.get(0));\n\n    \n  try {\n    otherWay.add(\"nope\");\n    fail(\"no exception thrown\");\n  } catch (UnsupportedOperationException expected) {\n  }\n\n    \n  try {\n    otherWay.remove(2);\n    fail(\"no exception thrown\");\n  } catch (UnsupportedOperationException expected) {\n  }\n}",
        "summary_tokens": [
            "this",
            "is",
            "just",
            "here",
            "to",
            "illustrate",
            "how",
            "arrays",
            "as",
            "list",
            "differs",
            "from",
            "lists",
            "new",
            "array",
            "list"
        ]
    },
    {
        "id": 308,
        "code": "public void testTransformedSequentialIterationUsesBackingListIterationOnly() {\n  List<Integer> randomAccessList = Lists.newArrayList(SOME_SEQUENTIAL_LIST);\n  List<Integer> listIteratorOnlyList = new ListIterationOnlyList<>(randomAccessList);\n  List<String> transform = Lists.transform(listIteratorOnlyList, SOME_FUNCTION);\n  assertTrue(\n      Iterables.elementsEqual(transform, Lists.transform(randomAccessList, SOME_FUNCTION)));\n}",
        "summary_tokens": [
            "this",
            "test",
            "depends",
            "on",
            "the",
            "fact",
            "that",
            "abstract",
            "sequential",
            "list"
        ]
    },
    {
        "id": 309,
        "code": "public void testNewHashMapWithExpectedSize_wontGrow() throws Exception {\n    \n    \n  assertTrue(bucketsOf(Maps.newHashMapWithExpectedSize(0)) <= 1);\n\n  for (int size = 1; size < 200; size++) {\n    assertWontGrow(\n        size, Maps.newHashMapWithExpectedSize(size), Maps.newHashMapWithExpectedSize(size));\n  }\n}",
        "summary_tokens": [
            "tests",
            "that",
            "n",
            "hmwes",
            "makes",
            "hash",
            "maps",
            "large",
            "enough",
            "that",
            "adding",
            "the",
            "expected",
            "number",
            "of",
            "elements",
            "won",
            "t",
            "cause",
            "a",
            "rehash"
        ]
    },
    {
        "id": 310,
        "code": "public void testNewLinkedHashMapWithExpectedSize_wontGrow() throws Exception {\n  assertTrue(bucketsOf(Maps.newLinkedHashMapWithExpectedSize(0)) <= 1);\n\n  for (int size = 1; size < 200; size++) {\n    assertWontGrow(\n        size,\n        Maps.newLinkedHashMapWithExpectedSize(size),\n        Maps.newLinkedHashMapWithExpectedSize(size));\n  }\n}",
        "summary_tokens": [
            "same",
            "test",
            "as",
            "above",
            "but",
            "for",
            "new",
            "linked",
            "hash",
            "map",
            "with",
            "expected",
            "size"
        ]
    },
    {
        "id": 311,
        "code": "public void testUniqueIndexDuplicates() {\n  try {\n    Map<Integer, String> unused =\n        Maps.uniqueIndex(ImmutableSet.of(\"one\", \"uno\"), Functions.constant(1));\n    fail();\n  } catch (IllegalArgumentException expected) {\n    assertThat(expected.getMessage()).contains(\"Multimaps.index\");\n  }\n}",
        "summary_tokens": [
            "can",
            "t",
            "create",
            "the",
            "map",
            "if",
            "more",
            "than",
            "one",
            "value",
            "maps",
            "to",
            "the",
            "same",
            "key"
        ]
    },
    {
        "id": 312,
        "code": "public void testUniqueIndexNullValue() {\n  List<String> listWithNull = Lists.newArrayList((String) null);\n  try {\n    Maps.uniqueIndex(listWithNull, Functions.constant(1));\n    fail();\n  } catch (NullPointerException expected) {\n  }\n}",
        "summary_tokens": [
            "null",
            "values",
            "are",
            "not",
            "allowed"
        ]
    },
    {
        "id": 313,
        "code": "public void testUniqueIndexNullKey() {\n  List<String> oneStringList = Lists.newArrayList(\"foo\");\n  try {\n    Maps.uniqueIndex(oneStringList, Functions.constant(null));\n    fail();\n  } catch (NullPointerException expected) {\n  }\n}",
        "summary_tokens": [
            "null",
            "keys",
            "aren",
            "t",
            "allowed",
            "either"
        ]
    },
    {
        "id": 314,
        "code": "public void testSynchronizedBiMap() {\n  BiMap<String, Integer> bimap = HashBiMap.create();\n  bimap.put(\"one\", 1);\n  BiMap<String, Integer> sync = Maps.synchronizedBiMap(bimap);\n  bimap.put(\"two\", 2);\n  sync.put(\"three\", 3);\n  assertEquals(ImmutableSet.of(1, 2, 3), bimap.inverse().keySet());\n  assertEquals(ImmutableSet.of(1, 2, 3), sync.inverse().keySet());\n}",
        "summary_tokens": [
            "see",
            "synchronized",
            "bi",
            "map",
            "test",
            "for",
            "more",
            "tests"
        ]
    },
    {
        "id": 315,
        "code": "private void assertMapsEqual(Map<?, ?> expected, Map<?, ?> map) {\n  assertEquals(expected, map);\n  assertEquals(expected.hashCode(), map.hashCode());\n  assertEquals(expected.entrySet(), map.entrySet());\n\n    \n    \n  Collection<?> expectedValues = expected.values();\n  Collection<?> mapValues = map.values();\n  assertEquals(expectedValues.size(), mapValues.size());\n  assertTrue(expectedValues.containsAll(mapValues));\n  assertTrue(mapValues.containsAll(expectedValues));\n}",
        "summary_tokens": [
            "helper",
            "assertion",
            "comparing",
            "two",
            "maps"
        ]
    },
    {
        "id": 316,
        "code": "private void assertMapsEqual(Map<?, ?> expected, Map<?, ?> map) {\n  assertEquals(expected, map);\n  assertEquals(expected.hashCode(), map.hashCode());\n  assertEquals(expected.entrySet(), map.entrySet());\n\n    \n    \n  Collection<?> expectedValues = expected.values();\n  Collection<?> mapValues = map.values();\n  assertEquals(expectedValues.size(), mapValues.size());\n  assertTrue(expectedValues.containsAll(mapValues));\n  assertTrue(mapValues.containsAll(expectedValues));\n}",
        "summary_tokens": [
            "helper",
            "assertion",
            "comparing",
            "two",
            "maps"
        ]
    },
    {
        "id": 317,
        "code": "public void testIteratorRegressionChildlessUncle() {\n  final ArrayList<Integer> initial = Lists.newArrayList(1, 15, 13, 8, 9, 10, 11, 14);\n  MinMaxPriorityQueue<Integer> q = MinMaxPriorityQueue.create(initial);\n  assertIntact(q);\n  q.remove(9);\n  q.remove(11);\n  q.remove(10);\n    \n    \n  List<Integer> result = Lists.newArrayListWithCapacity(initial.size());\n  for (Iterator<Integer> iter = q.iterator(); iter.hasNext(); ) {\n    Integer value = iter.next();\n    result.add(value);\n    if (value == 8) {\n      iter.remove();\n    }\n  }\n  assertIntact(q);\n  assertThat(result).containsExactly(1, 15, 13, 8, 14);\n}",
        "summary_tokens": [
            "tests",
            "a",
            "failure",
            "caused",
            "by",
            "fix",
            "to",
            "childless",
            "uncle",
            "issue"
        ]
    },
    {
        "id": 318,
        "code": "public void testInvalidatingRemove() {\n  MinMaxPriorityQueue<Integer> mmHeap = MinMaxPriorityQueue.create();\n  mmHeap.addAll(\n      Lists.newArrayList(1, 20, 1000, 2, 3, 30, 40, 10, 11, 12, 13, 300, 400, 500, 600));\n  assertEquals(15, mmHeap.size());\n  assertTrue(\"Heap is not intact initially\", mmHeap.isIntact());\n  mmHeap.remove(12);\n  assertEquals(14, mmHeap.size());\n  assertTrue(\"Heap is not intact after remove()\", mmHeap.isIntact());\n}",
        "summary_tokens": [
            "this",
            "tests",
            "a",
            "special",
            "case",
            "of",
            "the",
            "remove",
            "at",
            "call"
        ]
    },
    {
        "id": 319,
        "code": "public void testInvalidatingRemove2() {\n  MinMaxPriorityQueue<Integer> mmHeap = MinMaxPriorityQueue.create();\n  List<Integer> values =\n      Lists.newArrayList(\n          1, 20, 1000, 2, 3, 30, 40, 10, 11, 12, 13, 300, 400, 500, 600, 4, 5, 6, 7, 8, 9, 4, 5,\n          200, 250);\n  mmHeap.addAll(values);\n  assertEquals(25, mmHeap.size());\n  assertTrue(\"Heap is not intact initially\", mmHeap.isIntact());\n  mmHeap.remove(2);\n  assertEquals(24, mmHeap.size());\n  assertTrue(\"Heap is not intact after remove()\", mmHeap.isIntact());\n  values.removeAll(Lists.newArrayList(2));\n  assertEquals(values.size(), mmHeap.size());\n  assertTrue(values.containsAll(mmHeap));\n  assertTrue(mmHeap.containsAll(values));\n}",
        "summary_tokens": [
            "this",
            "tests",
            "a",
            "more",
            "obscure",
            "special",
            "case",
            "but",
            "otherwise",
            "similar",
            "to",
            "above"
        ]
    },
    {
        "id": 320,
        "code": "public void testIteratorInvalidatingIteratorRemove2() {\n  MinMaxPriorityQueue<Integer> mmHeap = MinMaxPriorityQueue.create();\n  mmHeap.addAll(\n      Lists.newArrayList(1, 20, 1000, 2, 3, 30, 40, 10, 11, 12, 13, 200, 300, 500, 400));\n  assertTrue(\"Heap is not intact initially\", mmHeap.isIntact());\n  Iterator<Integer> it = mmHeap.iterator();\n  assertEquals((Integer) 1, it.next());\n  assertEquals((Integer) 20, it.next());\n  assertEquals((Integer) 1000, it.next());\n  assertEquals((Integer) 2, it.next());\n  it.remove();\n    \n  assertTrue(\"Heap is not intact after remove\", mmHeap.isIntact());\n  assertEquals((Integer) 10, it.next());\n  assertEquals((Integer) 3, it.next());\n  it.remove();\n    \n  assertTrue(\"Heap is not intact after remove\", mmHeap.isIntact());\n  assertEquals((Integer) 12, it.next());\n  assertEquals((Integer) 30, it.next());\n  assertEquals((Integer) 40, it.next());\n    \n  assertEquals((Integer) 11, it.next());\n    \n  assertEquals((Integer) 400, it.next());\n  assertEquals((Integer) 13, it.next());\n  assertEquals((Integer) 200, it.next());\n  assertEquals((Integer) 300, it.next());\n    \n  assertEquals((Integer) 500, it.next());\n}",
        "summary_tokens": [
            "this",
            "tests",
            "a",
            "special",
            "case",
            "where",
            "remove",
            "at",
            "has",
            "to",
            "trickle",
            "an",
            "element",
            "first",
            "down",
            "one",
            "level",
            "from",
            "a",
            "min",
            "to",
            "a",
            "max",
            "level",
            "then",
            "up",
            "one",
            "level",
            "above",
            "the",
            "index",
            "of",
            "the",
            "removed",
            "element"
        ]
    },
    {
        "id": 321,
        "code": "public void testCorrectOrdering_regression() {\n  MinMaxPriorityQueue<Integer> q = MinMaxPriorityQueue.create(ImmutableList.of(3, 5, 1, 4, 7));\n  List<Integer> expected = ImmutableList.of(1, 3, 4, 5, 7);\n  List<Integer> actual = new ArrayList<>(5);\n  for (int i = 0; i < expected.size(); i++) {\n    actual.add(q.pollFirst());\n  }\n  assertEquals(expected, actual);\n}",
        "summary_tokens": [
            "regression",
            "test",
            "for",
            "bug",
            "found"
        ]
    },
    {
        "id": 322,
        "code": "public void testCorrectOrdering_73ElementBug() {\n  int size = 73;\n  long seed = 7522346378524621981L;\n  ArrayList<Integer> elements = createOrderedList(size);\n  List<Integer> expected = ImmutableList.copyOf(elements);\n  MinMaxPriorityQueue<Integer> q = MinMaxPriorityQueue.create();\n  insertRandomly(elements, q, new Random(seed));\n  assertIntact(q);\n  while (!q.isEmpty()) {\n    elements.add(q.pollFirst());\n    assertIntact(q);\n  }\n  assertEqualsUsingSeed(seed, expected, elements);\n}",
        "summary_tokens": [
            "regression",
            "test",
            "for",
            "bug",
            "found",
            "in",
            "random",
            "testing"
        ]
    },
    {
        "id": 323,
        "code": "public void testRegression_dataCorruption() {\n  int size = 8;\n  List<Integer> expected = createOrderedList(size);\n  MinMaxPriorityQueue<Integer> q = MinMaxPriorityQueue.create(expected);\n  List<Integer> contents = Lists.newArrayList(expected);\n  List<Integer> elements = Lists.newArrayListWithCapacity(size);\n  while (!q.isEmpty()) {\n    assertThat(q).containsExactlyElementsIn(contents);\n    Integer next = q.pollFirst();\n    contents.remove(next);\n    assertThat(q).containsExactlyElementsIn(contents);\n    for (int i = 0; i <= size; i++) {\n      q.add(i);\n      contents.add(i);\n      assertThat(q).containsExactlyElementsIn(contents);\n      q.add(next);\n      contents.add(next);\n      assertThat(q).containsExactlyElementsIn(contents);\n      q.remove(i);\n      assertTrue(contents.remove(Integer.valueOf(i)));\n      assertThat(q).containsExactlyElementsIn(contents);\n      assertEquals(next, q.poll());\n      contents.remove(next);\n      assertThat(q).containsExactlyElementsIn(contents);\n    }\n    elements.add(next);\n  }\n  assertEquals(expected, elements);\n}",
        "summary_tokens": [
            "regression",
            "test",
            "for",
            "b",
            "0"
        ]
    },
    {
        "id": 324,
        "code": "public void testRemoveRegression() {\n  MinMaxPriorityQueue<Long> queue =\n      MinMaxPriorityQueue.create(ImmutableList.of(2L, 3L, 0L, 4L, 1L));\n  queue.remove(4L);\n  queue.remove(1L);\n  assertThat(queue).doesNotContain(1L);\n}",
        "summary_tokens": [
            "regression",
            "test",
            "for",
            "https",
            "github"
        ]
    },
    {
        "id": 325,
        "code": "private long insertRandomly(ArrayList<Integer> elements, MinMaxPriorityQueue<Integer> q) {\n  long seed = new Random().nextLong();\n  Random random = new Random(seed);\n  insertRandomly(elements, q, random);\n  return seed;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "seed",
            "used",
            "for",
            "the",
            "randomization"
        ]
    },
    {
        "id": 326,
        "code": "private static void checkUnmodifiableMultimap(\n    Multimap<String, Integer> multimap,\n    boolean permitsDuplicates,\n    @Nullable String nullKey,\n    @Nullable Integer nullValue) {\n  Multimap<String, Integer> unmodifiable =\n      prepareUnmodifiableTests(multimap, permitsDuplicates, nullKey, nullValue);\n\n  UnmodifiableCollectionTests.assertMultimapIsUnmodifiable(unmodifiable, \"test\", 123);\n\n  assertUnmodifiableIterableInTandem(unmodifiable.keys(), multimap.keys());\n\n  assertUnmodifiableIterableInTandem(unmodifiable.keySet(), multimap.keySet());\n\n  assertUnmodifiableIterableInTandem(unmodifiable.entries(), multimap.entries());\n\n  assertUnmodifiableIterableInTandem(\n      unmodifiable.asMap().entrySet(), multimap.asMap().entrySet());\n\n  assertEquals(multimap.toString(), unmodifiable.toString());\n  assertEquals(multimap.hashCode(), unmodifiable.hashCode());\n  assertEquals(multimap, unmodifiable);\n\n  assertThat(unmodifiable.asMap().get(\"bar\")).containsExactly(5, -1);\n  assertNull(unmodifiable.asMap().get(\"missing\"));\n\n  assertFalse(unmodifiable.entries() instanceof Serializable);\n}",
        "summary_tokens": [
            "the",
            "supplied",
            "multimap",
            "will",
            "be",
            "mutated",
            "and",
            "an",
            "unmodifiable",
            "instance",
            "used",
            "in",
            "its",
            "stead"
        ]
    },
    {
        "id": 327,
        "code": "private static Multimap<String, Integer> prepareUnmodifiableTests(\n    Multimap<String, Integer> multimap,\n    boolean permitsDuplicates,\n    @Nullable String nullKey,\n    @Nullable Integer nullValue) {\n  multimap.clear();\n  multimap.put(\"foo\", 1);\n  multimap.put(\"foo\", 2);\n  multimap.put(\"foo\", 3);\n  multimap.put(\"bar\", 5);\n  multimap.put(\"bar\", -1);\n  multimap.put(nullKey, nullValue);\n  multimap.put(\"foo\", nullValue);\n  multimap.put(nullKey, 5);\n  multimap.put(\"foo\", 2);\n\n  if (permitsDuplicates) {\n    assertEquals(9, multimap.size());\n  } else {\n    assertEquals(8, multimap.size());\n  }\n\n  Multimap<String, Integer> unmodifiable;\n  if (multimap instanceof SortedSetMultimap) {\n    unmodifiable =\n        Multimaps.unmodifiableSortedSetMultimap((SortedSetMultimap<String, Integer>) multimap);\n  } else if (multimap instanceof SetMultimap) {\n    unmodifiable = Multimaps.unmodifiableSetMultimap((SetMultimap<String, Integer>) multimap);\n  } else if (multimap instanceof ListMultimap) {\n    unmodifiable = Multimaps.unmodifiableListMultimap((ListMultimap<String, Integer>) multimap);\n  } else {\n    unmodifiable = Multimaps.unmodifiableMultimap(multimap);\n  }\n  return unmodifiable;\n}",
        "summary_tokens": [
            "prepares",
            "the",
            "multimap",
            "for",
            "unmodifiable",
            "tests",
            "returning",
            "an",
            "unmodifiable",
            "view",
            "of",
            "the",
            "map"
        ]
    },
    {
        "id": 328,
        "code": "private static <T> void testExhaustively(\n    Ordering<? super T> ordering, T... strictlyOrderedElements) {\n  checkArgument(\n      strictlyOrderedElements.length >= 3,\n      \"strictlyOrderedElements \" + \"requires at least 3 elements\");\n  List<T> list = Arrays.asList(strictlyOrderedElements);\n\n    \n  T[] emptyArray = Platform.newArray(strictlyOrderedElements, 0);\n\n    \n  @SuppressWarnings(\"unchecked\")\n  Scenario<T> starter = new Scenario<>((Ordering) ordering, list, emptyArray);\n  verifyScenario(starter, 0);\n}",
        "summary_tokens": [
            "requires",
            "at",
            "least",
            "0",
            "elements",
            "in",
            "strictly",
            "ordered",
            "elements",
            "in",
            "order",
            "to",
            "test",
            "the",
            "varargs",
            "version",
            "of",
            "min",
            "max"
        ]
    },
    {
        "id": 329,
        "code": "private void assertDrained(BlockingQueue<Object> q) {\n  assertNull(q.peek());\n  assertInterruptibleDrained(q);\n  assertUninterruptibleDrained(q);\n}",
        "summary_tokens": [
            "checks",
            "that",
            "drain",
            "invocations",
            "behave",
            "correctly",
            "for",
            "a",
            "drained",
            "empty",
            "queue"
        ]
    },
    {
        "id": 330,
        "code": "public void testDoesntCheckForNull() {\n  ImmutableSet<Integer> set = ImmutableSet.of(1, 2, 3);\n  new RegularImmutableAsList<Integer>(set, new Object[] {null, null, null});\n    \n}",
        "summary_tokens": [
            "regular",
            "immutable",
            "as",
            "list",
            "should",
            "assume",
            "its",
            "input",
            "is",
            "null",
            "free",
            "without",
            "checking",
            "because",
            "it",
            "only",
            "gets",
            "invoked",
            "from",
            "other",
            "immutable",
            "collections"
        ]
    },
    {
        "id": 331,
        "code": "public void testCartesianProduct_zeroary() {\n  assertThat(Sets.cartesianProduct()).containsExactly(list());\n}",
        "summary_tokens": [
            "the",
            "0",
            "ary",
            "cartesian",
            "product",
            "is",
            "a",
            "single",
            "empty",
            "list"
        ]
    },
    {
        "id": 332,
        "code": "public void testCartesianProduct_unary() {\n  assertThat(Sets.cartesianProduct(set(1, 2))).containsExactly(list(1), list(2));\n}",
        "summary_tokens": [
            "a",
            "unary",
            "cartesian",
            "product",
            "is",
            "one",
            "list",
            "of",
            "size",
            "0",
            "for",
            "each",
            "element",
            "in",
            "the",
            "input",
            "set"
        ]
    },
    {
        "id": 333,
        "code": "public void testPowerSetHashCode_inputHashCodeTimesTooFarValueIsZero() {\n  Set<Object> sumToEighthMaxIntElements =\n      newHashSet(objectWithHashCode(1 << 29), objectWithHashCode(0));\n  assertPowerSetHashCode(1 << 30, sumToEighthMaxIntElements);\n\n  Set<Object> sumToQuarterMaxIntElements =\n      newHashSet(objectWithHashCode(1 << 30), objectWithHashCode(0));\n  assertPowerSetHashCode(1 << 31, sumToQuarterMaxIntElements);\n}",
        "summary_tokens": [
            "test",
            "that",
            "a",
            "hash",
            "code",
            "miscomputed",
            "by",
            "input"
        ]
    },
    {
        "id": 334,
        "code": "private static <E> void verifyLinkedHashSetContents(\n    LinkedHashSet<E> set, Collection<E> contents) {\n  assertEquals(\n      \"LinkedHashSet should have preserved order for iteration\",\n      new ArrayList<E>(set),\n      new ArrayList<E>(contents));\n  verifySetContents(set, contents);\n}",
        "summary_tokens": [
            "utility",
            "method",
            "to",
            "verify",
            "that",
            "the",
            "given",
            "linked",
            "hash",
            "set",
            "is",
            "equal",
            "to",
            "and",
            "hashes",
            "identically",
            "to",
            "a",
            "set",
            "constructed",
            "with",
            "the",
            "elements",
            "in",
            "the",
            "given",
            "collection"
        ]
    },
    {
        "id": 335,
        "code": "private static <E> void verifySortedSetContents(\n    SortedSet<E> set, Iterable<E> iterable, @Nullable Comparator<E> comparator) {\n  assertSame(comparator, set.comparator());\n  verifySetContents(set, iterable);\n}",
        "summary_tokens": [
            "utility",
            "method",
            "to",
            "verify",
            "that",
            "the",
            "given",
            "sorted",
            "set",
            "is",
            "equal",
            "to",
            "and",
            "hashes",
            "identically",
            "to",
            "a",
            "set",
            "constructed",
            "with",
            "the",
            "elements",
            "in",
            "the",
            "given",
            "iterable"
        ]
    },
    {
        "id": 336,
        "code": "private static <E> void verifySetContents(Set<E> set, Iterable<E> contents) {\n  Set<E> expected = null;\n  if (contents instanceof Set) {\n    expected = (Set<E>) contents;\n  } else {\n    expected = new HashSet<E>();\n    for (E element : contents) {\n      expected.add(element);\n    }\n  }\n  assertEquals(expected, set);\n}",
        "summary_tokens": [
            "utility",
            "method",
            "that",
            "verifies",
            "that",
            "the",
            "given",
            "set",
            "is",
            "equal",
            "to",
            "and",
            "hashes",
            "identically",
            "to",
            "a",
            "set",
            "constructed",
            "with",
            "the",
            "elements",
            "in",
            "the",
            "given",
            "iterable"
        ]
    },
    {
        "id": 337,
        "code": "private TreeMultimap<String, Integer> createPopulate() {\n  TreeMultimap<String, Integer> multimap =\n      TreeMultimap.create(StringLength.COMPARATOR, DECREASING_INT_COMPARATOR);\n  multimap.put(\"google\", 2);\n  multimap.put(\"google\", 6);\n  multimap.put(null, 3);\n  multimap.put(null, 1);\n  multimap.put(null, 7);\n  multimap.put(\"tree\", 0);\n  multimap.put(\"tree\", null);\n  return multimap;\n}",
        "summary_tokens": [
            "create",
            "and",
            "populate",
            "a",
            "tree",
            "multimap",
            "with",
            "explicit",
            "comparators"
        ]
    },
    {
        "id": 338,
        "code": "public void testMultimapCreateFromTreeMultimap() {\n  TreeMultimap<String, Integer> tree =\n      TreeMultimap.create(StringLength.COMPARATOR, DECREASING_INT_COMPARATOR);\n  tree.put(\"google\", 2);\n  tree.put(\"google\", 6);\n  tree.put(\"tree\", 0);\n  tree.put(\"tree\", 3);\n  assertThat(tree.keySet()).containsExactly(\"tree\", \"google\").inOrder();\n  assertThat(tree.get(\"google\")).containsExactly(6, 2).inOrder();\n\n  TreeMultimap<String, Integer> copy = TreeMultimap.create(tree);\n  assertEquals(tree, copy);\n  assertThat(copy.keySet()).containsExactly(\"google\", \"tree\").inOrder();\n  assertThat(copy.get(\"google\")).containsExactly(2, 6).inOrder();\n  assertEquals(Ordering.natural(), copy.keyComparator());\n  assertEquals(Ordering.natural(), copy.valueComparator());\n  assertEquals(Ordering.natural(), copy.get(\"google\").comparator());\n}",
        "summary_tokens": [
            "test",
            "that",
            "a",
            "tree",
            "multimap",
            "created",
            "from",
            "another",
            "uses",
            "the",
            "natural",
            "ordering"
        ]
    },
    {
        "id": 339,
        "code": "private TreeMultimap<String, Integer> createPopulate() {\n  TreeMultimap<String, Integer> multimap = TreeMultimap.create();\n  multimap.put(\"google\", 2);\n  multimap.put(\"google\", 6);\n  multimap.put(\"foo\", 3);\n  multimap.put(\"foo\", 1);\n  multimap.put(\"foo\", 7);\n  multimap.put(\"tree\", 4);\n  multimap.put(\"tree\", 0);\n  return multimap;\n}",
        "summary_tokens": [
            "create",
            "and",
            "populate",
            "a",
            "tree",
            "multimap",
            "with",
            "the",
            "natural",
            "ordering",
            "of",
            "keys",
            "and",
            "values"
        ]
    },
    {
        "id": 340,
        "code": "public void testCreateFromTreeMultimap() {\n  Multimap<Double, Double> tree = TreeMultimap.create(KEY_COMPARATOR, VALUE_COMPARATOR);\n  tree.put(1.0, 2.0);\n  tree.put(2.0, 3.0);\n  tree.put(3.0, 4.0);\n  tree.put(4.0, 5.0);\n\n  TreeMultimap<Double, Double> copyFromTree = TreeMultimap.create(tree);\n  assertEquals(tree, copyFromTree);\n  assertSame(Ordering.natural(), copyFromTree.keyComparator());\n  assertSame(Ordering.natural(), copyFromTree.valueComparator());\n  assertSame(Ordering.natural(), copyFromTree.get(1.0).comparator());\n}",
        "summary_tokens": [
            "test",
            "that",
            "creating",
            "one",
            "tree",
            "multimap",
            "from",
            "another",
            "does",
            "not",
            "copy",
            "the",
            "comparators",
            "from",
            "the",
            "source",
            "tree",
            "multimap"
        ]
    },
    {
        "id": 341,
        "code": "public void testCreateFromHashMultimap() {\n  Multimap<Double, Double> hash = HashMultimap.create();\n  hash.put(1.0, 2.0);\n  hash.put(2.0, 3.0);\n  hash.put(3.0, 4.0);\n  hash.put(4.0, 5.0);\n\n  TreeMultimap<Double, Double> copyFromHash = TreeMultimap.create(hash);\n  assertEquals(hash, copyFromHash);\n  assertEquals(Ordering.natural(), copyFromHash.keyComparator());\n  assertEquals(Ordering.natural(), copyFromHash.valueComparator());\n}",
        "summary_tokens": [
            "test",
            "that",
            "creating",
            "one",
            "tree",
            "multimap",
            "from",
            "a",
            "non",
            "tree",
            "multimap",
            "results",
            "in",
            "natural",
            "ordering"
        ]
    },
    {
        "id": 342,
        "code": "public void testCreateFromSortedSetMultimap() {\n  SortedSetMultimap<Double, Double> tree = TreeMultimap.create(KEY_COMPARATOR, VALUE_COMPARATOR);\n  tree.put(1.0, 2.0);\n  tree.put(2.0, 3.0);\n  tree.put(3.0, 4.0);\n  tree.put(4.0, 5.0);\n\n  SortedSetMultimap<Double, Double> sorted = Multimaps.unmodifiableSortedSetMultimap(tree);\n  TreeMultimap<Double, Double> copyFromSorted = TreeMultimap.create(sorted);\n  assertEquals(tree, copyFromSorted);\n  assertSame(Ordering.natural(), copyFromSorted.keyComparator());\n  assertSame(Ordering.natural(), copyFromSorted.valueComparator());\n  assertSame(Ordering.natural(), copyFromSorted.get(1.0).comparator());\n}",
        "summary_tokens": [
            "test",
            "that",
            "creating",
            "one",
            "tree",
            "multimap",
            "from",
            "a",
            "sorted",
            "set",
            "multimap",
            "uses",
            "natural",
            "ordering"
        ]
    },
    {
        "id": 343,
        "code": "public void testDegenerateComparator() throws Exception {\n  TreeMultiset<String> ms = TreeMultiset.create(DEGENERATE_COMPARATOR);\n\n  ms.add(\"foo\");\n  ms.add(\"a\");\n  ms.add(\"bar\");\n  ms.add(\"b\");\n  ms.add(\"c\");\n\n  assertEquals(2, ms.count(\"bar\"));\n  assertEquals(3, ms.count(\"b\"));\n\n  Multiset<String> ms2 = TreeMultiset.create(DEGENERATE_COMPARATOR);\n\n  ms2.add(\"cat\", 2);\n  ms2.add(\"x\", 3);\n\n  assertEquals(ms, ms2);\n  assertEquals(ms2, ms);\n\n  SortedSet<String> elementSet = ms.elementSet();\n  assertEquals(\"a\", elementSet.first());\n  assertEquals(\"foo\", elementSet.last());\n  assertEquals(DEGENERATE_COMPARATOR, elementSet.comparator());\n}",
        "summary_tokens": [
            "test",
            "a",
            "tree",
            "multiset",
            "with",
            "a",
            "comparator",
            "that",
            "can",
            "return",
            "0",
            "when",
            "comparing",
            "unequal",
            "values"
        ]
    },
    {
        "id": 344,
        "code": "public void testPolymorphicDistribution() {\n    \n    \n    \n    \n  StringCatcher stringCatcher = new StringCatcher();\n\n  final List<Object> objectEvents = Lists.newArrayList();\n  Object objCatcher =\n      new Object() {\n        @SuppressWarnings(\"unused\")\n        @Subscribe\n        public void eat(Object food) {\n          objectEvents.add(food);\n        }\n      };\n\n  final List<Comparable<?>> compEvents = Lists.newArrayList();\n  Object compCatcher =\n      new Object() {\n        @SuppressWarnings(\"unused\")\n        @Subscribe\n        public void eat(Comparable<?> food) {\n          compEvents.add(food);\n        }\n      };\n  bus.register(stringCatcher);\n  bus.register(objCatcher);\n  bus.register(compCatcher);\n\n    \n  Object objEvent = new Object();\n  Object compEvent = new Integer(6);\n\n  bus.post(EVENT);\n  bus.post(objEvent);\n  bus.post(compEvent);\n\n    \n  List<String> stringEvents = stringCatcher.getEvents();\n  assertEquals(\"Only one String should be delivered.\", 1, stringEvents.size());\n  assertEquals(\"Correct string should be delivered.\", EVENT, stringEvents.get(0));\n\n    \n  assertEquals(\"Three Objects should be delivered.\", 3, objectEvents.size());\n  assertEquals(\"String fixture must be first object delivered.\", EVENT, objectEvents.get(0));\n  assertEquals(\"Object fixture must be second object delivered.\", objEvent, objectEvents.get(1));\n  assertEquals(\n      \"Comparable fixture must be thirdobject delivered.\", compEvent, objectEvents.get(2));\n\n    \n  assertEquals(\"Two Comparable<?>s should be delivered.\", 2, compEvents.size());\n  assertEquals(\"String fixture must be first comparable delivered.\", EVENT, compEvents.get(0));\n  assertEquals(\n      \"Comparable fixture must be second comparable delivered.\", compEvent, compEvents.get(1));\n}",
        "summary_tokens": [
            "tests",
            "that",
            "events",
            "are",
            "distributed",
            "to",
            "any",
            "subscribers",
            "to",
            "their",
            "type",
            "or",
            "any",
            "supertype",
            "including",
            "interfaces",
            "and",
            "superclasses"
        ]
    },
    {
        "id": 345,
        "code": "public void testRegistrationWithBridgeMethod() {\n  final AtomicInteger calls = new AtomicInteger();\n  bus.register(\n      new Callback<String>() {\n        @Subscribe\n        @Override\n        public void call(String s) {\n          calls.incrementAndGet();\n        }\n      });\n\n  bus.post(\"hello\");\n\n  assertEquals(1, calls.get());\n}",
        "summary_tokens": [
            "tests",
            "that",
            "bridge",
            "methods",
            "are",
            "not",
            "subscribed",
            "to",
            "events"
        ]
    },
    {
        "id": 346,
        "code": "public void recordingMethod(Object arg) {\n  assertFalse(methodCalled);\n  methodCalled = true;\n  methodArgument = arg;\n}",
        "summary_tokens": [
            "records",
            "the",
            "provided",
            "object",
            "in",
            "method",
            "argument",
            "and",
            "sets",
            "method",
            "called"
        ]
    },
    {
        "id": 347,
        "code": "private void populateStarShapedGraph() {\n  putEdge(2, 1);\n  putEdge(1, 4);\n  putEdge(1, 3);\n  putEdge(5, 1);\n  putEdge(1, 2);\n  putEdge(3, 1);\n}",
        "summary_tokens": [
            "populates",
            "the",
            "graph",
            "with",
            "nodes",
            "and",
            "edges",
            "in",
            "a",
            "star",
            "shape",
            "with",
            "node",
            "0",
            "in",
            "the",
            "middle"
        ]
    },
    {
        "id": 348,
        "code": "public void putEdge_nodesNotInGraph() {\n  assume().that(graphIsMutable()).isTrue();\n\n  graphAsMutableGraph.addNode(N1);\n  assertTrue(graphAsMutableGraph.putEdge(N1, N5));\n  assertTrue(graphAsMutableGraph.putEdge(N4, N1));\n  assertTrue(graphAsMutableGraph.putEdge(N2, N3));\n  assertThat(graph.nodes()).containsExactly(N1, N5, N4, N2, N3).inOrder();\n  assertThat(graph.successors(N1)).containsExactly(N5);\n  assertThat(graph.successors(N2)).containsExactly(N3);\n  assertThat(graph.successors(N3)).isEmpty();\n  assertThat(graph.successors(N4)).containsExactly(N1);\n  assertThat(graph.successors(N5)).isEmpty();\n}",
        "summary_tokens": [
            "tests",
            "that",
            "the",
            "method",
            "put",
            "edge",
            "will",
            "silently",
            "add",
            "the",
            "missing",
            "nodes",
            "to",
            "the",
            "graph",
            "then",
            "add",
            "the",
            "edge",
            "connecting",
            "them"
        ]
    },
    {
        "id": 349,
        "code": "public void addEdge_nodesNotInGraph() {\n  assume().that(graphIsMutable()).isTrue();\n\n  networkAsMutableNetwork.addNode(N1);\n  assertTrue(networkAsMutableNetwork.addEdge(N1, N5, E15));\n  assertTrue(networkAsMutableNetwork.addEdge(N4, N1, E41));\n  assertTrue(networkAsMutableNetwork.addEdge(N2, N3, E23));\n  assertThat(network.nodes()).containsExactly(N1, N5, N4, N2, N3);\n  assertThat(network.edges()).containsExactly(E15, E41, E23);\n  assertThat(network.edgesConnecting(N1, N5)).containsExactly(E15);\n  assertThat(network.edgesConnecting(N4, N1)).containsExactly(E41);\n  assertThat(network.edgesConnecting(N2, N3)).containsExactly(E23);\n    \n  assertThat(network.edgesConnecting(N3, N2)).isEmpty();\n}",
        "summary_tokens": [
            "this",
            "test",
            "checks",
            "an",
            "implementation",
            "dependent",
            "feature"
        ]
    },
    {
        "id": 350,
        "code": "private void populateTShapedGraph() {\n  putEdge(2, 1);\n  putEdge(1, 4);\n  putEdge(1, 3);\n  putEdge(1, 2); \n  putEdge(4, 5);\n}",
        "summary_tokens": [
            "populates",
            "the",
            "graph",
            "with",
            "nodes",
            "and",
            "edges",
            "in",
            "a",
            "star",
            "shape",
            "with",
            "node",
            "0",
            "in",
            "the",
            "middle"
        ]
    },
    {
        "id": 351,
        "code": "public void putEdge_nodesNotInGraph() {\n  assume().that(graphIsMutable()).isTrue();\n\n  graphAsMutableGraph.addNode(N1);\n  assertTrue(graphAsMutableGraph.putEdge(N1, N5));\n  assertTrue(graphAsMutableGraph.putEdge(N4, N1));\n  assertTrue(graphAsMutableGraph.putEdge(N2, N3));\n  assertThat(graph.nodes()).containsExactly(N1, N5, N4, N2, N3).inOrder();\n  assertThat(graph.adjacentNodes(N1)).containsExactly(N4, N5);\n  assertThat(graph.adjacentNodes(N2)).containsExactly(N3);\n  assertThat(graph.adjacentNodes(N3)).containsExactly(N2);\n  assertThat(graph.adjacentNodes(N4)).containsExactly(N1);\n  assertThat(graph.adjacentNodes(N5)).containsExactly(N1);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "the",
            "method",
            "put",
            "edge",
            "will",
            "silently",
            "add",
            "the",
            "missing",
            "nodes",
            "to",
            "the",
            "graph",
            "then",
            "add",
            "the",
            "edge",
            "connecting",
            "them"
        ]
    },
    {
        "id": 352,
        "code": "public void addEdge_nodesNotInGraph() {\n  assume().that(graphIsMutable()).isTrue();\n\n  networkAsMutableNetwork.addNode(N1);\n  assertTrue(networkAsMutableNetwork.addEdge(N1, N5, E15));\n  assertTrue(networkAsMutableNetwork.addEdge(N4, N1, E41));\n  assertTrue(networkAsMutableNetwork.addEdge(N2, N3, E23));\n  assertThat(network.nodes()).containsExactly(N1, N5, N4, N2, N3);\n  assertThat(network.edges()).containsExactly(E15, E41, E23);\n  assertThat(network.edgesConnecting(N1, N5)).containsExactly(E15);\n  assertThat(network.edgesConnecting(N4, N1)).containsExactly(E41);\n  assertThat(network.edgesConnecting(N2, N3)).containsExactly(E23);\n  assertThat(network.edgesConnecting(N3, N2)).containsExactly(E23);\n}",
        "summary_tokens": [
            "this",
            "test",
            "checks",
            "an",
            "implementation",
            "dependent",
            "feature"
        ]
    },
    {
        "id": 353,
        "code": "public void immutableNetworkBuilder_copiesNetworkBuilder() {\n  NetworkBuilder<String, Object> networkBuilder =\n      NetworkBuilder.directed()\n          .allowsSelfLoops(true)\n          .<String>nodeOrder(ElementOrder.<String>natural());\n  ImmutableNetwork.Builder<String, Integer> immutableNetworkBuilder =\n      networkBuilder.<String, Integer>immutable();\n\n    \n  networkBuilder.allowsSelfLoops(false).nodeOrder(ElementOrder.<String>unordered());\n\n  ImmutableNetwork<String, Integer> emptyNetwork = immutableNetworkBuilder.build();\n\n  assertThat(emptyNetwork.isDirected()).isTrue();\n  assertThat(emptyNetwork.allowsSelfLoops()).isTrue();\n  assertThat(emptyNetwork.nodeOrder()).isEqualTo(ElementOrder.<String>natural());\n}",
        "summary_tokens": [
            "tests",
            "that",
            "the",
            "immutable",
            "network"
        ]
    },
    {
        "id": 354,
        "code": "public void immutableValueGraphBuilder_copiesGraphBuilder() {\n  ValueGraphBuilder<String, Object> graphBuilder =\n      ValueGraphBuilder.directed()\n          .allowsSelfLoops(true)\n          .<String>nodeOrder(ElementOrder.<String>natural());\n  ImmutableValueGraph.Builder<String, Integer> immutableValueGraphBuilder =\n      graphBuilder.<String, Integer>immutable();\n\n    \n  graphBuilder.allowsSelfLoops(false).nodeOrder(ElementOrder.<String>unordered());\n\n  ImmutableValueGraph<String, Integer> emptyGraph = immutableValueGraphBuilder.build();\n\n  assertThat(emptyGraph.isDirected()).isTrue();\n  assertThat(emptyGraph.allowsSelfLoops()).isTrue();\n  assertThat(emptyGraph.nodeOrder()).isEqualTo(ElementOrder.<String>natural());\n}",
        "summary_tokens": [
            "tests",
            "that",
            "the",
            "immutable",
            "value",
            "graph"
        ]
    },
    {
        "id": 355,
        "code": "public void immutableGraphBuilder_copiesGraphBuilder() {\n  GraphBuilder<String> graphBuilder =\n      GraphBuilder.directed()\n          .allowsSelfLoops(true)\n          .<String>nodeOrder(ElementOrder.<String>natural());\n  ImmutableGraph.Builder<String> immutableGraphBuilder = graphBuilder.immutable();\n\n    \n  graphBuilder.allowsSelfLoops(false).nodeOrder(ElementOrder.<String>unordered());\n\n  ImmutableGraph<String> emptyGraph = immutableGraphBuilder.build();\n\n  assertThat(emptyGraph.isDirected()).isTrue();\n  assertThat(emptyGraph.allowsSelfLoops()).isTrue();\n  assertThat(emptyGraph.nodeOrder()).isEqualTo(ElementOrder.<String>natural());\n}",
        "summary_tokens": [
            "tests",
            "that",
            "the",
            "immutable",
            "graph"
        ]
    },
    {
        "id": 356,
        "code": "static <T> Set<T> sanityCheckSet(Set<T> set) {\n  assertThat(set).hasSize(Iterators.size(set.iterator()));\n  for (Object element : set) {\n    assertThat(set).contains(element);\n  }\n  assertThat(set).doesNotContain(new Object());\n  assertThat(set).isEqualTo(ImmutableSet.copyOf(set));\n  return set;\n}",
        "summary_tokens": [
            "in",
            "some",
            "cases",
            "our",
            "graph",
            "implementations",
            "return",
            "custom",
            "sets",
            "that",
            "define",
            "their",
            "own",
            "size",
            "and",
            "contains"
        ]
    },
    {
        "id": 357,
        "code": "public void forGraph_breadthFirstIterable_emptyGraph() {\n  assertEqualCharNodes(\n      Traverser.forGraph(createDirectedGraph()).breadthFirst(charactersOf(\"\")), \"\");\n  try {\n    Traverser.forGraph(createDirectedGraph()).breadthFirst(charactersOf(\"a\"));\n    fail(\"Expected IllegalArgumentException\");\n  } catch (IllegalArgumentException expected) {\n  }\n}",
        "summary_tokens": [
            "checks",
            "that",
            "the",
            "elements",
            "of",
            "the",
            "iterable",
            "are",
            "calculated",
            "on",
            "the",
            "fly"
        ]
    },
    {
        "id": 358,
        "code": "public void forGraph_breadthFirst_iterableIsLazy() {\n  RequestSavingGraph graph = new RequestSavingGraph(DIAMOND_GRAPH);\n  Iterable<Character> result = Traverser.forGraph(graph).breadthFirst('a');\n\n  assertEqualCharNodes(Iterables.limit(result, 2), \"ab\");\n  assertThat(graph.requestedNodes).containsExactly('a', 'a', 'b');\n\n    \n  assertEqualCharNodes(Iterables.limit(result, 2), \"ab\");\n  assertThat(graph.requestedNodes).containsExactly('a', 'a', 'a', 'b', 'b');\n}",
        "summary_tokens": [
            "checks",
            "that",
            "the",
            "elements",
            "of",
            "the",
            "iterable",
            "are",
            "calculated",
            "on",
            "the",
            "fly"
        ]
    },
    {
        "id": 359,
        "code": "private static SuccessorsFunction<Character> createGraph(boolean directed, String... edges) {\n  ImmutableMultimap.Builder<Character, Character> graphMapBuilder = ImmutableMultimap.builder();\n  for (String edge : edges) {\n    checkArgument(\n        edge.length() == 2, \"Expecting each edge to consist of 2 characters but got %s\", edge);\n    char node1 = edge.charAt(0);\n    char node2 = edge.charAt(1);\n    graphMapBuilder.put(node1, node2);\n    if (!directed) {\n      graphMapBuilder.put(node2, node1);\n    }\n  }\n  final ImmutableMultimap<Character, Character> graphMap = graphMapBuilder.build();\n\n  return new SuccessorsFunction<Character>() {\n    @Override\n    public Iterable<? extends Character> successors(Character node) {\n      checkArgument(\n          graphMap.containsKey(node) || graphMap.containsValue(node),\n          \"Node %s is not an element of this graph\",\n          node);\n      return Ordering.natural().immutableSortedCopy(graphMap.get(node));\n    }\n  };\n}",
        "summary_tokens": [
            "creates",
            "a",
            "graph",
            "from",
            "a",
            "list",
            "of",
            "node",
            "pairs",
            "encoded",
            "as",
            "strings",
            "e"
        ]
    },
    {
        "id": 360,
        "code": "public void testExhaustive() {\n  List<Hasher> hashers =\n      ImmutableList.of(\n          new StreamingVersion().newHasher(),\n          new StreamingVersion().newHasher(52),\n          new NonStreamingVersion().newHasher(),\n          new NonStreamingVersion().newHasher(123));\n  Random random = new Random(0);\n  for (int i = 0; i < 200; i++) {\n    RandomHasherAction.pickAtRandom(random).performAction(random, hashers);\n  }\n  HashCode[] codes = new HashCode[hashers.size()];\n  for (int i = 0; i < hashers.size(); i++) {\n    codes[i] = hashers.get(i).hash();\n  }\n  for (int i = 1; i < codes.length; i++) {\n    assertEquals(codes[i - 1], codes[i]);\n  }\n}",
        "summary_tokens": [
            "constructs",
            "two",
            "trivial",
            "hash",
            "functions",
            "output",
            "input",
            "one",
            "streaming",
            "and",
            "one",
            "non",
            "streaming",
            "and",
            "checks",
            "that",
            "their",
            "results",
            "are",
            "identical",
            "no",
            "matter",
            "which",
            "new",
            "hasher",
            "version",
            "we",
            "used"
        ]
    },
    {
        "id": 361,
        "code": "public void testExhaustive() throws Exception {\n  Random random = new Random(0); \n  for (int totalInsertions = 0; totalInsertions < 200; totalInsertions++) {\n\n    List<Sink> sinks = Lists.newArrayList();\n    for (int chunkSize = 4; chunkSize <= 32; chunkSize++) {\n      for (int bufferSize = chunkSize; bufferSize <= chunkSize * 4; bufferSize += chunkSize) {\n          \n        sinks.add(new Sink(chunkSize, bufferSize));\n          \n          \n          \n      }\n    }\n\n    Control control = new Control();\n    Hasher controlSink = control.newHasher(1024);\n\n    Iterable<Hasher> sinksAndControl =\n        Iterables.concat(sinks, Collections.singleton(controlSink));\n    for (int insertion = 0; insertion < totalInsertions; insertion++) {\n      RandomHasherAction.pickAtRandom(random).performAction(random, sinksAndControl);\n    }\n      \n      \n    int intToPut = random.nextInt();\n    for (Hasher hasher : sinksAndControl) {\n      hasher.putInt(intToPut);\n    }\n    for (Sink sink : sinks) {\n      HashCode unused = sink.hash();\n    }\n\n    byte[] expected = controlSink.hash().asBytes();\n    for (Sink sink : sinks) {\n      sink.assertInvariants(expected.length);\n      sink.assertBytes(expected);\n    }\n  }\n}",
        "summary_tokens": [
            "this",
            "test",
            "creates",
            "a",
            "long",
            "random",
            "sequence",
            "of",
            "inputs",
            "then",
            "a",
            "lot",
            "of",
            "differently",
            "configured",
            "sinks",
            "process",
            "it",
            "all",
            "should",
            "produce",
            "the",
            "same",
            "answer",
            "the",
            "only",
            "difference",
            "should",
            "be",
            "the",
            "number",
            "of",
            "process",
            "process",
            "remaining",
            "invocations",
            "due",
            "to",
            "alignment"
        ]
    },
    {
        "id": 362,
        "code": "private static void assertApproximateElementCountGuess(BloomFilter<?> bf, int sizeGuess) {\n  assertThat(bf.approximateElementCount()).isAtLeast((long) (sizeGuess * 0.99));\n  assertThat(bf.approximateElementCount()).isAtMost((long) (sizeGuess * 1.01));\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "bloom",
            "filter",
            "approximate",
            "element",
            "count",
            "is",
            "within",
            "0",
            "percent",
            "of",
            "the",
            "expected",
            "value"
        ]
    },
    {
        "id": 363,
        "code": "public void testBasic() {\n  for (double fpr = 0.0000001; fpr < 0.1; fpr *= 10) {\n    for (int expectedInsertions = 1; expectedInsertions <= 10000; expectedInsertions *= 10) {\n      checkSanity(BloomFilter.create(HashTestUtils.BAD_FUNNEL, expectedInsertions, fpr));\n    }\n  }\n}",
        "summary_tokens": [
            "sanity",
            "checking",
            "with",
            "many",
            "combinations",
            "of",
            "false",
            "positive",
            "rates",
            "and",
            "expected",
            "insertions"
        ]
    },
    {
        "id": 364,
        "code": "public void testOptimalHashes() {\n  for (int n = 1; n < 1000; n++) {\n    for (int m = 0; m < 1000; m++) {\n      assertTrue(BloomFilter.optimalNumOfHashFunctions(n, m) > 0);\n    }\n  }\n}",
        "summary_tokens": [
            "tests",
            "that",
            "we",
            "never",
            "get",
            "an",
            "optimal",
            "hashes",
            "number",
            "of",
            "zero"
        ]
    },
    {
        "id": 365,
        "code": "public void testOptimalSize() {\n  for (int n = 1; n < 1000; n++) {\n    for (double fpp = Double.MIN_VALUE; fpp < 1.0; fpp += 0.001) {\n      assertTrue(BloomFilter.optimalNumOfBits(n, fpp) >= 0);\n    }\n  }\n\n    \n  Random random = new Random(0);\n  for (int repeats = 0; repeats < 10000; repeats++) {\n    assertTrue(BloomFilter.optimalNumOfBits(random.nextInt(1 << 16), random.nextDouble()) >= 0);\n  }\n\n    \n  assertEquals(3327428144502L, BloomFilter.optimalNumOfBits(Integer.MAX_VALUE, Double.MIN_VALUE));\n  try {\n    BloomFilter<String> unused =\n        BloomFilter.create(HashTestUtils.BAD_FUNNEL, Integer.MAX_VALUE, Double.MIN_VALUE);\n    fail(\"we can't represent such a large BF!\");\n  } catch (IllegalArgumentException expected) {\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Could not create BloomFilter of 3327428144502 bits\");\n  }\n}",
        "summary_tokens": [
            "tests",
            "that",
            "we",
            "always",
            "get",
            "a",
            "non",
            "negative",
            "optimal",
            "size"
        ]
    },
    {
        "id": 366,
        "code": "public void testBloomFilterStrategies() {\n  assertThat(BloomFilterStrategies.values()).hasLength(2);\n  assertEquals(BloomFilterStrategies.MURMUR128_MITZ_32, BloomFilterStrategies.values()[0]);\n  assertEquals(BloomFilterStrategies.MURMUR128_MITZ_64, BloomFilterStrategies.values()[1]);\n}",
        "summary_tokens": [
            "this",
            "test",
            "will",
            "fail",
            "whenever",
            "someone",
            "updates",
            "reorders",
            "the",
            "bloom",
            "filter",
            "strategies",
            "constants"
        ]
    },
    {
        "id": 367,
        "code": "private static void assertCrc(int expectedCrc, byte[] data) {\n  int actualCrc = Hashing.crc32c().hashBytes(data).asInt();\n  assertEquals(\n      String.format(\"expected: %08x, actual: %08x\", expectedCrc, actualCrc),\n      expectedCrc,\n      actualCrc);\n  int actualCrcHasher = Hashing.crc32c().newHasher().putBytes(data).hash().asInt();\n  assertEquals(\n      String.format(\"expected: %08x, actual: %08x\", expectedCrc, actualCrc),\n      expectedCrc,\n      actualCrcHasher);\n}",
        "summary_tokens": [
            "verifies",
            "that",
            "the",
            "crc",
            "of",
            "an",
            "array",
            "of",
            "byte",
            "data",
            "matches",
            "the",
            "expected",
            "value"
        ]
    },
    {
        "id": 368,
        "code": "private static long fingerprint(byte[] bytes, int length) {\n  return HASH_FN.hashBytes(bytes, 0, length).asLong();\n}",
        "summary_tokens": [
            "convenience",
            "method",
            "to",
            "compute",
            "a",
            "fingerprint",
            "on",
            "a",
            "subset",
            "of",
            "a",
            "byte",
            "array"
        ]
    },
    {
        "id": 369,
        "code": "public void testMultipleLengths() {\n  int iterations = 800;\n  byte[] buf = new byte[iterations * 4];\n  int bufLen = 0;\n  long h = 0;\n  for (int i = 0; i < iterations; ++i) {\n    h ^= fingerprint(buf, i);\n    h = remix(h);\n    buf[bufLen++] = getChar(h);\n\n    h ^= fingerprint(buf, i * i % bufLen);\n    h = remix(h);\n    buf[bufLen++] = getChar(h);\n\n    h ^= fingerprint(buf, i * i * i % bufLen);\n    h = remix(h);\n    buf[bufLen++] = getChar(h);\n\n    h ^= fingerprint(buf, bufLen);\n    h = remix(h);\n    buf[bufLen++] = getChar(h);\n\n    int x0 = buf[bufLen - 1] & 0xff;\n    int x1 = buf[bufLen - 2] & 0xff;\n    int x2 = buf[bufLen - 3] & 0xff;\n    int x3 = buf[bufLen / 2] & 0xff;\n    buf[((x0 << 16) + (x1 << 8) + x2) % bufLen] ^= x3;\n    buf[((x1 << 16) + (x2 << 8) + x3) % bufLen] ^= i % 256;\n  }\n  assertEquals(0x7a1d67c50ec7e167L, h);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "the",
            "java",
            "port",
            "of",
            "farm",
            "hash",
            "fingerprint",
            "0",
            "provides",
            "the",
            "same",
            "results",
            "on",
            "buffers",
            "up",
            "to",
            "0",
            "bytes",
            "long",
            "as",
            "the",
            "c",
            "reference",
            "implementation"
        ]
    },
    {
        "id": 370,
        "code": "private static long fingerprint(byte[] bytes, int length) {\n  return HASH_FN.hashBytes(bytes, 0, length).asLong();\n}",
        "summary_tokens": [
            "convenience",
            "method",
            "to",
            "compute",
            "a",
            "fingerprint",
            "on",
            "a",
            "subset",
            "of",
            "a",
            "byte",
            "array"
        ]
    },
    {
        "id": 371,
        "code": "public void testMultipleLengths() {\n  int iterations = 800;\n  byte[] buf = new byte[iterations * 4];\n  int bufLen = 0;\n  long h = 0;\n  for (int i = 0; i < iterations; ++i) {\n    h ^= fingerprint(buf, i);\n    h = remix(h);\n    buf[bufLen++] = getChar(h);\n\n    h ^= fingerprint(buf, i * i % bufLen);\n    h = remix(h);\n    buf[bufLen++] = getChar(h);\n\n    h ^= fingerprint(buf, i * i * i % bufLen);\n    h = remix(h);\n    buf[bufLen++] = getChar(h);\n\n    h ^= fingerprint(buf, bufLen);\n    h = remix(h);\n    buf[bufLen++] = getChar(h);\n\n    int x0 = buf[bufLen - 1] & 0xff;\n    int x1 = buf[bufLen - 2] & 0xff;\n    int x2 = buf[bufLen - 3] & 0xff;\n    int x3 = buf[bufLen / 2] & 0xff;\n    buf[((x0 << 16) + (x1 << 8) + x2) % bufLen] ^= x3;\n    buf[((x1 << 16) + (x2 << 8) + x3) % bufLen] ^= i % 256;\n  }\n  assertEquals(0xeaa3b1c985261632L, h);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "the",
            "java",
            "port",
            "of",
            "fingerprint",
            "0",
            "provides",
            "the",
            "same",
            "results",
            "on",
            "buffers",
            "up",
            "to",
            "0",
            "bytes",
            "long",
            "as",
            "the",
            "original",
            "implementation",
            "in",
            "c"
        ]
    },
    {
        "id": 372,
        "code": "static byte[] ascii(String string) {\n  byte[] bytes = new byte[string.length()];\n  for (int i = 0; i < string.length(); i++) {\n    bytes[i] = (byte) string.charAt(i);\n  }\n  return bytes;\n}",
        "summary_tokens": [
            "converts",
            "a",
            "string",
            "which",
            "should",
            "contain",
            "only",
            "ascii",
            "representable",
            "characters",
            "to",
            "a",
            "byte"
        ]
    },
    {
        "id": 373,
        "code": "static void checkNoFunnels(HashFunction function) {\n  Random rand = new Random(0);\n  int keyBits = 32;\n  int hashBits = function.bits();\n\n    \n  for (int i = 0; i < keyBits; i++) {\n    int same = 0x0; \n    int diff = 0x0; \n    int count = 0;\n      \n    int maxCount = (int) (4 * Math.log(2 * keyBits * hashBits) + 1);\n    while (same != 0xffffffff || diff != 0xffffffff) {\n      int key1 = rand.nextInt();\n        \n      int key2 = key1 ^ (1 << i);\n        \n      int hash1 = function.hashInt(key1).asInt();\n      int hash2 = function.hashInt(key2).asInt();\n        \n      same |= ~(hash1 ^ hash2);\n        \n      diff |= (hash1 ^ hash2);\n\n      count++;\n        \n        \n      if (count > maxCount) {\n        Assert.fail(\n            \"input bit(\"\n                + i\n                + \") was found not to affect all \"\n                + hashBits\n                + \" output bits; The unaffected bits are \"\n                + \"as follows: \"\n                + ~(same & diff)\n                + \". This was \"\n                + \"determined after \"\n                + count\n                + \" trials.\");\n      }\n    }\n  }\n}",
        "summary_tokens": [
            "test",
            "that",
            "the",
            "hash",
            "function",
            "contains",
            "no",
            "funnels"
        ]
    },
    {
        "id": 374,
        "code": "static void checkNo2BitCharacteristics(HashFunction function) {\n  Random rand = new Random(0);\n  int keyBits = 32;\n\n    \n  for (int i = 0; i < keyBits; i++) {\n    for (int j = 0; j < keyBits; j++) {\n      if (j <= i) continue;\n      int count = 0;\n      int maxCount = 20; \n      boolean diff = false;\n\n      while (!diff) {\n        int delta = (1 << i) | (1 << j);\n        int key1 = rand.nextInt();\n          \n        int key2 = key1 ^ delta;\n\n          \n        int hash1 = function.hashInt(key1).asInt();\n        int hash2 = function.hashInt(key2).asInt();\n\n          \n          \n        if ((hash1 ^ hash2) != delta) {\n          diff = true;\n          continue;\n        }\n\n          \n          \n          \n        count++;\n        if (count > maxCount) {\n          Assert.fail(\n              \"2-bit delta (\"\n                  + i\n                  + \", \"\n                  + j\n                  + \") is likely a \"\n                  + \"characteristic for this hash. This was \"\n                  + \"determined after \"\n                  + count\n                  + \" trials\");\n        }\n      }\n    }\n  }\n}",
        "summary_tokens": [
            "test",
            "for",
            "0",
            "bit",
            "characteristics"
        ]
    },
    {
        "id": 375,
        "code": "static void check2BitAvalanche(HashFunction function, int trials, double epsilon) {\n  Random rand = new Random(0);\n  int keyBits = 32;\n  int hashBits = function.bits();\n  for (int bit1 = 0; bit1 < keyBits; bit1++) {\n    for (int bit2 = 0; bit2 < keyBits; bit2++) {\n      if (bit2 <= bit1) continue;\n      int delta = (1 << bit1) | (1 << bit2);\n      int[] same = new int[hashBits];\n      int[] diff = new int[hashBits];\n        \n      for (int j = 0; j < trials; j++) {\n        int key1 = rand.nextInt();\n          \n        int key2 = key1 ^ delta;\n          \n        int hash1 = function.hashInt(key1).asInt();\n        int hash2 = function.hashInt(key2).asInt();\n        for (int k = 0; k < hashBits; k++) {\n          if ((hash1 & (1 << k)) == (hash2 & (1 << k))) {\n            same[k] += 1;\n          } else {\n            diff[k] += 1;\n          }\n        }\n      }\n        \n      for (int j = 0; j < hashBits; j++) {\n        double prob = (double) diff[j] / (double) (diff[j] + same[j]);\n        Assert.assertEquals(0.50d, prob, epsilon);\n      }\n    }\n  }\n}",
        "summary_tokens": [
            "test",
            "for",
            "avalanche",
            "with",
            "0",
            "bit",
            "deltas"
        ]
    },
    {
        "id": 376,
        "code": "static void assertInvariants(HashFunction hashFunction) {\n  int objects = 100;\n  Set<HashCode> hashcodes = Sets.newHashSetWithExpectedSize(objects);\n  Random random = new Random(314159);\n  for (int i = 0; i < objects; i++) {\n    int value = random.nextInt();\n    HashCode hashcode1 = hashFunction.hashInt(value);\n    HashCode hashcode2 = hashFunction.hashInt(value);\n    Assert.assertEquals(hashcode1, hashcode2); \n    Assert.assertEquals(hashFunction.bits(), hashcode1.bits());\n    Assert.assertEquals(hashFunction.bits(), hashcode1.asBytes().length * 8);\n    hashcodes.add(hashcode1);\n  }\n  Assert.assertTrue(hashcodes.size() > objects * 0.95); \n\n  assertHashBytesThrowsCorrectExceptions(hashFunction);\n  assertIndependentHashers(hashFunction);\n  assertShortcutsAreEquivalent(hashFunction, 512);\n}",
        "summary_tokens": [
            "checks",
            "that",
            "a",
            "hasher",
            "returns",
            "the",
            "same",
            "hash",
            "code",
            "when",
            "given",
            "the",
            "same",
            "input",
            "and",
            "also",
            "that",
            "the",
            "collision",
            "rate",
            "looks",
            "sane"
        ]
    },
    {
        "id": 377,
        "code": "private static void assertHashStringWithSurrogatesEquivalence(\n    HashFunction hashFunction, Random random) {\n  int size = random.nextInt(8) + 1;\n  char[] chars = new char[size];\n  for (int i = 0; i < chars.length; i++) {\n    chars[i] = random.nextBoolean() ? randomLowSurrogate(random) : randomHighSurrogate(random);\n  }\n  String string = new String(chars);\n  assertEquals(\n      hashFunction.hashUnencodedChars(string),\n      hashFunction.newHasher().putUnencodedChars(string).hash());\n}",
        "summary_tokens": [
            "this",
            "verifies",
            "that",
            "put",
            "unencoded",
            "chars",
            "string",
            "and",
            "hash",
            "unencoded",
            "chars",
            "string",
            "are",
            "equivalent",
            "even",
            "for",
            "funny",
            "strings",
            "composed",
            "by",
            "possibly",
            "unmatched",
            "and",
            "mostly",
            "illegal",
            "surrogate",
            "characters"
        ]
    },
    {
        "id": 378,
        "code": "public void testConsistentHash_linearCongruentialGeneratorCompatibility() {\n  int[] golden100 = {\n    0, 55, 62, 8, 45, 59, 86, 97, 82, 59,\n    73, 37, 17, 56, 86, 21, 90, 37, 38, 83\n  };\n  for (int i = 0; i < golden100.length; i++) {\n    assertEquals(golden100[i], Hashing.consistentHash(i, 100));\n  }\n  assertEquals(6, Hashing.consistentHash(10863919174838991L, 11));\n  assertEquals(3, Hashing.consistentHash(2016238256797177309L, 11));\n  assertEquals(5, Hashing.consistentHash(1673758223894951030L, 11));\n  assertEquals(80343, Hashing.consistentHash(2, 100001));\n  assertEquals(22152, Hashing.consistentHash(2201, 100001));\n  assertEquals(15018, Hashing.consistentHash(2202, 100001));\n}",
        "summary_tokens": [
            "check",
            "a",
            "few",
            "golden",
            "values",
            "to",
            "see",
            "that",
            "implementations",
            "across",
            "languages",
            "are",
            "equivalent"
        ]
    },
    {
        "id": 379,
        "code": "public void testGoodFastHashEquals() throws Exception {\n  HashFunction hashFunction1a = Hashing.goodFastHash(1);\n  HashFunction hashFunction1b = Hashing.goodFastHash(32);\n  HashFunction hashFunction2a = Hashing.goodFastHash(33);\n  HashFunction hashFunction2b = Hashing.goodFastHash(128);\n  HashFunction hashFunction3a = Hashing.goodFastHash(129);\n  HashFunction hashFunction3b = Hashing.goodFastHash(256);\n  HashFunction hashFunction4a = Hashing.goodFastHash(257);\n  HashFunction hashFunction4b = Hashing.goodFastHash(384);\n\n  new EqualsTester()\n      .addEqualityGroup(hashFunction1a, hashFunction1b)\n      .addEqualityGroup(hashFunction2a, hashFunction2b)\n      .addEqualityGroup(hashFunction3a, hashFunction3b)\n      .addEqualityGroup(hashFunction4a, hashFunction4b)\n      .testEquals();\n\n  assertEquals(hashFunction1a.toString(), hashFunction1b.toString());\n  assertEquals(hashFunction2a.toString(), hashFunction2b.toString());\n  assertEquals(hashFunction3a.toString(), hashFunction3b.toString());\n  assertEquals(hashFunction4a.toString(), hashFunction4b.toString());\n}",
        "summary_tokens": [
            "tests",
            "equality",
            "of",
            "hashing",
            "good",
            "fast",
            "hash",
            "instances"
        ]
    },
    {
        "id": 380,
        "code": "private static HashCode toHashCode(long... longs) {\n  ByteBuffer bb = ByteBuffer.wrap(new byte[longs.length * 8]).order(ByteOrder.LITTLE_ENDIAN);\n  for (long x : longs) {\n    bb.putLong(x);\n  }\n  return HashCode.fromBytes(bb.array());\n}",
        "summary_tokens": [
            "returns",
            "a",
            "hash",
            "code",
            "for",
            "a",
            "sequence",
            "of",
            "longs",
            "in",
            "big",
            "endian",
            "order"
        ]
    },
    {
        "id": 381,
        "code": "public void testSlice_appendingAfterSlicing() throws IOException {\n    \n  AppendableByteSource source = new AppendableByteSource(newPreFilledByteArray(5));\n\n    \n  ByteSource slice = source.slice(10, 5);\n\n    \n  InputStream in = slice.openStream();\n\n    \n  source.append(newPreFilledByteArray(5, 10));\n\n    \n    \n    \n    \n  assertEquals(-1, in.read());\n}",
        "summary_tokens": [
            "tests",
            "that",
            "the",
            "default",
            "slice",
            "behavior",
            "is",
            "correct",
            "when",
            "the",
            "source",
            "is",
            "sliced",
            "starting",
            "at",
            "an",
            "offset",
            "that",
            "is",
            "greater",
            "than",
            "the",
            "current",
            "length",
            "of",
            "the",
            "source",
            "a",
            "stream",
            "is",
            "then",
            "opened",
            "to",
            "that",
            "source",
            "and",
            "finally",
            "additional",
            "bytes",
            "are",
            "appended",
            "to",
            "the",
            "source",
            "before",
            "the",
            "stream",
            "is",
            "read"
        ]
    },
    {
        "id": 382,
        "code": "private static void assertCorrectSlice(int input, int offset, long length, int expectRead)\n    throws IOException {\n  checkArgument(expectRead == (int) Math.max(0, Math.min(input, offset + length) - offset));\n\n  byte[] expected = newPreFilledByteArray(offset, expectRead);\n\n  ByteSource source = new TestByteSource(newPreFilledByteArray(input));\n  ByteSource slice = source.slice(offset, length);\n\n  assertArrayEquals(expected, slice.read());\n}",
        "summary_tokens": [
            "input",
            "the",
            "size",
            "of",
            "the",
            "input",
            "source",
            "offset",
            "the",
            "first",
            "argument",
            "to",
            "byte",
            "source",
            "slice",
            "length",
            "the",
            "second",
            "argument",
            "to",
            "byte",
            "source",
            "slice",
            "expect",
            "read",
            "the",
            "number",
            "of",
            "bytes",
            "we",
            "expect",
            "to",
            "read"
        ]
    },
    {
        "id": 383,
        "code": "private static int runSuppressionFailureTest(ByteSource in, ByteSink out) {\n  try {\n    in.copyTo(out);\n    fail();\n  } catch (IOException expected) {\n    return CloserTest.getSuppressed(expected).length;\n  }\n  throw new AssertionError(); \n}",
        "summary_tokens": [
            "the",
            "number",
            "of",
            "exceptions",
            "that",
            "were",
            "suppressed",
            "on",
            "the",
            "expected",
            "thrown",
            "exception"
        ]
    },
    {
        "id": 384,
        "code": "private static void assertReadsCorrectly(CharSequence charSequence) throws IOException {\n  String expected = charSequence.toString();\n\n    \n  CharSequenceReader reader = new CharSequenceReader(charSequence);\n  for (int i = 0; i < expected.length(); i++) {\n    assertEquals(expected.charAt(i), reader.read());\n  }\n  assertFullyRead(reader);\n\n    \n  reader = new CharSequenceReader(charSequence);\n  char[] buf = new char[expected.length()];\n  assertEquals(expected.length() == 0 ? -1 : expected.length(), reader.read(buf));\n  assertEquals(expected, new String(buf));\n  assertFullyRead(reader);\n\n    \n  reader = new CharSequenceReader(charSequence);\n  buf = new char[5];\n  StringBuilder builder = new StringBuilder();\n  int read;\n  while ((read = reader.read(buf, 0, buf.length)) != -1) {\n    builder.append(buf, 0, read);\n  }\n  assertEquals(expected, builder.toString());\n  assertFullyRead(reader);\n\n    \n  reader = new CharSequenceReader(charSequence);\n  CharBuffer buf2 = CharBuffer.allocate(expected.length());\n  assertEquals(expected.length() == 0 ? -1 : expected.length(), reader.read(buf2));\n  Java8Compatibility.flip(buf2);\n  assertEquals(expected, buf2.toString());\n  assertFullyRead(reader);\n\n    \n  reader = new CharSequenceReader(charSequence);\n  buf2 = CharBuffer.allocate(5);\n  builder = new StringBuilder();\n  while (reader.read(buf2) != -1) {\n    Java8Compatibility.flip(buf2);\n    builder.append(buf2);\n    Java8Compatibility.clear(buf2);\n  }\n  assertEquals(expected, builder.toString());\n  assertFullyRead(reader);\n\n    \n  reader = new CharSequenceReader(charSequence);\n  assertEquals(expected.length(), reader.skip(Long.MAX_VALUE));\n  assertFullyRead(reader);\n\n    \n  if (expected.length() > 5) {\n    reader = new CharSequenceReader(charSequence);\n    assertEquals(5, reader.skip(5));\n\n    buf = new char[expected.length() - 5];\n    assertEquals(buf.length, reader.read(buf, 0, buf.length));\n    assertEquals(expected.substring(5), new String(buf));\n    assertFullyRead(reader);\n  }\n}",
        "summary_tokens": [
            "creates",
            "a",
            "char",
            "sequence",
            "reader",
            "wrapping",
            "the",
            "given",
            "char",
            "sequence",
            "and",
            "tests",
            "that",
            "the",
            "reader",
            "produces",
            "the",
            "same",
            "sequence",
            "when",
            "read",
            "using",
            "each",
            "type",
            "of",
            "read",
            "method",
            "it",
            "provides"
        ]
    },
    {
        "id": 385,
        "code": "private static int runSuppressionFailureTest(CharSource in, CharSink out) {\n  try {\n    in.copyTo(out);\n    fail();\n  } catch (IOException expected) {\n    return CloserTest.getSuppressed(expected).length;\n  }\n  throw new AssertionError(); \n}",
        "summary_tokens": [
            "the",
            "number",
            "of",
            "exceptions",
            "that",
            "were",
            "suppressed",
            "on",
            "the",
            "expected",
            "thrown",
            "exception"
        ]
    },
    {
        "id": 386,
        "code": "public void testCopyWithReaderThatDoesNotFillBuffer() throws IOException {\n    \n  String string = Strings.repeat(\"0123456789\", 100);\n  StringBuilder b = new StringBuilder();\n    \n    \n  long copied = CharStreams.copy(newNonBufferFillingReader(new StringReader(string)), b);\n  assertEquals(string, b.toString());\n  assertEquals(string.length(), copied);\n}",
        "summary_tokens": [
            "test",
            "for",
            "guava",
            "issue",
            "0",
            "http",
            "code"
        ]
    },
    {
        "id": 387,
        "code": "private static Reader newNonBufferFillingReader(Reader reader) {\n  return new FilterReader(reader) {\n    @Override\n    public int read(char[] cbuf, int off, int len) throws IOException {\n        \n        \n      if (len <= 0) {\n        fail(\"read called with a len of \" + len);\n      }\n        \n        \n      return in.read(cbuf, off, Math.max(len - 1024, 0));\n    }\n  };\n}",
        "summary_tokens": [
            "returns",
            "a",
            "reader",
            "wrapping",
            "the",
            "given",
            "reader",
            "that",
            "only",
            "reads",
            "half",
            "of",
            "the",
            "maximum",
            "number",
            "of",
            "characters",
            "that",
            "it",
            "could",
            "read",
            "in",
            "read",
            "char",
            "int",
            "int"
        ]
    },
    {
        "id": 388,
        "code": "private static Appendable wrapAsGenericAppendable(final Appendable a) {\n  return new Appendable() {\n\n    @Override\n    public Appendable append(CharSequence csq) throws IOException {\n      a.append(csq);\n      return this;\n    }\n\n    @Override\n    public Appendable append(CharSequence csq, int start, int end) throws IOException {\n      a.append(csq, start, end);\n      return this;\n    }\n\n    @Override\n    public Appendable append(char c) throws IOException {\n      a.append(c);\n      return this;\n    }\n  };\n}",
        "summary_tokens": [
            "wrap",
            "an",
            "appendable",
            "in",
            "an",
            "appendable",
            "to",
            "defeat",
            "any",
            "type",
            "specific",
            "optimizations"
        ]
    },
    {
        "id": 389,
        "code": "private static Readable wrapAsGenericReadable(final Readable a) {\n  return new Readable() {\n    @Override\n    public int read(CharBuffer cb) throws IOException {\n      return a.read(cb);\n    }\n  };\n}",
        "summary_tokens": [
            "wrap",
            "a",
            "readable",
            "in",
            "a",
            "readable",
            "to",
            "defeat",
            "any",
            "type",
            "specific",
            "optimizations"
        ]
    },
    {
        "id": 390,
        "code": "private void assertSuppressed(Suppression... expected) {\n  assertEquals(ImmutableList.copyOf(expected), suppressor.suppressions);\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "an",
            "exception",
            "was",
            "thrown",
            "when",
            "trying",
            "to",
            "close",
            "each",
            "of",
            "the",
            "given",
            "throwables",
            "and",
            "that",
            "each",
            "such",
            "exception",
            "was",
            "suppressed",
            "because",
            "of",
            "the",
            "given",
            "thrown",
            "exception"
        ]
    },
    {
        "id": 391,
        "code": "private static File root() {\n  return File.listRoots()[0];\n}",
        "summary_tokens": [
            "returns",
            "a",
            "root",
            "path",
            "for",
            "the",
            "file",
            "system"
        ]
    },
    {
        "id": 392,
        "code": "private static File file(File first, String... more) {\n    \n  File file = first;\n  for (String name : more) {\n    file = new File(file, name);\n  }\n  return file;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "file",
            "object",
            "for",
            "the",
            "given",
            "path",
            "parts"
        ]
    },
    {
        "id": 393,
        "code": "protected final File getTestFile(String name) throws IOException {\n  File file = new File(getTestDir(), name);\n  if (!file.exists()) {\n    URL resourceUrl = IoTestCase.class.getResource(\"testdata/\" + name);\n    if (resourceUrl == null) {\n      return null;\n    }\n    copy(resourceUrl, file);\n  }\n\n  return file;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "file",
            "with",
            "the",
            "given",
            "name",
            "under",
            "the",
            "testdata",
            "directory"
        ]
    },
    {
        "id": 394,
        "code": "protected final File createTempDir() throws IOException {\n  File tempFile = File.createTempFile(\"IoTestCase\", \"\");\n  if (!tempFile.delete() || !tempFile.mkdir()) {\n    throw new IOException(\"failed to create temp dir\");\n  }\n  filesToDelete.add(tempFile);\n  return tempFile;\n}",
        "summary_tokens": [
            "creates",
            "a",
            "new",
            "temp",
            "dir",
            "for",
            "testing"
        ]
    },
    {
        "id": 395,
        "code": "protected final File getTempDir() throws IOException {\n  if (tempDir == null) {\n    tempDir = createTempDir();\n  }\n\n  return tempDir;\n}",
        "summary_tokens": [
            "gets",
            "a",
            "temp",
            "dir",
            "for",
            "testing"
        ]
    },
    {
        "id": 396,
        "code": "protected final File createTempFile() throws IOException {\n  return File.createTempFile(\"test\", null, getTempDir());\n}",
        "summary_tokens": [
            "creates",
            "a",
            "new",
            "temp",
            "file",
            "in",
            "the",
            "temp",
            "directory",
            "returned",
            "by",
            "get",
            "temp",
            "dir"
        ]
    },
    {
        "id": 397,
        "code": "static byte[] newPreFilledByteArray(int offset, int size) {\n  byte[] array = new byte[size];\n  for (int i = 0; i < size; i++) {\n    array[i] = (byte) (offset + i);\n  }\n  return array;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "byte",
            "array",
            "of",
            "length",
            "size",
            "that",
            "has",
            "values",
            "offset"
        ]
    },
    {
        "id": 398,
        "code": "private static void assertMean(int x, int y) {\n  int expectedMean = computeMeanSafely(x, y);\n  assertEquals(expectedMean, IntMath.mean(x, y));\n  assertEquals(\n      \"The mean of x and y should equal the mean of y and x\", expectedMean, IntMath.mean(y, x));\n}",
        "summary_tokens": [
            "helper",
            "method",
            "that",
            "asserts",
            "the",
            "arithmetic",
            "mean",
            "of",
            "x",
            "and",
            "y",
            "is",
            "equal",
            "to",
            "the",
            "result",
            "of",
            "compute",
            "mean",
            "safely"
        ]
    },
    {
        "id": 399,
        "code": "private static int computeMeanSafely(int x, int y) {\n  BigInteger bigX = BigInteger.valueOf(x);\n  BigInteger bigY = BigInteger.valueOf(y);\n  BigDecimal bigMean =\n      new BigDecimal(bigX.add(bigY)).divide(BigDecimal.valueOf(2), BigDecimal.ROUND_FLOOR);\n    \n  return Integer.parseInt(bigMean.toString());\n}",
        "summary_tokens": [
            "computes",
            "the",
            "mean",
            "in",
            "a",
            "way",
            "that",
            "is",
            "obvious",
            "and",
            "resilient",
            "to",
            "overflow",
            "by",
            "using",
            "big",
            "integer",
            "arithmetic"
        ]
    },
    {
        "id": 400,
        "code": "private static void assertMean(long x, long y) {\n  long expectedMean = computeMeanSafely(x, y);\n  assertEquals(expectedMean, LongMath.mean(x, y));\n  assertEquals(\n      \"The mean of x and y should equal the mean of y and x\", expectedMean, LongMath.mean(y, x));\n}",
        "summary_tokens": [
            "helper",
            "method",
            "that",
            "asserts",
            "the",
            "arithmetic",
            "mean",
            "of",
            "x",
            "and",
            "y",
            "is",
            "equal",
            "to",
            "the",
            "result",
            "of",
            "compute",
            "mean",
            "safely"
        ]
    },
    {
        "id": 401,
        "code": "private static long computeMeanSafely(long x, long y) {\n  BigInteger bigX = BigInteger.valueOf(x);\n  BigInteger bigY = BigInteger.valueOf(y);\n  BigDecimal bigMean =\n      new BigDecimal(bigX.add(bigY)).divide(BigDecimal.valueOf(2), BigDecimal.ROUND_FLOOR);\n    \n  return Long.parseLong(bigMean.toString());\n}",
        "summary_tokens": [
            "computes",
            "the",
            "mean",
            "in",
            "a",
            "way",
            "that",
            "is",
            "obvious",
            "and",
            "resilient",
            "to",
            "overflow",
            "by",
            "using",
            "big",
            "integer",
            "arithmetic"
        ]
    },
    {
        "id": 402,
        "code": "static BigInteger randomPositiveBigInteger(int numBits) {\n  BigInteger result;\n  do {\n    result = randomNonNegativeBigInteger(numBits);\n  } while (result.signum() == 0);\n  return result;\n}",
        "summary_tokens": [
            "generates",
            "values",
            "in",
            "a",
            "distribution",
            "equivalent",
            "to",
            "random",
            "non",
            "negative",
            "big",
            "integer",
            "but",
            "omitting",
            "zero"
        ]
    },
    {
        "id": 403,
        "code": "static BigInteger randomNonNegativeBigInteger(int numBits) {\n  int digits = RANDOM_SOURCE.nextInt(numBits);\n  if (digits == 0) {\n    return new BigInteger(1, RANDOM_SOURCE);\n  } else {\n    return new BigInteger(digits, RANDOM_SOURCE).setBit(digits);\n  }\n}",
        "summary_tokens": [
            "generates",
            "a",
            "number",
            "in",
            "0",
            "0",
            "num",
            "bits",
            "with",
            "an",
            "exponential",
            "distribution"
        ]
    },
    {
        "id": 404,
        "code": "static BigInteger randomNonZeroBigInteger(int numBits) {\n  BigInteger result = randomPositiveBigInteger(numBits);\n  return RANDOM_SOURCE.nextBoolean() ? result : result.negate();\n}",
        "summary_tokens": [
            "equivalent",
            "to",
            "calling",
            "random",
            "positive",
            "big",
            "integer",
            "num",
            "bits",
            "and",
            "then",
            "flipping",
            "the",
            "sign",
            "with",
            "0",
            "probability"
        ]
    },
    {
        "id": 405,
        "code": "static BigInteger randomBigInteger(int numBits) {\n  while (true) {\n    if (RANDOM_SOURCE.nextBoolean()) {\n      return randomNonNegativeBigInteger(numBits);\n    }\n    BigInteger neg = randomNonNegativeBigInteger(numBits).negate();\n    if (neg.signum() != 0) {\n      return neg;\n    }\n  }\n}",
        "summary_tokens": [
            "chooses",
            "a",
            "number",
            "in",
            "0",
            "num",
            "bits",
            "0",
            "num",
            "bits",
            "at",
            "random",
            "with",
            "density",
            "concentrated",
            "in",
            "numbers",
            "of",
            "lower",
            "magnitude"
        ]
    },
    {
        "id": 406,
        "code": "static double randomDouble(int maxExponent) {\n  double result = RANDOM_SOURCE.nextDouble();\n  result = Math.scalb(result, RANDOM_SOURCE.nextInt(maxExponent + 1));\n  return RANDOM_SOURCE.nextBoolean() ? result : -result;\n}",
        "summary_tokens": [
            "generates",
            "a",
            "number",
            "in",
            "0",
            "0",
            "num",
            "bits",
            "with",
            "an",
            "exponential",
            "distribution"
        ]
    },
    {
        "id": 407,
        "code": "static int randomExponent() {\n  return RANDOM_SOURCE.nextInt(MAX_EXPONENT + 1);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "random",
            "integer",
            "between",
            "zero",
            "and",
            "max",
            "exponent"
        ]
    },
    {
        "id": 408,
        "code": "static void assertDiagonalLinearTransformation(\n    LinearTransformation transformation, double x1, double y1, double xDelta, double yDelta) {\n  checkArgument(xDelta != 0.0);\n  checkArgument(yDelta != 0.0);\n  assertThat(transformation.isHorizontal()).isFalse();\n  assertThat(transformation.isVertical()).isFalse();\n  assertThat(transformation.inverse().isHorizontal()).isFalse();\n  assertThat(transformation.inverse().isVertical()).isFalse();\n  assertThat(transformation.transform(x1)).isWithin(ALLOWED_ERROR).of(y1);\n  assertThat(transformation.transform(x1 + xDelta)).isWithin(ALLOWED_ERROR).of(y1 + yDelta);\n  assertThat(transformation.inverse().transform(y1)).isWithin(ALLOWED_ERROR).of(x1);\n  assertThat(transformation.inverse().transform(y1 + yDelta))\n      .isWithin(ALLOWED_ERROR)\n      .of(x1 + xDelta);\n  assertThat(transformation.slope()).isWithin(ALLOWED_ERROR).of(yDelta / xDelta);\n  assertThat(transformation.inverse().slope()).isWithin(ALLOWED_ERROR).of(xDelta / yDelta);\n  assertThat(transformation.inverse()).isSameInstanceAs(transformation.inverse());\n  assertThat(transformation.inverse().inverse()).isSameInstanceAs(transformation);\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "transformation",
            "is",
            "diagonal",
            "i"
        ]
    },
    {
        "id": 409,
        "code": "static void assertHorizontalLinearTransformation(LinearTransformation transformation, double y) {\n  assertThat(transformation.isHorizontal()).isTrue();\n  assertThat(transformation.isVertical()).isFalse();\n  assertThat(transformation.inverse().isHorizontal()).isFalse();\n  assertThat(transformation.inverse().isVertical()).isTrue();\n  assertThat(transformation.transform(-1.0)).isWithin(ALLOWED_ERROR).of(y);\n  assertThat(transformation.transform(1.0)).isWithin(ALLOWED_ERROR).of(y);\n  try {\n    transformation.inverse().transform(0.0);\n    fail(\"Expected IllegalStateException\");\n  } catch (IllegalStateException expected) {\n  }\n  assertThat(transformation.slope()).isWithin(ALLOWED_ERROR).of(0.0);\n  try {\n    transformation.inverse().slope();\n    fail(\"Expected IllegalStateException\");\n  } catch (IllegalStateException expected) {\n  }\n  assertThat(transformation.inverse()).isSameInstanceAs(transformation.inverse());\n  assertThat(transformation.inverse().inverse()).isSameInstanceAs(transformation);\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "transformation",
            "is",
            "horizontal",
            "with",
            "the",
            "given",
            "value",
            "of",
            "y"
        ]
    },
    {
        "id": 410,
        "code": "static void assertVerticalLinearTransformation(LinearTransformation transformation, double x) {\n  assertThat(transformation.isHorizontal()).isFalse();\n  assertThat(transformation.isVertical()).isTrue();\n  assertThat(transformation.inverse().isHorizontal()).isTrue();\n  assertThat(transformation.inverse().isVertical()).isFalse();\n  try {\n    transformation.transform(0.0);\n    fail(\"Expected IllegalStateException\");\n  } catch (IllegalStateException expected) {\n  }\n  assertThat(transformation.inverse().transform(-1.0)).isWithin(ALLOWED_ERROR).of(x);\n  assertThat(transformation.inverse().transform(1.0)).isWithin(ALLOWED_ERROR).of(x);\n  try {\n    transformation.slope();\n    fail(\"Expected IllegalStateException\");\n  } catch (IllegalStateException expected) {\n  }\n  assertThat(transformation.inverse().slope()).isWithin(ALLOWED_ERROR).of(0.0);\n  assertThat(transformation.inverse()).isSameInstanceAs(transformation.inverse());\n  assertThat(transformation.inverse().inverse()).isSameInstanceAs(transformation);\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "transformation",
            "is",
            "vertical",
            "with",
            "the",
            "given",
            "value",
            "of",
            "x"
        ]
    },
    {
        "id": 411,
        "code": "static void assertLinearTransformationNaN(LinearTransformation transformation) {\n  assertThat(transformation.isHorizontal()).isFalse();\n  assertThat(transformation.isVertical()).isFalse();\n  assertThat(transformation.slope()).isNaN();\n  assertThat(transformation.transform(0.0)).isNaN();\n  assertThat(transformation.inverse()).isSameInstanceAs(transformation);\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "transformation",
            "behaves",
            "as",
            "expected",
            "for",
            "linear",
            "transformation",
            "for",
            "na",
            "n"
        ]
    },
    {
        "id": 412,
        "code": "static PairedStats createPairedStatsOf(List<Double> xValues, List<Double> yValues) {\n  return createFilledPairedStatsAccumulator(xValues, yValues).snapshot();\n}",
        "summary_tokens": [
            "creates",
            "a",
            "paired",
            "stats",
            "from",
            "with",
            "the",
            "given",
            "lists",
            "of",
            "x",
            "and",
            "y",
            "values",
            "which",
            "must",
            "be",
            "of",
            "the",
            "same",
            "size"
        ]
    },
    {
        "id": 413,
        "code": "static PairedStatsAccumulator createFilledPairedStatsAccumulator(\n    List<Double> xValues, List<Double> yValues) {\n  checkArgument(xValues.size() == yValues.size());\n  PairedStatsAccumulator accumulator = new PairedStatsAccumulator();\n  for (int index = 0; index < xValues.size(); index++) {\n    accumulator.add(xValues.get(index), yValues.get(index));\n  }\n  return accumulator;\n}",
        "summary_tokens": [
            "creates",
            "a",
            "paired",
            "stats",
            "accumulator",
            "filled",
            "with",
            "the",
            "given",
            "lists",
            "of",
            "x",
            "and",
            "y",
            "values",
            "which",
            "must",
            "be",
            "of",
            "the",
            "same",
            "size"
        ]
    },
    {
        "id": 414,
        "code": "static PairedStatsAccumulator createPartitionedFilledPairedStatsAccumulator(\n    List<Double> xValues, List<Double> yValues, int partitionSize) {\n  checkArgument(xValues.size() == yValues.size());\n  checkArgument(partitionSize > 0);\n  PairedStatsAccumulator accumulator = new PairedStatsAccumulator();\n  List<List<Double>> xPartitions = Lists.partition(xValues, partitionSize);\n  List<List<Double>> yPartitions = Lists.partition(yValues, partitionSize);\n  for (int index = 0; index < xPartitions.size(); index++) {\n    accumulator.addAll(createPairedStatsOf(xPartitions.get(index), yPartitions.get(index)));\n  }\n  return accumulator;\n}",
        "summary_tokens": [
            "creates",
            "a",
            "paired",
            "stats",
            "accumulator",
            "filled",
            "with",
            "the",
            "given",
            "lists",
            "of",
            "x",
            "and",
            "y",
            "values",
            "which",
            "must",
            "be",
            "of",
            "the",
            "same",
            "size",
            "added",
            "in",
            "groups",
            "of",
            "partition",
            "size",
            "using",
            "paired",
            "stats",
            "accumulator",
            "add",
            "all",
            "paired",
            "stats"
        ]
    },
    {
        "id": 415,
        "code": "private static void checkBigIntegerConversion(String ip, BigInteger bigIntegerIp) {\n  InetAddress address = InetAddresses.forString(ip);\n  boolean isIpv6 = address instanceof Inet6Address;\n  assertEquals(bigIntegerIp, InetAddresses.toBigInteger(address));\n  assertEquals(\n      address,\n      isIpv6\n          ? InetAddresses.fromIPv6BigInteger(bigIntegerIp)\n          : InetAddresses.fromIPv4BigInteger(bigIntegerIp));\n}",
        "summary_tokens": [
            "checks",
            "that",
            "the",
            "ip",
            "converts",
            "to",
            "the",
            "big",
            "integer",
            "and",
            "the",
            "big",
            "integer",
            "converts",
            "to",
            "the",
            "ip"
        ]
    },
    {
        "id": 416,
        "code": "public void testSimpleEscaper() {\n  UnicodeEscaper e = new PercentEscaper(\"\", false);\n  for (char c = 0; c < 128; c++) {\n    if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {\n      assertUnescaped(e, c);\n    } else {\n      assertEscaping(e, escapeAscii(c), c);\n    }\n  }\n\n    \n  assertEscaping(e, \"%00\", '\\u0000'); \n  assertEscaping(e, \"%7F\", '\\u007f'); \n  assertEscaping(e, \"%C2%80\", '\\u0080'); \n  assertEscaping(e, \"%DF%BF\", '\\u07ff'); \n  assertEscaping(e, \"%E0%A0%80\", '\\u0800'); \n  assertEscaping(e, \"%EF%BF%BF\", '\\uffff'); \n  assertUnicodeEscaping(e, \"%F0%90%80%80\", '\\uD800', '\\uDC00');\n  assertUnicodeEscaping(e, \"%F4%8F%BF%BF\", '\\uDBFF', '\\uDFFF');\n\n    \n  assertEquals(\"\", e.escape(\"\"));\n  assertEquals(\"safestring\", e.escape(\"safestring\"));\n  assertEquals(\"embedded%00null\", e.escape(\"embedded\\0null\"));\n  assertEquals(\"max%EF%BF%BFchar\", e.escape(\"max\\uffffchar\"));\n}",
        "summary_tokens": [
            "tests",
            "that",
            "the",
            "simple",
            "escaper",
            "treats",
            "0",
            "0",
            "a",
            "z",
            "and",
            "a",
            "z",
            "as",
            "safe"
        ]
    },
    {
        "id": 417,
        "code": "public void testPlusForSpace() {\n  UnicodeEscaper basicEscaper = new PercentEscaper(\"\", false);\n  UnicodeEscaper plusForSpaceEscaper = new PercentEscaper(\"\", true);\n  UnicodeEscaper spaceEscaper = new PercentEscaper(\" \", false);\n\n  assertEquals(\"string%20with%20spaces\", basicEscaper.escape(\"string with spaces\"));\n  assertEquals(\"string+with+spaces\", plusForSpaceEscaper.escape(\"string with spaces\"));\n  assertEquals(\"string with spaces\", spaceEscaper.escape(\"string with spaces\"));\n}",
        "summary_tokens": [
            "tests",
            "the",
            "various",
            "ways",
            "that",
            "the",
            "space",
            "character",
            "can",
            "be",
            "handled"
        ]
    },
    {
        "id": 418,
        "code": "public void testCustomEscaper() {\n  UnicodeEscaper e = new PercentEscaper(\"+*/-\", false);\n  for (char c = 0; c < 128; c++) {\n    if ((c >= '0' && c <= '9')\n        || (c >= 'a' && c <= 'z')\n        || (c >= 'A' && c <= 'Z')\n        || \"+*/-\".indexOf(c) >= 0) {\n      assertUnescaped(e, c);\n    } else {\n      assertEscaping(e, escapeAscii(c), c);\n    }\n  }\n}",
        "summary_tokens": [
            "tests",
            "that",
            "if",
            "we",
            "add",
            "extra",
            "safe",
            "characters",
            "they",
            "remain",
            "unescaped"
        ]
    },
    {
        "id": 419,
        "code": "public void testCustomEscaper_withpercent() {\n  UnicodeEscaper e = new PercentEscaper(\"%\", false);\n  assertEquals(\"foo%7Cbar\", e.escape(\"foo|bar\"));\n  assertEquals(\"foo%7Cbar\", e.escape(\"foo%7Cbar\")); \n}",
        "summary_tokens": [
            "tests",
            "that",
            "if",
            "specify",
            "as",
            "safe",
            "the",
            "result",
            "is",
            "an",
            "idempotent",
            "escaper"
        ]
    },
    {
        "id": 420,
        "code": "public void testBadArguments_null() {\n  try {\n    new PercentEscaper(null, false);\n    fail(\"Expected null pointer exception for null parameter\");\n  } catch (NullPointerException expected) {\n      \n  }\n}",
        "summary_tokens": [
            "test",
            "that",
            "giving",
            "a",
            "null",
            "safe",
            "chars",
            "string",
            "causes",
            "a",
            "null",
            "pointer",
            "exception"
        ]
    },
    {
        "id": 421,
        "code": "public void testBadArguments_badchars() {\n  String msg =\n      \"Alphanumeric characters are always 'safe' \" + \"and should not be explicitly specified\";\n  try {\n    new PercentEscaper(\"-+#abc.!\", false);\n    fail(msg);\n  } catch (IllegalArgumentException expected) {\n    assertThat(expected).hasMessageThat().isEqualTo(msg);\n  }\n}",
        "summary_tokens": [
            "tests",
            "that",
            "specifying",
            "any",
            "alphanumeric",
            "characters",
            "as",
            "safe",
            "causes",
            "an",
            "illegal",
            "argument",
            "exception"
        ]
    },
    {
        "id": 422,
        "code": "public void testBadArguments_plusforspace() {\n  try {\n    new PercentEscaper(\" \", false);\n  } catch (IllegalArgumentException e) {\n    fail(\"Space can be a 'safe' character if plusForSpace is false\");\n  }\n  String msg = \"plusForSpace cannot be specified when space is a 'safe' character\";\n  try {\n    new PercentEscaper(\" \", true);\n    fail(msg);\n  } catch (IllegalArgumentException expected) {\n    assertThat(expected).hasMessageThat().isEqualTo(msg);\n  }\n}",
        "summary_tokens": [
            "tests",
            "that",
            "if",
            "space",
            "is",
            "a",
            "safe",
            "character",
            "you",
            "cannot",
            "also",
            "specify",
            "plus",
            "for",
            "space",
            "throws",
            "illegal",
            "argument",
            "exception"
        ]
    },
    {
        "id": 423,
        "code": "private String escapeAscii(char c) {\n  Preconditions.checkArgument(c < 128);\n  String hex = \"0123456789ABCDEF\";\n  return \"%\" + hex.charAt((c >> 4) & 0xf) + hex.charAt(c & 0xf);\n}",
        "summary_tokens": [
            "helper",
            "to",
            "manually",
            "escape",
            "a",
            "0",
            "bit",
            "ascii",
            "character"
        ]
    },
    {
        "id": 424,
        "code": "static void assertBasicUrlEscaperExceptPercent(UnicodeEscaper e) {\n    \n  try {\n    e.escape((String) null);\n    fail(\"Escaping null string should throw exception\");\n  } catch (NullPointerException x) {\n      \n  }\n\n    \n  assertUnescaped(e, 'a');\n  assertUnescaped(e, 'z');\n  assertUnescaped(e, 'A');\n  assertUnescaped(e, 'Z');\n  assertUnescaped(e, '0');\n  assertUnescaped(e, '9');\n\n    \n  assertUnescaped(e, '-');\n  assertUnescaped(e, '_');\n  assertUnescaped(e, '.');\n  assertUnescaped(e, '*');\n\n  assertEscaping(e, \"%00\", '\\u0000'); \n  assertEscaping(e, \"%7F\", '\\u007f'); \n  assertEscaping(e, \"%C2%80\", '\\u0080'); \n  assertEscaping(e, \"%DF%BF\", '\\u07ff'); \n  assertEscaping(e, \"%E0%A0%80\", '\\u0800'); \n  assertEscaping(e, \"%EF%BF%BF\", '\\uffff'); \n  assertUnicodeEscaping(e, \"%F0%90%80%80\", '\\uD800', '\\uDC00');\n  assertUnicodeEscaping(e, \"%F4%8F%BF%BF\", '\\uDBFF', '\\uDFFF');\n\n  assertEquals(\"\", e.escape(\"\"));\n  assertEquals(\"safestring\", e.escape(\"safestring\"));\n  assertEquals(\"embedded%00null\", e.escape(\"embedded\\0null\"));\n  assertEquals(\"max%EF%BF%BFchar\", e.escape(\"max\\uffffchar\"));\n}",
        "summary_tokens": [
            "helper",
            "to",
            "assert",
            "common",
            "expected",
            "behaviour",
            "of",
            "uri",
            "escapers"
        ]
    },
    {
        "id": 425,
        "code": "private static Double referenceTryParse(String input) {\n  if (input.trim().length() < input.length()) {\n    return null;\n  }\n  try {\n    return Double.valueOf(input);\n  } catch (NumberFormatException e) {\n    return null;\n  }\n}",
        "summary_tokens": [
            "a",
            "reference",
            "implementation",
            "for",
            "try",
            "parse",
            "that",
            "just",
            "catches",
            "the",
            "exception",
            "from",
            "double",
            "value",
            "of"
        ]
    },
    {
        "id": 426,
        "code": "private static Float referenceTryParse(String input) {\n  if (input.trim().length() < input.length()) {\n    return null;\n  }\n  try {\n    return Float.valueOf(input);\n  } catch (NumberFormatException e) {\n    return null;\n  }\n}",
        "summary_tokens": [
            "a",
            "reference",
            "implementation",
            "for",
            "try",
            "parse",
            "that",
            "just",
            "catches",
            "the",
            "exception",
            "from",
            "float",
            "value",
            "of"
        ]
    },
    {
        "id": 427,
        "code": "public void testBuilder_bruteForce() {\n  for (int i = 0; i < reduceIterationsIfGwt(100); i++) {\n    ImmutableDoubleArray.Builder builder = ImmutableDoubleArray.builder(RANDOM.nextInt(20));\n    AtomicInteger counter = new AtomicInteger(0);\n    while (counter.get() < 1000) {\n      BuilderOp op = BuilderOp.randomOp();\n      op.doIt(builder, counter);\n    }\n    ImmutableDoubleArray iia = builder.build();\n    for (int j = 0; j < iia.length(); j++) {\n      assertThat(iia.get(j)).isEqualTo((double) j);\n    }\n  }\n}",
        "summary_tokens": [
            "if",
            "there",
            "s",
            "a",
            "bug",
            "in",
            "builder",
            "growth",
            "we",
            "wouldn",
            "t",
            "know",
            "how",
            "to",
            "expose",
            "it"
        ]
    },
    {
        "id": 428,
        "code": "public void testTrimmed() {\n  ImmutableDoubleArray iia = ImmutableDoubleArray.of(0, 1, 3);\n  assertDoesntActuallyTrim(iia);\n  assertDoesntActuallyTrim(iia.subArray(0, 3));\n  assertActuallyTrims(iia.subArray(0, 2));\n  assertActuallyTrims(iia.subArray(1, 3));\n\n  ImmutableDoubleArray rightSized = ImmutableDoubleArray.builder(3).add(0).add(1).add(3).build();\n  assertDoesntActuallyTrim(rightSized);\n\n  ImmutableDoubleArray overSized = ImmutableDoubleArray.builder(3).add(0).add(1).build();\n  assertActuallyTrims(overSized);\n\n  ImmutableDoubleArray underSized = ImmutableDoubleArray.builder(2).add(0).add(1).add(3).build();\n  assertActuallyTrims(underSized);\n}",
        "summary_tokens": [
            "this",
            "is",
            "probably",
            "a",
            "weird",
            "and",
            "hacky",
            "way",
            "to",
            "test",
            "what",
            "we",
            "re",
            "really",
            "trying",
            "to",
            "test",
            "but",
            "hey",
            "it",
            "caught",
            "a",
            "bug"
        ]
    },
    {
        "id": 429,
        "code": "public void testBuilder_bruteForce() {\n  for (int i = 0; i < reduceIterationsIfGwt(100); i++) {\n    ImmutableIntArray.Builder builder = ImmutableIntArray.builder(RANDOM.nextInt(20));\n    AtomicInteger counter = new AtomicInteger(0);\n    while (counter.get() < 1000) {\n      BuilderOp op = BuilderOp.randomOp();\n      op.doIt(builder, counter);\n    }\n    ImmutableIntArray iia = builder.build();\n    for (int j = 0; j < iia.length(); j++) {\n      assertThat(iia.get(j)).isEqualTo(j);\n    }\n  }\n}",
        "summary_tokens": [
            "if",
            "there",
            "s",
            "a",
            "bug",
            "in",
            "builder",
            "growth",
            "we",
            "wouldn",
            "t",
            "know",
            "how",
            "to",
            "expose",
            "it"
        ]
    },
    {
        "id": 430,
        "code": "public void testTrimmed() {\n  ImmutableIntArray iia = ImmutableIntArray.of(0, 1, 3);\n  assertDoesntActuallyTrim(iia);\n  assertDoesntActuallyTrim(iia.subArray(0, 3));\n  assertActuallyTrims(iia.subArray(0, 2));\n  assertActuallyTrims(iia.subArray(1, 3));\n\n  ImmutableIntArray rightSized = ImmutableIntArray.builder(3).add(0).add(1).add(3).build();\n  assertDoesntActuallyTrim(rightSized);\n\n  ImmutableIntArray overSized = ImmutableIntArray.builder(3).add(0).add(1).build();\n  assertActuallyTrims(overSized);\n\n  ImmutableIntArray underSized = ImmutableIntArray.builder(2).add(0).add(1).add(3).build();\n  assertActuallyTrims(underSized);\n}",
        "summary_tokens": [
            "this",
            "is",
            "probably",
            "a",
            "weird",
            "and",
            "hacky",
            "way",
            "to",
            "test",
            "what",
            "we",
            "re",
            "really",
            "trying",
            "to",
            "test",
            "but",
            "hey",
            "it",
            "caught",
            "a",
            "bug"
        ]
    },
    {
        "id": 431,
        "code": "public void testBuilder_bruteForce() {\n  for (int i = 0; i < reduceIterationsIfGwt(100); i++) {\n    ImmutableLongArray.Builder builder = ImmutableLongArray.builder(RANDOM.nextInt(20));\n    AtomicLong counter = new AtomicLong(0);\n    while (counter.get() < 1000) {\n      BuilderOp op = BuilderOp.randomOp();\n      op.doIt(builder, counter);\n    }\n    ImmutableLongArray iia = builder.build();\n    for (int j = 0; j < iia.length(); j++) {\n      assertThat(iia.get(j)).isEqualTo((long) j);\n    }\n  }\n}",
        "summary_tokens": [
            "if",
            "there",
            "s",
            "a",
            "bug",
            "in",
            "builder",
            "growth",
            "we",
            "wouldn",
            "t",
            "know",
            "how",
            "to",
            "expose",
            "it"
        ]
    },
    {
        "id": 432,
        "code": "public void testTrimmed() {\n  ImmutableLongArray iia = ImmutableLongArray.of(0, 1, 3);\n  assertDoesntActuallyTrim(iia);\n  assertDoesntActuallyTrim(iia.subArray(0, 3));\n  assertActuallyTrims(iia.subArray(0, 2));\n  assertActuallyTrims(iia.subArray(1, 3));\n\n  ImmutableLongArray rightSized = ImmutableLongArray.builder(3).add(0).add(1).add(3).build();\n  assertDoesntActuallyTrim(rightSized);\n\n  ImmutableLongArray overSized = ImmutableLongArray.builder(3).add(0).add(1).build();\n  assertActuallyTrims(overSized);\n\n  ImmutableLongArray underSized = ImmutableLongArray.builder(2).add(0).add(1).add(3).build();\n  assertActuallyTrims(underSized);\n}",
        "summary_tokens": [
            "this",
            "is",
            "probably",
            "a",
            "weird",
            "and",
            "hacky",
            "way",
            "to",
            "test",
            "what",
            "we",
            "re",
            "really",
            "trying",
            "to",
            "test",
            "but",
            "hey",
            "it",
            "caught",
            "a",
            "bug"
        ]
    },
    {
        "id": 433,
        "code": "private static void tryParseAndAssertEquals(Integer expected, String value) {\n  assertEquals(expected, Ints.tryParse(value));\n}",
        "summary_tokens": [
            "applies",
            "ints",
            "try",
            "parse",
            "string",
            "to",
            "the",
            "given",
            "string",
            "and",
            "asserts",
            "that",
            "the",
            "result",
            "is",
            "as",
            "expected"
        ]
    },
    {
        "id": 434,
        "code": "private static void radixEncodeParseAndAssertEquals(Integer value, int radix) {\n  assertEquals(\"Radix: \" + radix, value, Ints.tryParse(Integer.toString(value, radix), radix));\n}",
        "summary_tokens": [
            "encodes",
            "the",
            "an",
            "integer",
            "as",
            "a",
            "string",
            "with",
            "given",
            "radix",
            "then",
            "uses",
            "ints",
            "try",
            "parse",
            "string",
            "int",
            "to",
            "parse",
            "the",
            "result"
        ]
    },
    {
        "id": 435,
        "code": "private static void tryParseAndAssertEquals(Long expected, String value) {\n  assertEquals(expected, Longs.tryParse(value));\n}",
        "summary_tokens": [
            "applies",
            "longs",
            "try",
            "parse",
            "string",
            "to",
            "the",
            "given",
            "string",
            "and",
            "asserts",
            "that",
            "the",
            "result",
            "is",
            "as",
            "expected"
        ]
    },
    {
        "id": 436,
        "code": "private static void radixEncodeParseAndAssertEquals(Long value, int radix) {\n  assertEquals(\"Radix: \" + radix, value, Longs.tryParse(Long.toString(value, radix), radix));\n}",
        "summary_tokens": [
            "encodes",
            "the",
            "long",
            "as",
            "a",
            "string",
            "with",
            "given",
            "radix",
            "then",
            "uses",
            "longs",
            "try",
            "parse",
            "string",
            "int",
            "to",
            "parse",
            "the",
            "result"
        ]
    },
    {
        "id": 437,
        "code": "final <T> T isSubtype(T sub) {\n  Type returnType = method.getGenericReturnType();\n  Type paramType = getOnlyParameterType();\n  TestSubtype spec = method.getAnnotation(TestSubtype.class);\n  assertWithMessage(\"%s is subtype of %s\", paramType, returnType)\n      .that(TypeToken.of(paramType).isSubtypeOf(returnType))\n      .isTrue();\n  assertWithMessage(\"%s is supertype of %s\", returnType, paramType)\n      .that(TypeToken.of(returnType).isSupertypeOf(paramType))\n      .isTrue();\n  if (!spec.suppressGetSubtype()) {\n    assertThat(getSubtype(returnType, TypeToken.of(paramType).getRawType())).isEqualTo(paramType);\n  }\n  if (!spec.suppressGetSupertype()) {\n    assertThat(getSupertype(paramType, TypeToken.of(returnType).getRawType()))\n        .isEqualTo(returnType);\n  }\n  return sub;\n}",
        "summary_tokens": [
            "call",
            "this",
            "in",
            "a",
            "test",
            "subtype",
            "public",
            "method",
            "asserting",
            "subtype",
            "relationship"
        ]
    },
    {
        "id": 438,
        "code": "final <X> X notSubtype(@SuppressWarnings(\"unused\") Object sub) {\n  Type returnType = method.getGenericReturnType();\n  Type paramType = getOnlyParameterType();\n  TestSubtype spec = method.getAnnotation(TestSubtype.class);\n  assertWithMessage(\"%s is subtype of %s\", paramType, returnType)\n      .that(TypeToken.of(paramType).isSubtypeOf(returnType))\n      .isFalse();\n  assertWithMessage(\"%s is supertype of %s\", returnType, paramType)\n      .that(TypeToken.of(returnType).isSupertypeOf(paramType))\n      .isFalse();\n  if (!spec.suppressGetSubtype()) {\n    try {\n      assertThat(getSubtype(returnType, TypeToken.of(paramType).getRawType()))\n          .isNotEqualTo(paramType);\n    } catch (IllegalArgumentException notSubtype1) {\n        \n    }\n  }\n  if (!spec.suppressGetSupertype()) {\n    try {\n      assertThat(getSupertype(paramType, TypeToken.of(returnType).getRawType()))\n          .isNotEqualTo(returnType);\n    } catch (IllegalArgumentException notSubtype2) {\n        \n    }\n  }\n  return null;\n}",
        "summary_tokens": [
            "call",
            "this",
            "in",
            "a",
            "test",
            "subtype",
            "public",
            "method",
            "asserting",
            "that",
            "subtype",
            "relationship",
            "does",
            "not",
            "hold"
        ]
    },
    {
        "id": 439,
        "code": "public void testRecursiveWildcardSubtypeBug() throws Exception {\n  try {\n    new RecursiveTypeBoundBugExample<>().testAllDeclarations();\n    fail();\n  } catch (Exception e) {\n    assertThat(e).hasCauseThat().isInstanceOf(AssertionError.class);\n  }\n}",
        "summary_tokens": [
            "this",
            "test",
            "reproduces",
            "the",
            "bug",
            "in",
            "canonicalize",
            "wildcard",
            "type",
            "when",
            "the",
            "type",
            "variable",
            "is",
            "recursively",
            "bounded"
        ]
    },
    {
        "id": 440,
        "code": "public void testNewParameterizedTypeImmutability() {\n  Type[] typesIn = {String.class, Integer.class};\n  ParameterizedType parameterizedType = Types.newParameterizedType(Map.class, typesIn);\n  typesIn[0] = null;\n  typesIn[1] = null;\n\n  Type[] typesOut = parameterizedType.getActualTypeArguments();\n  typesOut[0] = null;\n  typesOut[1] = null;\n\n  assertEquals(String.class, parameterizedType.getActualTypeArguments()[0]);\n  assertEquals(Integer.class, parameterizedType.getActualTypeArguments()[1]);\n}",
        "summary_tokens": [
            "working",
            "with",
            "arrays",
            "requires",
            "defensive",
            "code"
        ]
    },
    {
        "id": 441,
        "code": "public void testToString_delayedTimeout() throws Exception {\n  TimedWaiterThread thread =\n      new TimedWaiterThread(new AbstractFuture<Object>() {}, 2, TimeUnit.SECONDS);\n  thread.start();\n  thread.awaitWaiting();\n  thread.suspend();\n    \n  long toWaitMillis = 3500 - TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - thread.startTime);\n  Thread.sleep(toWaitMillis);\n  thread.setPriority(Thread.MAX_PRIORITY);\n  thread.resume();\n  thread.join();\n    \n    \n    \n    \n    \n  boolean longWait = TimeUnit.NANOSECONDS.toSeconds(thread.timeSpentBlocked) >= 5;\n    \n    \n  char overWaitNanosFirstDigit =\n      Long.toString(\n              thread.timeSpentBlocked - TimeUnit.MILLISECONDS.toNanos(longWait ? 5000 : 3000))\n          .charAt(0);\n  if (overWaitNanosFirstDigit < '4') {\n    overWaitNanosFirstDigit = '9';\n  }\n  String nanosRegex = \"[4-\" + overWaitNanosFirstDigit + \"][0-9]+\";\n  assertWithMessage(\n          \"Spent \" + thread.timeSpentBlocked + \" ns blocked; slept for \" + toWaitMillis + \" ms\")\n      .that(thread.exception)\n      .hasMessageThat()\n      .matches(\n          \"Waited 2 seconds \\\\(plus \"\n              + (longWait ? \"3\" : \"1\")\n              + \" seconds, \"\n              + nanosRegex\n              + \" nanoseconds delay\\\\).*\");\n}",
        "summary_tokens": [
            "this",
            "test",
            "attempts",
            "to",
            "cause",
            "a",
            "future",
            "to",
            "wait",
            "for",
            "longer",
            "than",
            "it",
            "was",
            "requested",
            "to",
            "from",
            "a",
            "timed",
            "get",
            "call"
        ]
    },
    {
        "id": 442,
        "code": "public void testFutureBash() {\n  final CyclicBarrier barrier =\n      new CyclicBarrier(\n          6 \n              + 50 \n              + 50 \n              + 1); \n  final ExecutorService executor = Executors.newFixedThreadPool(barrier.getParties());\n  final AtomicReference<AbstractFuture<String>> currentFuture = Atomics.newReference();\n  final AtomicInteger numSuccessfulSetCalls = new AtomicInteger();\n  Callable<Void> completeSuccessfullyRunnable =\n      new Callable<Void>() {\n        @Override\n        public Void call() {\n          if (currentFuture.get().set(\"set\")) {\n            numSuccessfulSetCalls.incrementAndGet();\n          }\n          awaitUnchecked(barrier);\n          return null;\n        }\n      };\n  Callable<Void> completeExceptionallyRunnable =\n      new Callable<Void>() {\n        Exception failureCause = new Exception(\"setException\");\n\n        @Override\n        public Void call() {\n          if (currentFuture.get().setException(failureCause)) {\n            numSuccessfulSetCalls.incrementAndGet();\n          }\n          awaitUnchecked(barrier);\n          return null;\n        }\n      };\n  Callable<Void> cancelRunnable =\n      new Callable<Void>() {\n        @Override\n        public Void call() {\n          if (currentFuture.get().cancel(true)) {\n            numSuccessfulSetCalls.incrementAndGet();\n          }\n          awaitUnchecked(barrier);\n          return null;\n        }\n      };\n  Callable<Void> setFutureCompleteSuccessfullyRunnable =\n      new Callable<Void>() {\n        ListenableFuture<String> future = Futures.immediateFuture(\"setFuture\");\n\n        @Override\n        public Void call() {\n          if (currentFuture.get().setFuture(future)) {\n            numSuccessfulSetCalls.incrementAndGet();\n          }\n          awaitUnchecked(barrier);\n          return null;\n        }\n      };\n  Callable<Void> setFutureCompleteExceptionallyRunnable =\n      new Callable<Void>() {\n        ListenableFuture<String> future =\n            Futures.immediateFailedFuture(new Exception(\"setFuture\"));\n\n        @Override\n        public Void call() {\n          if (currentFuture.get().setFuture(future)) {\n            numSuccessfulSetCalls.incrementAndGet();\n          }\n          awaitUnchecked(barrier);\n          return null;\n        }\n      };\n  Callable<Void> setFutureCancelRunnable =\n      new Callable<Void>() {\n        ListenableFuture<String> future = Futures.immediateCancelledFuture();\n\n        @Override\n        public Void call() {\n          if (currentFuture.get().setFuture(future)) {\n            numSuccessfulSetCalls.incrementAndGet();\n          }\n          awaitUnchecked(barrier);\n          return null;\n        }\n      };\n  final Set<Object> finalResults = Collections.synchronizedSet(Sets.newIdentityHashSet());\n  Runnable collectResultsRunnable =\n      new Runnable() {\n        @Override\n        public void run() {\n          try {\n            String result = Uninterruptibles.getUninterruptibly(currentFuture.get());\n            finalResults.add(result);\n          } catch (ExecutionException e) {\n            finalResults.add(e.getCause());\n          } catch (CancellationException e) {\n            finalResults.add(CancellationException.class);\n          } finally {\n            awaitUnchecked(barrier);\n          }\n        }\n      };\n  Runnable collectResultsTimedGetRunnable =\n      new Runnable() {\n        @Override\n        public void run() {\n          Future<String> future = currentFuture.get();\n          while (true) {\n            try {\n              String result = Uninterruptibles.getUninterruptibly(future, 0, TimeUnit.SECONDS);\n              finalResults.add(result);\n              break;\n            } catch (ExecutionException e) {\n              finalResults.add(e.getCause());\n              break;\n            } catch (CancellationException e) {\n              finalResults.add(CancellationException.class);\n              break;\n            } catch (TimeoutException e) {\n                \n            }\n          }\n          awaitUnchecked(barrier);\n        }\n      };\n  List<Callable<?>> allTasks = new ArrayList<>();\n  allTasks.add(completeSuccessfullyRunnable);\n  allTasks.add(completeExceptionallyRunnable);\n  allTasks.add(cancelRunnable);\n  allTasks.add(setFutureCompleteSuccessfullyRunnable);\n  allTasks.add(setFutureCompleteExceptionallyRunnable);\n  allTasks.add(setFutureCancelRunnable);\n  for (int k = 0; k < 50; k++) {\n      \n      \n      \n    final Runnable listener =\n        k % 2 == 0 ? collectResultsRunnable : collectResultsTimedGetRunnable;\n    allTasks.add(Executors.callable(listener));\n    allTasks.add(\n        new Callable<Void>() {\n          @Override\n          public Void call() throws Exception {\n            currentFuture.get().addListener(listener, executor);\n            return null;\n          }\n        });\n  }\n  assertEquals(allTasks.size() + 1, barrier.getParties());\n  for (int i = 0; i < 1000; i++) {\n    Collections.shuffle(allTasks);\n    final AbstractFuture<String> future = new AbstractFuture<String>() {};\n    currentFuture.set(future);\n    for (Callable<?> task : allTasks) {\n      @SuppressWarnings(\"unused\") \n      Future<?> possiblyIgnoredError = executor.submit(task);\n    }\n    awaitUnchecked(barrier);\n    assertThat(future.isDone()).isTrue();\n      \n      \n    Object result = Iterables.getOnlyElement(finalResults);\n    if (result == CancellationException.class) {\n      assertTrue(future.isCancelled());\n      if (future.wasInterrupted()) {\n          \n        assertThat(numSuccessfulSetCalls.get()).isIn(Range.closed(1, 2));\n      } else {\n        assertThat(numSuccessfulSetCalls.get()).isEqualTo(1);\n      }\n    } else {\n      assertThat(numSuccessfulSetCalls.get()).isEqualTo(1);\n    }\n      \n    numSuccessfulSetCalls.set(0);\n    finalResults.clear();\n  }\n  executor.shutdown();\n}",
        "summary_tokens": [
            "he",
            "did",
            "the",
            "bash",
            "he",
            "did",
            "the",
            "future",
            "bash",
            "the",
            "future",
            "bash",
            "it",
            "was",
            "a",
            "concurrency",
            "smash",
            "he",
            "did",
            "the",
            "bash",
            "it",
            "caught",
            "on",
            "in",
            "a",
            "flash",
            "he",
            "did",
            "the",
            "bash",
            "he",
            "did",
            "the",
            "future",
            "bash"
        ]
    },
    {
        "id": 443,
        "code": "public void testManualServiceStopMultipleTimesWhileStarting() throws Exception {\n  ManualSwitchedService service = new ManualSwitchedService();\n  final AtomicInteger stoppingCount = new AtomicInteger();\n  service.addListener(\n      new Listener() {\n        @Override\n        public void stopping(State from) {\n          stoppingCount.incrementAndGet();\n        }\n      },\n      directExecutor());\n\n  service.startAsync();\n  service.stopAsync();\n  assertEquals(1, stoppingCount.get());\n  service.stopAsync();\n  assertEquals(1, stoppingCount.get());\n}",
        "summary_tokens": [
            "this",
            "tests",
            "for",
            "a",
            "bug",
            "where",
            "if",
            "service",
            "stop",
            "async",
            "was",
            "called",
            "while",
            "the",
            "service",
            "was",
            "state",
            "starting",
            "more",
            "than",
            "once",
            "the",
            "listener",
            "stopping",
            "state",
            "callback",
            "would",
            "get",
            "called",
            "multiple",
            "times"
        ]
    },
    {
        "id": 444,
        "code": "static boolean bitEquals(double x, double y) {\n  return Double.doubleToRawLongBits(x) == Double.doubleToRawLongBits(y);\n}",
        "summary_tokens": [
            "the",
            "notion",
            "of",
            "equality",
            "used",
            "by",
            "atomic",
            "double",
            "array"
        ]
    },
    {
        "id": 445,
        "code": "public void testConstructor() {\n  AtomicDoubleArray aa = new AtomicDoubleArray(SIZE);\n  for (int i = 0; i < SIZE; i++) {\n    assertBitEquals(0.0, aa.get(i));\n  }\n}",
        "summary_tokens": [
            "constructor",
            "creates",
            "array",
            "of",
            "given",
            "size",
            "with",
            "all",
            "elements",
            "zero"
        ]
    },
    {
        "id": 446,
        "code": "public void testConstructor2NPE() {\n  double[] a = null;\n  try {\n    new AtomicDoubleArray(a);\n    fail();\n  } catch (NullPointerException success) {\n  }\n}",
        "summary_tokens": [
            "constructor",
            "with",
            "null",
            "array",
            "throws",
            "npe"
        ]
    },
    {
        "id": 447,
        "code": "public void testConstructor2() {\n  AtomicDoubleArray aa = new AtomicDoubleArray(VALUES);\n  assertEquals(VALUES.length, aa.length());\n  for (int i = 0; i < VALUES.length; i++) {\n    assertBitEquals(VALUES[i], aa.get(i));\n  }\n}",
        "summary_tokens": [
            "constructor",
            "with",
            "array",
            "is",
            "of",
            "same",
            "size",
            "and",
            "has",
            "all",
            "elements"
        ]
    },
    {
        "id": 448,
        "code": "public void testConstructorEmptyArray() {\n  AtomicDoubleArray aa = new AtomicDoubleArray(new double[0]);\n  assertEquals(0, aa.length());\n  try {\n    aa.get(0);\n    fail();\n  } catch (IndexOutOfBoundsException success) {\n  }\n}",
        "summary_tokens": [
            "constructor",
            "with",
            "empty",
            "array",
            "has",
            "size",
            "0",
            "and",
            "contains",
            "no",
            "elements"
        ]
    },
    {
        "id": 449,
        "code": "public void testConstructorZeroLength() {\n  AtomicDoubleArray aa = new AtomicDoubleArray(0);\n  assertEquals(0, aa.length());\n  try {\n    aa.get(0);\n    fail();\n  } catch (IndexOutOfBoundsException success) {\n  }\n}",
        "summary_tokens": [
            "constructor",
            "with",
            "length",
            "zero",
            "has",
            "size",
            "0",
            "and",
            "contains",
            "no",
            "elements"
        ]
    },
    {
        "id": 450,
        "code": "public void testIndexing() {\n  AtomicDoubleArray aa = new AtomicDoubleArray(SIZE);\n  for (int index : new int[] {-1, SIZE}) {\n    try {\n      aa.get(index);\n      fail();\n    } catch (IndexOutOfBoundsException success) {\n    }\n    try {\n      aa.set(index, 1.0);\n      fail();\n    } catch (IndexOutOfBoundsException success) {\n    }\n    try {\n      aa.lazySet(index, 1.0);\n      fail();\n    } catch (IndexOutOfBoundsException success) {\n    }\n    try {\n      aa.compareAndSet(index, 1.0, 2.0);\n      fail();\n    } catch (IndexOutOfBoundsException success) {\n    }\n    try {\n      aa.weakCompareAndSet(index, 1.0, 2.0);\n      fail();\n    } catch (IndexOutOfBoundsException success) {\n    }\n    try {\n      aa.getAndAdd(index, 1.0);\n      fail();\n    } catch (IndexOutOfBoundsException success) {\n    }\n    try {\n      aa.addAndGet(index, 1.0);\n      fail();\n    } catch (IndexOutOfBoundsException success) {\n    }\n  }\n}",
        "summary_tokens": [
            "get",
            "and",
            "set",
            "for",
            "out",
            "of",
            "bound",
            "indices",
            "throw",
            "index",
            "out",
            "of",
            "bounds",
            "exception"
        ]
    },
    {
        "id": 451,
        "code": "public void testGetSet() {\n  AtomicDoubleArray aa = new AtomicDoubleArray(VALUES.length);\n  for (int i = 0; i < VALUES.length; i++) {\n    assertBitEquals(0.0, aa.get(i));\n    aa.set(i, VALUES[i]);\n    assertBitEquals(VALUES[i], aa.get(i));\n    aa.set(i, -3.0);\n    assertBitEquals(-3.0, aa.get(i));\n  }\n}",
        "summary_tokens": [
            "get",
            "returns",
            "the",
            "last",
            "value",
            "set",
            "at",
            "index"
        ]
    },
    {
        "id": 452,
        "code": "public void testGetLazySet() {\n  AtomicDoubleArray aa = new AtomicDoubleArray(VALUES.length);\n  for (int i = 0; i < VALUES.length; i++) {\n    assertBitEquals(0.0, aa.get(i));\n    aa.lazySet(i, VALUES[i]);\n    assertBitEquals(VALUES[i], aa.get(i));\n    aa.lazySet(i, -3.0);\n    assertBitEquals(-3.0, aa.get(i));\n  }\n}",
        "summary_tokens": [
            "get",
            "returns",
            "the",
            "last",
            "value",
            "lazy",
            "set",
            "at",
            "index",
            "by",
            "same",
            "thread"
        ]
    },
    {
        "id": 453,
        "code": "public void testCompareAndSet() {\n  AtomicDoubleArray aa = new AtomicDoubleArray(SIZE);\n  for (int i : new int[] {0, SIZE - 1}) {\n    double prev = 0.0;\n    double unused = Math.E + Math.PI;\n    for (double x : VALUES) {\n      assertBitEquals(prev, aa.get(i));\n      assertFalse(aa.compareAndSet(i, unused, x));\n      assertBitEquals(prev, aa.get(i));\n      assertTrue(aa.compareAndSet(i, prev, x));\n      assertBitEquals(x, aa.get(i));\n      prev = x;\n    }\n  }\n}",
        "summary_tokens": [
            "compare",
            "and",
            "set",
            "succeeds",
            "in",
            "changing",
            "value",
            "if",
            "equal",
            "to",
            "expected",
            "else",
            "fails"
        ]
    },
    {
        "id": 454,
        "code": "public void testCompareAndSetInMultipleThreads() throws InterruptedException {\n  final AtomicDoubleArray a = new AtomicDoubleArray(1);\n  a.set(0, 1.0);\n  Thread t =\n      newStartedThread(\n          new CheckedRunnable() {\n            @Override\n            public void realRun() {\n              while (!a.compareAndSet(0, 2.0, 3.0)) {\n                Thread.yield();\n              }\n            }\n          });\n\n  assertTrue(a.compareAndSet(0, 1.0, 2.0));\n  awaitTermination(t);\n  assertBitEquals(3.0, a.get(0));\n}",
        "summary_tokens": [
            "compare",
            "and",
            "set",
            "in",
            "one",
            "thread",
            "enables",
            "another",
            "waiting",
            "for",
            "value",
            "to",
            "succeed"
        ]
    },
    {
        "id": 455,
        "code": "public void testWeakCompareAndSet() {\n  AtomicDoubleArray aa = new AtomicDoubleArray(SIZE);\n  for (int i : new int[] {0, SIZE - 1}) {\n    double prev = 0.0;\n    double unused = Math.E + Math.PI;\n    for (double x : VALUES) {\n      assertBitEquals(prev, aa.get(i));\n      assertFalse(aa.weakCompareAndSet(i, unused, x));\n      assertBitEquals(prev, aa.get(i));\n      while (!aa.weakCompareAndSet(i, prev, x)) {\n        ;\n      }\n      assertBitEquals(x, aa.get(i));\n      prev = x;\n    }\n  }\n}",
        "summary_tokens": [
            "repeated",
            "weak",
            "compare",
            "and",
            "set",
            "succeeds",
            "in",
            "changing",
            "value",
            "when",
            "equal",
            "to",
            "expected"
        ]
    },
    {
        "id": 456,
        "code": "public void testGetAndSet() {\n  AtomicDoubleArray aa = new AtomicDoubleArray(SIZE);\n  for (int i : new int[] {0, SIZE - 1}) {\n    double prev = 0.0;\n    for (double x : VALUES) {\n      assertBitEquals(prev, aa.getAndSet(i, x));\n      prev = x;\n    }\n  }\n}",
        "summary_tokens": [
            "get",
            "and",
            "set",
            "returns",
            "previous",
            "value",
            "and",
            "sets",
            "to",
            "given",
            "value",
            "at",
            "given",
            "index"
        ]
    },
    {
        "id": 457,
        "code": "public void testGetAndAdd() {\n  AtomicDoubleArray aa = new AtomicDoubleArray(SIZE);\n  for (int i : new int[] {0, SIZE - 1}) {\n    for (double x : VALUES) {\n      for (double y : VALUES) {\n        aa.set(i, x);\n        double z = aa.getAndAdd(i, y);\n        assertBitEquals(x, z);\n        assertBitEquals(x + y, aa.get(i));\n      }\n    }\n  }\n}",
        "summary_tokens": [
            "get",
            "and",
            "add",
            "returns",
            "previous",
            "value",
            "and",
            "adds",
            "given",
            "value"
        ]
    },
    {
        "id": 458,
        "code": "public void testAddAndGet() {\n  AtomicDoubleArray aa = new AtomicDoubleArray(SIZE);\n  for (int i : new int[] {0, SIZE - 1}) {\n    for (double x : VALUES) {\n      for (double y : VALUES) {\n        aa.set(i, x);\n        double z = aa.addAndGet(i, y);\n        assertBitEquals(x + y, z);\n        assertBitEquals(x + y, aa.get(i));\n      }\n    }\n  }\n}",
        "summary_tokens": [
            "add",
            "and",
            "get",
            "adds",
            "given",
            "value",
            "to",
            "current",
            "and",
            "returns",
            "current",
            "value"
        ]
    },
    {
        "id": 459,
        "code": "public void testCountingInMultipleThreads() throws InterruptedException {\n  final AtomicDoubleArray aa = new AtomicDoubleArray(SIZE);\n  for (int i = 0; i < SIZE; i++) {\n    aa.set(i, (double) COUNTDOWN);\n  }\n  Counter c1 = new Counter(aa);\n  Counter c2 = new Counter(aa);\n  Thread t1 = newStartedThread(c1);\n  Thread t2 = newStartedThread(c2);\n  awaitTermination(t1);\n  awaitTermination(t2);\n  assertEquals(SIZE * COUNTDOWN, c1.counts + c2.counts);\n}",
        "summary_tokens": [
            "multiple",
            "threads",
            "using",
            "same",
            "array",
            "of",
            "counters",
            "successfully",
            "update",
            "a",
            "number",
            "of",
            "times",
            "equal",
            "to",
            "total",
            "count"
        ]
    },
    {
        "id": 460,
        "code": "public void testSerialization() throws Exception {\n  AtomicDoubleArray x = new AtomicDoubleArray(SIZE);\n  for (int i = 0; i < SIZE; i++) {\n    x.set(i, (double) -i);\n  }\n  AtomicDoubleArray y = serialClone(x);\n  assertTrue(x != y);\n  assertEquals(x.length(), y.length());\n  for (int i = 0; i < SIZE; i++) {\n    assertBitEquals(x.get(i), y.get(i));\n  }\n\n  AtomicDoubleArray a = new AtomicDoubleArray(VALUES);\n  AtomicDoubleArray b = serialClone(a);\n  assertFalse(a.equals(b));\n  assertFalse(b.equals(a));\n  assertEquals(a.length(), b.length());\n  for (int i = 0; i < VALUES.length; i++) {\n    assertBitEquals(a.get(i), b.get(i));\n  }\n}",
        "summary_tokens": [
            "a",
            "deserialized",
            "serialized",
            "array",
            "holds",
            "same",
            "values"
        ]
    },
    {
        "id": 461,
        "code": "public void testToString() {\n  AtomicDoubleArray aa = new AtomicDoubleArray(VALUES);\n  assertEquals(Arrays.toString(VALUES), aa.toString());\n  assertEquals(\"[]\", new AtomicDoubleArray(0).toString());\n  assertEquals(\"[]\", new AtomicDoubleArray(new double[0]).toString());\n}",
        "summary_tokens": [
            "to",
            "string",
            "returns",
            "current",
            "value"
        ]
    },
    {
        "id": 462,
        "code": "public void testDistinctZeros() {\n  AtomicDoubleArray aa = new AtomicDoubleArray(SIZE);\n  for (int i : new int[] {0, SIZE - 1}) {\n    assertFalse(aa.compareAndSet(i, -0.0, 7.0));\n    assertFalse(aa.weakCompareAndSet(i, -0.0, 7.0));\n    assertBitEquals(+0.0, aa.get(i));\n    assertTrue(aa.compareAndSet(i, +0.0, -0.0));\n    assertBitEquals(-0.0, aa.get(i));\n    assertFalse(aa.compareAndSet(i, +0.0, 7.0));\n    assertFalse(aa.weakCompareAndSet(i, +0.0, 7.0));\n    assertBitEquals(-0.0, aa.get(i));\n  }\n}",
        "summary_tokens": [
            "compare",
            "and",
            "set",
            "treats",
            "0"
        ]
    },
    {
        "id": 463,
        "code": "static boolean bitEquals(double x, double y) {\n  return Double.doubleToRawLongBits(x) == Double.doubleToRawLongBits(y);\n}",
        "summary_tokens": [
            "the",
            "notion",
            "of",
            "equality",
            "used",
            "by",
            "atomic",
            "double"
        ]
    },
    {
        "id": 464,
        "code": "public void testConstructor() {\n  for (double x : VALUES) {\n    AtomicDouble a = new AtomicDouble(x);\n    assertBitEquals(x, a.get());\n  }\n}",
        "summary_tokens": [
            "constructor",
            "initializes",
            "to",
            "given",
            "value"
        ]
    },
    {
        "id": 465,
        "code": "public void testConstructor2() {\n  AtomicDouble a = new AtomicDouble();\n  assertBitEquals(0.0, a.get());\n}",
        "summary_tokens": [
            "default",
            "constructed",
            "initializes",
            "to",
            "zero"
        ]
    },
    {
        "id": 466,
        "code": "public void testGetSet() {\n  AtomicDouble at = new AtomicDouble(1.0);\n  assertBitEquals(1.0, at.get());\n  for (double x : VALUES) {\n    at.set(x);\n    assertBitEquals(x, at.get());\n  }\n}",
        "summary_tokens": [
            "get",
            "returns",
            "the",
            "last",
            "value",
            "set"
        ]
    },
    {
        "id": 467,
        "code": "public void testGetLazySet() {\n  AtomicDouble at = new AtomicDouble(1.0);\n  assertBitEquals(1.0, at.get());\n  for (double x : VALUES) {\n    at.lazySet(x);\n    assertBitEquals(x, at.get());\n  }\n}",
        "summary_tokens": [
            "get",
            "returns",
            "the",
            "last",
            "value",
            "lazy",
            "set",
            "in",
            "same",
            "thread"
        ]
    },
    {
        "id": 468,
        "code": "public void testCompareAndSet() {\n  double prev = Math.E;\n  double unused = Math.E + Math.PI;\n  AtomicDouble at = new AtomicDouble(prev);\n  for (double x : VALUES) {\n    assertBitEquals(prev, at.get());\n    assertFalse(at.compareAndSet(unused, x));\n    assertBitEquals(prev, at.get());\n    assertTrue(at.compareAndSet(prev, x));\n    assertBitEquals(x, at.get());\n    prev = x;\n  }\n}",
        "summary_tokens": [
            "compare",
            "and",
            "set",
            "succeeds",
            "in",
            "changing",
            "value",
            "if",
            "equal",
            "to",
            "expected",
            "else",
            "fails"
        ]
    },
    {
        "id": 469,
        "code": "public void testCompareAndSetInMultipleThreads() throws Exception {\n  final AtomicDouble at = new AtomicDouble(1.0);\n  Thread t =\n      newStartedThread(\n          new CheckedRunnable() {\n            @Override\n            public void realRun() {\n              while (!at.compareAndSet(2.0, 3.0)) {\n                Thread.yield();\n              }\n            }\n          });\n\n  assertTrue(at.compareAndSet(1.0, 2.0));\n  awaitTermination(t);\n  assertBitEquals(3.0, at.get());\n}",
        "summary_tokens": [
            "compare",
            "and",
            "set",
            "in",
            "one",
            "thread",
            "enables",
            "another",
            "waiting",
            "for",
            "value",
            "to",
            "succeed"
        ]
    },
    {
        "id": 470,
        "code": "public void testWeakCompareAndSet() {\n  double prev = Math.E;\n  double unused = Math.E + Math.PI;\n  AtomicDouble at = new AtomicDouble(prev);\n  for (double x : VALUES) {\n    assertBitEquals(prev, at.get());\n    assertFalse(at.weakCompareAndSet(unused, x));\n    assertBitEquals(prev, at.get());\n    while (!at.weakCompareAndSet(prev, x)) {\n      ;\n    }\n    assertBitEquals(x, at.get());\n    prev = x;\n  }\n}",
        "summary_tokens": [
            "repeated",
            "weak",
            "compare",
            "and",
            "set",
            "succeeds",
            "in",
            "changing",
            "value",
            "when",
            "equal",
            "to",
            "expected"
        ]
    },
    {
        "id": 471,
        "code": "public void testGetAndSet() {\n  double prev = Math.E;\n  AtomicDouble at = new AtomicDouble(prev);\n  for (double x : VALUES) {\n    assertBitEquals(prev, at.getAndSet(x));\n    prev = x;\n  }\n}",
        "summary_tokens": [
            "get",
            "and",
            "set",
            "returns",
            "previous",
            "value",
            "and",
            "sets",
            "to",
            "given",
            "value"
        ]
    },
    {
        "id": 472,
        "code": "public void testGetAndAdd() {\n  for (double x : VALUES) {\n    for (double y : VALUES) {\n      AtomicDouble a = new AtomicDouble(x);\n      double z = a.getAndAdd(y);\n      assertBitEquals(x, z);\n      assertBitEquals(x + y, a.get());\n    }\n  }\n}",
        "summary_tokens": [
            "get",
            "and",
            "add",
            "returns",
            "previous",
            "value",
            "and",
            "adds",
            "given",
            "value"
        ]
    },
    {
        "id": 473,
        "code": "public void testAddAndGet() {\n  for (double x : VALUES) {\n    for (double y : VALUES) {\n      AtomicDouble a = new AtomicDouble(x);\n      double z = a.addAndGet(y);\n      assertBitEquals(x + y, z);\n      assertBitEquals(x + y, a.get());\n    }\n  }\n}",
        "summary_tokens": [
            "add",
            "and",
            "get",
            "adds",
            "given",
            "value",
            "to",
            "current",
            "and",
            "returns",
            "current",
            "value"
        ]
    },
    {
        "id": 474,
        "code": "public void testSerialization() throws Exception {\n  AtomicDouble a = new AtomicDouble();\n  AtomicDouble b = serialClone(a);\n  assertNotSame(a, b);\n  a.set(-22.0);\n  AtomicDouble c = serialClone(a);\n  assertNotSame(b, c);\n  assertBitEquals(-22.0, a.get());\n  assertBitEquals(0.0, b.get());\n  assertBitEquals(-22.0, c.get());\n  for (double x : VALUES) {\n    AtomicDouble d = new AtomicDouble(x);\n    assertBitEquals(serialClone(d).get(), d.get());\n  }\n}",
        "summary_tokens": [
            "a",
            "deserialized",
            "serialized",
            "atomic",
            "holds",
            "same",
            "value"
        ]
    },
    {
        "id": 475,
        "code": "public void testToString() {\n  AtomicDouble at = new AtomicDouble();\n  assertEquals(\"0.0\", at.toString());\n  for (double x : VALUES) {\n    at.set(x);\n    assertEquals(Double.toString(x), at.toString());\n  }\n}",
        "summary_tokens": [
            "to",
            "string",
            "returns",
            "current",
            "value"
        ]
    },
    {
        "id": 476,
        "code": "public void testIntValue() {\n  AtomicDouble at = new AtomicDouble();\n  assertEquals(0, at.intValue());\n  for (double x : VALUES) {\n    at.set(x);\n    assertEquals((int) x, at.intValue());\n  }\n}",
        "summary_tokens": [
            "int",
            "value",
            "returns",
            "current",
            "value"
        ]
    },
    {
        "id": 477,
        "code": "public void testLongValue() {\n  AtomicDouble at = new AtomicDouble();\n  assertEquals(0L, at.longValue());\n  for (double x : VALUES) {\n    at.set(x);\n    assertEquals((long) x, at.longValue());\n  }\n}",
        "summary_tokens": [
            "long",
            "value",
            "returns",
            "current",
            "value"
        ]
    },
    {
        "id": 478,
        "code": "public void testFloatValue() {\n  AtomicDouble at = new AtomicDouble();\n  assertEquals(0.0f, at.floatValue());\n  for (double x : VALUES) {\n    at.set(x);\n    assertEquals((float) x, at.floatValue());\n  }\n}",
        "summary_tokens": [
            "float",
            "value",
            "returns",
            "current",
            "value"
        ]
    },
    {
        "id": 479,
        "code": "public void testDoubleValue() {\n  AtomicDouble at = new AtomicDouble();\n  assertEquals(0.0d, at.doubleValue());\n  for (double x : VALUES) {\n    at.set(x);\n    assertBitEquals(x, at.doubleValue());\n  }\n}",
        "summary_tokens": [
            "double",
            "value",
            "returns",
            "current",
            "value"
        ]
    },
    {
        "id": 480,
        "code": "public void testDistinctZeros() {\n  AtomicDouble at = new AtomicDouble(+0.0);\n  assertFalse(at.compareAndSet(-0.0, 7.0));\n  assertFalse(at.weakCompareAndSet(-0.0, 7.0));\n  assertBitEquals(+0.0, at.get());\n  assertTrue(at.compareAndSet(+0.0, -0.0));\n  assertBitEquals(-0.0, at.get());\n  assertFalse(at.compareAndSet(+0.0, 7.0));\n  assertFalse(at.weakCompareAndSet(+0.0, 7.0));\n  assertBitEquals(-0.0, at.get());\n}",
        "summary_tokens": [
            "compare",
            "and",
            "set",
            "treats",
            "0"
        ]
    },
    {
        "id": 481,
        "code": "static URL[] parseJavaClassPath() {\n  ImmutableList.Builder<URL> urls = ImmutableList.builder();\n  for (String entry : Splitter.on(PATH_SEPARATOR.value()).split(JAVA_CLASS_PATH.value())) {\n    try {\n      try {\n        urls.add(new File(entry).toURI().toURL());\n      } catch (SecurityException e) { \n        urls.add(new URL(\"file\", null, new File(entry).getAbsolutePath()));\n      }\n    } catch (MalformedURLException e) {\n      AssertionError error = new AssertionError(\"malformed class path entry: \" + entry);\n      error.initCause(e);\n      throw error;\n    }\n  }\n  return urls.build().toArray(new URL[0]);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "urls",
            "in",
            "the",
            "class",
            "path",
            "specified",
            "by",
            "the",
            "java"
        ]
    },
    {
        "id": 482,
        "code": "static URL[] getClassPathUrls() {\n  return ClassPathUtil.class.getClassLoader() instanceof URLClassLoader\n      ? ((URLClassLoader) ClassPathUtil.class.getClassLoader()).getURLs()\n      : parseJavaClassPath();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "urls",
            "in",
            "the",
            "class",
            "path"
        ]
    },
    {
        "id": 483,
        "code": "protected void assertFinalStepThrowsIllegalStateException(ClosingFuture<?> closingFuture) {\n  try {\n    closingFuture.finishToFuture();\n    fail();\n  } catch (IllegalStateException expected) {\n  }\n  try {\n    closingFuture.finishToValueAndCloser(new NoOpValueAndCloserConsumer<>(), executor);\n    fail();\n  } catch (IllegalStateException expected) {\n  }\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "marking",
            "this",
            "step",
            "a",
            "final",
            "step",
            "throws",
            "illegal",
            "state",
            "exception"
        ]
    },
    {
        "id": 484,
        "code": "void waitUntilClosed(ClosingFuture<?> closingFuture) {\n  assertTrue(awaitUninterruptibly(closingFuture.whenClosedCountDown(), 1, SECONDS));\n}",
        "summary_tokens": [
            "waits",
            "for",
            "the",
            "given",
            "step",
            "s",
            "closeables",
            "to",
            "be",
            "closed"
        ]
    },
    {
        "id": 485,
        "code": "static <T extends ForwardingObject> void testForwardingObject(final Class<T> forwarderClass) {\n  @SuppressWarnings(\"unchecked\") \n  Class<? super T> interfaceType =\n      (Class<? super T>) Iterables.getOnlyElement(Arrays.asList(forwarderClass.getInterfaces()));\n  new ForwardingWrapperTester()\n      .testForwarding(\n          interfaceType,\n          new Function<Object, T>() {\n            @Override\n            public T apply(Object delegate) {\n              T mock = mock(forwarderClass, CALLS_REAL_METHODS);\n              try {\n                T stubber = doReturn(delegate).when(mock);\n                DELEGATE_METHOD.invoke(stubber);\n              } catch (Exception e) {\n                throw new RuntimeException(e);\n              }\n              return mock;\n            }\n          });\n}",
        "summary_tokens": [
            "ensures",
            "that",
            "all",
            "interface",
            "methods",
            "of",
            "forwarder",
            "class",
            "are",
            "forwarded",
            "to",
            "the",
            "forwarding",
            "object",
            "delegate"
        ]
    },
    {
        "id": 486,
        "code": "private WeakReference<?> doTestClassUnloading() throws Exception {\n  URLClassLoader shadowLoader = new URLClassLoader(parseJavaClassPath(), null);\n  @SuppressWarnings(\"unchecked\")\n  Class<WillBeUnloadedException> shadowClass =\n      (Class<WillBeUnloadedException>)\n          Class.forName(WillBeUnloadedException.class.getName(), false, shadowLoader);\n  assertNotSame(shadowClass, WillBeUnloadedException.class);\n  getChecked(immediateFuture(\"foo\"), shadowClass);\n  return new WeakReference<>(shadowLoader);\n}",
        "summary_tokens": [
            "loads",
            "will",
            "be",
            "unloaded",
            "exception",
            "in",
            "a",
            "separate",
            "class",
            "loader",
            "calls",
            "get",
            "checked",
            "future",
            "will",
            "be",
            "unloaded",
            "exception"
        ]
    },
    {
        "id": 487,
        "code": "public void testTransformValueRemainsMemoized() throws Exception {\n  class Holder {\n\n    int value = 2;\n  }\n  final Holder holder = new Holder();\n\n    \n  Function<Integer, Integer> adder =\n      new Function<Integer, Integer>() {\n        @Override\n        public Integer apply(Integer from) {\n          return from + holder.value;\n        }\n      };\n\n    \n  assertEquals(6, adder.apply(4).intValue());\n\n  ListenableFuture<Integer> immediateFuture = immediateFuture(4);\n  Future<Integer> transformedFuture = transform(immediateFuture, adder, directExecutor());\n\n    \n  assertEquals(6, getDone(transformedFuture).intValue());\n\n    \n    \n  holder.value = 3;\n  assertEquals(6, getDone(transformedFuture).intValue());\n  assertEquals(7, adder.apply(4).intValue());\n\n    \n  holder.value = 4;\n  assertEquals(6, getDone(transformedFuture).intValue());\n  assertEquals(8, adder.apply(4).intValue());\n\n    \n  assertEquals(6, getDoneFromTimeoutOverload(transformedFuture).intValue());\n\n    \n  assertEquals(8, getDone(transform(immediateFuture, adder, directExecutor())).intValue());\n\n    \n  assertEquals(\n      8,\n      getDoneFromTimeoutOverload(transform(immediateFuture, adder, directExecutor())).intValue());\n}",
        "summary_tokens": [
            "tests",
            "that",
            "the",
            "function",
            "is",
            "invoked",
            "only",
            "once",
            "even",
            "if",
            "it",
            "throws",
            "an",
            "exception"
        ]
    },
    {
        "id": 488,
        "code": "public void testTransformExceptionRemainsMemoized() throws Throwable {\n    \n    \n    \n    \n  SettableFuture<Integer> exceptionInput = SettableFuture.create();\n  ListenableFuture<Integer> exceptionComposedFuture =\n      transform(exceptionInput, newOneTimeExceptionThrower(), directExecutor());\n  exceptionInput.set(0);\n  runGetIdempotencyTest(exceptionComposedFuture, MyRuntimeException.class);\n\n  SettableFuture<Integer> errorInput = SettableFuture.create();\n  ListenableFuture<Integer> errorComposedFuture =\n      transform(errorInput, newOneTimeErrorThrower(), directExecutor());\n  errorInput.set(0);\n\n  runGetIdempotencyTest(errorComposedFuture, MyError.class);\n\n    \n  exceptionComposedFuture =\n      transform(exceptionInput, newOneTimeExceptionThrower(), directExecutor());\n  runGetIdempotencyTest(exceptionComposedFuture, MyRuntimeException.class);\n\n  runGetIdempotencyTest(\n      transform(errorInput, newOneTimeErrorThrower(), directExecutor()), MyError.class);\n  runGetIdempotencyTest(errorComposedFuture, MyError.class);\n}",
        "summary_tokens": [
            "test",
            "that",
            "the",
            "function",
            "is",
            "invoked",
            "only",
            "once",
            "even",
            "if",
            "it",
            "throws",
            "an",
            "exception"
        ]
    },
    {
        "id": 489,
        "code": "private static AssertionError newAssertionError(String message, Throwable cause) {\n  AssertionError e = new AssertionError(message);\n  e.initCause(cause);\n  return e;\n}",
        "summary_tokens": [
            "alternative",
            "to",
            "assertion",
            "error",
            "string",
            "throwable",
            "which",
            "doesn",
            "t",
            "exist",
            "in",
            "gwt",
            "0"
        ]
    },
    {
        "id": 490,
        "code": "public void testAllAsList_doneFutures() throws Exception {\n    \n  SettableFuture<String> future1 = SettableFuture.create();\n  SettableFuture<String> future2 = SettableFuture.create();\n  SettableFuture<String> future3 = SettableFuture.create();\n\n    \n  future1.set(DATA1);\n  future2.set(DATA2);\n  future3.set(DATA3);\n\n  @SuppressWarnings(\"unchecked\") \n  ListenableFuture<List<String>> compound = allAsList(future1, future2, future3);\n\n    \n  SingleCallListener listener = new SingleCallListener();\n  listener.expectCall();\n  compound.addListener(listener, directExecutor());\n\n  assertTrue(listener.wasCalled());\n\n  List<String> results = getDone(compound);\n  assertThat(results).containsExactly(DATA1, DATA2, DATA3).inOrder();\n}",
        "summary_tokens": [
            "test",
            "the",
            "case",
            "where",
            "the",
            "futures",
            "are",
            "fulfilled",
            "prior",
            "to",
            "constructing",
            "the",
            "list",
            "future"
        ]
    },
    {
        "id": 491,
        "code": "public void testAllAsList_logging_exception() throws Exception {\n  try {\n    getDone(allAsList(immediateFailedFuture(new MyException())));\n    fail();\n  } catch (ExecutionException expected) {\n    assertThat(expected.getCause()).isInstanceOf(MyException.class);\n    assertEquals(\n        \"Nothing should be logged\", 0, aggregateFutureLogHandler.getStoredLogRecords().size());\n  }\n}",
        "summary_tokens": [
            "a",
            "single",
            "non",
            "error",
            "failure",
            "is",
            "not",
            "logged",
            "because",
            "it",
            "is",
            "reported",
            "via",
            "the",
            "output",
            "future"
        ]
    },
    {
        "id": 492,
        "code": "public void testAllAsList_logging_error() throws Exception {\n  try {\n    getDone(allAsList(immediateFailedFuture(new MyError())));\n    fail();\n  } catch (ExecutionException expected) {\n    assertThat(expected.getCause()).isInstanceOf(MyError.class);\n    List<LogRecord> logged = aggregateFutureLogHandler.getStoredLogRecords();\n    assertThat(logged).hasSize(1); \n    assertThat(logged.get(0).getThrown()).isInstanceOf(MyError.class);\n  }\n}",
        "summary_tokens": [
            "ensure",
            "that",
            "errors",
            "are",
            "always",
            "logged"
        ]
    },
    {
        "id": 493,
        "code": "public void testAllAsList_logging_multipleExceptions_alreadyDone() throws Exception {\n  try {\n    getDone(\n        allAsList(\n            immediateFailedFuture(new MyException()), immediateFailedFuture(new MyException())));\n    fail();\n  } catch (ExecutionException expected) {\n    assertThat(expected.getCause()).isInstanceOf(MyException.class);\n    List<LogRecord> logged = aggregateFutureLogHandler.getStoredLogRecords();\n    assertThat(logged).hasSize(1); \n    assertThat(logged.get(0).getThrown()).isInstanceOf(MyException.class);\n  }\n}",
        "summary_tokens": [
            "all",
            "as",
            "list",
            "will",
            "log",
            "extra",
            "exceptions",
            "that",
            "have",
            "already",
            "occurred"
        ]
    },
    {
        "id": 494,
        "code": "public void testAllAsList_logging_multipleExceptions_doneLater() throws Exception {\n  SettableFuture<Object> future1 = SettableFuture.create();\n  SettableFuture<Object> future2 = SettableFuture.create();\n  SettableFuture<Object> future3 = SettableFuture.create();\n  ListenableFuture<List<Object>> all = allAsList(future1, future2, future3);\n\n  future1.setException(new MyException());\n  future2.setException(new MyException());\n  future3.setException(new MyException());\n\n  try {\n    getDone(all);\n    fail();\n  } catch (ExecutionException expected) {\n    List<LogRecord> logged = aggregateFutureLogHandler.getStoredLogRecords();\n    assertThat(logged).hasSize(2); \n    assertThat(logged.get(0).getThrown()).isInstanceOf(MyException.class);\n    assertThat(logged.get(1).getThrown()).isInstanceOf(MyException.class);\n  }\n}",
        "summary_tokens": [
            "all",
            "as",
            "list",
            "will",
            "log",
            "extra",
            "exceptions",
            "that",
            "occur",
            "later"
        ]
    },
    {
        "id": 495,
        "code": "public void testAllAsList_logging_same_exception() throws Exception {\n  try {\n    MyException sameInstance = new MyException();\n    getDone(allAsList(immediateFailedFuture(sameInstance), immediateFailedFuture(sameInstance)));\n    fail();\n  } catch (ExecutionException expected) {\n    assertThat(expected.getCause()).isInstanceOf(MyException.class);\n    assertEquals(\n        \"Nothing should be logged\", 0, aggregateFutureLogHandler.getStoredLogRecords().size());\n  }\n}",
        "summary_tokens": [
            "the",
            "same",
            "exception",
            "happening",
            "on",
            "multiple",
            "futures",
            "should",
            "not",
            "be",
            "logged"
        ]
    },
    {
        "id": 496,
        "code": "public void testAllAsList_logging_same_cause() throws Exception {\n  try {\n    MyException exception1 = new MyException();\n    MyException exception2 = new MyException();\n    MyException exception3 = new MyException();\n\n    MyException sameInstance = new MyException();\n    exception1.initCause(sameInstance);\n    exception2.initCause(sameInstance);\n    exception3.initCause(exception2);\n    getDone(allAsList(immediateFailedFuture(exception1), immediateFailedFuture(exception3)));\n    fail();\n  } catch (ExecutionException expected) {\n    assertThat(expected.getCause()).isInstanceOf(MyException.class);\n    assertEquals(\n        \"Nothing should be logged\", 0, aggregateFutureLogHandler.getStoredLogRecords().size());\n  }\n}",
        "summary_tokens": [
            "different",
            "exceptions",
            "happening",
            "on",
            "multiple",
            "futures",
            "with",
            "the",
            "same",
            "cause",
            "should",
            "not",
            "be",
            "logged"
        ]
    },
    {
        "id": 497,
        "code": "static <V> V pseudoTimedGetUninterruptibly(final Future<V> input, long timeout, TimeUnit unit)\n    throws ExecutionException, TimeoutException {\n  ExecutorService executor = newSingleThreadExecutor();\n  Future<V> waiter =\n      executor.submit(\n          new Callable<V>() {\n            @Override\n            public V call() throws Exception {\n              return input.get();\n            }\n          });\n\n  try {\n    return getUninterruptibly(waiter, timeout, unit);\n  } catch (ExecutionException e) {\n    propagateIfInstanceOf(e.getCause(), ExecutionException.class);\n    propagateIfInstanceOf(e.getCause(), CancellationException.class);\n    throw failureWithCause(e, \"Unexpected exception\");\n  } finally {\n    executor.shutdownNow();\n      \n  }\n}",
        "summary_tokens": [
            "very",
            "rough",
            "equivalent",
            "of",
            "a",
            "timed",
            "get",
            "produced",
            "by",
            "calling",
            "the",
            "no",
            "arg",
            "get",
            "method",
            "in",
            "another",
            "thread",
            "and",
            "waiting",
            "a",
            "short",
            "time",
            "for",
            "it"
        ]
    },
    {
        "id": 498,
        "code": "private static void runExtensiveMergerTest(Merger merger) throws InterruptedException {\n  int inputCount = new TestFutureBatch().allFutures.size();\n\n  for (int i = 0; i < inputCount; i++) {\n    for (int j = 0; j < inputCount; j++) {\n      for (boolean iBeforeJ : new boolean[] {true, false}) {\n        TestFutureBatch inputs = new TestFutureBatch();\n        ListenableFuture<String> iFuture = inputs.allFutures.get(i).future;\n        ListenableFuture<String> jFuture = inputs.allFutures.get(j).future;\n        ListenableFuture<List<String>> future = merger.merged(iFuture, jFuture);\n\n          \n        try {\n          List<String> result = future.get(0, MILLISECONDS);\n          assertTrue(\"Got \" + result, asList(\"a\", null).containsAll(result));\n        } catch (CancellationException e) {\n          assertTrue(merger == Merger.allMerger);\n          inputs.assertHasImmediateCancel(iFuture, jFuture, e);\n        } catch (ExecutionException e) {\n          assertTrue(merger == Merger.allMerger);\n          inputs.assertHasImmediateFailure(iFuture, jFuture, e);\n        } catch (TimeoutException e) {\n          inputs.assertHasDelayed(iFuture, jFuture, e);\n        }\n\n          \n        try {\n          List<String> result =\n              conditionalPseudoTimedGetUninterruptibly(\n                  inputs, iFuture, jFuture, future, 20, MILLISECONDS);\n          assertTrue(\"Got \" + result, asList(\"a\", null).containsAll(result));\n        } catch (CancellationException e) {\n          assertTrue(merger == Merger.allMerger);\n          inputs.assertHasImmediateCancel(iFuture, jFuture, e);\n        } catch (ExecutionException e) {\n          assertTrue(merger == Merger.allMerger);\n          inputs.assertHasImmediateFailure(iFuture, jFuture, e);\n        } catch (TimeoutException e) {\n          inputs.assertHasDelayed(iFuture, jFuture, e);\n        }\n\n          \n        inputs.allFutures.get(iBeforeJ ? i : j).finisher.run();\n        inputs.allFutures.get(iBeforeJ ? j : i).finisher.run();\n\n          \n        try {\n          List<String> result = getDone(future);\n          assertTrue(\"Got \" + result, asList(\"a\", \"b\", null).containsAll(result));\n        } catch (CancellationException e) {\n          assertTrue(merger == Merger.allMerger);\n          inputs.assertHasCancel(iFuture, jFuture, e);\n        } catch (ExecutionException e) {\n          assertTrue(merger == Merger.allMerger);\n          inputs.assertHasFailure(iFuture, jFuture, e);\n        }\n      }\n    }\n  }\n}",
        "summary_tokens": [
            "for",
            "each",
            "possible",
            "pair",
            "of",
            "futures",
            "from",
            "test",
            "future",
            "batch",
            "for",
            "each",
            "possible",
            "completion",
            "order",
            "of",
            "those",
            "futures",
            "test",
            "that",
            "various",
            "get",
            "calls",
            "timed",
            "before",
            "future",
            "completion",
            "untimed",
            "before",
            "future",
            "completion",
            "and",
            "untimed",
            "after",
            "future",
            "completion",
            "return",
            "or",
            "throw",
            "the",
            "proper",
            "values"
        ]
    },
    {
        "id": 499,
        "code": "private static List<String> conditionalPseudoTimedGetUninterruptibly(\n    TestFutureBatch inputs,\n    ListenableFuture<String> iFuture,\n    ListenableFuture<String> jFuture,\n    ListenableFuture<List<String>> future,\n    int timeout,\n    TimeUnit unit)\n    throws ExecutionException, TimeoutException {\n    \n  return (inputs.hasDelayed(iFuture, jFuture))\n      ? pseudoTimedGetUninterruptibly(future, timeout, unit)\n      : pseudoTimedGetUninterruptibly(future, 2500, MILLISECONDS);\n}",
        "summary_tokens": [
            "call",
            "the",
            "non",
            "timed",
            "future",
            "get",
            "in",
            "a",
            "way",
            "that",
            "allows",
            "us",
            "to",
            "abort",
            "if",
            "it",
            "s",
            "expected",
            "to",
            "hang",
            "forever"
        ]
    },
    {
        "id": 500,
        "code": "public void testSuccessfulAsList_logging_exception() throws Exception {\n  assertEquals(\n      newArrayList((Object) null),\n      getDone(successfulAsList(immediateFailedFuture(new MyException()))));\n  assertWithMessage(\"Nothing should be logged\")\n      .that(aggregateFutureLogHandler.getStoredLogRecords())\n      .isEmpty();\n\n    \n  assertEquals(\n      newArrayList(null, null, null),\n      getDone(\n          successfulAsList(\n              immediateFailedFuture(new MyException()),\n              immediateFailedFuture(new MyException()),\n              immediateFailedFuture(new MyException()))));\n  assertWithMessage(\"Nothing should be logged\")\n      .that(aggregateFutureLogHandler.getStoredLogRecords())\n      .isEmpty();\n}",
        "summary_tokens": [
            "non",
            "error",
            "exceptions",
            "are",
            "never",
            "logged"
        ]
    },
    {
        "id": 501,
        "code": "public void testSuccessfulAsList_logging_error() throws Exception {\n  assertEquals(\n      newArrayList((Object) null),\n      getDone(successfulAsList(immediateFailedFuture(new MyError()))));\n  List<LogRecord> logged = aggregateFutureLogHandler.getStoredLogRecords();\n  assertThat(logged).hasSize(1); \n  assertThat(logged.get(0).getThrown()).isInstanceOf(MyError.class);\n}",
        "summary_tokens": [
            "ensure",
            "that",
            "errors",
            "are",
            "always",
            "logged"
        ]
    },
    {
        "id": 502,
        "code": "private static boolean isAnyEnter(Method method) {\n  return method.getName().startsWith(\"enter\") || method.getName().startsWith(\"tryEnter\");\n}",
        "summary_tokens": [
            "identifies",
            "all",
            "enter",
            "xxx",
            "and",
            "try",
            "enter",
            "xxx",
            "methods"
        ]
    },
    {
        "id": 503,
        "code": "private static boolean isTryEnter(Method method) {\n  return method.getName().startsWith(\"tryEnter\");\n}",
        "summary_tokens": [
            "identifies",
            "just",
            "try",
            "enter",
            "xxx",
            "methods",
            "a",
            "subset",
            "of",
            "is",
            "any",
            "enter",
            "which",
            "never",
            "block"
        ]
    },
    {
        "id": 504,
        "code": "private static boolean isEnterIf(Method method) {\n  return method.getName().startsWith(\"enterIf\");\n}",
        "summary_tokens": [
            "identifies",
            "just",
            "enter",
            "if",
            "xxx",
            "methods",
            "a",
            "subset",
            "of",
            "is",
            "any",
            "enter",
            "which",
            "are",
            "mostly",
            "like",
            "the",
            "enter",
            "xxx",
            "methods",
            "but",
            "behave",
            "like",
            "try",
            "enter",
            "xxx",
            "in",
            "some",
            "scenarios"
        ]
    },
    {
        "id": 505,
        "code": "private static boolean isWaitFor(Method method) {\n  return method.getName().startsWith(\"waitFor\");\n}",
        "summary_tokens": [
            "identifies",
            "all",
            "wait",
            "for",
            "xxx",
            "methods",
            "which",
            "must",
            "be",
            "called",
            "while",
            "occupying",
            "the",
            "monitor"
        ]
    },
    {
        "id": 506,
        "code": "private static boolean isGuarded(Method method) {\n  Class<?>[] parameterTypes = method.getParameterTypes();\n  return parameterTypes.length >= 1 && parameterTypes[0] == Monitor.Guard.class;\n}",
        "summary_tokens": [
            "determines",
            "whether",
            "the",
            "given",
            "method",
            "takes",
            "a",
            "guard",
            "as",
            "its",
            "first",
            "parameter"
        ]
    },
    {
        "id": 507,
        "code": "private static boolean isTimed(Method method) {\n  return isLongTimeUnitBased(method) || isDurationBased(method);\n}",
        "summary_tokens": [
            "determines",
            "whether",
            "the",
            "given",
            "method",
            "is",
            "time",
            "based"
        ]
    },
    {
        "id": 508,
        "code": "private static boolean isBoolean(Method method) {\n  return method.getReturnType() == boolean.class;\n}",
        "summary_tokens": [
            "determines",
            "whether",
            "the",
            "given",
            "method",
            "returns",
            "a",
            "boolean",
            "value"
        ]
    },
    {
        "id": 509,
        "code": "private static boolean isInterruptible(Method method) {\n  return Arrays.asList(method.getExceptionTypes()).contains(InterruptedException.class);\n}",
        "summary_tokens": [
            "determines",
            "whether",
            "the",
            "given",
            "method",
            "can",
            "throw",
            "interrupted",
            "exception"
        ]
    },
    {
        "id": 510,
        "code": "private static void sortMethods(Method[] methods) {\n  Arrays.sort(\n      methods,\n      new Comparator<Method>() {\n        @Override\n        public int compare(Method m1, Method m2) {\n          int nameComparison = m1.getName().compareTo(m2.getName());\n          if (nameComparison != 0) {\n            return nameComparison;\n          } else {\n            return Ints.compare(m1.getParameterTypes().length, m2.getParameterTypes().length);\n          }\n        }\n      });\n}",
        "summary_tokens": [
            "sorts",
            "the",
            "given",
            "methods",
            "primarily",
            "by",
            "name",
            "and",
            "secondarily",
            "by",
            "number",
            "of",
            "parameters"
        ]
    },
    {
        "id": 511,
        "code": "private static void validateMethod(Method method) {\n  String desc = method.toString();\n\n  assertTrue(desc, isAnyEnter(method) || isWaitFor(method));\n\n  switch (method.getParameterTypes().length) {\n    case 0:\n      assertFalse(desc, isGuarded(method));\n      assertFalse(desc, isTimed(method));\n      break;\n    case 1:\n      if (isDurationBased(method)) {\n        assertFalse(desc, isGuarded(method));\n      } else {\n        assertTrue(desc, isGuarded(method));\n      }\n        \n        \n      assertFalse(desc, isLongTimeUnitBased(method));\n      break;\n    case 2:\n      if (isDurationBased(method)) {\n        assertTrue(desc, isGuarded(method));\n      } else {\n        assertFalse(desc, isGuarded(method));\n      }\n      assertTrue(desc, isTimed(method));\n      break;\n    case 3:\n      assertTrue(desc, isGuarded(method));\n      assertTrue(desc, isTimed(method));\n      break;\n    default:\n      fail(desc);\n  }\n\n  if (method.getReturnType() == void.class) {\n    assertFalse(desc, isBoolean(method));\n  } else {\n    assertTrue(desc, isBoolean(method));\n  }\n\n  switch (method.getExceptionTypes().length) {\n    case 0:\n      assertFalse(desc, isInterruptible(method));\n      break;\n    case 1:\n      assertTrue(desc, isInterruptible(method));\n      break;\n    default:\n      fail(desc);\n  }\n\n  if (isEnterIf(method)) {\n    assertTrue(desc, isGuarded(method));\n    assertTrue(desc, isBoolean(method));\n  } else if (isTryEnter(method)) {\n    assertFalse(desc, isTimed(method));\n    assertTrue(desc, isBoolean(method));\n    assertFalse(desc, isInterruptible(method));\n  } else if (isWaitFor(method)) {\n    assertTrue(desc, isGuarded(method));\n    assertEquals(desc, isTimed(method), isBoolean(method));\n  } else { \n    assertEquals(desc, isTimed(method), isBoolean(method));\n  }\n}",
        "summary_tokens": [
            "validates",
            "that",
            "the",
            "given",
            "method",
            "s",
            "signature",
            "meets",
            "all",
            "of",
            "our",
            "assumptions"
        ]
    },
    {
        "id": 512,
        "code": "private static void addTests(\n    TestSuite suite,\n    Method method,\n    Scenario scenario,\n    TimeoutsToUse timeoutsToUse,\n    Outcome expectedOutcome) {\n  for (boolean fair : new boolean[] {true, false}) {\n    if (isTimed(method)) {\n      for (Timeout timeout : timeoutsToUse.timeouts) {\n        suite.addTest(new GeneratedMonitorTest(method, scenario, fair, timeout, expectedOutcome));\n      }\n    } else {\n      Timeout implicitTimeout = (isTryEnter(method) ? Timeout.ZERO : Timeout.MAX);\n      if (timeoutsToUse.timeouts.contains(implicitTimeout)) {\n        suite.addTest(new GeneratedMonitorTest(method, scenario, fair, null, expectedOutcome));\n      }\n    }\n  }\n}",
        "summary_tokens": [
            "generates",
            "test",
            "cases",
            "for",
            "the",
            "given",
            "combination",
            "of",
            "scenario",
            "and",
            "timeouts"
        ]
    },
    {
        "id": 513,
        "code": "private static TestCase generateGuardWithWrongMonitorTestCase(\n    final Method method, final boolean fair1, final boolean fair2) {\n  final boolean timed = isTimed(method); \n  return new TestCase(method.getName() + (timed ? \"(0ms)\" : \"()\") + \"/WrongMonitor->IMSE\") {\n    @Override\n    protected void runTest() throws Throwable {\n      Monitor monitor1 = new Monitor(fair1);\n      Monitor monitor2 = new Monitor(fair2);\n      FlagGuard guard = new FlagGuard(monitor2);\n      List<Object> arguments = new ArrayList<>();\n      arguments.add(guard);\n      if (isDurationBased(method)) {\n        arguments.add(Duration.ZERO);\n      }\n      if (isLongTimeUnitBased(method)) {\n        arguments.add(0L);\n        arguments.add(TimeUnit.MILLISECONDS);\n      }\n      boolean occupyMonitor = isWaitFor(method);\n      if (occupyMonitor) {\n          \n          \n        monitor1.enter();\n      }\n      try {\n        method.invoke(monitor1, arguments.toArray());\n        fail(\"expected IllegalMonitorStateException\");\n      } catch (InvocationTargetException e) {\n        assertEquals(IllegalMonitorStateException.class, e.getTargetException().getClass());\n      } finally {\n        if (occupyMonitor) {\n          monitor1.leave();\n        }\n      }\n    }\n  };\n}",
        "summary_tokens": [
            "generates",
            "a",
            "test",
            "case",
            "verifying",
            "that",
            "calling",
            "any",
            "enter",
            "xxx",
            "try",
            "enter",
            "xxx",
            "or",
            "wait",
            "for",
            "xxx",
            "method",
            "with",
            "a",
            "guard",
            "that",
            "doesn",
            "t",
            "match",
            "the",
            "monitor",
            "produces",
            "an",
            "illegal",
            "monitor",
            "state",
            "exception"
        ]
    },
    {
        "id": 514,
        "code": "private static TestCase generateWaitForWhenNotOccupyingTestCase(\n    final Method method, final boolean fair) {\n  final boolean timed = isTimed(method); \n  String testName =\n      method.getName()\n          + (fair ? \"(fair)\" : \"(nonfair)\")\n          + (timed ? \"(0ms)\" : \"()\")\n          + \"/NotOccupying->IMSE\";\n  return new TestCase(testName) {\n    @Override\n    protected void runTest() throws Throwable {\n      Monitor monitor = new Monitor(fair);\n      FlagGuard guard = new FlagGuard(monitor);\n      List<Object> arguments = new ArrayList<>();\n      arguments.add(guard);\n      if (isDurationBased(method)) {\n        arguments.add(Duration.ZERO);\n      }\n      if (isLongTimeUnitBased(method)) {\n        arguments.add(0L);\n        arguments.add(TimeUnit.MILLISECONDS);\n      }\n      try {\n        method.invoke(monitor, arguments.toArray());\n        fail(\"expected IllegalMonitorStateException\");\n      } catch (InvocationTargetException e) {\n        assertEquals(IllegalMonitorStateException.class, e.getTargetException().getClass());\n      }\n    }\n  };\n}",
        "summary_tokens": [
            "generates",
            "a",
            "test",
            "case",
            "verifying",
            "that",
            "calling",
            "any",
            "wait",
            "for",
            "xxx",
            "method",
            "when",
            "not",
            "occupying",
            "the",
            "monitor",
            "produces",
            "an",
            "illegal",
            "monitor",
            "state",
            "exception"
        ]
    },
    {
        "id": 515,
        "code": "private static AssertionError newAssertionError(String message, Throwable cause) {\n  AssertionError e = new AssertionError(message);\n  e.initCause(cause);\n  return e;\n}",
        "summary_tokens": [
            "alternative",
            "to",
            "assertion",
            "error",
            "string",
            "throwable",
            "which",
            "doesn",
            "t",
            "exist",
            "in",
            "java",
            "0"
        ]
    },
    {
        "id": 516,
        "code": "static void requestInterruptIn(final long time, final TimeUnit unit) {\n  checkNotNull(unit);\n  final Thread interruptee = Thread.currentThread();\n  new Thread(\n          new Runnable() {\n            @Override\n            public void run() {\n              try {\n                unit.sleep(time);\n              } catch (InterruptedException wontHappen) {\n                throw new AssertionError(wontHappen);\n              }\n              interruptee.interrupt();\n            }\n          })\n      .start();\n}",
        "summary_tokens": [
            "interrupts",
            "the",
            "current",
            "thread",
            "after",
            "sleeping",
            "for",
            "the",
            "specified",
            "delay"
        ]
    },
    {
        "id": 517,
        "code": "protected long getShortDelay() {\n  return 50;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "shortest",
            "timed",
            "delay"
        ]
    },
    {
        "id": 518,
        "code": "protected void setDelays() {\n  SHORT_DELAY_MS = getShortDelay();\n  SMALL_DELAY_MS = SHORT_DELAY_MS * 5;\n  MEDIUM_DELAY_MS = SHORT_DELAY_MS * 10;\n  LONG_DELAY_MS = SHORT_DELAY_MS * 200;\n}",
        "summary_tokens": [
            "sets",
            "delays",
            "as",
            "multiples",
            "of",
            "short",
            "delay"
        ]
    },
    {
        "id": 519,
        "code": "long timeoutMillis() {\n  return SHORT_DELAY_MS / 4;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "timeout",
            "in",
            "milliseconds",
            "to",
            "be",
            "used",
            "in",
            "tests",
            "that",
            "verify",
            "that",
            "operations",
            "block",
            "or",
            "time",
            "out"
        ]
    },
    {
        "id": 520,
        "code": "Date delayedDate(long delayMillis) {\n  return new Date(System.currentTimeMillis() + delayMillis);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "date",
            "instance",
            "representing",
            "a",
            "time",
            "delay",
            "millis",
            "milliseconds",
            "in",
            "the",
            "future"
        ]
    },
    {
        "id": 521,
        "code": "public void threadRecordFailure(Throwable t) {\n  threadFailure.compareAndSet(null, t);\n}",
        "summary_tokens": [
            "records",
            "an",
            "exception",
            "so",
            "that",
            "it",
            "can",
            "be",
            "rethrown",
            "later",
            "in",
            "the",
            "test",
            "harness",
            "thread",
            "triggering",
            "a",
            "test",
            "case",
            "failure"
        ]
    },
    {
        "id": 522,
        "code": "public void tearDown() throws Exception {\n  Throwable t = threadFailure.getAndSet(null);\n  if (t != null) {\n    if (t instanceof Error) throw (Error) t;\n    else if (t instanceof RuntimeException) throw (RuntimeException) t;\n    else if (t instanceof Exception) throw (Exception) t;\n    else {\n      AssertionFailedError afe = new AssertionFailedError(t.toString());\n      afe.initCause(t);\n      throw afe;\n    }\n  }\n\n  if (Thread.interrupted()) throw new AssertionFailedError(\"interrupt status set in main thread\");\n}",
        "summary_tokens": [
            "extra",
            "checks",
            "that",
            "get",
            "done",
            "for",
            "all",
            "test",
            "cases"
        ]
    },
    {
        "id": 523,
        "code": "public void threadFail(String reason) {\n  try {\n    fail(reason);\n  } catch (AssertionFailedError t) {\n    threadRecordFailure(t);\n    fail(reason);\n  }\n}",
        "summary_tokens": [
            "just",
            "like",
            "fail",
            "reason",
            "but",
            "additionally",
            "recording",
            "using",
            "thread",
            "record",
            "failure",
            "any",
            "assertion",
            "failed",
            "error",
            "thrown",
            "so",
            "that",
            "the",
            "current",
            "testcase",
            "will",
            "fail"
        ]
    },
    {
        "id": 524,
        "code": "public void threadAssertTrue(boolean b) {\n  try {\n    assertTrue(b);\n  } catch (AssertionFailedError t) {\n    threadRecordFailure(t);\n    throw t;\n  }\n}",
        "summary_tokens": [
            "just",
            "like",
            "assert",
            "true",
            "b",
            "but",
            "additionally",
            "recording",
            "using",
            "thread",
            "record",
            "failure",
            "any",
            "assertion",
            "failed",
            "error",
            "thrown",
            "so",
            "that",
            "the",
            "current",
            "testcase",
            "will",
            "fail"
        ]
    },
    {
        "id": 525,
        "code": "public void threadAssertFalse(boolean b) {\n  try {\n    assertFalse(b);\n  } catch (AssertionFailedError t) {\n    threadRecordFailure(t);\n    throw t;\n  }\n}",
        "summary_tokens": [
            "just",
            "like",
            "assert",
            "false",
            "b",
            "but",
            "additionally",
            "recording",
            "using",
            "thread",
            "record",
            "failure",
            "any",
            "assertion",
            "failed",
            "error",
            "thrown",
            "so",
            "that",
            "the",
            "current",
            "testcase",
            "will",
            "fail"
        ]
    },
    {
        "id": 526,
        "code": "public void threadAssertNull(Object x) {\n  try {\n    assertNull(x);\n  } catch (AssertionFailedError t) {\n    threadRecordFailure(t);\n    throw t;\n  }\n}",
        "summary_tokens": [
            "just",
            "like",
            "assert",
            "null",
            "x",
            "but",
            "additionally",
            "recording",
            "using",
            "thread",
            "record",
            "failure",
            "any",
            "assertion",
            "failed",
            "error",
            "thrown",
            "so",
            "that",
            "the",
            "current",
            "testcase",
            "will",
            "fail"
        ]
    },
    {
        "id": 527,
        "code": "public void threadAssertEquals(Object x, Object y) {\n  try {\n    assertEquals(x, y);\n  } catch (AssertionFailedError t) {\n    threadRecordFailure(t);\n    throw t;\n  } catch (Throwable t) {\n    threadUnexpectedException(t);\n  }\n}",
        "summary_tokens": [
            "just",
            "like",
            "assert",
            "equals",
            "x",
            "y",
            "but",
            "additionally",
            "recording",
            "using",
            "thread",
            "record",
            "failure",
            "any",
            "assertion",
            "failed",
            "error",
            "thrown",
            "so",
            "that",
            "the",
            "current",
            "testcase",
            "will",
            "fail"
        ]
    },
    {
        "id": 528,
        "code": "public void threadAssertSame(Object x, Object y) {\n  try {\n    assertSame(x, y);\n  } catch (AssertionFailedError t) {\n    threadRecordFailure(t);\n    throw t;\n  }\n}",
        "summary_tokens": [
            "just",
            "like",
            "assert",
            "same",
            "x",
            "y",
            "but",
            "additionally",
            "recording",
            "using",
            "thread",
            "record",
            "failure",
            "any",
            "assertion",
            "failed",
            "error",
            "thrown",
            "so",
            "that",
            "the",
            "current",
            "testcase",
            "will",
            "fail"
        ]
    },
    {
        "id": 529,
        "code": "public void threadShouldThrow(String exceptionName) {\n  threadFail(\"should throw \" + exceptionName);\n}",
        "summary_tokens": [
            "calls",
            "thread",
            "fail",
            "with",
            "message",
            "should",
            "throw",
            "exception",
            "name"
        ]
    },
    {
        "id": 530,
        "code": "public void threadUnexpectedException(Throwable t) {\n  threadRecordFailure(t);\n  t.printStackTrace();\n  if (t instanceof RuntimeException) throw (RuntimeException) t;\n  else if (t instanceof Error) throw (Error) t;\n  else {\n    AssertionFailedError afe = new AssertionFailedError(\"unexpected exception: \" + t);\n    afe.initCause(t);\n    throw afe;\n  }\n}",
        "summary_tokens": [
            "records",
            "the",
            "given",
            "exception",
            "using",
            "thread",
            "record",
            "failure",
            "then",
            "rethrows",
            "the",
            "exception",
            "wrapping",
            "it",
            "in",
            "an",
            "assertion",
            "failed",
            "error",
            "if",
            "necessary"
        ]
    },
    {
        "id": 531,
        "code": "void joinPool(ExecutorService exec) {\n  try {\n    exec.shutdown();\n    assertTrue(\n        \"ExecutorService did not terminate in a timely manner\",\n        exec.awaitTermination(2 * LONG_DELAY_MS, MILLISECONDS));\n  } catch (SecurityException ok) {\n      \n  } catch (InterruptedException ie) {\n    fail(\"Unexpected InterruptedException\");\n  }\n}",
        "summary_tokens": [
            "waits",
            "out",
            "termination",
            "of",
            "a",
            "thread",
            "pool",
            "or",
            "fails",
            "doing",
            "so"
        ]
    },
    {
        "id": 532,
        "code": "void assertThreadStaysAlive(Thread thread, long millis) {\n  try {\n      \n    delay(millis);\n    assertTrue(thread.isAlive());\n  } catch (InterruptedException ie) {\n    fail(\"Unexpected InterruptedException\");\n  }\n}",
        "summary_tokens": [
            "checks",
            "that",
            "thread",
            "does",
            "not",
            "terminate",
            "within",
            "the",
            "given",
            "millisecond",
            "delay"
        ]
    },
    {
        "id": 533,
        "code": "void assertThreadsStayAlive(long millis, Thread... threads) {\n  try {\n      \n    delay(millis);\n    for (Thread thread : threads) assertTrue(thread.isAlive());\n  } catch (InterruptedException ie) {\n    fail(\"Unexpected InterruptedException\");\n  }\n}",
        "summary_tokens": [
            "checks",
            "that",
            "the",
            "threads",
            "do",
            "not",
            "terminate",
            "within",
            "the",
            "given",
            "millisecond",
            "delay"
        ]
    },
    {
        "id": 534,
        "code": "public void shouldThrow(String exceptionName) {\n  fail(\"Should throw \" + exceptionName);\n}",
        "summary_tokens": [
            "fails",
            "with",
            "message",
            "should",
            "throw",
            "exception",
            "name"
        ]
    },
    {
        "id": 535,
        "code": "public void runWithPermissions(Runnable r, Permission... permissions) {\n  SecurityManager sm = System.getSecurityManager();\n  if (sm == null) {\n    r.run();\n    Policy savedPolicy = Policy.getPolicy();\n    try {\n      Policy.setPolicy(permissivePolicy());\n      System.setSecurityManager(new SecurityManager());\n      runWithPermissions(r, permissions);\n    } finally {\n      System.setSecurityManager(null);\n      Policy.setPolicy(savedPolicy);\n    }\n  } else {\n    Policy savedPolicy = Policy.getPolicy();\n    AdjustablePolicy policy = new AdjustablePolicy(permissions);\n    Policy.setPolicy(policy);\n\n    try {\n      r.run();\n    } finally {\n      policy.addPermission(new SecurityPermission(\"setPolicy\"));\n      Policy.setPolicy(savedPolicy);\n    }\n  }\n}",
        "summary_tokens": [
            "runs",
            "runnable",
            "r",
            "with",
            "a",
            "security",
            "policy",
            "that",
            "permits",
            "precisely",
            "the",
            "specified",
            "permissions"
        ]
    },
    {
        "id": 536,
        "code": "public void runWithoutPermissions(Runnable r) {\n  runWithPermissions(r);\n}",
        "summary_tokens": [
            "runs",
            "a",
            "runnable",
            "without",
            "any",
            "permissions"
        ]
    },
    {
        "id": 537,
        "code": "public static Policy permissivePolicy() {\n  return new AdjustablePolicy\n    \n  (\n      new RuntimePermission(\"modifyThread\"),\n      new RuntimePermission(\"getClassLoader\"),\n      new RuntimePermission(\"setContextClassLoader\"),\n        \n      new SecurityPermission(\"getPolicy\"),\n      new SecurityPermission(\"setPolicy\"),\n      new RuntimePermission(\"setSecurityManager\"),\n        \n      new RuntimePermission(\"accessDeclaredMembers\"),\n      new PropertyPermission(\"*\", \"read\"),\n      new java.io.FilePermission(\"<<ALL FILES>>\", \"read\"));\n}",
        "summary_tokens": [
            "returns",
            "a",
            "policy",
            "containing",
            "all",
            "the",
            "permissions",
            "we",
            "ever",
            "need"
        ]
    },
    {
        "id": 538,
        "code": "void sleep(long millis) {\n  try {\n    delay(millis);\n  } catch (InterruptedException ie) {\n    AssertionFailedError afe = new AssertionFailedError(\"Unexpected InterruptedException\");\n    afe.initCause(ie);\n    throw afe;\n  }\n}",
        "summary_tokens": [
            "sleeps",
            "until",
            "the",
            "given",
            "time",
            "has",
            "elapsed"
        ]
    },
    {
        "id": 539,
        "code": "void waitForThreadToEnterWaitState(Thread thread) {\n  waitForThreadToEnterWaitState(thread, LONG_DELAY_MS);\n}",
        "summary_tokens": [
            "waits",
            "up",
            "to",
            "long",
            "delay",
            "ms",
            "for",
            "the",
            "given",
            "thread",
            "to",
            "enter",
            "a",
            "wait",
            "state",
            "blocked",
            "waiting",
            "or",
            "timed",
            "waiting"
        ]
    },
    {
        "id": 540,
        "code": "long millisElapsedSince(long startNanoTime) {\n  return NANOSECONDS.toMillis(System.nanoTime() - startNanoTime);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "milliseconds",
            "since",
            "time",
            "given",
            "by",
            "start",
            "nano",
            "time",
            "which",
            "must",
            "have",
            "been",
            "previously",
            "returned",
            "from",
            "a",
            "call",
            "to",
            "system",
            "nano",
            "time"
        ]
    },
    {
        "id": 541,
        "code": "Thread newStartedThread(Runnable runnable) {\n  Thread t = new Thread(runnable);\n  t.setDaemon(true);\n  t.start();\n  return t;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "started",
            "daemon",
            "thread",
            "running",
            "the",
            "given",
            "runnable"
        ]
    },
    {
        "id": 542,
        "code": "void awaitTermination(Thread t) {\n  awaitTermination(t, LONG_DELAY_MS);\n}",
        "summary_tokens": [
            "waits",
            "for",
            "long",
            "delay",
            "ms",
            "milliseconds",
            "for",
            "the",
            "thread",
            "to",
            "terminate",
            "using",
            "thread",
            "join",
            "long",
            "else",
            "interrupts",
            "the",
            "thread",
            "in",
            "the",
            "hope",
            "that",
            "it",
            "may",
            "terminate",
            "later",
            "and",
            "fails"
        ]
    },
    {
        "id": 543,
        "code": "public void testDirectExecutorService_awaitTermination_missedSignal() {\n  final ExecutorService service = MoreExecutors.newDirectExecutorService();\n  Thread waiter =\n      new Thread() {\n        @Override\n        public void run() {\n          try {\n            service.awaitTermination(1, TimeUnit.DAYS);\n          } catch (InterruptedException e) {\n            return;\n          }\n        }\n      };\n  waiter.start();\n  awaitTimedWaiting(waiter);\n  service.shutdown();\n  Uninterruptibles.joinUninterruptibly(waiter, 10, TimeUnit.SECONDS);\n  if (waiter.isAlive()) {\n    waiter.interrupt();\n    fail(\"awaitTermination failed to trigger after shutdown()\");\n  }\n}",
        "summary_tokens": [
            "test",
            "for",
            "a",
            "bug",
            "where",
            "threads",
            "weren",
            "t",
            "getting",
            "signaled",
            "when",
            "shutdown",
            "was",
            "called",
            "only",
            "when",
            "tasks",
            "completed"
        ]
    },
    {
        "id": 544,
        "code": "void awaitTimedWaiting(Thread thread) {\n  while (true) {\n    switch (thread.getState()) {\n      case BLOCKED:\n      case NEW:\n      case RUNNABLE:\n      case WAITING:\n        Thread.yield();\n        break;\n      case TIMED_WAITING:\n        return;\n      case TERMINATED:\n      default:\n        throw new AssertionError();\n    }\n  }\n}",
        "summary_tokens": [
            "wait",
            "for",
            "the",
            "given",
            "thread",
            "to",
            "reach",
            "the",
            "state",
            "timed",
            "waiting",
            "thread",
            "state"
        ]
    },
    {
        "id": 545,
        "code": "public void testInvokeAnyImpl_nullTasks() throws Exception {\n  ListeningExecutorService e = newDirectExecutorService();\n  try {\n    invokeAnyImpl(e, null, false, 0, TimeUnit.NANOSECONDS);\n    fail();\n  } catch (NullPointerException success) {\n  } finally {\n    joinPool(e);\n  }\n}",
        "summary_tokens": [
            "invoke",
            "any",
            "null",
            "throws",
            "npe"
        ]
    },
    {
        "id": 546,
        "code": "public void testInvokeAnyImpl_emptyTasks() throws Exception {\n  ListeningExecutorService e = newDirectExecutorService();\n  try {\n    invokeAnyImpl(e, new ArrayList<Callable<String>>(), false, 0, TimeUnit.NANOSECONDS);\n    fail();\n  } catch (IllegalArgumentException success) {\n  } finally {\n    joinPool(e);\n  }\n}",
        "summary_tokens": [
            "invoke",
            "any",
            "empty",
            "collection",
            "throws",
            "iae"
        ]
    },
    {
        "id": 547,
        "code": "public void testInvokeAnyImpl_nullElement() throws Exception {\n  ListeningExecutorService e = newDirectExecutorService();\n  List<Callable<Integer>> l = new ArrayList<>();\n  l.add(\n      new Callable<Integer>() {\n        @Override\n        public Integer call() {\n          throw new ArithmeticException(\"/ by zero\");\n        }\n      });\n  l.add(null);\n  try {\n    invokeAnyImpl(e, l, false, 0, TimeUnit.NANOSECONDS);\n    fail();\n  } catch (NullPointerException success) {\n  } finally {\n    joinPool(e);\n  }\n}",
        "summary_tokens": [
            "invoke",
            "any",
            "c",
            "throws",
            "npe",
            "if",
            "c",
            "has",
            "null",
            "elements"
        ]
    },
    {
        "id": 548,
        "code": "public void testInvokeAnyImpl_noTaskCompletes() throws Exception {\n  ListeningExecutorService e = newDirectExecutorService();\n  List<Callable<String>> l = new ArrayList<>();\n  l.add(new NPETask());\n  try {\n    invokeAnyImpl(e, l, false, 0, TimeUnit.NANOSECONDS);\n    fail();\n  } catch (ExecutionException success) {\n    assertThat(success).hasCauseThat().isInstanceOf(NullPointerException.class);\n  } finally {\n    joinPool(e);\n  }\n}",
        "summary_tokens": [
            "invoke",
            "any",
            "c",
            "throws",
            "execution",
            "exception",
            "if",
            "no",
            "task",
            "in",
            "c",
            "completes"
        ]
    },
    {
        "id": 549,
        "code": "public void testInvokeAnyImpl() throws Exception {\n  ListeningExecutorService e = newDirectExecutorService();\n  try {\n    List<Callable<String>> l = new ArrayList<>();\n    l.add(new StringTask());\n    l.add(new StringTask());\n    String result = invokeAnyImpl(e, l, false, 0, TimeUnit.NANOSECONDS);\n    assertSame(TEST_STRING, result);\n  } finally {\n    joinPool(e);\n  }\n}",
        "summary_tokens": [
            "invoke",
            "any",
            "c",
            "returns",
            "result",
            "of",
            "some",
            "task",
            "in",
            "c",
            "if",
            "at",
            "least",
            "one",
            "completes"
        ]
    },
    {
        "id": 550,
        "code": "public void testWeNeverGetABurstMoreThanOneSec() {\n  RateLimiter limiter = RateLimiter.create(1.0, stopwatch);\n  int[] rates = {1000, 1, 10, 1000000, 10, 1};\n  for (int rate : rates) {\n    int oneSecWorthOfWork = rate;\n    stopwatch.sleepMillis(rate * 1000);\n    limiter.setRate(rate);\n    long burst = measureTotalTimeMillis(limiter, oneSecWorthOfWork, new Random());\n      \n    assertTrue(burst <= 1000);\n    long afterBurst = measureTotalTimeMillis(limiter, oneSecWorthOfWork, new Random());\n      \n    assertTrue(afterBurst >= 1000);\n  }\n}",
        "summary_tokens": [
            "make",
            "sure",
            "that",
            "bursts",
            "can",
            "never",
            "go",
            "above",
            "0",
            "second",
            "worth",
            "of",
            "work",
            "for",
            "the",
            "current",
            "rate",
            "even",
            "when",
            "we",
            "change",
            "the",
            "rate"
        ]
    },
    {
        "id": 551,
        "code": "public void testTimeToWarmUpIsHonouredEvenWithWeights() {\n  Random random = new Random();\n  int warmupPermits = 10;\n  double[] coldFactorsToTest = {2.0, 3.0, 10.0};\n  double[] qpsToTest = {4.0, 2.0, 1.0, 0.5, 0.1};\n  for (int trial = 0; trial < 100; trial++) {\n    for (double coldFactor : coldFactorsToTest) {\n      for (double qps : qpsToTest) {\n          \n          \n        long warmupMillis = (long) ((1 + coldFactor) * warmupPermits / (2.0 * qps) * 1000.0);\n        RateLimiter rateLimiter =\n            RateLimiter.create(qps, warmupMillis, MILLISECONDS, coldFactor, stopwatch);\n        assertEquals(warmupMillis, measureTotalTimeMillis(rateLimiter, warmupPermits, random));\n      }\n    }\n  }\n}",
        "summary_tokens": [
            "this",
            "neat",
            "test",
            "shows",
            "that",
            "no",
            "matter",
            "what",
            "weights",
            "we",
            "use",
            "in",
            "our",
            "requests",
            "if",
            "we",
            "push",
            "x",
            "amount",
            "of",
            "permits",
            "in",
            "a",
            "cool",
            "state",
            "where",
            "x",
            "rate",
            "time",
            "to",
            "cool",
            "down",
            "and",
            "we",
            "have",
            "specified",
            "a",
            "time",
            "to",
            "warm",
            "up",
            "period",
            "it",
            "will",
            "cost",
            "as",
            "the",
            "prescribed",
            "amount",
            "of",
            "time"
        ]
    },
    {
        "id": 552,
        "code": "public void testSingleFailedServiceCallsStopped() {\n  Service a = new FailStartService();\n  ServiceManager manager = new ServiceManager(asList(a));\n  RecordingListener listener = new RecordingListener();\n  manager.addListener(listener, directExecutor());\n  try {\n    manager.startAsync().awaitHealthy();\n    fail();\n  } catch (IllegalStateException expected) {\n  }\n  assertTrue(listener.stoppedCalled);\n}",
        "summary_tokens": [
            "this",
            "covers",
            "a",
            "case",
            "where",
            "if",
            "the",
            "last",
            "service",
            "to",
            "stop",
            "failed",
            "then",
            "the",
            "stopped",
            "callback",
            "would",
            "never",
            "be",
            "called"
        ]
    },
    {
        "id": 553,
        "code": "public void testFailStart_singleServiceCallsHealthy() {\n  Service a = new FailStartService();\n  ServiceManager manager = new ServiceManager(asList(a));\n  RecordingListener listener = new RecordingListener();\n  manager.addListener(listener, directExecutor());\n  try {\n    manager.startAsync().awaitHealthy();\n    fail();\n  } catch (IllegalStateException expected) {\n  }\n  assertFalse(listener.healthyCalled);\n}",
        "summary_tokens": [
            "this",
            "covers",
            "a",
            "bug",
            "where",
            "listener"
        ]
    },
    {
        "id": 554,
        "code": "public void testFailStart_stopOthers() throws TimeoutException {\n  Service a = new FailStartService();\n  Service b = new NoOpService();\n  final ServiceManager manager = new ServiceManager(asList(a, b));\n  manager.addListener(\n      new Listener() {\n        @Override\n        public void failure(Service service) {\n          manager.stopAsync();\n        }\n      },\n      directExecutor());\n  manager.startAsync();\n  manager.awaitStopped(10, TimeUnit.MILLISECONDS);\n}",
        "summary_tokens": [
            "this",
            "covers",
            "a",
            "bug",
            "where",
            "if",
            "a",
            "listener",
            "was",
            "installed",
            "that",
            "would",
            "stop",
            "the",
            "manager",
            "if",
            "any",
            "service",
            "fails",
            "and",
            "something",
            "failed",
            "during",
            "startup",
            "before",
            "service"
        ]
    },
    {
        "id": 555,
        "code": "public void testEmptyServiceManager() {\n  Logger logger = Logger.getLogger(ServiceManager.class.getName());\n  logger.setLevel(Level.FINEST);\n  TestLogHandler logHandler = new TestLogHandler();\n  logger.addHandler(logHandler);\n  ServiceManager manager = new ServiceManager(Arrays.<Service>asList());\n  RecordingListener listener = new RecordingListener();\n  manager.addListener(listener, directExecutor());\n  manager.startAsync().awaitHealthy();\n  assertTrue(manager.isHealthy());\n  assertTrue(listener.healthyCalled);\n  assertFalse(listener.stoppedCalled);\n  assertTrue(listener.failedServices.isEmpty());\n  manager.stopAsync().awaitStopped();\n  assertFalse(manager.isHealthy());\n  assertTrue(listener.stoppedCalled);\n  assertTrue(listener.failedServices.isEmpty());\n    \n    \n  assertEquals(\"ServiceManager{services=[]}\", manager.toString());\n  assertTrue(manager.servicesByState().isEmpty());\n  assertTrue(manager.startupTimes().isEmpty());\n  Formatter logFormatter =\n      new Formatter() {\n        @Override\n        public String format(LogRecord record) {\n          return formatMessage(record);\n        }\n      };\n  for (LogRecord record : logHandler.getStoredLogRecords()) {\n    assertThat(logFormatter.format(record)).doesNotContain(\"NoOpService\");\n  }\n}",
        "summary_tokens": [
            "this",
            "is",
            "for",
            "covering",
            "a",
            "case",
            "where",
            "the",
            "service",
            "manager",
            "would",
            "behave",
            "strangely",
            "if",
            "constructed",
            "with",
            "no",
            "service",
            "under",
            "management"
        ]
    },
    {
        "id": 556,
        "code": "public void testListenerDeadlock() throws InterruptedException {\n  final CountDownLatch failEnter = new CountDownLatch(1);\n  final CountDownLatch failLeave = new CountDownLatch(1);\n  final CountDownLatch afterStarted = new CountDownLatch(1);\n  Service failRunService =\n      new AbstractService() {\n        @Override\n        protected void doStart() {\n          new Thread() {\n            @Override\n            public void run() {\n              notifyStarted();\n                \n                \n                \n              Uninterruptibles.awaitUninterruptibly(afterStarted);\n              notifyFailed(new Exception(\"boom\"));\n            }\n          }.start();\n        }\n\n        @Override\n        protected void doStop() {\n          notifyStopped();\n        }\n      };\n  final ServiceManager manager =\n      new ServiceManager(Arrays.asList(failRunService, new NoOpService()));\n  manager.addListener(\n      new ServiceManager.Listener() {\n        @Override\n        public void failure(Service service) {\n          failEnter.countDown();\n            \n          Uninterruptibles.awaitUninterruptibly(failLeave);\n        }\n      },\n      directExecutor());\n  manager.startAsync();\n  afterStarted.countDown();\n    \n    \n    \n  failEnter.await();\n  assertFalse(\"State should be updated before calling listeners\", manager.isHealthy());\n    \n  Thread stoppingThread =\n      new Thread() {\n        @Override\n        public void run() {\n          manager.stopAsync().awaitStopped();\n        }\n      };\n  stoppingThread.start();\n    \n  stoppingThread.join(1000);\n  assertFalse(\"stopAsync has deadlocked!.\", stoppingThread.isAlive());\n  failLeave.countDown(); \n}",
        "summary_tokens": [
            "tests",
            "that",
            "a",
            "service",
            "manager",
            "can",
            "be",
            "fully",
            "shut",
            "down",
            "if",
            "one",
            "of",
            "its",
            "failure",
            "listeners",
            "is",
            "slow",
            "or",
            "even",
            "permanently",
            "blocked"
        ]
    },
    {
        "id": 557,
        "code": "public void testPartiallyConstructedManager() {\n  Logger logger = Logger.getLogger(\"global\");\n  logger.setLevel(Level.FINEST);\n  TestLogHandler logHandler = new TestLogHandler();\n  logger.addHandler(logHandler);\n  NoOpService service = new NoOpService();\n  service.startAsync();\n  try {\n    new ServiceManager(Arrays.asList(service));\n    fail();\n  } catch (IllegalArgumentException expected) {\n  }\n  service.stopAsync();\n    \n  assertEquals(0, logHandler.getStoredLogRecords().size());\n}",
        "summary_tokens": [
            "catches",
            "a",
            "bug",
            "where",
            "when",
            "constructing",
            "a",
            "service",
            "manager",
            "failed",
            "later",
            "interactions",
            "with",
            "the",
            "service",
            "could",
            "cause",
            "illegal",
            "state",
            "exceptions",
            "inside",
            "the",
            "partially",
            "constructed",
            "service",
            "manager"
        ]
    },
    {
        "id": 558,
        "code": "public void testTransitionRace() throws TimeoutException {\n  for (int k = 0; k < 1000; k++) {\n    List<Service> services = Lists.newArrayList();\n    for (int i = 0; i < 5; i++) {\n      services.add(new SnappyShutdownService(i));\n    }\n    ServiceManager manager = new ServiceManager(services);\n    manager.startAsync().awaitHealthy();\n    manager.stopAsync().awaitStopped(10, TimeUnit.SECONDS);\n  }\n}",
        "summary_tokens": [
            "this",
            "test",
            "is",
            "for",
            "a",
            "case",
            "where",
            "two",
            "service"
        ]
    },
    {
        "id": 559,
        "code": "public void testStateOrdering() {\n    \n  assertLessThan(NEW, STARTING);\n  assertLessThan(NEW, TERMINATED);\n\n  assertLessThan(STARTING, RUNNING);\n  assertLessThan(STARTING, STOPPING);\n  assertLessThan(STARTING, FAILED);\n\n  assertLessThan(RUNNING, STOPPING);\n  assertLessThan(RUNNING, FAILED);\n\n  assertLessThan(STOPPING, FAILED);\n  assertLessThan(STOPPING, TERMINATED);\n}",
        "summary_tokens": [
            "assert",
            "on",
            "the",
            "comparison",
            "ordering",
            "of",
            "the",
            "state",
            "enum",
            "since",
            "we",
            "guarantee",
            "it"
        ]
    },
    {
        "id": 560,
        "code": "public void testCreate() throws Exception {\n  SettableFuture<Integer> future = SettableFuture.create();\n  assertFalse(future.isDone());\n  assertFalse(future.isCancelled());\n}",
        "summary_tokens": [
            "tests",
            "the",
            "initial",
            "state",
            "of",
            "the",
            "future"
        ]
    },
    {
        "id": 561,
        "code": "public void testBasicInvariants() {\n  for (Striped<?> striped : allImplementations()) {\n    assertBasicInvariants(striped);\n  }\n}",
        "summary_tokens": [
            "checks",
            "idempotency",
            "and",
            "that",
            "we",
            "observe",
            "the",
            "promised",
            "number",
            "of",
            "stripes"
        ]
    },
    {
        "id": 562,
        "code": "static <V> V getDoneFromTimeoutOverload(Future<V> future) throws ExecutionException {\n  checkState(future.isDone(), \"Future was expected to be done: %s\", future);\n  try {\n    return getUninterruptibly(future, 0, SECONDS);\n  } catch (TimeoutException e) {\n    AssertionFailedError error = new AssertionFailedError(e.getMessage());\n    error.initCause(e);\n    throw error;\n  }\n}",
        "summary_tokens": [
            "retrieves",
            "the",
            "result",
            "of",
            "a",
            "future",
            "known",
            "to",
            "be",
            "done",
            "but",
            "uses",
            "the",
            "get",
            "long",
            "time",
            "unit",
            "overload",
            "in",
            "order",
            "to",
            "test",
            "that",
            "method"
        ]
    },
    {
        "id": 563,
        "code": "public void callAndAssertReturns(int expected, String methodName, Object... arguments)\n    throws Exception {\n  checkNotNull(methodName);\n  checkNotNull(arguments);\n  sendRequest(methodName, arguments);\n  assertEquals(expected, getResponse(methodName).getResult());\n}",
        "summary_tokens": [
            "causes",
            "this",
            "thread",
            "to",
            "call",
            "the",
            "named",
            "method",
            "and",
            "asserts",
            "that",
            "the",
            "call",
            "returns",
            "the",
            "expected",
            "int",
            "value"
        ]
    },
    {
        "id": 564,
        "code": "public void callAndAssertThrows(\n    Class<? extends Throwable> expected, String methodName, Object... arguments)\n    throws Exception {\n  checkNotNull(expected);\n  checkNotNull(methodName);\n  checkNotNull(arguments);\n  sendRequest(methodName, arguments);\n  assertEquals(expected, getResponse(methodName).getThrowable().getClass());\n}",
        "summary_tokens": [
            "causes",
            "this",
            "thread",
            "to",
            "call",
            "the",
            "named",
            "method",
            "and",
            "asserts",
            "that",
            "the",
            "call",
            "throws",
            "the",
            "expected",
            "type",
            "of",
            "throwable"
        ]
    },
    {
        "id": 565,
        "code": "public void callAndAssertBlocks(String methodName, Object... arguments) throws Exception {\n  checkNotNull(methodName);\n  checkNotNull(arguments);\n  assertEquals(false, invokeMethod(\"hasQueuedThread\", this));\n  sendRequest(methodName, arguments);\n  Thread.sleep(DUE_DILIGENCE_MILLIS);\n  assertEquals(true, invokeMethod(\"hasQueuedThread\", this));\n  assertNull(responseQueue.poll());\n}",
        "summary_tokens": [
            "causes",
            "this",
            "thread",
            "to",
            "call",
            "the",
            "named",
            "method",
            "and",
            "asserts",
            "that",
            "this",
            "thread",
            "becomes",
            "blocked",
            "on",
            "the",
            "lock",
            "like",
            "object"
        ]
    },
    {
        "id": 566,
        "code": "public void callAndAssertWaits(String methodName, Object conditionLikeObject) throws Exception {\n  checkNotNull(methodName);\n  checkNotNull(conditionLikeObject);\n    \n    \n  sendRequest(methodName, conditionLikeObject);\n  Thread.sleep(DUE_DILIGENCE_MILLIS);\n  assertEquals(true, invokeMethod(\"hasWaiters\", conditionLikeObject));\n  assertNull(responseQueue.poll());\n}",
        "summary_tokens": [
            "causes",
            "this",
            "thread",
            "to",
            "call",
            "the",
            "named",
            "method",
            "and",
            "asserts",
            "that",
            "this",
            "thread",
            "thereby",
            "waits",
            "on",
            "the",
            "given",
            "condition",
            "like",
            "object"
        ]
    },
    {
        "id": 567,
        "code": "public void assertPriorCallReturns(boolean expected, @Nullable String methodName)\n    throws Exception {\n  assertEquals(expected, getResponse(methodName).getResult());\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "a",
            "prior",
            "call",
            "that",
            "had",
            "caused",
            "this",
            "thread",
            "to",
            "block",
            "or",
            "wait",
            "has",
            "since",
            "returned",
            "the",
            "expected",
            "boolean",
            "value"
        ]
    },
    {
        "id": 568,
        "code": "private void sendRequest(String methodName, Object... arguments) throws Exception {\n  if (!requestQueue.offer(\n      new Request(methodName, arguments), TIMEOUT_MILLIS, TimeUnit.MILLISECONDS)) {\n    throw new TimeoutException();\n  }\n}",
        "summary_tokens": [
            "sends",
            "the",
            "given",
            "method",
            "call",
            "to",
            "this",
            "thread"
        ]
    },
    {
        "id": 569,
        "code": "private Response getResponse(String methodName) throws Exception {\n  Response response = responseQueue.poll(TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);\n  if (response == null) {\n    throw new TimeoutException();\n  }\n  assertEquals(methodName, response.methodName);\n  return response;\n}",
        "summary_tokens": [
            "receives",
            "a",
            "response",
            "from",
            "this",
            "thread"
        ]
    },
    {
        "id": 570,
        "code": "public void testRegularFutureInterrupted() throws ExecutionException {\n\n    \n  InterruptionUtil.requestInterruptIn(200, TimeUnit.MILLISECONDS);\n\n  assertFalse(Thread.interrupted());\n  try {\n    delayedFuture.get(20000, TimeUnit.MILLISECONDS);\n    fail(\"expected to be interrupted\");\n  } catch (InterruptedException expected) {\n  } catch (TimeoutException e) {\n    throw new RuntimeException(e);\n  }\n\n    \n  assertFalse(Thread.interrupted());\n\n  assertFalse(sleeper.completed);\n  try {\n    assertTrue(delayedFuture.get());\n  } catch (InterruptedException e) {\n    throw new RuntimeException(e);\n  }\n  assertTrue(sleeper.completed);\n}",
        "summary_tokens": [
            "this",
            "first",
            "test",
            "doesn",
            "t",
            "test",
            "anything",
            "in",
            "uninterruptibles",
            "just",
            "demonstrates",
            "some",
            "normal",
            "behavior",
            "of",
            "futures",
            "so",
            "that",
            "you",
            "can",
            "contrast",
            "the",
            "next",
            "test",
            "with",
            "it"
        ]
    },
    {
        "id": 571,
        "code": "public void testMakeUninterruptible_plainFutureSanityCheck() throws Exception {\n  SettableFuture<String> future = SettableFuture.create();\n  FutureTask<Boolean> wasInterrupted = untimedInterruptReporter(future, true);\n\n  Thread waitingThread = new Thread(wasInterrupted);\n  waitingThread.start();\n  waitingThread.interrupt();\n  try {\n    wasInterrupted.get();\n    fail();\n  } catch (ExecutionException expected) {\n    assertTrue(\n        expected.getCause().toString(), expected.getCause() instanceof InterruptedException);\n  }\n}",
        "summary_tokens": [
            "confirms",
            "that",
            "the",
            "test",
            "code",
            "triggers",
            "interrupted",
            "exception",
            "in",
            "a",
            "standard",
            "future"
        ]
    },
    {
        "id": 572,
        "code": "private static void assertInterrupted() {\n  try {\n      \n    Thread.sleep(LONG_DELAY_MS);\n    fail(\"Dude, where's my interrupt?\");\n  } catch (InterruptedException expected) {\n  }\n}",
        "summary_tokens": [
            "await",
            "an",
            "interrupt",
            "then",
            "clear",
            "the",
            "interrupt",
            "status"
        ]
    },
    {
        "id": 573,
        "code": "public static char toLowerCase(char c) {\n  return isUpperCase(c) ? (char) (c ^ CASE_MASK) : c;\n}",
        "summary_tokens": [
            "if",
            "the",
            "argument",
            "is",
            "an",
            "is",
            "upper",
            "case",
            "char",
            "uppercase",
            "ascii",
            "character",
            "returns",
            "the",
            "lowercase",
            "equivalent"
        ]
    },
    {
        "id": 574,
        "code": "public static char toUpperCase(char c) {\n  return isLowerCase(c) ? (char) (c ^ CASE_MASK) : c;\n}",
        "summary_tokens": [
            "if",
            "the",
            "argument",
            "is",
            "a",
            "is",
            "lower",
            "case",
            "char",
            "lowercase",
            "ascii",
            "character",
            "returns",
            "the",
            "uppercase",
            "equivalent"
        ]
    },
    {
        "id": 575,
        "code": "public static boolean isLowerCase(char c) {\n    \n    \n  return (c >= 'a') && (c <= 'z');\n}",
        "summary_tokens": [
            "indicates",
            "whether",
            "c",
            "is",
            "one",
            "of",
            "the",
            "twenty",
            "six",
            "lowercase",
            "ascii",
            "alphabetic",
            "characters",
            "between",
            "a",
            "and",
            "z",
            "inclusive"
        ]
    },
    {
        "id": 576,
        "code": "public static boolean isUpperCase(char c) {\n  return (c >= 'A') && (c <= 'Z');\n}",
        "summary_tokens": [
            "indicates",
            "whether",
            "c",
            "is",
            "one",
            "of",
            "the",
            "twenty",
            "six",
            "uppercase",
            "ascii",
            "alphabetic",
            "characters",
            "between",
            "a",
            "and",
            "z",
            "inclusive"
        ]
    },
    {
        "id": 577,
        "code": "public static String truncate(CharSequence seq, int maxLength, String truncationIndicator) {\n  checkNotNull(seq);\n\n    \n  int truncationLength = maxLength - truncationIndicator.length();\n\n    \n    \n  checkArgument(\n      truncationLength >= 0,\n      \"maxLength (%s) must be >= length of the truncation indicator (%s)\",\n      maxLength,\n      truncationIndicator.length());\n\n  if (seq.length() <= maxLength) {\n    String string = seq.toString();\n    if (string.length() <= maxLength) {\n      return string;\n    }\n      \n    seq = string;\n  }\n\n  return new StringBuilder(maxLength)\n      .append(seq, 0, truncationLength)\n      .append(truncationIndicator)\n      .toString();\n}",
        "summary_tokens": [
            "truncates",
            "the",
            "given",
            "character",
            "sequence",
            "to",
            "the",
            "given",
            "maximum",
            "length"
        ]
    },
    {
        "id": 578,
        "code": "public static boolean equalsIgnoreCase(CharSequence s1, CharSequence s2) {\n    \n  int length = s1.length();\n  if (s1 == s2) {\n    return true;\n  }\n  if (length != s2.length()) {\n    return false;\n  }\n  for (int i = 0; i < length; i++) {\n    char c1 = s1.charAt(i);\n    char c2 = s2.charAt(i);\n    if (c1 == c2) {\n      continue;\n    }\n    int alphaIndex = getAlphaIndex(c1);\n      \n      \n    if (alphaIndex < 26 && alphaIndex == getAlphaIndex(c2)) {\n      continue;\n    }\n    return false;\n  }\n  return true;\n}",
        "summary_tokens": [
            "indicates",
            "whether",
            "the",
            "contents",
            "of",
            "the",
            "given",
            "character",
            "sequences",
            "s",
            "0",
            "and",
            "s",
            "0",
            "are",
            "equal",
            "ignoring",
            "the",
            "case",
            "of",
            "any",
            "ascii",
            "alphabetic",
            "characters",
            "between",
            "a",
            "and",
            "z",
            "or",
            "a",
            "and",
            "z",
            "inclusive"
        ]
    },
    {
        "id": 579,
        "code": "private static int getAlphaIndex(char c) {\n    \n  return (char) ((c | CASE_MASK) - 'a');\n}",
        "summary_tokens": [
            "returns",
            "the",
            "non",
            "negative",
            "index",
            "value",
            "of",
            "the",
            "alpha",
            "character",
            "c",
            "regardless",
            "of",
            "case"
        ]
    },
    {
        "id": 580,
        "code": "public static CharMatcher whitespace() {\n  return Whitespace.INSTANCE;\n}",
        "summary_tokens": [
            "determines",
            "whether",
            "a",
            "character",
            "is",
            "whitespace",
            "according",
            "to",
            "the",
            "latest",
            "unicode",
            "standard",
            "as",
            "illustrated",
            "a",
            "href",
            "http",
            "unicode"
        ]
    },
    {
        "id": 581,
        "code": "public static CharMatcher breakingWhitespace() {\n  return BreakingWhitespace.INSTANCE;\n}",
        "summary_tokens": [
            "determines",
            "whether",
            "a",
            "character",
            "is",
            "a",
            "breaking",
            "whitespace",
            "that",
            "is",
            "a",
            "whitespace",
            "which",
            "can",
            "be",
            "interpreted",
            "as",
            "a",
            "break",
            "between",
            "words",
            "for",
            "formatting",
            "purposes"
        ]
    },
    {
        "id": 582,
        "code": "public static CharMatcher ascii() {\n  return Ascii.INSTANCE;\n}",
        "summary_tokens": [
            "determines",
            "whether",
            "a",
            "character",
            "is",
            "ascii",
            "meaning",
            "that",
            "its",
            "code",
            "point",
            "is",
            "less",
            "than",
            "0"
        ]
    },
    {
        "id": 583,
        "code": "public static CharMatcher digit() {\n  return Digit.INSTANCE;\n}",
        "summary_tokens": [
            "determines",
            "whether",
            "a",
            "character",
            "is",
            "a",
            "bmp",
            "digit",
            "according",
            "to",
            "a",
            "href",
            "http",
            "unicode"
        ]
    },
    {
        "id": 584,
        "code": "public static CharMatcher javaDigit() {\n  return JavaDigit.INSTANCE;\n}",
        "summary_tokens": [
            "determines",
            "whether",
            "a",
            "character",
            "is",
            "a",
            "bmp",
            "digit",
            "according",
            "to",
            "character",
            "is",
            "digit",
            "char",
            "java",
            "s",
            "definition"
        ]
    },
    {
        "id": 585,
        "code": "public static CharMatcher javaLetter() {\n  return JavaLetter.INSTANCE;\n}",
        "summary_tokens": [
            "determines",
            "whether",
            "a",
            "character",
            "is",
            "a",
            "bmp",
            "letter",
            "according",
            "to",
            "character",
            "is",
            "letter",
            "char",
            "java",
            "s",
            "definition"
        ]
    },
    {
        "id": 586,
        "code": "public static CharMatcher javaLetterOrDigit() {\n  return JavaLetterOrDigit.INSTANCE;\n}",
        "summary_tokens": [
            "determines",
            "whether",
            "a",
            "character",
            "is",
            "a",
            "bmp",
            "letter",
            "or",
            "digit",
            "according",
            "to",
            "character",
            "is",
            "letter",
            "or",
            "digit",
            "char",
            "java",
            "s",
            "definition"
        ]
    },
    {
        "id": 587,
        "code": "public static CharMatcher javaUpperCase() {\n  return JavaUpperCase.INSTANCE;\n}",
        "summary_tokens": [
            "determines",
            "whether",
            "a",
            "bmp",
            "character",
            "is",
            "upper",
            "case",
            "according",
            "to",
            "character",
            "is",
            "upper",
            "case",
            "char",
            "java",
            "s",
            "definition"
        ]
    },
    {
        "id": 588,
        "code": "public static CharMatcher javaLowerCase() {\n  return JavaLowerCase.INSTANCE;\n}",
        "summary_tokens": [
            "determines",
            "whether",
            "a",
            "bmp",
            "character",
            "is",
            "lower",
            "case",
            "according",
            "to",
            "character",
            "is",
            "lower",
            "case",
            "char",
            "java",
            "s",
            "definition"
        ]
    },
    {
        "id": 589,
        "code": "public static CharMatcher javaIsoControl() {\n  return JavaIsoControl.INSTANCE;\n}",
        "summary_tokens": [
            "determines",
            "whether",
            "a",
            "character",
            "is",
            "an",
            "iso",
            "control",
            "character",
            "as",
            "specified",
            "by",
            "character",
            "is",
            "isocontrol",
            "char"
        ]
    },
    {
        "id": 590,
        "code": "public static CharMatcher invisible() {\n  return Invisible.INSTANCE;\n}",
        "summary_tokens": [
            "determines",
            "whether",
            "a",
            "character",
            "is",
            "invisible",
            "that",
            "is",
            "if",
            "its",
            "unicode",
            "category",
            "is",
            "any",
            "of",
            "space",
            "separator",
            "line",
            "separator",
            "paragraph",
            "separator",
            "control",
            "format",
            "surrogate",
            "and",
            "private",
            "use",
            "according",
            "to",
            "icu",
            "0",
            "j"
        ]
    },
    {
        "id": 591,
        "code": "public static CharMatcher singleWidth() {\n  return SingleWidth.INSTANCE;\n}",
        "summary_tokens": [
            "determines",
            "whether",
            "a",
            "character",
            "is",
            "single",
            "width",
            "not",
            "double",
            "width"
        ]
    },
    {
        "id": 592,
        "code": "public static CharMatcher is(final char match) {\n  return new Is(match);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "char",
            "matcher",
            "that",
            "matches",
            "only",
            "one",
            "specified",
            "bmp",
            "character"
        ]
    },
    {
        "id": 593,
        "code": "public static CharMatcher isNot(final char match) {\n  return new IsNot(match);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "char",
            "matcher",
            "that",
            "matches",
            "any",
            "character",
            "except",
            "the",
            "bmp",
            "character",
            "specified"
        ]
    },
    {
        "id": 594,
        "code": "public static CharMatcher anyOf(final CharSequence sequence) {\n  switch (sequence.length()) {\n    case 0:\n      return none();\n    case 1:\n      return is(sequence.charAt(0));\n    case 2:\n      return isEither(sequence.charAt(0), sequence.charAt(1));\n    default:\n        \n        \n      return new AnyOf(sequence);\n  }\n}",
        "summary_tokens": [
            "returns",
            "a",
            "char",
            "matcher",
            "that",
            "matches",
            "any",
            "bmp",
            "character",
            "present",
            "in",
            "the",
            "given",
            "character",
            "sequence"
        ]
    },
    {
        "id": 595,
        "code": "public static CharMatcher noneOf(CharSequence sequence) {\n  return anyOf(sequence).negate();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "char",
            "matcher",
            "that",
            "matches",
            "any",
            "bmp",
            "character",
            "not",
            "present",
            "in",
            "the",
            "given",
            "character",
            "sequence"
        ]
    },
    {
        "id": 596,
        "code": "public static CharMatcher inRange(final char startInclusive, final char endInclusive) {\n  return new InRange(startInclusive, endInclusive);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "char",
            "matcher",
            "that",
            "matches",
            "any",
            "character",
            "in",
            "a",
            "given",
            "bmp",
            "range",
            "both",
            "endpoints",
            "are",
            "inclusive"
        ]
    },
    {
        "id": 597,
        "code": "public static CharMatcher forPredicate(final Predicate<? super Character> predicate) {\n  return predicate instanceof CharMatcher ? (CharMatcher) predicate : new ForPredicate(predicate);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "matcher",
            "with",
            "identical",
            "behavior",
            "to",
            "the",
            "given",
            "character",
            "based",
            "predicate",
            "but",
            "which",
            "operates",
            "on",
            "primitive",
            "char",
            "instances",
            "instead"
        ]
    },
    {
        "id": 598,
        "code": "public CharMatcher negate() {\n  return new Negated(this);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "matcher",
            "that",
            "matches",
            "any",
            "character",
            "not",
            "matched",
            "by",
            "this",
            "matcher"
        ]
    },
    {
        "id": 599,
        "code": "public CharMatcher and(CharMatcher other) {\n  return new And(this, other);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "matcher",
            "that",
            "matches",
            "any",
            "character",
            "matched",
            "by",
            "both",
            "this",
            "matcher",
            "and",
            "other"
        ]
    },
    {
        "id": 600,
        "code": "public CharMatcher or(CharMatcher other) {\n  return new Or(this, other);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "matcher",
            "that",
            "matches",
            "any",
            "character",
            "matched",
            "by",
            "either",
            "this",
            "matcher",
            "or",
            "other"
        ]
    },
    {
        "id": 601,
        "code": "public CharMatcher precomputed() {\n  return Platform.precomputeCharMatcher(this);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "char",
            "matcher",
            "functionally",
            "equivalent",
            "to",
            "this",
            "one",
            "but",
            "which",
            "may",
            "be",
            "faster",
            "to",
            "query",
            "than",
            "the",
            "original",
            "your",
            "mileage",
            "may",
            "vary"
        ]
    },
    {
        "id": 602,
        "code": "CharMatcher precomputedInternal() {\n  final BitSet table = new BitSet();\n  setBits(table);\n  int totalCharacters = table.cardinality();\n  if (totalCharacters * 2 <= DISTINCT_CHARS) {\n    return precomputedPositive(totalCharacters, table, toString());\n  } else {\n      \n    table.flip(Character.MIN_VALUE, Character.MAX_VALUE + 1);\n    int negatedCharacters = DISTINCT_CHARS - totalCharacters;\n    String suffix = \".negate()\";\n    final String description = toString();\n    String negatedDescription =\n        description.endsWith(suffix)\n            ? description.substring(0, description.length() - suffix.length())\n            : description + suffix;\n    return new NegatedFastMatcher(\n        precomputedPositive(negatedCharacters, table, negatedDescription)) {\n      @Override\n      public String toString() {\n        return description;\n      }\n    };\n  }\n}",
        "summary_tokens": [
            "this",
            "is",
            "the",
            "actual",
            "implementation",
            "of",
            "precomputed",
            "but",
            "we",
            "bounce",
            "calls",
            "through",
            "a",
            "method",
            "on",
            "platform",
            "so",
            "that",
            "we",
            "can",
            "have",
            "different",
            "behavior",
            "in",
            "gwt"
        ]
    },
    {
        "id": 603,
        "code": "private static CharMatcher precomputedPositive(\n    int totalCharacters, BitSet table, String description) {\n  switch (totalCharacters) {\n    case 0:\n      return none();\n    case 1:\n      return is((char) table.nextSetBit(0));\n    case 2:\n      char c1 = (char) table.nextSetBit(0);\n      char c2 = (char) table.nextSetBit(c1 + 1);\n      return isEither(c1, c2);\n    default:\n      return isSmall(totalCharacters, table.length())\n          ? SmallCharMatcher.from(table, description)\n          : new BitSetMatcher(table, description);\n  }\n}",
        "summary_tokens": [
            "helper",
            "method",
            "for",
            "precomputed",
            "internal",
            "that",
            "doesn",
            "t",
            "test",
            "if",
            "the",
            "negation",
            "is",
            "cheaper"
        ]
    },
    {
        "id": 604,
        "code": "void setBits(BitSet table) {\n  for (int c = Character.MAX_VALUE; c >= Character.MIN_VALUE; c--) {\n    if (matches((char) c)) {\n      table.set(c);\n    }\n  }\n}",
        "summary_tokens": [
            "sets",
            "bits",
            "in",
            "table",
            "matched",
            "by",
            "this",
            "matcher"
        ]
    },
    {
        "id": 605,
        "code": "public boolean matchesAnyOf(CharSequence sequence) {\n  return !matchesNoneOf(sequence);\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "a",
            "character",
            "sequence",
            "contains",
            "at",
            "least",
            "one",
            "matching",
            "bmp",
            "character"
        ]
    },
    {
        "id": 606,
        "code": "public boolean matchesAllOf(CharSequence sequence) {\n  for (int i = sequence.length() - 1; i >= 0; i--) {\n    if (!matches(sequence.charAt(i))) {\n      return false;\n    }\n  }\n  return true;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "a",
            "character",
            "sequence",
            "contains",
            "only",
            "matching",
            "bmp",
            "characters"
        ]
    },
    {
        "id": 607,
        "code": "public boolean matchesNoneOf(CharSequence sequence) {\n  return indexIn(sequence) == -1;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "a",
            "character",
            "sequence",
            "contains",
            "no",
            "matching",
            "bmp",
            "characters"
        ]
    },
    {
        "id": 608,
        "code": "public int indexIn(CharSequence sequence, int start) {\n  int length = sequence.length();\n  checkPositionIndex(start, length);\n  for (int i = start; i < length; i++) {\n    if (matches(sequence.charAt(i))) {\n      return i;\n    }\n  }\n  return -1;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "index",
            "of",
            "the",
            "first",
            "matching",
            "bmp",
            "character",
            "in",
            "a",
            "character",
            "sequence",
            "starting",
            "from",
            "a",
            "given",
            "position",
            "or",
            "0",
            "if",
            "no",
            "character",
            "matches",
            "after",
            "that",
            "position"
        ]
    },
    {
        "id": 609,
        "code": "public int lastIndexIn(CharSequence sequence) {\n  for (int i = sequence.length() - 1; i >= 0; i--) {\n    if (matches(sequence.charAt(i))) {\n      return i;\n    }\n  }\n  return -1;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "index",
            "of",
            "the",
            "last",
            "matching",
            "bmp",
            "character",
            "in",
            "a",
            "character",
            "sequence",
            "or",
            "0",
            "if",
            "no",
            "matching",
            "character",
            "is",
            "present"
        ]
    },
    {
        "id": 610,
        "code": "public int countIn(CharSequence sequence) {\n  int count = 0;\n  for (int i = 0; i < sequence.length(); i++) {\n    if (matches(sequence.charAt(i))) {\n      count++;\n    }\n  }\n  return count;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "matching",
            "char",
            "s",
            "found",
            "in",
            "a",
            "character",
            "sequence"
        ]
    },
    {
        "id": 611,
        "code": "public String removeFrom(CharSequence sequence) {\n  String string = sequence.toString();\n  int pos = indexIn(string);\n  if (pos == -1) {\n    return string;\n  }\n\n  char[] chars = string.toCharArray();\n  int spread = 1;\n\n    \n  OUT:\n  while (true) {\n    pos++;\n    while (true) {\n      if (pos == chars.length) {\n        break OUT;\n      }\n      if (matches(chars[pos])) {\n        break;\n      }\n      chars[pos - spread] = chars[pos];\n      pos++;\n    }\n    spread++;\n  }\n  return new String(chars, 0, pos - spread);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "string",
            "containing",
            "all",
            "non",
            "matching",
            "characters",
            "of",
            "a",
            "character",
            "sequence",
            "in",
            "order"
        ]
    },
    {
        "id": 612,
        "code": "public String retainFrom(CharSequence sequence) {\n  return negate().removeFrom(sequence);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "string",
            "containing",
            "all",
            "matching",
            "bmp",
            "characters",
            "of",
            "a",
            "character",
            "sequence",
            "in",
            "order"
        ]
    },
    {
        "id": 613,
        "code": "public String replaceFrom(CharSequence sequence, CharSequence replacement) {\n  int replacementLen = replacement.length();\n  if (replacementLen == 0) {\n    return removeFrom(sequence);\n  }\n  if (replacementLen == 1) {\n    return replaceFrom(sequence, replacement.charAt(0));\n  }\n\n  String string = sequence.toString();\n  int pos = indexIn(string);\n  if (pos == -1) {\n    return string;\n  }\n\n  int len = string.length();\n  StringBuilder buf = new StringBuilder((len * 3 / 2) + 16);\n\n  int oldpos = 0;\n  do {\n    buf.append(string, oldpos, pos);\n    buf.append(replacement);\n    oldpos = pos + 1;\n    pos = indexIn(string, oldpos);\n  } while (pos != -1);\n\n  buf.append(string, oldpos, len);\n  return buf.toString();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "string",
            "copy",
            "of",
            "the",
            "input",
            "character",
            "sequence",
            "with",
            "each",
            "matching",
            "bmp",
            "character",
            "replaced",
            "by",
            "a",
            "given",
            "replacement",
            "sequence"
        ]
    },
    {
        "id": 614,
        "code": "public String trimFrom(CharSequence sequence) {\n  int len = sequence.length();\n  int first;\n  int last;\n\n  for (first = 0; first < len; first++) {\n    if (!matches(sequence.charAt(first))) {\n      break;\n    }\n  }\n  for (last = len - 1; last > first; last--) {\n    if (!matches(sequence.charAt(last))) {\n      break;\n    }\n  }\n\n  return sequence.subSequence(first, last + 1).toString();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "substring",
            "of",
            "the",
            "input",
            "character",
            "sequence",
            "that",
            "omits",
            "all",
            "matching",
            "bmp",
            "characters",
            "from",
            "the",
            "beginning",
            "and",
            "from",
            "the",
            "end",
            "of",
            "the",
            "string"
        ]
    },
    {
        "id": 615,
        "code": "public String trimLeadingFrom(CharSequence sequence) {\n  int len = sequence.length();\n  for (int first = 0; first < len; first++) {\n    if (!matches(sequence.charAt(first))) {\n      return sequence.subSequence(first, len).toString();\n    }\n  }\n  return \"\";\n}",
        "summary_tokens": [
            "returns",
            "a",
            "substring",
            "of",
            "the",
            "input",
            "character",
            "sequence",
            "that",
            "omits",
            "all",
            "matching",
            "bmp",
            "characters",
            "from",
            "the",
            "beginning",
            "of",
            "the",
            "string"
        ]
    },
    {
        "id": 616,
        "code": "public String trimTrailingFrom(CharSequence sequence) {\n  int len = sequence.length();\n  for (int last = len - 1; last >= 0; last--) {\n    if (!matches(sequence.charAt(last))) {\n      return sequence.subSequence(0, last + 1).toString();\n    }\n  }\n  return \"\";\n}",
        "summary_tokens": [
            "returns",
            "a",
            "substring",
            "of",
            "the",
            "input",
            "character",
            "sequence",
            "that",
            "omits",
            "all",
            "matching",
            "bmp",
            "characters",
            "from",
            "the",
            "end",
            "of",
            "the",
            "string"
        ]
    },
    {
        "id": 617,
        "code": "public String collapseFrom(CharSequence sequence, char replacement) {\n    \n  int len = sequence.length();\n  for (int i = 0; i < len; i++) {\n    char c = sequence.charAt(i);\n    if (matches(c)) {\n      if (c == replacement && (i == len - 1 || !matches(sequence.charAt(i + 1)))) {\n          \n        i++;\n      } else {\n        StringBuilder builder = new StringBuilder(len).append(sequence, 0, i).append(replacement);\n        return finishCollapseFrom(sequence, i + 1, len, replacement, builder, true);\n      }\n    }\n  }\n    \n  return sequence.toString();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "string",
            "copy",
            "of",
            "the",
            "input",
            "character",
            "sequence",
            "with",
            "each",
            "group",
            "of",
            "consecutive",
            "matching",
            "bmp",
            "characters",
            "replaced",
            "by",
            "a",
            "single",
            "replacement",
            "character"
        ]
    },
    {
        "id": 618,
        "code": "public String trimAndCollapseFrom(CharSequence sequence, char replacement) {\n    \n  int len = sequence.length();\n  int first = 0;\n  int last = len - 1;\n\n  while (first < len && matches(sequence.charAt(first))) {\n    first++;\n  }\n\n  while (last > first && matches(sequence.charAt(last))) {\n    last--;\n  }\n\n  return (first == 0 && last == len - 1)\n      ? collapseFrom(sequence, replacement)\n      : finishCollapseFrom(\n          sequence, first, last + 1, replacement, new StringBuilder(last + 1 - first), false);\n}",
        "summary_tokens": [
            "collapses",
            "groups",
            "of",
            "matching",
            "characters",
            "exactly",
            "as",
            "collapse",
            "from",
            "does",
            "except",
            "that",
            "groups",
            "of",
            "matching",
            "bmp",
            "characters",
            "at",
            "the",
            "start",
            "or",
            "end",
            "of",
            "the",
            "sequence",
            "are",
            "removed",
            "without",
            "replacement"
        ]
    },
    {
        "id": 619,
        "code": "public boolean apply(Character character) {\n  return matches(character);\n}",
        "summary_tokens": [
            "provided",
            "only",
            "to",
            "satisfy",
            "the",
            "predicate",
            "interface",
            "use",
            "matches",
            "instead"
        ]
    },
    {
        "id": 620,
        "code": "public String toString() {\n  return super.toString();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "string",
            "representation",
            "of",
            "this",
            "char",
            "matcher",
            "such",
            "as",
            "char",
            "matcher"
        ]
    },
    {
        "id": 621,
        "code": "private static String showCharacter(char c) {\n  String hex = \"0123456789ABCDEF\";\n  char[] tmp = {'\\\\', 'u', '\\0', '\\0', '\\0', '\\0'};\n  for (int i = 0; i < 4; i++) {\n    tmp[5 - i] = hex.charAt(c & 0xF);\n    c = (char) (c >> 4);\n  }\n  return String.copyValueOf(tmp);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "java",
            "unicode",
            "escape",
            "sequence",
            "for",
            "the",
            "given",
            "char",
            "in",
            "the",
            "form",
            "where",
            "0",
            "ab",
            "is",
            "the",
            "four",
            "hexadecimal",
            "digits",
            "representing",
            "the",
            "0",
            "bit",
            "code",
            "unit"
        ]
    },
    {
        "id": 622,
        "code": "public final B convert(@CheckForNull A a) {\n  return correctedDoForward(a);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "representation",
            "of",
            "a",
            "as",
            "an",
            "instance",
            "of",
            "type",
            "b"
        ]
    },
    {
        "id": 623,
        "code": "public Iterable<B> convertAll(Iterable<? extends A> fromIterable) {\n  checkNotNull(fromIterable, \"fromIterable\");\n  return new Iterable<B>() {\n    @Override\n    public Iterator<B> iterator() {\n      return new Iterator<B>() {\n        private final Iterator<? extends A> fromIterator = fromIterable.iterator();\n\n        @Override\n        public boolean hasNext() {\n          return fromIterator.hasNext();\n        }\n\n        @Override\n        @SuppressWarnings(\"nullness\") \n        @CheckForNull\n        public B next() {\n          return convert(fromIterator.next());\n        }\n\n        @Override\n        public void remove() {\n          fromIterator.remove();\n        }\n      };\n    }\n  };\n}",
        "summary_tokens": [
            "returns",
            "an",
            "iterable",
            "that",
            "applies",
            "convert",
            "to",
            "each",
            "element",
            "of",
            "from",
            "iterable"
        ]
    },
    {
        "id": 624,
        "code": "public Converter<B, A> reverse() {\n  Converter<B, A> result = reverse;\n  return (result == null) ? reverse = new ReverseConverter<>(this) : result;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "reversed",
            "view",
            "of",
            "this",
            "converter",
            "which",
            "converts",
            "this"
        ]
    },
    {
        "id": 625,
        "code": "public final <C> Converter<A, C> andThen(Converter<B, C> secondConverter) {\n  return doAndThen(secondConverter);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "converter",
            "whose",
            "convert",
            "method",
            "applies",
            "second",
            "converter",
            "to",
            "the",
            "result",
            "of",
            "this",
            "converter"
        ]
    },
    {
        "id": 626,
        "code": "<C> Converter<A, C> doAndThen(Converter<B, C> secondConverter) {\n  return new ConverterComposition<>(this, checkNotNull(secondConverter));\n}",
        "summary_tokens": [
            "package",
            "private",
            "non",
            "final",
            "implementation",
            "of",
            "and",
            "then",
            "so",
            "only",
            "we",
            "can",
            "override",
            "it"
        ]
    },
    {
        "id": 627,
        "code": "public final B apply(@CheckForNull A a) {\n  return convert(a);\n}",
        "summary_tokens": [
            "provided",
            "to",
            "satisfy",
            "the",
            "function",
            "interface",
            "use",
            "convert",
            "instead"
        ]
    },
    {
        "id": 628,
        "code": "public boolean equals(@CheckForNull Object object) {\n  return super.equals(object);\n}",
        "summary_tokens": [
            "indicates",
            "whether",
            "another",
            "object",
            "is",
            "equal",
            "to",
            "this",
            "converter"
        ]
    },
    {
        "id": 629,
        "code": "public static <A, B> Converter<A, B> from(\n    Function<? super A, ? extends B> forwardFunction,\n    Function<? super B, ? extends A> backwardFunction) {\n  return new FunctionBasedConverter<>(forwardFunction, backwardFunction);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "converter",
            "based",
            "on",
            "separate",
            "forward",
            "and",
            "backward",
            "functions"
        ]
    },
    {
        "id": 630,
        "code": "public static <T> Converter<T, T> identity() {\n  return (IdentityConverter<T>) IdentityConverter.INSTANCE;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "serializable",
            "converter",
            "that",
            "always",
            "converts",
            "or",
            "reverses",
            "an",
            "object",
            "to",
            "itself"
        ]
    },
    {
        "id": 631,
        "code": "public static <T> T defaultValue(Class<T> type) {\n  checkNotNull(type);\n  if (type.isPrimitive()) {\n    if (type == boolean.class) {\n      return (T) Boolean.FALSE;\n    } else if (type == char.class) {\n      return (T) Character.valueOf('\\0');\n    } else if (type == byte.class) {\n      return (T) Byte.valueOf((byte) 0);\n    } else if (type == short.class) {\n      return (T) Short.valueOf((short) 0);\n    } else if (type == int.class) {\n      return (T) Integer.valueOf(0);\n    } else if (type == long.class) {\n      return (T) Long.valueOf(0L);\n    } else if (type == float.class) {\n      return (T) FLOAT_DEFAULT;\n    } else if (type == double.class) {\n      return (T) DOUBLE_DEFAULT;\n    }\n  }\n  return null;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "default",
            "value",
            "of",
            "type",
            "as",
            "defined",
            "by",
            "jls",
            "0",
            "for",
            "numbers",
            "false",
            "for",
            "boolean",
            "and",
            "0",
            "for",
            "char"
        ]
    },
    {
        "id": 632,
        "code": "public static Field getField(Enum<?> enumValue) {\n  Class<?> clazz = enumValue.getDeclaringClass();\n  try {\n    return clazz.getDeclaredField(enumValue.name());\n  } catch (NoSuchFieldException impossible) {\n    throw new AssertionError(impossible);\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "field",
            "in",
            "which",
            "enum",
            "value",
            "is",
            "defined"
        ]
    },
    {
        "id": 633,
        "code": "public static <T extends Enum<T>> Optional<T> getIfPresent(Class<T> enumClass, String value) {\n  checkNotNull(enumClass);\n  checkNotNull(value);\n  return Platform.getEnumIfPresent(enumClass, value);\n}",
        "summary_tokens": [
            "returns",
            "an",
            "optional",
            "enum",
            "constant",
            "for",
            "the",
            "given",
            "type",
            "using",
            "enum",
            "value",
            "of"
        ]
    },
    {
        "id": 634,
        "code": "public static <T extends Enum<T>> Converter<String, T> stringConverter(Class<T> enumClass) {\n  return new StringConverter<>(enumClass);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "converter",
            "that",
            "converts",
            "between",
            "strings",
            "and",
            "enum",
            "values",
            "of",
            "type",
            "enum",
            "class",
            "using",
            "enum",
            "value",
            "of",
            "class",
            "string",
            "and",
            "enum",
            "name"
        ]
    },
    {
        "id": 635,
        "code": "void cleanUp() {\n  if (threadStarted) {\n    return;\n  }\n\n  Reference<?> reference;\n  while ((reference = queue.poll()) != null) {\n      \n    reference.clear();\n    try {\n      ((FinalizableReference) reference).finalizeReferent();\n    } catch (Throwable t) {\n      logger.log(Level.SEVERE, \"Error cleaning up after reference.\", t);\n    }\n  }\n}",
        "summary_tokens": [
            "repeatedly",
            "dequeues",
            "references",
            "from",
            "the",
            "queue",
            "and",
            "invokes",
            "finalizable",
            "reference",
            "finalize",
            "referent",
            "on",
            "them",
            "until",
            "the",
            "queue",
            "is",
            "empty"
        ]
    },
    {
        "id": 636,
        "code": "private static Class<?> loadFinalizer(FinalizerLoader... loaders) {\n  for (FinalizerLoader loader : loaders) {\n    Class<?> finalizer = loader.loadFinalizer();\n    if (finalizer != null) {\n      return finalizer;\n    }\n  }\n\n  throw new AssertionError();\n}",
        "summary_tokens": [
            "iterates",
            "through",
            "the",
            "given",
            "loaders",
            "until",
            "it",
            "finds",
            "one",
            "that",
            "can",
            "load",
            "finalizer"
        ]
    },
    {
        "id": 637,
        "code": "public static <T> T firstNonNull(@CheckForNull T first, T second) {\n  if (first != null) {\n    return first;\n  }\n  if (second != null) {\n    return second;\n  }\n  throw new NullPointerException(\"Both parameters are null\");\n}",
        "summary_tokens": [
            "returns",
            "the",
            "first",
            "of",
            "two",
            "given",
            "parameters",
            "that",
            "is",
            "not",
            "null",
            "if",
            "either",
            "is",
            "or",
            "otherwise",
            "throws",
            "a",
            "null",
            "pointer",
            "exception"
        ]
    },
    {
        "id": 638,
        "code": "public static ToStringHelper toStringHelper(String className) {\n  return new ToStringHelper(className);\n}",
        "summary_tokens": [
            "creates",
            "an",
            "instance",
            "of",
            "to",
            "string",
            "helper",
            "in",
            "the",
            "same",
            "manner",
            "as",
            "to",
            "string",
            "helper",
            "object",
            "but",
            "using",
            "class",
            "name",
            "instead",
            "of",
            "using",
            "an",
            "instance",
            "s",
            "object",
            "get",
            "class"
        ]
    },
    {
        "id": 639,
        "code": "public static boolean equal(@CheckForNull Object a, @CheckForNull Object b) {\n  return a == b || (a != null && a.equals(b));\n}",
        "summary_tokens": [
            "determines",
            "whether",
            "two",
            "possibly",
            "null",
            "objects",
            "are",
            "equal"
        ]
    },
    {
        "id": 640,
        "code": "public static int hashCode(@CheckForNull @Nullable Object... objects) {\n  return Arrays.hashCode(objects);\n}",
        "summary_tokens": [
            "generates",
            "a",
            "hash",
            "code",
            "for",
            "multiple",
            "values"
        ]
    },
    {
        "id": 641,
        "code": "public static <T> Optional<T> absent() {\n  return Absent.withType();\n}",
        "summary_tokens": [
            "returns",
            "an",
            "optional",
            "instance",
            "with",
            "no",
            "contained",
            "reference"
        ]
    },
    {
        "id": 642,
        "code": "public static <T> Optional<T> of(T reference) {\n  return new Present<T>(checkNotNull(reference));\n}",
        "summary_tokens": [
            "returns",
            "an",
            "optional",
            "instance",
            "containing",
            "the",
            "given",
            "non",
            "null",
            "reference"
        ]
    },
    {
        "id": 643,
        "code": "public static <T> Optional<T> fromNullable(@CheckForNull T nullableReference) {\n  return (nullableReference == null) ? Optional.<T>absent() : new Present<T>(nullableReference);\n}",
        "summary_tokens": [
            "if",
            "nullable",
            "reference",
            "is",
            "non",
            "null",
            "returns",
            "an",
            "optional",
            "instance",
            "containing",
            "that",
            "reference",
            "otherwise",
            "returns",
            "optional",
            "absent"
        ]
    },
    {
        "id": 644,
        "code": "public static <T> Iterable<T> presentInstances(\n    final Iterable<? extends Optional<? extends T>> optionals) {\n  checkNotNull(optionals);\n  return new Iterable<T>() {\n    @Override\n    public Iterator<T> iterator() {\n      return new AbstractIterator<T>() {\n        private final Iterator<? extends Optional<? extends T>> iterator =\n            checkNotNull(optionals.iterator());\n\n        @Override\n        @CheckForNull\n        protected T computeNext() {\n          while (iterator.hasNext()) {\n            Optional<? extends T> optional = iterator.next();\n            if (optional.isPresent()) {\n              return optional.get();\n            }\n          }\n          return endOfData();\n        }\n      };\n    }\n  };\n}",
        "summary_tokens": [
            "returns",
            "the",
            "value",
            "of",
            "each",
            "present",
            "instance",
            "from",
            "the",
            "supplied",
            "optionals",
            "in",
            "order",
            "skipping",
            "over",
            "occurrences",
            "of",
            "optional",
            "absent"
        ]
    },
    {
        "id": 645,
        "code": "static long systemNanoTime() {\n  return System.nanoTime();\n}",
        "summary_tokens": [
            "calls",
            "system",
            "nano",
            "time"
        ]
    },
    {
        "id": 646,
        "code": "static String nullToEmpty(@CheckForNull String string) {\n  return (string == null) ? \"\" : string;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "string",
            "if",
            "it",
            "is",
            "not",
            "null",
            "or",
            "an",
            "empty",
            "string",
            "otherwise"
        ]
    },
    {
        "id": 647,
        "code": "static String emptyToNull(@CheckForNull String string) {\n  return stringIsNullOrEmpty(string) ? null : string;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "string",
            "if",
            "it",
            "is",
            "not",
            "empty",
            "or",
            "a",
            "null",
            "string",
            "otherwise"
        ]
    },
    {
        "id": 648,
        "code": "public static void checkArgument(\n    boolean b,\n    String errorMessageTemplate,\n    @CheckForNull Object p1,\n    @CheckForNull Object p2,\n    @CheckForNull Object p3,\n    @CheckForNull Object p4) {\n  if (!b) {\n    throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1, p2, p3, p4));\n  }\n}",
        "summary_tokens": [
            "ensures",
            "the",
            "truth",
            "of",
            "an",
            "expression",
            "involving",
            "one",
            "or",
            "more",
            "parameters",
            "to",
            "the",
            "calling",
            "method"
        ]
    },
    {
        "id": 649,
        "code": "public static void checkState(\n    boolean b,\n    String errorMessageTemplate,\n    @CheckForNull Object p1,\n    @CheckForNull Object p2,\n    @CheckForNull Object p3,\n    @CheckForNull Object p4) {\n  if (!b) {\n    throw new IllegalStateException(lenientFormat(errorMessageTemplate, p1, p2, p3, p4));\n  }\n}",
        "summary_tokens": [
            "ensures",
            "the",
            "truth",
            "of",
            "an",
            "expression",
            "involving",
            "the",
            "state",
            "of",
            "the",
            "calling",
            "instance",
            "but",
            "not",
            "involving",
            "any",
            "parameters",
            "to",
            "the",
            "calling",
            "method"
        ]
    },
    {
        "id": 650,
        "code": "public static <T> T checkNotNull(\n    @CheckForNull T obj,\n    String errorMessageTemplate,\n    @CheckForNull Object p1,\n    @CheckForNull Object p2,\n    @CheckForNull Object p3,\n    @CheckForNull Object p4) {\n  if (obj == null) {\n    throw new NullPointerException(lenientFormat(errorMessageTemplate, p1, p2, p3, p4));\n  }\n  return obj;\n}",
        "summary_tokens": [
            "ensures",
            "that",
            "an",
            "object",
            "reference",
            "passed",
            "as",
            "a",
            "parameter",
            "to",
            "the",
            "calling",
            "method",
            "is",
            "not",
            "null"
        ]
    },
    {
        "id": 651,
        "code": "public static int checkElementIndex(int index, int size, String desc) {\n    \n  if (index < 0 || index >= size) {\n    throw new IndexOutOfBoundsException(badElementIndex(index, size, desc));\n  }\n  return index;\n}",
        "summary_tokens": [
            "ensures",
            "that",
            "index",
            "specifies",
            "a",
            "valid",
            "i",
            "element",
            "i",
            "in",
            "an",
            "array",
            "list",
            "or",
            "string",
            "of",
            "size",
            "size"
        ]
    },
    {
        "id": 652,
        "code": "public static int checkPositionIndex(int index, int size, String desc) {\n    \n  if (index < 0 || index > size) {\n    throw new IndexOutOfBoundsException(badPositionIndex(index, size, desc));\n  }\n  return index;\n}",
        "summary_tokens": [
            "ensures",
            "that",
            "index",
            "specifies",
            "a",
            "valid",
            "i",
            "position",
            "i",
            "in",
            "an",
            "array",
            "list",
            "or",
            "string",
            "of",
            "size",
            "size"
        ]
    },
    {
        "id": 653,
        "code": "public static void checkPositionIndexes(int start, int end, int size) {\n    \n  if (start < 0 || end < start || end > size) {\n    throw new IndexOutOfBoundsException(badPositionIndexes(start, end, size));\n  }\n}",
        "summary_tokens": [
            "ensures",
            "that",
            "start",
            "and",
            "end",
            "specify",
            "valid",
            "i",
            "positions",
            "i",
            "in",
            "an",
            "array",
            "list",
            "or",
            "string",
            "of",
            "size",
            "size",
            "and",
            "are",
            "in",
            "order"
        ]
    },
    {
        "id": 654,
        "code": "static int chooseTableSize(int setSize) {\n  if (setSize == 1) {\n    return 2;\n  }\n    \n    \n  int tableSize = Integer.highestOneBit(setSize - 1) << 1;\n  while (tableSize * DESIRED_LOAD_FACTOR < setSize) {\n    tableSize <<= 1;\n  }\n  return tableSize;\n}",
        "summary_tokens": [
            "returns",
            "an",
            "array",
            "size",
            "suitable",
            "for",
            "the",
            "backing",
            "array",
            "of",
            "a",
            "hash",
            "table",
            "that",
            "uses",
            "open",
            "addressing",
            "with",
            "linear",
            "probing",
            "in",
            "its",
            "implementation"
        ]
    },
    {
        "id": 655,
        "code": "public static Splitter on(Pattern separatorPattern) {\n  return on(new JdkPattern(separatorPattern));\n}",
        "summary_tokens": [
            "returns",
            "a",
            "splitter",
            "that",
            "considers",
            "any",
            "subsequence",
            "matching",
            "pattern",
            "to",
            "be",
            "a",
            "separator"
        ]
    },
    {
        "id": 656,
        "code": "public static Splitter onPattern(String separatorPattern) {\n  return on(Platform.compilePattern(separatorPattern));\n}",
        "summary_tokens": [
            "returns",
            "a",
            "splitter",
            "that",
            "considers",
            "any",
            "subsequence",
            "matching",
            "a",
            "given",
            "pattern",
            "regular",
            "expression",
            "to",
            "be",
            "a",
            "separator"
        ]
    },
    {
        "id": 657,
        "code": "public static Splitter fixedLength(final int length) {\n  checkArgument(length > 0, \"The length may not be less than 1\");\n\n  return new Splitter(\n      new Strategy() {\n        @Override\n        public SplittingIterator iterator(final Splitter splitter, CharSequence toSplit) {\n          return new SplittingIterator(splitter, toSplit) {\n            @Override\n            public int separatorStart(int start) {\n              int nextChunkStart = start + length;\n              return (nextChunkStart < toSplit.length() ? nextChunkStart : -1);\n            }\n\n            @Override\n            public int separatorEnd(int separatorPosition) {\n              return separatorPosition;\n            }\n          };\n        }\n      });\n}",
        "summary_tokens": [
            "returns",
            "a",
            "splitter",
            "that",
            "divides",
            "strings",
            "into",
            "pieces",
            "of",
            "the",
            "given",
            "length"
        ]
    },
    {
        "id": 658,
        "code": "public Splitter omitEmptyStrings() {\n  return new Splitter(strategy, true, trimmer, limit);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "splitter",
            "that",
            "behaves",
            "equivalently",
            "to",
            "this",
            "splitter",
            "but",
            "automatically",
            "omits",
            "empty",
            "strings",
            "from",
            "the",
            "results"
        ]
    },
    {
        "id": 659,
        "code": "public Splitter limit(int maxItems) {\n  checkArgument(maxItems > 0, \"must be greater than zero: %s\", maxItems);\n  return new Splitter(strategy, omitEmptyStrings, trimmer, maxItems);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "splitter",
            "that",
            "behaves",
            "equivalently",
            "to",
            "this",
            "splitter",
            "but",
            "stops",
            "splitting",
            "after",
            "it",
            "reaches",
            "the",
            "limit"
        ]
    },
    {
        "id": 660,
        "code": "public Splitter trimResults(CharMatcher trimmer) {\n  checkNotNull(trimmer);\n  return new Splitter(strategy, omitEmptyStrings, trimmer, limit);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "splitter",
            "that",
            "behaves",
            "equivalently",
            "to",
            "this",
            "splitter",
            "but",
            "removes",
            "all",
            "leading",
            "or",
            "trailing",
            "characters",
            "matching",
            "the",
            "given",
            "char",
            "matcher",
            "from",
            "each",
            "returned",
            "substring"
        ]
    },
    {
        "id": 661,
        "code": "public Iterable<String> split(final CharSequence sequence) {\n  checkNotNull(sequence);\n\n  return new Iterable<String>() {\n    @Override\n    public Iterator<String> iterator() {\n      return splittingIterator(sequence);\n    }\n\n    @Override\n    public String toString() {\n      return Joiner.on(\", \")\n          .appendTo(new StringBuilder().append('['), this)\n          .append(']')\n          .toString();\n    }\n  };\n}",
        "summary_tokens": [
            "splits",
            "sequence",
            "into",
            "string",
            "components",
            "and",
            "makes",
            "them",
            "available",
            "through",
            "an",
            "iterator",
            "which",
            "may",
            "be",
            "lazily",
            "evaluated"
        ]
    },
    {
        "id": 662,
        "code": "public List<String> splitToList(CharSequence sequence) {\n  checkNotNull(sequence);\n\n  Iterator<String> iterator = splittingIterator(sequence);\n  List<String> result = new ArrayList<>();\n\n  while (iterator.hasNext()) {\n    result.add(iterator.next());\n  }\n\n  return Collections.unmodifiableList(result);\n}",
        "summary_tokens": [
            "splits",
            "sequence",
            "into",
            "string",
            "components",
            "and",
            "returns",
            "them",
            "as",
            "an",
            "immutable",
            "list"
        ]
    },
    {
        "id": 663,
        "code": "public MapSplitter withKeyValueSeparator(Splitter keyValueSplitter) {\n  return new MapSplitter(this, keyValueSplitter);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "map",
            "splitter",
            "which",
            "splits",
            "entries",
            "based",
            "on",
            "this",
            "splitter",
            "and",
            "splits",
            "entries",
            "into",
            "keys",
            "and",
            "values",
            "using",
            "the",
            "specified",
            "key",
            "value",
            "splitter"
        ]
    },
    {
        "id": 664,
        "code": "public static Stopwatch createUnstarted(Ticker ticker) {\n  return new Stopwatch(ticker);\n}",
        "summary_tokens": [
            "creates",
            "but",
            "does",
            "not",
            "start",
            "a",
            "new",
            "stopwatch",
            "using",
            "the",
            "specified",
            "time",
            "source"
        ]
    },
    {
        "id": 665,
        "code": "public static Stopwatch createStarted(Ticker ticker) {\n  return new Stopwatch(ticker).start();\n}",
        "summary_tokens": [
            "creates",
            "and",
            "starts",
            "a",
            "new",
            "stopwatch",
            "using",
            "the",
            "specified",
            "time",
            "source"
        ]
    },
    {
        "id": 666,
        "code": "public boolean isRunning() {\n  return isRunning;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "start",
            "has",
            "been",
            "called",
            "on",
            "this",
            "stopwatch",
            "and",
            "stop",
            "has",
            "not",
            "been",
            "called",
            "since",
            "the",
            "last",
            "call",
            "to",
            "start"
        ]
    },
    {
        "id": 667,
        "code": "public Stopwatch reset() {\n  elapsedNanos = 0;\n  isRunning = false;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "elapsed",
            "time",
            "for",
            "this",
            "stopwatch",
            "to",
            "zero",
            "and",
            "places",
            "it",
            "in",
            "a",
            "stopped",
            "state"
        ]
    },
    {
        "id": 668,
        "code": "public Duration elapsed() {\n  return Duration.ofNanos(elapsedNanos());\n}",
        "summary_tokens": [
            "returns",
            "the",
            "current",
            "elapsed",
            "time",
            "shown",
            "on",
            "this",
            "stopwatch",
            "as",
            "a",
            "duration"
        ]
    },
    {
        "id": 669,
        "code": "public String toString() {\n  long nanos = elapsedNanos();\n\n  TimeUnit unit = chooseUnit(nanos);\n  double value = (double) nanos / NANOSECONDS.convert(1, unit);\n\n    \n  return Platform.formatCompact4Digits(value) + \" \" + abbreviate(unit);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "string",
            "representation",
            "of",
            "the",
            "current",
            "elapsed",
            "time"
        ]
    },
    {
        "id": 670,
        "code": "public static String nullToEmpty(@CheckForNull String string) {\n  return Platform.nullToEmpty(string);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "given",
            "string",
            "if",
            "it",
            "is",
            "non",
            "null",
            "the",
            "empty",
            "string",
            "otherwise"
        ]
    },
    {
        "id": 671,
        "code": "public static String emptyToNull(@CheckForNull String string) {\n  return Platform.emptyToNull(string);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "given",
            "string",
            "if",
            "it",
            "is",
            "nonempty",
            "null",
            "otherwise"
        ]
    },
    {
        "id": 672,
        "code": "public static boolean isNullOrEmpty(@CheckForNull String string) {\n  return Platform.stringIsNullOrEmpty(string);\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "the",
            "given",
            "string",
            "is",
            "null",
            "or",
            "is",
            "the",
            "empty",
            "string"
        ]
    },
    {
        "id": 673,
        "code": "public static String padStart(String string, int minLength, char padChar) {\n  checkNotNull(string); \n  if (string.length() >= minLength) {\n    return string;\n  }\n  StringBuilder sb = new StringBuilder(minLength);\n  for (int i = string.length(); i < minLength; i++) {\n    sb.append(padChar);\n  }\n  sb.append(string);\n  return sb.toString();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "string",
            "of",
            "length",
            "at",
            "least",
            "min",
            "length",
            "consisting",
            "of",
            "string",
            "prepended",
            "with",
            "as",
            "many",
            "copies",
            "of",
            "pad",
            "char",
            "as",
            "are",
            "necessary",
            "to",
            "reach",
            "that",
            "length"
        ]
    },
    {
        "id": 674,
        "code": "public static String padEnd(String string, int minLength, char padChar) {\n  checkNotNull(string); \n  if (string.length() >= minLength) {\n    return string;\n  }\n  StringBuilder sb = new StringBuilder(minLength);\n  sb.append(string);\n  for (int i = string.length(); i < minLength; i++) {\n    sb.append(padChar);\n  }\n  return sb.toString();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "string",
            "of",
            "length",
            "at",
            "least",
            "min",
            "length",
            "consisting",
            "of",
            "string",
            "appended",
            "with",
            "as",
            "many",
            "copies",
            "of",
            "pad",
            "char",
            "as",
            "are",
            "necessary",
            "to",
            "reach",
            "that",
            "length"
        ]
    },
    {
        "id": 675,
        "code": "public static String repeat(String string, int count) {\n  checkNotNull(string); \n\n  if (count <= 1) {\n    checkArgument(count >= 0, \"invalid count: %s\", count);\n    return (count == 0) ? \"\" : string;\n  }\n\n    \n  final int len = string.length();\n  final long longSize = (long) len * (long) count;\n  final int size = (int) longSize;\n  if (size != longSize) {\n    throw new ArrayIndexOutOfBoundsException(\"Required array size too large: \" + longSize);\n  }\n\n  final char[] array = new char[size];\n  string.getChars(0, len, array, 0);\n  int n;\n  for (n = len; n < size - n; n <<= 1) {\n    System.arraycopy(array, 0, array, n, n);\n  }\n  System.arraycopy(array, 0, array, n, size - n);\n  return new String(array);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "string",
            "consisting",
            "of",
            "a",
            "specific",
            "number",
            "of",
            "concatenated",
            "copies",
            "of",
            "an",
            "input",
            "string"
        ]
    },
    {
        "id": 676,
        "code": "public static String commonPrefix(CharSequence a, CharSequence b) {\n  checkNotNull(a);\n  checkNotNull(b);\n\n  int maxPrefixLength = Math.min(a.length(), b.length());\n  int p = 0;\n  while (p < maxPrefixLength && a.charAt(p) == b.charAt(p)) {\n    p++;\n  }\n  if (validSurrogatePairAt(a, p - 1) || validSurrogatePairAt(b, p - 1)) {\n    p--;\n  }\n  return a.subSequence(0, p).toString();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "longest",
            "string",
            "prefix",
            "such",
            "that",
            "a"
        ]
    },
    {
        "id": 677,
        "code": "public static String commonSuffix(CharSequence a, CharSequence b) {\n  checkNotNull(a);\n  checkNotNull(b);\n\n  int maxSuffixLength = Math.min(a.length(), b.length());\n  int s = 0;\n  while (s < maxSuffixLength && a.charAt(a.length() - s - 1) == b.charAt(b.length() - s - 1)) {\n    s++;\n  }\n  if (validSurrogatePairAt(a, a.length() - s - 1)\n      || validSurrogatePairAt(b, b.length() - s - 1)) {\n    s--;\n  }\n  return a.subSequence(a.length() - s, a.length()).toString();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "longest",
            "string",
            "suffix",
            "such",
            "that",
            "a"
        ]
    },
    {
        "id": 678,
        "code": "static boolean validSurrogatePairAt(CharSequence string, int index) {\n  return index >= 0\n      && index <= (string.length() - 2)\n      && Character.isHighSurrogate(string.charAt(index))\n      && Character.isLowSurrogate(string.charAt(index + 1));\n}",
        "summary_tokens": [
            "true",
            "when",
            "a",
            "valid",
            "surrogate",
            "pair",
            "starts",
            "at",
            "the",
            "given",
            "index",
            "in",
            "the",
            "given",
            "string"
        ]
    },
    {
        "id": 679,
        "code": "public static String lenientFormat(\n    @CheckForNull String template, @CheckForNull @Nullable Object... args) {\n  template = String.valueOf(template); \n\n  if (args == null) {\n    args = new Object[] {\"(Object[])null\"};\n  } else {\n    for (int i = 0; i < args.length; i++) {\n      args[i] = lenientToString(args[i]);\n    }\n  }\n\n    \n  StringBuilder builder = new StringBuilder(template.length() + 16 * args.length);\n  int templateStart = 0;\n  int i = 0;\n  while (i < args.length) {\n    int placeholderStart = template.indexOf(\"%s\", templateStart);\n    if (placeholderStart == -1) {\n      break;\n    }\n    builder.append(template, templateStart, placeholderStart);\n    builder.append(args[i++]);\n    templateStart = placeholderStart + 2;\n  }\n  builder.append(template, templateStart, template.length());\n\n    \n  if (i < args.length) {\n    builder.append(\" [\");\n    builder.append(args[i++]);\n    while (i < args.length) {\n      builder.append(\", \");\n      builder.append(args[i++]);\n    }\n    builder.append(']');\n  }\n\n  return builder.toString();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "given",
            "template",
            "string",
            "with",
            "each",
            "occurrence",
            "of",
            "s",
            "replaced",
            "with",
            "the",
            "corresponding",
            "argument",
            "value",
            "from",
            "args",
            "or",
            "if",
            "the",
            "placeholder",
            "and",
            "argument",
            "counts",
            "do",
            "not",
            "match",
            "returns",
            "a",
            "best",
            "effort",
            "form",
            "of",
            "that",
            "string"
        ]
    },
    {
        "id": 680,
        "code": "public static <X extends Throwable> void throwIfInstanceOf(\n    Throwable throwable, Class<X> declaredType) throws X {\n  checkNotNull(throwable);\n  if (declaredType.isInstance(throwable)) {\n    throw declaredType.cast(throwable);\n  }\n}",
        "summary_tokens": [
            "throws",
            "throwable",
            "if",
            "it",
            "is",
            "an",
            "instance",
            "of",
            "declared",
            "type"
        ]
    },
    {
        "id": 681,
        "code": "public static <X extends Throwable> void propagateIfInstanceOf(\n    @CheckForNull Throwable throwable, Class<X> declaredType) throws X {\n  if (throwable != null) {\n    throwIfInstanceOf(throwable, declaredType);\n  }\n}",
        "summary_tokens": [
            "propagates",
            "throwable",
            "exactly",
            "as",
            "is",
            "if",
            "and",
            "only",
            "if",
            "it",
            "is",
            "an",
            "instance",
            "of",
            "declared",
            "type"
        ]
    },
    {
        "id": 682,
        "code": "public static void throwIfUnchecked(Throwable throwable) {\n  checkNotNull(throwable);\n  if (throwable instanceof RuntimeException) {\n    throw (RuntimeException) throwable;\n  }\n  if (throwable instanceof Error) {\n    throw (Error) throwable;\n  }\n}",
        "summary_tokens": [
            "throws",
            "throwable",
            "if",
            "it",
            "is",
            "a",
            "runtime",
            "exception",
            "or",
            "error"
        ]
    },
    {
        "id": 683,
        "code": "public static <X1 extends Throwable, X2 extends Throwable> void propagateIfPossible(\n    @CheckForNull Throwable throwable, Class<X1> declaredType1, Class<X2> declaredType2)\n    throws X1, X2 {\n  checkNotNull(declaredType2);\n  propagateIfInstanceOf(throwable, declaredType1);\n  propagateIfPossible(throwable, declaredType2);\n}",
        "summary_tokens": [
            "propagates",
            "throwable",
            "exactly",
            "as",
            "is",
            "if",
            "and",
            "only",
            "if",
            "it",
            "is",
            "an",
            "instance",
            "of",
            "runtime",
            "exception",
            "error",
            "declared",
            "type",
            "0",
            "or",
            "declared",
            "type",
            "0"
        ]
    },
    {
        "id": 684,
        "code": "public static RuntimeException propagate(Throwable throwable) {\n  throwIfUnchecked(throwable);\n  throw new RuntimeException(throwable);\n}",
        "summary_tokens": [
            "propagates",
            "throwable",
            "as",
            "is",
            "if",
            "it",
            "is",
            "an",
            "instance",
            "of",
            "runtime",
            "exception",
            "or",
            "error",
            "or",
            "else",
            "as",
            "a",
            "last",
            "resort",
            "wraps",
            "it",
            "in",
            "a",
            "runtime",
            "exception",
            "and",
            "then",
            "propagates"
        ]
    },
    {
        "id": 685,
        "code": "public static Throwable getRootCause(Throwable throwable) {\n    \n    \n  Throwable slowPointer = throwable;\n  boolean advanceSlowPointer = false;\n\n  Throwable cause;\n  while ((cause = throwable.getCause()) != null) {\n    throwable = cause;\n\n    if (throwable == slowPointer) {\n      throw new IllegalArgumentException(\"Loop in causal chain detected.\", throwable);\n    }\n    if (advanceSlowPointer) {\n      slowPointer = slowPointer.getCause();\n    }\n    advanceSlowPointer = !advanceSlowPointer; \n  }\n  return throwable;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "innermost",
            "cause",
            "of",
            "throwable"
        ]
    },
    {
        "id": 686,
        "code": "public static List<Throwable> getCausalChain(Throwable throwable) {\n  checkNotNull(throwable);\n  List<Throwable> causes = new ArrayList<>(4);\n  causes.add(throwable);\n\n    \n    \n  Throwable slowPointer = throwable;\n  boolean advanceSlowPointer = false;\n\n  Throwable cause;\n  while ((cause = throwable.getCause()) != null) {\n    throwable = cause;\n    causes.add(throwable);\n\n    if (throwable == slowPointer) {\n      throw new IllegalArgumentException(\"Loop in causal chain detected.\", throwable);\n    }\n    if (advanceSlowPointer) {\n      slowPointer = slowPointer.getCause();\n    }\n    advanceSlowPointer = !advanceSlowPointer; \n  }\n  return Collections.unmodifiableList(causes);\n}",
        "summary_tokens": [
            "gets",
            "a",
            "throwable",
            "cause",
            "chain",
            "as",
            "a",
            "list"
        ]
    },
    {
        "id": 687,
        "code": "public static <X extends Throwable> X getCauseAs(\n    Throwable throwable, Class<X> expectedCauseType) {\n  try {\n    return expectedCauseType.cast(throwable.getCause());\n  } catch (ClassCastException e) {\n    e.initCause(throwable);\n    throw e;\n  }\n}",
        "summary_tokens": [
            "returns",
            "throwable",
            "s",
            "cause",
            "cast",
            "to",
            "expected",
            "cause",
            "type"
        ]
    },
    {
        "id": 688,
        "code": "public static String getStackTraceAsString(Throwable throwable) {\n  StringWriter stringWriter = new StringWriter();\n  throwable.printStackTrace(new PrintWriter(stringWriter));\n  return stringWriter.toString();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "string",
            "containing",
            "the",
            "result",
            "of",
            "throwable",
            "to",
            "string",
            "to",
            "string",
            "followed",
            "by",
            "the",
            "full",
            "recursive",
            "stack",
            "trace",
            "of",
            "throwable"
        ]
    },
    {
        "id": 689,
        "code": "public static List<StackTraceElement> lazyStackTrace(Throwable throwable) {\n  return lazyStackTraceIsLazy()\n      ? jlaStackTrace(throwable)\n      : unmodifiableList(asList(throwable.getStackTrace()));\n}",
        "summary_tokens": [
            "returns",
            "the",
            "stack",
            "trace",
            "of",
            "throwable",
            "possibly",
            "providing",
            "slower",
            "iteration",
            "over",
            "the",
            "full",
            "trace",
            "but",
            "faster",
            "iteration",
            "over",
            "parts",
            "of",
            "the",
            "trace"
        ]
    },
    {
        "id": 690,
        "code": "public static boolean lazyStackTraceIsLazy() {\n  return getStackTraceElementMethod != null && getStackTraceDepthMethod != null;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "lazy",
            "stack",
            "trace",
            "will",
            "use",
            "the",
            "special",
            "implementation",
            "described",
            "in",
            "its",
            "documentation"
        ]
    },
    {
        "id": 691,
        "code": "private static Object getJLA() {\n  try {\n      \n    Class<?> sharedSecrets = Class.forName(SHARED_SECRETS_CLASSNAME, false, null);\n    Method langAccess = sharedSecrets.getMethod(\"getJavaLangAccess\");\n    return langAccess.invoke(null);\n  } catch (ThreadDeath death) {\n    throw death;\n  } catch (Throwable t) {\n      \n    return null;\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "java",
            "lang",
            "access",
            "class",
            "that",
            "is",
            "present",
            "in",
            "all",
            "sun",
            "jdks"
        ]
    },
    {
        "id": 692,
        "code": "private static Method getGetMethod() {\n  return getJlaMethod(\"getStackTraceElement\", Throwable.class, int.class);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "method",
            "that",
            "can",
            "be",
            "used",
            "to",
            "resolve",
            "an",
            "individual",
            "stack",
            "trace",
            "element",
            "or",
            "null",
            "if",
            "that",
            "method",
            "cannot",
            "be",
            "found",
            "it",
            "is",
            "only",
            "to",
            "be",
            "found",
            "in",
            "fairly",
            "recent",
            "jdks"
        ]
    },
    {
        "id": 693,
        "code": "private static Method getSizeMethod(Object jla) {\n  try {\n    Method getStackTraceDepth = getJlaMethod(\"getStackTraceDepth\", Throwable.class);\n    if (getStackTraceDepth == null) {\n      return null;\n    }\n    getStackTraceDepth.invoke(jla, new Throwable());\n    return getStackTraceDepth;\n  } catch (UnsupportedOperationException | IllegalAccessException | InvocationTargetException e) {\n    return null;\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "method",
            "that",
            "can",
            "be",
            "used",
            "to",
            "return",
            "the",
            "size",
            "of",
            "a",
            "stack",
            "or",
            "null",
            "if",
            "that",
            "method",
            "cannot",
            "be",
            "found",
            "it",
            "is",
            "only",
            "to",
            "be",
            "found",
            "in",
            "fairly",
            "recent",
            "jdks"
        ]
    },
    {
        "id": 694,
        "code": "public static Ticker systemTicker() {\n  return SYSTEM_TICKER;\n}",
        "summary_tokens": [
            "a",
            "ticker",
            "that",
            "reads",
            "the",
            "current",
            "time",
            "using",
            "system",
            "nano",
            "time"
        ]
    },
    {
        "id": 695,
        "code": "public static int encodedLength(CharSequence sequence) {\n    \n  int utf16Length = sequence.length();\n  int utf8Length = utf16Length;\n  int i = 0;\n\n    \n  while (i < utf16Length && sequence.charAt(i) < 0x80) {\n    i++;\n  }\n\n    \n  for (; i < utf16Length; i++) {\n    char c = sequence.charAt(i);\n    if (c < 0x800) {\n      utf8Length += ((0x7f - c) >>> 31); \n    } else {\n      utf8Length += encodedLengthGeneral(sequence, i);\n      break;\n    }\n  }\n\n  if (utf8Length < utf16Length) {\n      \n    throw new IllegalArgumentException(\n        \"UTF-8 length does not fit in int: \" + (utf8Length + (1L << 32)));\n  }\n  return utf8Length;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "bytes",
            "in",
            "the",
            "utf",
            "0",
            "encoded",
            "form",
            "of",
            "sequence"
        ]
    },
    {
        "id": 696,
        "code": "public static boolean isWellFormed(byte[] bytes, int off, int len) {\n  int end = off + len;\n  checkPositionIndexes(off, end, bytes.length);\n    \n  for (int i = off; i < end; i++) {\n    if (bytes[i] < 0) {\n      return isWellFormedSlowPath(bytes, i, end);\n    }\n  }\n  return true;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "given",
            "byte",
            "array",
            "slice",
            "is",
            "a",
            "well",
            "formed",
            "utf",
            "0",
            "byte",
            "sequence",
            "as",
            "defined",
            "by",
            "is",
            "well",
            "formed",
            "byte"
        ]
    },
    {
        "id": 697,
        "code": "public static void verify(\n    boolean expression,\n    String errorMessageTemplate,\n    @CheckForNull Object p1,\n    @CheckForNull Object p2,\n    @CheckForNull Object p3,\n    @CheckForNull Object p4) {\n  if (!expression) {\n    throw new VerifyException(lenientFormat(errorMessageTemplate, p1, p2, p3, p4));\n  }\n}",
        "summary_tokens": [
            "ensures",
            "that",
            "expression",
            "is",
            "true",
            "throwing",
            "a",
            "verify",
            "exception",
            "with",
            "a",
            "custom",
            "message",
            "otherwise"
        ]
    },
    {
        "id": 698,
        "code": "public static <T> T verifyNotNull(\n    @CheckForNull T reference,\n    String errorMessageTemplate,\n    @CheckForNull @Nullable Object... errorMessageArgs) {\n  if (reference == null) {\n    throw new VerifyException(lenientFormat(errorMessageTemplate, errorMessageArgs));\n  }\n  return reference;\n}",
        "summary_tokens": [
            "ensures",
            "that",
            "reference",
            "is",
            "non",
            "null",
            "throwing",
            "a",
            "verify",
            "exception",
            "with",
            "a",
            "custom",
            "message",
            "otherwise"
        ]
    },
    {
        "id": 699,
        "code": "public static void startFinalizer(\n    Class<?> finalizableReferenceClass,\n    ReferenceQueue<Object> queue,\n    PhantomReference<Object> frqReference) {\n    \n  if (!finalizableReferenceClass.getName().equals(FINALIZABLE_REFERENCE)) {\n    throw new IllegalArgumentException(\"Expected \" + FINALIZABLE_REFERENCE + \".\");\n  }\n\n  Finalizer finalizer = new Finalizer(finalizableReferenceClass, queue, frqReference);\n  String threadName = Finalizer.class.getName();\n  Thread thread = null;\n  if (bigThreadConstructor != null) {\n    try {\n      boolean inheritThreadLocals = false;\n      long defaultStackSize = 0;\n      thread =\n          bigThreadConstructor.newInstance(\n              (ThreadGroup) null, finalizer, threadName, defaultStackSize, inheritThreadLocals);\n    } catch (Throwable t) {\n      logger.log(\n          Level.INFO, \"Failed to create a thread without inherited thread-local values\", t);\n    }\n  }\n  if (thread == null) {\n    thread = new Thread((ThreadGroup) null, finalizer, threadName);\n  }\n  thread.setDaemon(true);\n\n  try {\n    if (inheritableThreadLocals != null) {\n      inheritableThreadLocals.set(thread, null);\n    }\n  } catch (Throwable t) {\n    logger.log(\n        Level.INFO,\n        \"Failed to clear thread local values inherited by reference finalizer thread.\",\n        t);\n  }\n\n  thread.start();\n}",
        "summary_tokens": [
            "starts",
            "the",
            "finalizer",
            "thread"
        ]
    },
    {
        "id": 700,
        "code": "public void run() {\n  while (true) {\n    try {\n      if (!cleanUp(queue.remove())) {\n        break;\n      }\n    } catch (InterruptedException e) {\n        \n    }\n  }\n}",
        "summary_tokens": [
            "loops",
            "continuously",
            "pulling",
            "references",
            "off",
            "the",
            "queue",
            "and",
            "cleaning",
            "them",
            "up"
        ]
    },
    {
        "id": 701,
        "code": "private boolean cleanUp(Reference<?> reference) {\n  Method finalizeReferentMethod = getFinalizeReferentMethod();\n  if (finalizeReferentMethod == null) {\n    return false;\n  }\n  do {\n      \n    reference.clear();\n\n    if (reference == frqReference) {\n        \n      return false;\n    }\n\n    try {\n      finalizeReferentMethod.invoke(reference);\n    } catch (Throwable t) {\n      logger.log(Level.SEVERE, \"Error cleaning up after reference.\", t);\n    }\n\n      \n  } while ((reference = queue.poll()) != null);\n  return true;\n}",
        "summary_tokens": [
            "cleans",
            "up",
            "a",
            "single",
            "reference"
        ]
    },
    {
        "id": 702,
        "code": "private Method getFinalizeReferentMethod() {\n  Class<?> finalizableReferenceClass = finalizableReferenceClassReference.get();\n  if (finalizableReferenceClass == null) {\n      \n    return null;\n  }\n  try {\n    return finalizableReferenceClass.getMethod(\"finalizeReferent\");\n  } catch (NoSuchMethodException e) {\n    throw new AssertionError(e);\n  }\n}",
        "summary_tokens": [
            "looks",
            "up",
            "finalizable",
            "reference"
        ]
    },
    {
        "id": 703,
        "code": "public static CacheBuilder<Object, Object> newBuilder() {\n  return new CacheBuilder<>();\n}",
        "summary_tokens": [
            "constructs",
            "a",
            "new",
            "cache",
            "builder",
            "instance",
            "with",
            "default",
            "settings",
            "including",
            "strong",
            "keys",
            "strong",
            "values",
            "and",
            "no",
            "automatic",
            "eviction",
            "of",
            "any",
            "kind"
        ]
    },
    {
        "id": 704,
        "code": "public static CacheBuilder<Object, Object> from(String spec) {\n  return from(CacheBuilderSpec.parse(spec));\n}",
        "summary_tokens": [
            "constructs",
            "a",
            "new",
            "cache",
            "builder",
            "instance",
            "with",
            "the",
            "settings",
            "specified",
            "in",
            "spec"
        ]
    },
    {
        "id": 705,
        "code": "CacheBuilder<K, V> keyEquivalence(Equivalence<Object> equivalence) {\n  checkState(keyEquivalence == null, \"key equivalence was already set to %s\", keyEquivalence);\n  keyEquivalence = checkNotNull(equivalence);\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "a",
            "custom",
            "equivalence",
            "strategy",
            "for",
            "comparing",
            "keys"
        ]
    },
    {
        "id": 706,
        "code": "CacheBuilder<K, V> valueEquivalence(Equivalence<Object> equivalence) {\n  checkState(\n      valueEquivalence == null, \"value equivalence was already set to %s\", valueEquivalence);\n  this.valueEquivalence = checkNotNull(equivalence);\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "a",
            "custom",
            "equivalence",
            "strategy",
            "for",
            "comparing",
            "values"
        ]
    },
    {
        "id": 707,
        "code": "public CacheBuilder<K, V> initialCapacity(int initialCapacity) {\n  checkState(\n      this.initialCapacity == UNSET_INT,\n      \"initial capacity was already set to %s\",\n      this.initialCapacity);\n  checkArgument(initialCapacity >= 0);\n  this.initialCapacity = initialCapacity;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "minimum",
            "total",
            "size",
            "for",
            "the",
            "internal",
            "hash",
            "tables"
        ]
    },
    {
        "id": 708,
        "code": "public CacheBuilder<K, V> concurrencyLevel(int concurrencyLevel) {\n  checkState(\n      this.concurrencyLevel == UNSET_INT,\n      \"concurrency level was already set to %s\",\n      this.concurrencyLevel);\n  checkArgument(concurrencyLevel > 0);\n  this.concurrencyLevel = concurrencyLevel;\n  return this;\n}",
        "summary_tokens": [
            "guides",
            "the",
            "allowed",
            "concurrency",
            "among",
            "update",
            "operations"
        ]
    },
    {
        "id": 709,
        "code": "public CacheBuilder<K, V> maximumSize(long maximumSize) {\n  checkState(\n      this.maximumSize == UNSET_INT, \"maximum size was already set to %s\", this.maximumSize);\n  checkState(\n      this.maximumWeight == UNSET_INT,\n      \"maximum weight was already set to %s\",\n      this.maximumWeight);\n  checkState(this.weigher == null, \"maximum size can not be combined with weigher\");\n  checkArgument(maximumSize >= 0, \"maximum size must not be negative\");\n  this.maximumSize = maximumSize;\n  return this;\n}",
        "summary_tokens": [
            "specifies",
            "the",
            "maximum",
            "number",
            "of",
            "entries",
            "the",
            "cache",
            "may",
            "contain"
        ]
    },
    {
        "id": 710,
        "code": "public CacheBuilder<K, V> maximumWeight(long maximumWeight) {\n  checkState(\n      this.maximumWeight == UNSET_INT,\n      \"maximum weight was already set to %s\",\n      this.maximumWeight);\n  checkState(\n      this.maximumSize == UNSET_INT, \"maximum size was already set to %s\", this.maximumSize);\n  checkArgument(maximumWeight >= 0, \"maximum weight must not be negative\");\n  this.maximumWeight = maximumWeight;\n  return this;\n}",
        "summary_tokens": [
            "specifies",
            "the",
            "maximum",
            "weight",
            "of",
            "entries",
            "the",
            "cache",
            "may",
            "contain"
        ]
    },
    {
        "id": 711,
        "code": "public <K1 extends K, V1 extends V> CacheBuilder<K1, V1> weigher(\n    Weigher<? super K1, ? super V1> weigher) {\n  checkState(this.weigher == null);\n  if (strictParsing) {\n    checkState(\n        this.maximumSize == UNSET_INT,\n        \"weigher can not be combined with maximum size\",\n        this.maximumSize);\n  }\n\n    \n  @SuppressWarnings(\"unchecked\")\n  CacheBuilder<K1, V1> me = (CacheBuilder<K1, V1>) this;\n  me.weigher = checkNotNull(weigher);\n  return me;\n}",
        "summary_tokens": [
            "specifies",
            "the",
            "weigher",
            "to",
            "use",
            "in",
            "determining",
            "the",
            "weight",
            "of",
            "entries"
        ]
    },
    {
        "id": 712,
        "code": "public CacheBuilder<K, V> weakKeys() {\n  return setKeyStrength(Strength.WEAK);\n}",
        "summary_tokens": [
            "specifies",
            "that",
            "each",
            "key",
            "not",
            "value",
            "stored",
            "in",
            "the",
            "cache",
            "should",
            "be",
            "wrapped",
            "in",
            "a",
            "weak",
            "reference",
            "by",
            "default",
            "strong",
            "references",
            "are",
            "used"
        ]
    },
    {
        "id": 713,
        "code": "public CacheBuilder<K, V> weakValues() {\n  return setValueStrength(Strength.WEAK);\n}",
        "summary_tokens": [
            "specifies",
            "that",
            "each",
            "value",
            "not",
            "key",
            "stored",
            "in",
            "the",
            "cache",
            "should",
            "be",
            "wrapped",
            "in",
            "a",
            "weak",
            "reference",
            "by",
            "default",
            "strong",
            "references",
            "are",
            "used"
        ]
    },
    {
        "id": 714,
        "code": "public CacheBuilder<K, V> softValues() {\n  return setValueStrength(Strength.SOFT);\n}",
        "summary_tokens": [
            "specifies",
            "that",
            "each",
            "value",
            "not",
            "key",
            "stored",
            "in",
            "the",
            "cache",
            "should",
            "be",
            "wrapped",
            "in",
            "a",
            "soft",
            "reference",
            "by",
            "default",
            "strong",
            "references",
            "are",
            "used"
        ]
    },
    {
        "id": 715,
        "code": "public CacheBuilder<K, V> expireAfterWrite(long duration, TimeUnit unit) {\n  checkState(\n      expireAfterWriteNanos == UNSET_INT,\n      \"expireAfterWrite was already set to %s ns\",\n      expireAfterWriteNanos);\n  checkArgument(duration >= 0, \"duration cannot be negative: %s %s\", duration, unit);\n  this.expireAfterWriteNanos = unit.toNanos(duration);\n  return this;\n}",
        "summary_tokens": [
            "specifies",
            "that",
            "each",
            "entry",
            "should",
            "be",
            "automatically",
            "removed",
            "from",
            "the",
            "cache",
            "once",
            "a",
            "fixed",
            "duration",
            "has",
            "elapsed",
            "after",
            "the",
            "entry",
            "s",
            "creation",
            "or",
            "the",
            "most",
            "recent",
            "replacement",
            "of",
            "its",
            "value"
        ]
    },
    {
        "id": 716,
        "code": "public CacheBuilder<K, V> expireAfterAccess(long duration, TimeUnit unit) {\n  checkState(\n      expireAfterAccessNanos == UNSET_INT,\n      \"expireAfterAccess was already set to %s ns\",\n      expireAfterAccessNanos);\n  checkArgument(duration >= 0, \"duration cannot be negative: %s %s\", duration, unit);\n  this.expireAfterAccessNanos = unit.toNanos(duration);\n  return this;\n}",
        "summary_tokens": [
            "specifies",
            "that",
            "each",
            "entry",
            "should",
            "be",
            "automatically",
            "removed",
            "from",
            "the",
            "cache",
            "once",
            "a",
            "fixed",
            "duration",
            "has",
            "elapsed",
            "after",
            "the",
            "entry",
            "s",
            "creation",
            "the",
            "most",
            "recent",
            "replacement",
            "of",
            "its",
            "value",
            "or",
            "its",
            "last",
            "access"
        ]
    },
    {
        "id": 717,
        "code": "public CacheBuilder<K, V> refreshAfterWrite(long duration, TimeUnit unit) {\n  checkNotNull(unit);\n  checkState(refreshNanos == UNSET_INT, \"refresh was already set to %s ns\", refreshNanos);\n  checkArgument(duration > 0, \"duration must be positive: %s %s\", duration, unit);\n  this.refreshNanos = unit.toNanos(duration);\n  return this;\n}",
        "summary_tokens": [
            "specifies",
            "that",
            "active",
            "entries",
            "are",
            "eligible",
            "for",
            "automatic",
            "refresh",
            "once",
            "a",
            "fixed",
            "duration",
            "has",
            "elapsed",
            "after",
            "the",
            "entry",
            "s",
            "creation",
            "or",
            "the",
            "most",
            "recent",
            "replacement",
            "of",
            "its",
            "value"
        ]
    },
    {
        "id": 718,
        "code": "public CacheBuilder<K, V> ticker(Ticker ticker) {\n  checkState(this.ticker == null);\n  this.ticker = checkNotNull(ticker);\n  return this;\n}",
        "summary_tokens": [
            "specifies",
            "a",
            "nanosecond",
            "precision",
            "time",
            "source",
            "for",
            "this",
            "cache"
        ]
    },
    {
        "id": 719,
        "code": "public <K1 extends K, V1 extends V> CacheBuilder<K1, V1> removalListener(\n    RemovalListener<? super K1, ? super V1> listener) {\n  checkState(this.removalListener == null);\n\n    \n  @SuppressWarnings(\"unchecked\")\n  CacheBuilder<K1, V1> me = (CacheBuilder<K1, V1>) this;\n  me.removalListener = checkNotNull(listener);\n  return me;\n}",
        "summary_tokens": [
            "specifies",
            "a",
            "listener",
            "instance",
            "that",
            "caches",
            "should",
            "notify",
            "each",
            "time",
            "an",
            "entry",
            "is",
            "removed",
            "for",
            "any",
            "removal",
            "cause",
            "reason"
        ]
    },
    {
        "id": 720,
        "code": "public CacheBuilder<K, V> recordStats() {\n  statsCounterSupplier = CACHE_STATS_COUNTER;\n  return this;\n}",
        "summary_tokens": [
            "enable",
            "the",
            "accumulation",
            "of",
            "cache",
            "stats",
            "during",
            "the",
            "operation",
            "of",
            "the",
            "cache"
        ]
    },
    {
        "id": 721,
        "code": "public <K1 extends K, V1 extends V> Cache<K1, V1> build() {\n  checkWeightWithWeigher();\n  checkNonLoadingCache();\n  return new LocalCache.LocalManualCache<>(this);\n}",
        "summary_tokens": [
            "builds",
            "a",
            "cache",
            "which",
            "does",
            "not",
            "automatically",
            "load",
            "values",
            "when",
            "keys",
            "are",
            "requested"
        ]
    },
    {
        "id": 722,
        "code": "public String toString() {\n  MoreObjects.ToStringHelper s = MoreObjects.toStringHelper(this);\n  if (initialCapacity != UNSET_INT) {\n    s.add(\"initialCapacity\", initialCapacity);\n  }\n  if (concurrencyLevel != UNSET_INT) {\n    s.add(\"concurrencyLevel\", concurrencyLevel);\n  }\n  if (maximumSize != UNSET_INT) {\n    s.add(\"maximumSize\", maximumSize);\n  }\n  if (maximumWeight != UNSET_INT) {\n    s.add(\"maximumWeight\", maximumWeight);\n  }\n  if (expireAfterWriteNanos != UNSET_INT) {\n    s.add(\"expireAfterWrite\", expireAfterWriteNanos + \"ns\");\n  }\n  if (expireAfterAccessNanos != UNSET_INT) {\n    s.add(\"expireAfterAccess\", expireAfterAccessNanos + \"ns\");\n  }\n  if (keyStrength != null) {\n    s.add(\"keyStrength\", Ascii.toLowerCase(keyStrength.toString()));\n  }\n  if (valueStrength != null) {\n    s.add(\"valueStrength\", Ascii.toLowerCase(valueStrength.toString()));\n  }\n  if (keyEquivalence != null) {\n    s.addValue(\"keyEquivalence\");\n  }\n  if (valueEquivalence != null) {\n    s.addValue(\"valueEquivalence\");\n  }\n  if (removalListener != null) {\n    s.addValue(\"removalListener\");\n  }\n  return s.toString();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "string",
            "representation",
            "for",
            "this",
            "cache",
            "builder",
            "instance"
        ]
    },
    {
        "id": 723,
        "code": "public static CacheBuilderSpec parse(String cacheBuilderSpecification) {\n  CacheBuilderSpec spec = new CacheBuilderSpec(cacheBuilderSpecification);\n  if (!cacheBuilderSpecification.isEmpty()) {\n    for (String keyValuePair : KEYS_SPLITTER.split(cacheBuilderSpecification)) {\n      List<String> keyAndValue = ImmutableList.copyOf(KEY_VALUE_SPLITTER.split(keyValuePair));\n      checkArgument(!keyAndValue.isEmpty(), \"blank key-value pair\");\n      checkArgument(\n          keyAndValue.size() <= 2,\n          \"key-value pair %s with more than one equals sign\",\n          keyValuePair);\n\n        \n      String key = keyAndValue.get(0);\n      ValueParser valueParser = VALUE_PARSERS.get(key);\n      checkArgument(valueParser != null, \"unknown key %s\", key);\n\n      String value = keyAndValue.size() == 1 ? null : keyAndValue.get(1);\n      valueParser.parse(spec, key, value);\n    }\n  }\n\n  return spec;\n}",
        "summary_tokens": [
            "creates",
            "a",
            "cache",
            "builder",
            "spec",
            "from",
            "a",
            "string"
        ]
    },
    {
        "id": 724,
        "code": "public static CacheBuilderSpec disableCaching() {\n    \n  return CacheBuilderSpec.parse(\"maximumSize=0\");\n}",
        "summary_tokens": [
            "returns",
            "a",
            "cache",
            "builder",
            "spec",
            "that",
            "will",
            "prevent",
            "caching"
        ]
    },
    {
        "id": 725,
        "code": "CacheBuilder<Object, Object> toCacheBuilder() {\n  CacheBuilder<Object, Object> builder = CacheBuilder.newBuilder();\n  if (initialCapacity != null) {\n    builder.initialCapacity(initialCapacity);\n  }\n  if (maximumSize != null) {\n    builder.maximumSize(maximumSize);\n  }\n  if (maximumWeight != null) {\n    builder.maximumWeight(maximumWeight);\n  }\n  if (concurrencyLevel != null) {\n    builder.concurrencyLevel(concurrencyLevel);\n  }\n  if (keyStrength != null) {\n    switch (keyStrength) {\n      case WEAK:\n        builder.weakKeys();\n        break;\n      default:\n        throw new AssertionError();\n    }\n  }\n  if (valueStrength != null) {\n    switch (valueStrength) {\n      case SOFT:\n        builder.softValues();\n        break;\n      case WEAK:\n        builder.weakValues();\n        break;\n      default:\n        throw new AssertionError();\n    }\n  }\n  if (recordStats != null && recordStats) {\n    builder.recordStats();\n  }\n  if (writeExpirationTimeUnit != null) {\n    builder.expireAfterWrite(writeExpirationDuration, writeExpirationTimeUnit);\n  }\n  if (accessExpirationTimeUnit != null) {\n    builder.expireAfterAccess(accessExpirationDuration, accessExpirationTimeUnit);\n  }\n  if (refreshTimeUnit != null) {\n    builder.refreshAfterWrite(refreshDuration, refreshTimeUnit);\n  }\n\n  return builder;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "cache",
            "builder",
            "configured",
            "according",
            "to",
            "this",
            "instance",
            "s",
            "specification"
        ]
    },
    {
        "id": 726,
        "code": "public String toParsableString() {\n  return specification;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "string",
            "that",
            "can",
            "be",
            "used",
            "to",
            "parse",
            "an",
            "equivalent",
            "cache",
            "builder",
            "spec"
        ]
    },
    {
        "id": 727,
        "code": "public String toString() {\n  return MoreObjects.toStringHelper(this).addValue(toParsableString()).toString();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "string",
            "representation",
            "for",
            "this",
            "cache",
            "builder",
            "spec",
            "instance"
        ]
    },
    {
        "id": 728,
        "code": "private static Long durationInNanos(long duration, @CheckForNull TimeUnit unit) {\n  return (unit == null) ? null : unit.toNanos(duration);\n}",
        "summary_tokens": [
            "converts",
            "an",
            "expiration",
            "duration",
            "unit",
            "pair",
            "into",
            "a",
            "single",
            "long",
            "for",
            "hashing",
            "and",
            "equality"
        ]
    },
    {
        "id": 729,
        "code": "public ListenableFuture<V> reload(K key, V oldValue) throws Exception {\n  checkNotNull(key);\n  checkNotNull(oldValue);\n  return Futures.immediateFuture(load(key));\n}",
        "summary_tokens": [
            "computes",
            "or",
            "retrieves",
            "a",
            "replacement",
            "value",
            "corresponding",
            "to",
            "an",
            "already",
            "cached",
            "key"
        ]
    },
    {
        "id": 730,
        "code": "public Map<K, V> loadAll(Iterable<? extends K> keys) throws Exception {\n    \n    \n  throw new UnsupportedLoadingOperationException();\n}",
        "summary_tokens": [
            "computes",
            "or",
            "retrieves",
            "the",
            "values",
            "corresponding",
            "to",
            "keys"
        ]
    },
    {
        "id": 731,
        "code": "public static <V> CacheLoader<Object, V> from(Supplier<V> supplier) {\n  return new SupplierToCacheLoader<V>(supplier);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "cache",
            "loader",
            "based",
            "on",
            "an",
            "i",
            "existing",
            "i",
            "supplier",
            "instance"
        ]
    },
    {
        "id": 732,
        "code": "public static <K, V> CacheLoader<K, V> asyncReloading(\n    final CacheLoader<K, V> loader, final Executor executor) {\n  checkNotNull(loader);\n  checkNotNull(executor);\n  return new CacheLoader<K, V>() {\n    @Override\n    public V load(K key) throws Exception {\n      return loader.load(key);\n    }\n\n    @Override\n    public ListenableFuture<V> reload(final K key, final V oldValue) throws Exception {\n      ListenableFutureTask<V> task =\n          ListenableFutureTask.create(\n              new Callable<V>() {\n                @Override\n                public V call() throws Exception {\n                  return loader.reload(key, oldValue).get();\n                }\n              });\n      executor.execute(task);\n      return task;\n    }\n\n    @Override\n    public Map<K, V> loadAll(Iterable<? extends K> keys) throws Exception {\n      return loader.loadAll(keys);\n    }\n  };\n}",
        "summary_tokens": [
            "returns",
            "a",
            "cache",
            "loader",
            "which",
            "wraps",
            "loader",
            "executing",
            "calls",
            "to",
            "cache",
            "loader",
            "reload",
            "using",
            "executor"
        ]
    },
    {
        "id": 733,
        "code": "public long requestCount() {\n  return saturatedAdd(hitCount, missCount);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "times",
            "cache",
            "lookup",
            "methods",
            "have",
            "returned",
            "either",
            "a",
            "cached",
            "or",
            "uncached",
            "value"
        ]
    },
    {
        "id": 734,
        "code": "public long hitCount() {\n  return hitCount;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "times",
            "cache",
            "lookup",
            "methods",
            "have",
            "returned",
            "a",
            "cached",
            "value"
        ]
    },
    {
        "id": 735,
        "code": "public double hitRate() {\n  long requestCount = requestCount();\n  return (requestCount == 0) ? 1.0 : (double) hitCount / requestCount;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "ratio",
            "of",
            "cache",
            "requests",
            "which",
            "were",
            "hits"
        ]
    },
    {
        "id": 736,
        "code": "public long missCount() {\n  return missCount;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "times",
            "cache",
            "lookup",
            "methods",
            "have",
            "returned",
            "an",
            "uncached",
            "newly",
            "loaded",
            "value",
            "or",
            "null"
        ]
    },
    {
        "id": 737,
        "code": "public double missRate() {\n  long requestCount = requestCount();\n  return (requestCount == 0) ? 0.0 : (double) missCount / requestCount;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "ratio",
            "of",
            "cache",
            "requests",
            "which",
            "were",
            "misses"
        ]
    },
    {
        "id": 738,
        "code": "public long loadCount() {\n  return saturatedAdd(loadSuccessCount, loadExceptionCount);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "total",
            "number",
            "of",
            "times",
            "that",
            "cache",
            "lookup",
            "methods",
            "attempted",
            "to",
            "load",
            "new",
            "values"
        ]
    },
    {
        "id": 739,
        "code": "public long loadSuccessCount() {\n  return loadSuccessCount;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "times",
            "cache",
            "lookup",
            "methods",
            "have",
            "successfully",
            "loaded",
            "a",
            "new",
            "value"
        ]
    },
    {
        "id": 740,
        "code": "public long loadExceptionCount() {\n  return loadExceptionCount;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "times",
            "cache",
            "lookup",
            "methods",
            "threw",
            "an",
            "exception",
            "while",
            "loading",
            "a",
            "new",
            "value"
        ]
    },
    {
        "id": 741,
        "code": "public double loadExceptionRate() {\n  long totalLoadCount = saturatedAdd(loadSuccessCount, loadExceptionCount);\n  return (totalLoadCount == 0) ? 0.0 : (double) loadExceptionCount / totalLoadCount;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "ratio",
            "of",
            "cache",
            "loading",
            "attempts",
            "which",
            "threw",
            "exceptions"
        ]
    },
    {
        "id": 742,
        "code": "public long totalLoadTime() {\n  return totalLoadTime;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "total",
            "number",
            "of",
            "nanoseconds",
            "the",
            "cache",
            "has",
            "spent",
            "loading",
            "new",
            "values"
        ]
    },
    {
        "id": 743,
        "code": "public double averageLoadPenalty() {\n  long totalLoadCount = saturatedAdd(loadSuccessCount, loadExceptionCount);\n  return (totalLoadCount == 0) ? 0.0 : (double) totalLoadTime / totalLoadCount;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "average",
            "time",
            "spent",
            "loading",
            "new",
            "values"
        ]
    },
    {
        "id": 744,
        "code": "public long evictionCount() {\n  return evictionCount;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "times",
            "an",
            "entry",
            "has",
            "been",
            "evicted"
        ]
    },
    {
        "id": 745,
        "code": "public CacheStats minus(CacheStats other) {\n  return new CacheStats(\n      Math.max(0, saturatedSubtract(hitCount, other.hitCount)),\n      Math.max(0, saturatedSubtract(missCount, other.missCount)),\n      Math.max(0, saturatedSubtract(loadSuccessCount, other.loadSuccessCount)),\n      Math.max(0, saturatedSubtract(loadExceptionCount, other.loadExceptionCount)),\n      Math.max(0, saturatedSubtract(totalLoadTime, other.totalLoadTime)),\n      Math.max(0, saturatedSubtract(evictionCount, other.evictionCount)));\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "cache",
            "stats",
            "representing",
            "the",
            "difference",
            "between",
            "this",
            "cache",
            "stats",
            "and",
            "other"
        ]
    },
    {
        "id": 746,
        "code": "public CacheStats plus(CacheStats other) {\n  return new CacheStats(\n      saturatedAdd(hitCount, other.hitCount),\n      saturatedAdd(missCount, other.missCount),\n      saturatedAdd(loadSuccessCount, other.loadSuccessCount),\n      saturatedAdd(loadExceptionCount, other.loadExceptionCount),\n      saturatedAdd(totalLoadTime, other.totalLoadTime),\n      saturatedAdd(evictionCount, other.evictionCount));\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "cache",
            "stats",
            "representing",
            "the",
            "sum",
            "of",
            "this",
            "cache",
            "stats",
            "and",
            "other"
        ]
    },
    {
        "id": 747,
        "code": "static <K, V> ValueReference<K, V> unset() {\n  return (ValueReference<K, V>) UNSET;\n}",
        "summary_tokens": [
            "singleton",
            "placeholder",
            "that",
            "indicates",
            "a",
            "value",
            "is",
            "being",
            "loaded"
        ]
    },
    {
        "id": 748,
        "code": "static <E> Queue<E> discardingQueue() {\n  return (Queue) DISCARDING_QUEUE;\n}",
        "summary_tokens": [
            "queue",
            "that",
            "discards",
            "all",
            "elements"
        ]
    },
    {
        "id": 749,
        "code": "static int rehash(int h) {\n    \n    \n    \n  h += (h << 15) ^ 0xffffcd7d;\n  h ^= (h >>> 10);\n  h += (h << 3);\n  h ^= (h >>> 6);\n  h += (h << 2) + (h << 14);\n  return h ^ (h >>> 16);\n}",
        "summary_tokens": [
            "applies",
            "a",
            "supplemental",
            "hash",
            "function",
            "to",
            "a",
            "given",
            "hash",
            "code",
            "which",
            "defends",
            "against",
            "poor",
            "quality",
            "hash",
            "functions"
        ]
    },
    {
        "id": 750,
        "code": "ReferenceEntry<K, V> newEntry(K key, int hash, @Nullable ReferenceEntry<K, V> next) {\n  Segment<K, V> segment = segmentFor(hash);\n  segment.lock();\n  try {\n    return segment.newEntry(key, hash, next);\n  } finally {\n    segment.unlock();\n  }\n}",
        "summary_tokens": [
            "this",
            "method",
            "is",
            "a",
            "convenience",
            "for",
            "testing"
        ]
    },
    {
        "id": 751,
        "code": "ReferenceEntry<K, V> copyEntry(ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext) {\n  int hash = original.getHash();\n  return segmentFor(hash).copyEntry(original, newNext);\n}",
        "summary_tokens": [
            "this",
            "method",
            "is",
            "a",
            "convenience",
            "for",
            "testing"
        ]
    },
    {
        "id": 752,
        "code": "ValueReference<K, V> newValueReference(ReferenceEntry<K, V> entry, V value, int weight) {\n  int hash = entry.getHash();\n  return valueStrength.referenceValue(segmentFor(hash), entry, checkNotNull(value), weight);\n}",
        "summary_tokens": [
            "this",
            "method",
            "is",
            "a",
            "convenience",
            "for",
            "testing"
        ]
    },
    {
        "id": 753,
        "code": "boolean isLive(ReferenceEntry<K, V> entry, long now) {\n  return segmentFor(entry.getHash()).getLiveValue(entry, now) != null;\n}",
        "summary_tokens": [
            "this",
            "method",
            "is",
            "a",
            "convenience",
            "for",
            "testing"
        ]
    },
    {
        "id": 754,
        "code": "Segment<K, V> segmentFor(int hash) {\n    \n  return segments[(hash >>> segmentShift) & segmentMask];\n}",
        "summary_tokens": [
            "returns",
            "the",
            "segment",
            "that",
            "should",
            "be",
            "used",
            "for",
            "a",
            "key",
            "with",
            "the",
            "given",
            "hash"
        ]
    },
    {
        "id": 755,
        "code": "V getLiveValue(ReferenceEntry<K, V> entry, long now) {\n  if (entry.getKey() == null) {\n    return null;\n  }\n  V value = entry.getValueReference().get();\n  if (value == null) {\n    return null;\n  }\n\n  if (isExpired(entry, now)) {\n    return null;\n  }\n  return value;\n}",
        "summary_tokens": [
            "gets",
            "the",
            "value",
            "from",
            "an",
            "entry"
        ]
    },
    {
        "id": 756,
        "code": "boolean isExpired(ReferenceEntry<K, V> entry, long now) {\n  checkNotNull(entry);\n  if (expiresAfterAccess() && (now - entry.getAccessTime() >= expireAfterAccessNanos)) {\n    return true;\n  }\n  if (expiresAfterWrite() && (now - entry.getWriteTime() >= expireAfterWriteNanos)) {\n    return true;\n  }\n  return false;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "the",
            "entry",
            "has",
            "expired"
        ]
    },
    {
        "id": 757,
        "code": "void processPendingNotifications() {\n  RemovalNotification<K, V> notification;\n  while ((notification = removalNotificationQueue.poll()) != null) {\n    try {\n      removalListener.onRemoval(notification);\n    } catch (Throwable e) {\n      logger.log(Level.WARNING, \"Exception thrown by removal listener\", e);\n    }\n  }\n}",
        "summary_tokens": [
            "notifies",
            "listeners",
            "that",
            "an",
            "entry",
            "has",
            "been",
            "automatically",
            "removed",
            "due",
            "to",
            "expiration",
            "eviction",
            "or",
            "eligibility",
            "for",
            "garbage",
            "collection"
        ]
    },
    {
        "id": 758,
        "code": "Map<K, V> loadAll(Set<? extends K> keys, CacheLoader<? super K, V> loader)\n    throws ExecutionException {\n  checkNotNull(loader);\n  checkNotNull(keys);\n  Stopwatch stopwatch = Stopwatch.createStarted();\n  Map<K, V> result;\n  boolean success = false;\n  try {\n    @SuppressWarnings(\"unchecked\") \n    Map<K, V> map = (Map<K, V>) loader.loadAll(keys);\n    result = map;\n    success = true;\n  } catch (UnsupportedLoadingOperationException e) {\n    success = true;\n    throw e;\n  } catch (InterruptedException e) {\n    Thread.currentThread().interrupt();\n    throw new ExecutionException(e);\n  } catch (RuntimeException e) {\n    throw new UncheckedExecutionException(e);\n  } catch (Exception e) {\n    throw new ExecutionException(e);\n  } catch (Error e) {\n    throw new ExecutionError(e);\n  } finally {\n    if (!success) {\n      globalStatsCounter.recordLoadException(stopwatch.elapsed(NANOSECONDS));\n    }\n  }\n\n  if (result == null) {\n    globalStatsCounter.recordLoadException(stopwatch.elapsed(NANOSECONDS));\n    throw new InvalidCacheLoadException(loader + \" returned null map from loadAll\");\n  }\n\n  stopwatch.stop();\n    \n  boolean nullsPresent = false;\n  for (Entry<K, V> entry : result.entrySet()) {\n    K key = entry.getKey();\n    V value = entry.getValue();\n    if (key == null || value == null) {\n        \n      nullsPresent = true;\n    } else {\n      put(key, value);\n    }\n  }\n\n  if (nullsPresent) {\n    globalStatsCounter.recordLoadException(stopwatch.elapsed(NANOSECONDS));\n    throw new InvalidCacheLoadException(loader + \" returned null keys or values from loadAll\");\n  }\n\n    \n  globalStatsCounter.recordLoadSuccess(stopwatch.elapsed(NANOSECONDS));\n  return result;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "result",
            "of",
            "calling",
            "cache",
            "loader",
            "load",
            "all",
            "or",
            "null",
            "if",
            "loader",
            "doesn",
            "t",
            "implement",
            "load",
            "all"
        ]
    },
    {
        "id": 759,
        "code": "ReferenceEntry<K, V> getEntry(@Nullable Object key) {\n    \n  if (key == null) {\n    return null;\n  }\n  int hash = hash(key);\n  return segmentFor(hash).getEntry(key, hash);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "internal",
            "entry",
            "for",
            "the",
            "specified",
            "key"
        ]
    },
    {
        "id": 760,
        "code": "final long fn(long v, long x) {\n  return v + x;\n}",
        "summary_tokens": [
            "version",
            "of",
            "plus",
            "for",
            "use",
            "in",
            "retry",
            "update"
        ]
    },
    {
        "id": 761,
        "code": "public void add(long x) {\n  Cell[] as;\n  long b, v;\n  int[] hc;\n  Cell a;\n  int n;\n  if ((as = cells) != null || !casBase(b = base, b + x)) {\n    boolean uncontended = true;\n    if ((hc = threadHashCode.get()) == null\n        || as == null\n        || (n = as.length) < 1\n        || (a = as[(n - 1) & hc[0]]) == null\n        || !(uncontended = a.cas(v = a.value, v + x))) retryUpdate(x, hc, uncontended);\n  }\n}",
        "summary_tokens": [
            "adds",
            "the",
            "given",
            "value"
        ]
    },
    {
        "id": 762,
        "code": "public void increment() {\n  add(1L);\n}",
        "summary_tokens": [
            "equivalent",
            "to",
            "add",
            "0"
        ]
    },
    {
        "id": 763,
        "code": "public void decrement() {\n  add(-1L);\n}",
        "summary_tokens": [
            "equivalent",
            "to",
            "add",
            "0"
        ]
    },
    {
        "id": 764,
        "code": "public long sum() {\n  long sum = base;\n  Cell[] as = cells;\n  if (as != null) {\n    int n = as.length;\n    for (int i = 0; i < n; ++i) {\n      Cell a = as[i];\n      if (a != null) sum += a.value;\n    }\n  }\n  return sum;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "current",
            "sum"
        ]
    },
    {
        "id": 765,
        "code": "public void reset() {\n  internalReset(0L);\n}",
        "summary_tokens": [
            "resets",
            "variables",
            "maintaining",
            "the",
            "sum",
            "to",
            "zero"
        ]
    },
    {
        "id": 766,
        "code": "public long sumThenReset() {\n  long sum = base;\n  Cell[] as = cells;\n  base = 0L;\n  if (as != null) {\n    int n = as.length;\n    for (int i = 0; i < n; ++i) {\n      Cell a = as[i];\n      if (a != null) {\n        sum += a.value;\n        a.value = 0L;\n      }\n    }\n  }\n  return sum;\n}",
        "summary_tokens": [
            "equivalent",
            "in",
            "effect",
            "to",
            "sum",
            "followed",
            "by",
            "reset"
        ]
    },
    {
        "id": 767,
        "code": "public String toString() {\n  return Long.toString(sum());\n}",
        "summary_tokens": [
            "returns",
            "the",
            "string",
            "representation",
            "of",
            "the",
            "sum"
        ]
    },
    {
        "id": 768,
        "code": "public int intValue() {\n  return (int) sum();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "sum",
            "as",
            "an",
            "int",
            "after",
            "a",
            "narrowing",
            "primitive",
            "conversion"
        ]
    },
    {
        "id": 769,
        "code": "public float floatValue() {\n  return (float) sum();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "sum",
            "as",
            "a",
            "float",
            "after",
            "a",
            "widening",
            "primitive",
            "conversion"
        ]
    },
    {
        "id": 770,
        "code": "public double doubleValue() {\n  return (double) sum();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "sum",
            "as",
            "a",
            "double",
            "after",
            "a",
            "widening",
            "primitive",
            "conversion"
        ]
    },
    {
        "id": 771,
        "code": "public static <K, V> RemovalListener<K, V> asynchronous(\n    RemovalListener<K, V> listener, Executor executor) {\n  checkNotNull(listener);\n  checkNotNull(executor);\n  return (RemovalNotification<K, V> notification) ->\n      executor.execute(() -> listener.onRemoval(notification));\n}",
        "summary_tokens": [
            "returns",
            "a",
            "removal",
            "listener",
            "which",
            "processes",
            "all",
            "eviction",
            "notifications",
            "using",
            "executor"
        ]
    },
    {
        "id": 772,
        "code": "static void checkRemove(boolean canRemove) {\n  checkState(canRemove, \"no calls to next() since the last call to remove()\");\n}",
        "summary_tokens": [
            "precondition",
            "tester",
            "for",
            "iterator"
        ]
    },
    {
        "id": 773,
        "code": "static int tableSize(int expectedSize) {\n    \n  return Math.max(MIN_HASH_TABLE_SIZE, Hashing.closedTableSize(expectedSize + 1, 1.0f));\n}",
        "summary_tokens": [
            "returns",
            "the",
            "power",
            "of",
            "0",
            "hashtable",
            "size",
            "required",
            "to",
            "hold",
            "the",
            "expected",
            "number",
            "of",
            "items",
            "or",
            "the",
            "minimum",
            "hashtable",
            "size",
            "whichever",
            "is",
            "greater"
        ]
    },
    {
        "id": 774,
        "code": "static Object createTable(int buckets) {\n  if (buckets < 2\n      || buckets > Ints.MAX_POWER_OF_TWO\n      || Integer.highestOneBit(buckets) != buckets) {\n    throw new IllegalArgumentException(\"must be power of 2 between 2^1 and 2^30: \" + buckets);\n  }\n  if (buckets <= BYTE_MAX_SIZE) {\n    return new byte[buckets];\n  } else if (buckets <= SHORT_MAX_SIZE) {\n    return new short[buckets];\n  } else {\n    return new int[buckets];\n  }\n}",
        "summary_tokens": [
            "creates",
            "and",
            "returns",
            "a",
            "properly",
            "sized",
            "array",
            "with",
            "the",
            "given",
            "number",
            "of",
            "buckets"
        ]
    },
    {
        "id": 775,
        "code": "static int tableGet(Object table, int index) {\n  if (table instanceof byte[]) {\n    return ((byte[]) table)[index] & BYTE_MASK; \n  } else if (table instanceof short[]) {\n    return ((short[]) table)[index] & SHORT_MASK; \n  } else {\n    return ((int[]) table)[index];\n  }\n}",
        "summary_tokens": [
            "returns",
            "table",
            "index",
            "where",
            "table",
            "is",
            "actually",
            "a",
            "byte",
            "short",
            "or",
            "int"
        ]
    },
    {
        "id": 776,
        "code": "static void tableSet(Object table, int index, int entry) {\n  if (table instanceof byte[]) {\n    ((byte[]) table)[index] = (byte) entry; \n  } else if (table instanceof short[]) {\n    ((short[]) table)[index] = (short) entry; \n  } else {\n    ((int[]) table)[index] = entry;\n  }\n}",
        "summary_tokens": [
            "sets",
            "table",
            "index",
            "to",
            "entry",
            "where",
            "table",
            "is",
            "actually",
            "a",
            "byte",
            "short",
            "or",
            "int"
        ]
    },
    {
        "id": 777,
        "code": "static int newCapacity(int mask) {\n  return ((mask < 32) ? 4 : 2) * (mask + 1);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "larger",
            "power",
            "of",
            "0",
            "hashtable",
            "size",
            "given",
            "the",
            "current",
            "mask"
        ]
    },
    {
        "id": 778,
        "code": "static int getHashPrefix(int value, int mask) {\n  return value & ~mask;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "hash",
            "prefix",
            "given",
            "the",
            "current",
            "mask"
        ]
    },
    {
        "id": 779,
        "code": "static int getNext(int entry, int mask) {\n  return entry & mask;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "index",
            "or",
            "0",
            "if",
            "the",
            "entry",
            "is",
            "null"
        ]
    },
    {
        "id": 780,
        "code": "static int maskCombine(int prefix, int suffix, int mask) {\n  return (prefix & ~mask) | (suffix & mask);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "value",
            "combining",
            "the",
            "prefix",
            "and",
            "suffix",
            "using",
            "the",
            "given",
            "mask"
        ]
    },
    {
        "id": 781,
        "code": "public static <C extends Comparable> ContiguousSet<C> create(\n    Range<C> range, DiscreteDomain<C> domain) {\n  checkNotNull(range);\n  checkNotNull(domain);\n  Range<C> effectiveRange = range;\n  try {\n    if (!range.hasLowerBound()) {\n      effectiveRange = effectiveRange.intersection(Range.atLeast(domain.minValue()));\n    }\n    if (!range.hasUpperBound()) {\n      effectiveRange = effectiveRange.intersection(Range.atMost(domain.maxValue()));\n    }\n  } catch (NoSuchElementException e) {\n    throw new IllegalArgumentException(e);\n  }\n\n  boolean empty;\n  if (effectiveRange.isEmpty()) {\n    empty = true;\n  } else {\n      \n    C afterLower = requireNonNull(range.lowerBound.leastValueAbove(domain));\n    C beforeUpper = requireNonNull(range.upperBound.greatestValueBelow(domain));\n      \n    empty = Range.compareOrThrow(afterLower, beforeUpper) > 0;\n  }\n\n  return empty\n      ? new EmptyContiguousSet<C>(domain)\n      : new RegularContiguousSet<C>(effectiveRange, domain);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "contiguous",
            "set",
            "containing",
            "the",
            "same",
            "values",
            "in",
            "the",
            "given",
            "domain",
            "range",
            "contains",
            "contained",
            "by",
            "the",
            "range"
        ]
    },
    {
        "id": 782,
        "code": "public static ContiguousSet<Long> closed(long lower, long upper) {\n  return create(Range.closed(lower, upper), DiscreteDomain.longs());\n}",
        "summary_tokens": [
            "returns",
            "a",
            "nonempty",
            "contiguous",
            "set",
            "containing",
            "all",
            "long",
            "values",
            "from",
            "lower",
            "inclusive",
            "to",
            "upper",
            "inclusive"
        ]
    },
    {
        "id": 783,
        "code": "public static ContiguousSet<Long> closedOpen(long lower, long upper) {\n  return create(Range.closedOpen(lower, upper), DiscreteDomain.longs());\n}",
        "summary_tokens": [
            "returns",
            "a",
            "contiguous",
            "set",
            "containing",
            "all",
            "long",
            "values",
            "from",
            "lower",
            "inclusive",
            "to",
            "upper",
            "exclusive"
        ]
    },
    {
        "id": 784,
        "code": "public String toString() {\n  return range().toString();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "short",
            "hand",
            "representation",
            "of",
            "the",
            "contents",
            "such",
            "as",
            "0"
        ]
    },
    {
        "id": 785,
        "code": "public static DiscreteDomain<Integer> integers() {\n  return IntegerDomain.INSTANCE;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "discrete",
            "domain",
            "for",
            "values",
            "of",
            "type",
            "integer"
        ]
    },
    {
        "id": 786,
        "code": "public static DiscreteDomain<Long> longs() {\n  return LongDomain.INSTANCE;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "discrete",
            "domain",
            "for",
            "values",
            "of",
            "type",
            "long"
        ]
    },
    {
        "id": 787,
        "code": "public static DiscreteDomain<BigInteger> bigIntegers() {\n  return BigIntegerDomain.INSTANCE;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "discrete",
            "domain",
            "for",
            "values",
            "of",
            "type",
            "big",
            "integer"
        ]
    },
    {
        "id": 788,
        "code": "C offset(C origin, long distance) {\n  C current = origin;\n  checkNonnegative(distance, \"distance\");\n  for (long i = 0; i < distance; i++) {\n    current = next(current);\n    if (current == null) {\n      throw new IllegalArgumentException(\n          \"overflowed computing offset(\" + origin + \", \" + distance + \")\");\n    }\n  }\n  return current;\n}",
        "summary_tokens": [
            "returns",
            "conceptually",
            "origin",
            "distance",
            "or",
            "equivalently",
            "the",
            "result",
            "of",
            "calling",
            "next",
            "on",
            "origin",
            "distance",
            "times"
        ]
    },
    {
        "id": 789,
        "code": "public C minValue() {\n  throw new NoSuchElementException();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "minimum",
            "value",
            "of",
            "type",
            "c",
            "if",
            "it",
            "has",
            "one"
        ]
    },
    {
        "id": 790,
        "code": "public C maxValue() {\n  throw new NoSuchElementException();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "maximum",
            "value",
            "of",
            "type",
            "c",
            "if",
            "it",
            "has",
            "one"
        ]
    },
    {
        "id": 791,
        "code": "public static <K extends Enum<K>, V extends Enum<V>> EnumBiMap<K, V> create(Map<K, V> map) {\n  EnumBiMap<K, V> bimap = create(inferKeyType(map), inferValueType(map));\n  bimap.putAll(map);\n  return bimap;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "bimap",
            "with",
            "the",
            "same",
            "mappings",
            "as",
            "the",
            "specified",
            "map"
        ]
    },
    {
        "id": 792,
        "code": "public Class<K> keyType() {\n  return keyType;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "associated",
            "key",
            "type"
        ]
    },
    {
        "id": 793,
        "code": "public Class<V> valueType() {\n  return valueType;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "associated",
            "value",
            "type"
        ]
    },
    {
        "id": 794,
        "code": "private void writeObject(ObjectOutputStream stream) throws IOException {\n  stream.defaultWriteObject();\n  stream.writeObject(keyType);\n  stream.writeObject(valueType);\n  Serialization.writeMap(this, stream);\n}",
        "summary_tokens": [
            "the",
            "key",
            "class",
            "value",
            "class",
            "number",
            "of",
            "entries",
            "first",
            "key",
            "first",
            "value",
            "second",
            "key",
            "second",
            "value",
            "and",
            "so",
            "on"
        ]
    },
    {
        "id": 795,
        "code": "public static <E extends Enum<E>> EnumMultiset<E> create(Iterable<E> elements, Class<E> type) {\n  EnumMultiset<E> result = create(type);\n  Iterables.addAll(result, elements);\n  return result;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "enum",
            "multiset",
            "instance",
            "containing",
            "the",
            "given",
            "elements"
        ]
    },
    {
        "id": 796,
        "code": "private void checkIsE(Object element) {\n  checkNotNull(element);\n  if (!isActuallyE(element)) {\n    throw new ClassCastException(\"Expected an \" + type + \" but got \" + element);\n  }\n}",
        "summary_tokens": [
            "returns",
            "element",
            "cast",
            "to",
            "e",
            "if",
            "it",
            "actually",
            "is",
            "a",
            "nonnull",
            "e"
        ]
    },
    {
        "id": 797,
        "code": "private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {\n  stream.defaultReadObject();\n  @SuppressWarnings(\"unchecked\") \n  Class<E> localType = (Class<E>) stream.readObject();\n  type = localType;\n  enumConstants = type.getEnumConstants();\n  counts = new int[enumConstants.length];\n  Serialization.populateMultiset(this, stream);\n}",
        "summary_tokens": [
            "the",
            "class",
            "e",
            "for",
            "the",
            "enum",
            "type",
            "the",
            "number",
            "of",
            "distinct",
            "elements",
            "the",
            "first",
            "element",
            "its",
            "count",
            "the",
            "second",
            "element",
            "its",
            "count",
            "and",
            "so",
            "on"
        ]
    },
    {
        "id": 798,
        "code": "public static <E> EvictingQueue<E> create(int maxSize) {\n  return new EvictingQueue<>(maxSize);\n}",
        "summary_tokens": [
            "creates",
            "and",
            "returns",
            "a",
            "new",
            "evicting",
            "queue",
            "that",
            "will",
            "hold",
            "up",
            "to",
            "max",
            "size",
            "elements"
        ]
    },
    {
        "id": 799,
        "code": "public int remainingCapacity() {\n  return maxSize - size();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "additional",
            "elements",
            "that",
            "this",
            "queue",
            "can",
            "accept",
            "without",
            "evicting",
            "zero",
            "if",
            "the",
            "queue",
            "is",
            "currently",
            "full"
        ]
    },
    {
        "id": 800,
        "code": "public boolean offer(E e) {\n  return add(e);\n}",
        "summary_tokens": [
            "adds",
            "the",
            "given",
            "element",
            "to",
            "this",
            "queue"
        ]
    },
    {
        "id": 801,
        "code": "public boolean add(E e) {\n  checkNotNull(e); \n  if (maxSize == 0) {\n    return true;\n  }\n  if (size() == maxSize) {\n    delegate.remove();\n  }\n  delegate.add(e);\n  return true;\n}",
        "summary_tokens": [
            "adds",
            "the",
            "given",
            "element",
            "to",
            "this",
            "queue"
        ]
    },
    {
        "id": 802,
        "code": "public static <R, C, V> HashBasedTable<R, C, V> create(\n    Table<? extends R, ? extends C, ? extends V> table) {\n  HashBasedTable<R, C, V> result = create();\n  result.putAll(table);\n  return result;\n}",
        "summary_tokens": [
            "creates",
            "a",
            "hash",
            "based",
            "table",
            "with",
            "the",
            "same",
            "mappings",
            "as",
            "the",
            "specified",
            "table"
        ]
    },
    {
        "id": 803,
        "code": "public static <K, V> ImmutableBiMap<K, V> of(\n    K k1,\n    V v1,\n    K k2,\n    V v2,\n    K k3,\n    V v3,\n    K k4,\n    V v4,\n    K k5,\n    V v5,\n    K k6,\n    V v6,\n    K k7,\n    V v7,\n    K k8,\n    V v8,\n    K k9,\n    V v9,\n    K k10,\n    V v10) {\n  checkEntryNotNull(k1, v1);\n  checkEntryNotNull(k2, v2);\n  checkEntryNotNull(k3, v3);\n  checkEntryNotNull(k4, v4);\n  checkEntryNotNull(k5, v5);\n  checkEntryNotNull(k6, v6);\n  checkEntryNotNull(k7, v7);\n  checkEntryNotNull(k8, v8);\n  checkEntryNotNull(k9, v9);\n  checkEntryNotNull(k10, v10);\n  return new RegularImmutableBiMap<K, V>(\n      new Object[] {\n        k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7, k8, v8, k9, v9, k10, v10\n      },\n      10);\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "map",
            "containing",
            "the",
            "given",
            "entries",
            "in",
            "order"
        ]
    },
    {
        "id": 804,
        "code": "public static <K, V> ImmutableBiMap<K, V> ofEntries(Entry<? extends K, ? extends V>... entries) {\n  @SuppressWarnings(\"unchecked\") \n  Entry<K, V>[] entries2 = (Entry<K, V>[]) entries;\n  return copyOf(Arrays.asList(entries2));\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "map",
            "containing",
            "the",
            "given",
            "entries",
            "in",
            "order"
        ]
    },
    {
        "id": 805,
        "code": "public static <K, V> Builder<K, V> builder() {\n  return new Builder<>();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "builder"
        ]
    },
    {
        "id": 806,
        "code": "public static <K, V> Builder<K, V> builderWithExpectedSize(int expectedSize) {\n  checkNonnegative(expectedSize, \"expectedSize\");\n  return new Builder<>(expectedSize);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "builder",
            "expecting",
            "the",
            "specified",
            "number",
            "of",
            "entries",
            "to",
            "be",
            "added"
        ]
    },
    {
        "id": 807,
        "code": "public static <K, V> ImmutableBiMap<K, V> copyOf(\n    Iterable<? extends Entry<? extends K, ? extends V>> entries) {\n  int estimatedSize =\n      (entries instanceof Collection)\n          ? ((Collection<?>) entries).size()\n          : ImmutableCollection.Builder.DEFAULT_INITIAL_CAPACITY;\n  return new Builder<K, V>(estimatedSize).putAll(entries).build();\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "bimap",
            "containing",
            "the",
            "given",
            "entries"
        ]
    },
    {
        "id": 808,
        "code": "public ImmutableSet<V> values() {\n  return inverse().keySet();\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "set",
            "of",
            "the",
            "values",
            "in",
            "this",
            "map",
            "in",
            "the",
            "same",
            "order",
            "they",
            "appear",
            "in",
            "entry",
            "set"
        ]
    },
    {
        "id": 809,
        "code": "public final V forcePut(K key, V value) {\n  throw new UnsupportedOperationException();\n}",
        "summary_tokens": [
            "guaranteed",
            "to",
            "throw",
            "an",
            "exception",
            "and",
            "leave",
            "the",
            "bimap",
            "unmodified"
        ]
    },
    {
        "id": 810,
        "code": "public static <B, T extends B> ImmutableClassToInstanceMap<B> of(Class<T> type, T value) {\n  ImmutableMap<Class<? extends B>, B> map = ImmutableMap.<Class<? extends B>, B>of(type, value);\n  return new ImmutableClassToInstanceMap<>(map);\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "class",
            "to",
            "instance",
            "map",
            "containing",
            "a",
            "single",
            "entry"
        ]
    },
    {
        "id": 811,
        "code": "public static <B> Builder<B> builder() {\n  return new Builder<>();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "builder"
        ]
    },
    {
        "id": 812,
        "code": "public static <B, S extends B> ImmutableClassToInstanceMap<B> copyOf(\n    Map<? extends Class<? extends S>, ? extends S> map) {\n  if (map instanceof ImmutableClassToInstanceMap) {\n    @SuppressWarnings(\"unchecked\") \n    ImmutableClassToInstanceMap<B> cast = (ImmutableClassToInstanceMap<B>) map;\n    return cast;\n  }\n  return new Builder<B>().putAll(map).build();\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "map",
            "containing",
            "the",
            "same",
            "entries",
            "as",
            "map"
        ]
    },
    {
        "id": 813,
        "code": "public <T extends B> T putInstance(Class<T> type, T value) {\n  throw new UnsupportedOperationException();\n}",
        "summary_tokens": [
            "guaranteed",
            "to",
            "throw",
            "an",
            "exception",
            "and",
            "leave",
            "the",
            "map",
            "unmodified"
        ]
    },
    {
        "id": 814,
        "code": "public static <E> ImmutableList<E> of(\n    E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E e11, E e12, E... others) {\n  checkArgument(\n      others.length <= Integer.MAX_VALUE - 12, \"the total number of elements must fit in an int\");\n  Object[] array = new Object[12 + others.length];\n  array[0] = e1;\n  array[1] = e2;\n  array[2] = e3;\n  array[3] = e4;\n  array[4] = e5;\n  array[5] = e6;\n  array[6] = e7;\n  array[7] = e8;\n  array[8] = e9;\n  array[9] = e10;\n  array[10] = e11;\n  array[11] = e12;\n  System.arraycopy(others, 0, array, 12, others.length);\n  return construct(array);\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "list",
            "containing",
            "the",
            "given",
            "elements",
            "in",
            "order"
        ]
    },
    {
        "id": 815,
        "code": "public static <E> ImmutableList<E> copyOf(E[] elements) {\n  return (elements.length == 0)\n      ? ImmutableList.<E>of()\n      : ImmutableList.<E>construct(elements.clone());\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "list",
            "containing",
            "the",
            "given",
            "elements",
            "in",
            "order"
        ]
    },
    {
        "id": 816,
        "code": "public static <E> ImmutableList<E> sortedCopyOf(\n    Comparator<? super E> comparator, Iterable<? extends E> elements) {\n  checkNotNull(comparator);\n  @SuppressWarnings(\"unchecked\") \n  E[] array = (E[]) Iterables.toArray(elements);\n  checkElementsNotNull(array);\n  Arrays.sort(array, comparator);\n  return asImmutableList(array);\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "list",
            "containing",
            "the",
            "given",
            "elements",
            "in",
            "sorted",
            "order",
            "relative",
            "to",
            "the",
            "specified",
            "comparator"
        ]
    },
    {
        "id": 817,
        "code": "private static <E> ImmutableList<E> construct(Object... elements) {\n  return asImmutableList(checkElementsNotNull(elements));\n}",
        "summary_tokens": [
            "views",
            "the",
            "array",
            "as",
            "an",
            "immutable",
            "list"
        ]
    },
    {
        "id": 818,
        "code": "static <E> ImmutableList<E> asImmutableList(Object[] elements) {\n  return unsafeDelegateList((List) Arrays.asList(elements));\n}",
        "summary_tokens": [
            "views",
            "the",
            "array",
            "as",
            "an",
            "immutable",
            "list"
        ]
    },
    {
        "id": 819,
        "code": "public ImmutableList<E> subList(int fromIndex, int toIndex) {\n  checkPositionIndexes(fromIndex, toIndex, size());\n  int length = toIndex - fromIndex;\n  if (length == size()) {\n    return this;\n  } else if (length == 0) {\n    return of();\n  } else {\n    return subListUnchecked(fromIndex, toIndex);\n  }\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "list",
            "of",
            "the",
            "elements",
            "between",
            "the",
            "specified",
            "from",
            "index",
            "inclusive",
            "and",
            "to",
            "index",
            "exclusive"
        ]
    },
    {
        "id": 820,
        "code": "ImmutableList<E> subListUnchecked(int fromIndex, int toIndex) {\n  return new SubList(fromIndex, toIndex - fromIndex);\n}",
        "summary_tokens": [
            "called",
            "by",
            "the",
            "default",
            "implementation",
            "of",
            "sub",
            "list",
            "when",
            "to",
            "index",
            "from",
            "index",
            "0",
            "after",
            "index",
            "validation",
            "has",
            "already",
            "been",
            "performed"
        ]
    },
    {
        "id": 821,
        "code": "public final boolean addAll(int index, Collection<? extends E> newElements) {\n  throw new UnsupportedOperationException();\n}",
        "summary_tokens": [
            "guaranteed",
            "to",
            "throw",
            "an",
            "exception",
            "and",
            "leave",
            "the",
            "list",
            "unmodified"
        ]
    },
    {
        "id": 822,
        "code": "public final E set(int index, E element) {\n  throw new UnsupportedOperationException();\n}",
        "summary_tokens": [
            "guaranteed",
            "to",
            "throw",
            "an",
            "exception",
            "and",
            "leave",
            "the",
            "list",
            "unmodified"
        ]
    },
    {
        "id": 823,
        "code": "public final void add(int index, E element) {\n  throw new UnsupportedOperationException();\n}",
        "summary_tokens": [
            "guaranteed",
            "to",
            "throw",
            "an",
            "exception",
            "and",
            "leave",
            "the",
            "list",
            "unmodified"
        ]
    },
    {
        "id": 824,
        "code": "public final E remove(int index) {\n  throw new UnsupportedOperationException();\n}",
        "summary_tokens": [
            "guaranteed",
            "to",
            "throw",
            "an",
            "exception",
            "and",
            "leave",
            "the",
            "list",
            "unmodified"
        ]
    },
    {
        "id": 825,
        "code": "public final ImmutableList<E> asList() {\n  return this;\n}",
        "summary_tokens": [
            "returns",
            "this",
            "list",
            "instance"
        ]
    },
    {
        "id": 826,
        "code": "public ImmutableList<E> reverse() {\n  return (size() <= 1) ? this : new ReverseImmutableList<E>(this);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "view",
            "of",
            "this",
            "immutable",
            "list",
            "in",
            "reverse",
            "order"
        ]
    },
    {
        "id": 827,
        "code": "public static <E> Builder<E> builder() {\n  return new Builder<E>();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "builder"
        ]
    },
    {
        "id": 828,
        "code": "public static <E> Builder<E> builderWithExpectedSize(int expectedSize) {\n  checkNonnegative(expectedSize, \"expectedSize\");\n  return new ImmutableList.Builder<E>(expectedSize);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "builder",
            "expecting",
            "the",
            "specified",
            "number",
            "of",
            "elements",
            "to",
            "be",
            "added"
        ]
    },
    {
        "id": 829,
        "code": "public static <K, V> ImmutableListMultimap<K, V> of(\n    K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5) {\n  ImmutableListMultimap.Builder<K, V> builder = ImmutableListMultimap.builder();\n  builder.put(k1, v1);\n  builder.put(k2, v2);\n  builder.put(k3, v3);\n  builder.put(k4, v4);\n  builder.put(k5, v5);\n  return builder.build();\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "multimap",
            "containing",
            "the",
            "given",
            "entries",
            "in",
            "order"
        ]
    },
    {
        "id": 830,
        "code": "public static <K, V> Builder<K, V> builder() {\n  return new Builder<>();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "builder"
        ]
    },
    {
        "id": 831,
        "code": "public static <K, V> ImmutableListMultimap<K, V> copyOf(\n    Iterable<? extends Entry<? extends K, ? extends V>> entries) {\n  return new Builder<K, V>().putAll(entries).build();\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "multimap",
            "containing",
            "the",
            "specified",
            "entries"
        ]
    },
    {
        "id": 832,
        "code": "static <K, V> ImmutableListMultimap<K, V> fromMapEntries(\n    Collection<? extends Map.Entry<? extends K, ? extends Collection<? extends V>>> mapEntries,\n    @Nullable Comparator<? super V> valueComparator) {\n  if (mapEntries.isEmpty()) {\n    return of();\n  }\n  ImmutableMap.Builder<K, ImmutableList<V>> builder =\n      new ImmutableMap.Builder<>(mapEntries.size());\n  int size = 0;\n\n  for (Entry<? extends K, ? extends Collection<? extends V>> entry : mapEntries) {\n    K key = entry.getKey();\n    Collection<? extends V> values = entry.getValue();\n    ImmutableList<V> list =\n        (valueComparator == null)\n            ? ImmutableList.copyOf(values)\n            : ImmutableList.sortedCopyOf(valueComparator, values);\n    if (!list.isEmpty()) {\n      builder.put(key, list);\n      size += list.size();\n    }\n  }\n\n  return new ImmutableListMultimap<>(builder.build(), size);\n}",
        "summary_tokens": [
            "creates",
            "an",
            "immutable",
            "list",
            "multimap",
            "from",
            "an",
            "as",
            "map"
        ]
    },
    {
        "id": 833,
        "code": "public ImmutableList<V> get(K key) {\n    \n  ImmutableList<V> list = (ImmutableList<V>) map.get(key);\n  return (list == null) ? ImmutableList.<V>of() : list;\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "list",
            "of",
            "the",
            "values",
            "for",
            "the",
            "given",
            "key"
        ]
    },
    {
        "id": 834,
        "code": "public final ImmutableList<V> removeAll(@CheckForNull Object key) {\n  throw new UnsupportedOperationException();\n}",
        "summary_tokens": [
            "guaranteed",
            "to",
            "throw",
            "an",
            "exception",
            "and",
            "leave",
            "the",
            "multimap",
            "unmodified"
        ]
    },
    {
        "id": 835,
        "code": "public final ImmutableList<V> replaceValues(K key, Iterable<? extends V> values) {\n  throw new UnsupportedOperationException();\n}",
        "summary_tokens": [
            "guaranteed",
            "to",
            "throw",
            "an",
            "exception",
            "and",
            "leave",
            "the",
            "multimap",
            "unmodified"
        ]
    },
    {
        "id": 836,
        "code": "private void writeObject(ObjectOutputStream stream) throws IOException {\n  stream.defaultWriteObject();\n  Serialization.writeMultimap(this, stream);\n}",
        "summary_tokens": [
            "number",
            "of",
            "distinct",
            "keys",
            "and",
            "then",
            "for",
            "each",
            "distinct",
            "key",
            "the",
            "key",
            "the",
            "number",
            "of",
            "values",
            "for",
            "that",
            "key",
            "and",
            "the",
            "key",
            "s",
            "values"
        ]
    },
    {
        "id": 837,
        "code": "public static <K, V> ImmutableMultimap<K, V> of(\n    K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5) {\n  return ImmutableListMultimap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5);\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "multimap",
            "containing",
            "the",
            "given",
            "entries",
            "in",
            "the",
            "key",
            "grouped",
            "insertion",
            "order",
            "described",
            "in",
            "the",
            "a",
            "href",
            "iteration",
            "class",
            "documentation",
            "a"
        ]
    },
    {
        "id": 838,
        "code": "public static <K, V> Builder<K, V> builder() {\n  return new Builder<>();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "builder"
        ]
    },
    {
        "id": 839,
        "code": "public static <K, V> ImmutableMultimap<K, V> copyOf(\n    Iterable<? extends Entry<? extends K, ? extends V>> entries) {\n  return ImmutableListMultimap.copyOf(entries);\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "multimap",
            "containing",
            "the",
            "specified",
            "entries"
        ]
    },
    {
        "id": 840,
        "code": "public ImmutableCollection<V> removeAll(@CheckForNull Object key) {\n  throw new UnsupportedOperationException();\n}",
        "summary_tokens": [
            "guaranteed",
            "to",
            "throw",
            "an",
            "exception",
            "and",
            "leave",
            "the",
            "multimap",
            "unmodified"
        ]
    },
    {
        "id": 841,
        "code": "public ImmutableCollection<V> replaceValues(K key, Iterable<? extends V> values) {\n  throw new UnsupportedOperationException();\n}",
        "summary_tokens": [
            "guaranteed",
            "to",
            "throw",
            "an",
            "exception",
            "and",
            "leave",
            "the",
            "multimap",
            "unmodified"
        ]
    },
    {
        "id": 842,
        "code": "public final void clear() {\n  throw new UnsupportedOperationException();\n}",
        "summary_tokens": [
            "guaranteed",
            "to",
            "throw",
            "an",
            "exception",
            "and",
            "leave",
            "the",
            "multimap",
            "unmodified"
        ]
    },
    {
        "id": 843,
        "code": "public final boolean put(K key, V value) {\n  throw new UnsupportedOperationException();\n}",
        "summary_tokens": [
            "guaranteed",
            "to",
            "throw",
            "an",
            "exception",
            "and",
            "leave",
            "the",
            "multimap",
            "unmodified"
        ]
    },
    {
        "id": 844,
        "code": "public final boolean putAll(Multimap<? extends K, ? extends V> multimap) {\n  throw new UnsupportedOperationException();\n}",
        "summary_tokens": [
            "guaranteed",
            "to",
            "throw",
            "an",
            "exception",
            "and",
            "leave",
            "the",
            "multimap",
            "unmodified"
        ]
    },
    {
        "id": 845,
        "code": "public final boolean remove(@CheckForNull Object key, @CheckForNull Object value) {\n  throw new UnsupportedOperationException();\n}",
        "summary_tokens": [
            "guaranteed",
            "to",
            "throw",
            "an",
            "exception",
            "and",
            "leave",
            "the",
            "multimap",
            "unmodified"
        ]
    },
    {
        "id": 846,
        "code": "boolean isPartialView() {\n  return map.isPartialView();\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "this",
            "immutable",
            "multimap",
            "s",
            "implementation",
            "contains",
            "references",
            "to",
            "user",
            "created",
            "objects",
            "that",
            "aren",
            "t",
            "accessible",
            "via",
            "this",
            "multimap",
            "s",
            "methods"
        ]
    },
    {
        "id": 847,
        "code": "public ImmutableSet<K> keySet() {\n  return map.keySet();\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "set",
            "of",
            "the",
            "distinct",
            "keys",
            "in",
            "this",
            "multimap",
            "in",
            "the",
            "same",
            "order",
            "as",
            "they",
            "appear",
            "in",
            "this",
            "multimap"
        ]
    },
    {
        "id": 848,
        "code": "public ImmutableMap<K, Collection<V>> asMap() {\n  return (ImmutableMap) map;\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "map",
            "that",
            "associates",
            "each",
            "key",
            "with",
            "its",
            "corresponding",
            "values",
            "in",
            "the",
            "multimap"
        ]
    },
    {
        "id": 849,
        "code": "public ImmutableCollection<Entry<K, V>> entries() {\n  return (ImmutableCollection<Entry<K, V>>) super.entries();\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "collection",
            "of",
            "all",
            "key",
            "value",
            "pairs",
            "in",
            "the",
            "multimap"
        ]
    },
    {
        "id": 850,
        "code": "public ImmutableMultiset<K> keys() {\n  return (ImmutableMultiset<K>) super.keys();\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "multiset",
            "containing",
            "all",
            "the",
            "keys",
            "in",
            "this",
            "multimap",
            "in",
            "the",
            "same",
            "order",
            "and",
            "with",
            "the",
            "same",
            "frequencies",
            "as",
            "they",
            "appear",
            "in",
            "this",
            "multimap",
            "to",
            "get",
            "only",
            "a",
            "single",
            "occurrence",
            "of",
            "each",
            "key",
            "use",
            "key",
            "set"
        ]
    },
    {
        "id": 851,
        "code": "public ImmutableCollection<V> values() {\n  return (ImmutableCollection<V>) super.values();\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "collection",
            "of",
            "the",
            "values",
            "in",
            "this",
            "multimap"
        ]
    },
    {
        "id": 852,
        "code": "public static <E> ImmutableMultiset<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E... others) {\n  return new Builder<E>().add(e1).add(e2).add(e3).add(e4).add(e5).add(e6).add(others).build();\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "multiset",
            "containing",
            "the",
            "given",
            "elements",
            "in",
            "the",
            "grouped",
            "iteration",
            "order",
            "described",
            "in",
            "the",
            "class",
            "documentation"
        ]
    },
    {
        "id": 853,
        "code": "public static <E> ImmutableMultiset<E> copyOf(Iterator<? extends E> elements) {\n  return new ImmutableMultiset.Builder<E>().addAll(elements).build();\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "multiset",
            "containing",
            "the",
            "given",
            "elements",
            "in",
            "the",
            "grouped",
            "iteration",
            "order",
            "described",
            "in",
            "the",
            "class",
            "documentation"
        ]
    },
    {
        "id": 854,
        "code": "public final int add(E element, int occurrences) {\n  throw new UnsupportedOperationException();\n}",
        "summary_tokens": [
            "guaranteed",
            "to",
            "throw",
            "an",
            "exception",
            "and",
            "leave",
            "the",
            "collection",
            "unmodified"
        ]
    },
    {
        "id": 855,
        "code": "public final int remove(@CheckForNull Object element, int occurrences) {\n  throw new UnsupportedOperationException();\n}",
        "summary_tokens": [
            "guaranteed",
            "to",
            "throw",
            "an",
            "exception",
            "and",
            "leave",
            "the",
            "collection",
            "unmodified"
        ]
    },
    {
        "id": 856,
        "code": "public final boolean setCount(E element, int oldCount, int newCount) {\n  throw new UnsupportedOperationException();\n}",
        "summary_tokens": [
            "guaranteed",
            "to",
            "throw",
            "an",
            "exception",
            "and",
            "leave",
            "the",
            "collection",
            "unmodified"
        ]
    },
    {
        "id": 857,
        "code": "public static <E> Builder<E> builder() {\n  return new Builder<E>();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "builder"
        ]
    },
    {
        "id": 858,
        "code": "public static <K extends Comparable<?>, V> ImmutableRangeMap<K, V> of(Range<K> range, V value) {\n  return new ImmutableRangeMap<>(ImmutableList.of(range), ImmutableList.of(value));\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "range",
            "map",
            "mapping",
            "a",
            "single",
            "range",
            "to",
            "a",
            "single",
            "value"
        ]
    },
    {
        "id": 859,
        "code": "public static <K extends Comparable<?>, V> Builder<K, V> builder() {\n  return new Builder<>();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "builder",
            "for",
            "an",
            "immutable",
            "range",
            "map"
        ]
    },
    {
        "id": 860,
        "code": "public final void put(Range<K> range, V value) {\n  throw new UnsupportedOperationException();\n}",
        "summary_tokens": [
            "guaranteed",
            "to",
            "throw",
            "an",
            "exception",
            "and",
            "leave",
            "the",
            "range",
            "map",
            "unmodified"
        ]
    },
    {
        "id": 861,
        "code": "public final void putCoalescing(Range<K> range, V value) {\n  throw new UnsupportedOperationException();\n}",
        "summary_tokens": [
            "guaranteed",
            "to",
            "throw",
            "an",
            "exception",
            "and",
            "leave",
            "the",
            "range",
            "map",
            "unmodified"
        ]
    },
    {
        "id": 862,
        "code": "public final void putAll(RangeMap<K, V> rangeMap) {\n  throw new UnsupportedOperationException();\n}",
        "summary_tokens": [
            "guaranteed",
            "to",
            "throw",
            "an",
            "exception",
            "and",
            "leave",
            "the",
            "range",
            "map",
            "unmodified"
        ]
    },
    {
        "id": 863,
        "code": "public final void clear() {\n  throw new UnsupportedOperationException();\n}",
        "summary_tokens": [
            "guaranteed",
            "to",
            "throw",
            "an",
            "exception",
            "and",
            "leave",
            "the",
            "range",
            "map",
            "unmodified"
        ]
    },
    {
        "id": 864,
        "code": "public final void remove(Range<K> range) {\n  throw new UnsupportedOperationException();\n}",
        "summary_tokens": [
            "guaranteed",
            "to",
            "throw",
            "an",
            "exception",
            "and",
            "leave",
            "the",
            "range",
            "map",
            "unmodified"
        ]
    },
    {
        "id": 865,
        "code": "public static <C extends Comparable> ImmutableRangeSet<C> of(Range<C> range) {\n  checkNotNull(range);\n  if (range.isEmpty()) {\n    return of();\n  } else if (range.equals(Range.all())) {\n    return all();\n  } else {\n    return new ImmutableRangeSet<C>(ImmutableList.of(range));\n  }\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "range",
            "set",
            "containing",
            "the",
            "specified",
            "single",
            "range"
        ]
    },
    {
        "id": 866,
        "code": "static <C extends Comparable> ImmutableRangeSet<C> all() {\n  return (ImmutableRangeSet<C>) ALL;\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "range",
            "set",
            "containing",
            "the",
            "single",
            "range",
            "range",
            "all"
        ]
    },
    {
        "id": 867,
        "code": "public static <C extends Comparable<?>> ImmutableRangeSet<C> copyOf(Iterable<Range<C>> ranges) {\n  return new ImmutableRangeSet.Builder<C>().addAll(ranges).build();\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "range",
            "set",
            "containing",
            "each",
            "of",
            "the",
            "specified",
            "disjoint",
            "ranges"
        ]
    },
    {
        "id": 868,
        "code": "public static <C extends Comparable<?>> ImmutableRangeSet<C> unionOf(Iterable<Range<C>> ranges) {\n  return copyOf(TreeRangeSet.create(ranges));\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "range",
            "set",
            "representing",
            "the",
            "union",
            "of",
            "the",
            "specified",
            "ranges"
        ]
    },
    {
        "id": 869,
        "code": "public void add(Range<C> range) {\n  throw new UnsupportedOperationException();\n}",
        "summary_tokens": [
            "guaranteed",
            "to",
            "throw",
            "an",
            "exception",
            "and",
            "leave",
            "the",
            "range",
            "set",
            "unmodified"
        ]
    },
    {
        "id": 870,
        "code": "public void addAll(Iterable<Range<C>> other) {\n  throw new UnsupportedOperationException();\n}",
        "summary_tokens": [
            "guaranteed",
            "to",
            "throw",
            "an",
            "exception",
            "and",
            "leave",
            "the",
            "range",
            "set",
            "unmodified"
        ]
    },
    {
        "id": 871,
        "code": "public void remove(Range<C> range) {\n  throw new UnsupportedOperationException();\n}",
        "summary_tokens": [
            "guaranteed",
            "to",
            "throw",
            "an",
            "exception",
            "and",
            "leave",
            "the",
            "range",
            "set",
            "unmodified"
        ]
    },
    {
        "id": 872,
        "code": "public void removeAll(Iterable<Range<C>> other) {\n  throw new UnsupportedOperationException();\n}",
        "summary_tokens": [
            "guaranteed",
            "to",
            "throw",
            "an",
            "exception",
            "and",
            "leave",
            "the",
            "range",
            "set",
            "unmodified"
        ]
    },
    {
        "id": 873,
        "code": "public ImmutableRangeSet<C> union(RangeSet<C> other) {\n  return unionOf(Iterables.concat(asRanges(), other.asRanges()));\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "range",
            "set",
            "consisting",
            "of",
            "the",
            "union",
            "of",
            "this",
            "range",
            "set",
            "and",
            "other"
        ]
    },
    {
        "id": 874,
        "code": "public ImmutableRangeSet<C> intersection(RangeSet<C> other) {\n  RangeSet<C> copy = TreeRangeSet.create(this);\n  copy.removeAll(other.complement());\n  return copyOf(copy);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "range",
            "set",
            "consisting",
            "of",
            "the",
            "intersection",
            "of",
            "this",
            "range",
            "set",
            "and",
            "other"
        ]
    },
    {
        "id": 875,
        "code": "public ImmutableRangeSet<C> difference(RangeSet<C> other) {\n  RangeSet<C> copy = TreeRangeSet.create(this);\n  copy.removeAll(other);\n  return copyOf(copy);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "range",
            "set",
            "consisting",
            "of",
            "the",
            "difference",
            "of",
            "this",
            "range",
            "set",
            "and",
            "other"
        ]
    },
    {
        "id": 876,
        "code": "private ImmutableList<Range<C>> intersectRanges(final Range<C> range) {\n  if (ranges.isEmpty() || range.isEmpty()) {\n    return ImmutableList.of();\n  } else if (range.encloses(span())) {\n    return ranges;\n  }\n\n  final int fromIndex;\n  if (range.hasLowerBound()) {\n    fromIndex =\n        SortedLists.binarySearch(\n            ranges,\n            Range.<C>upperBoundFn(),\n            range.lowerBound,\n            KeyPresentBehavior.FIRST_AFTER,\n            KeyAbsentBehavior.NEXT_HIGHER);\n  } else {\n    fromIndex = 0;\n  }\n\n  int toIndex;\n  if (range.hasUpperBound()) {\n    toIndex =\n        SortedLists.binarySearch(\n            ranges,\n            Range.<C>lowerBoundFn(),\n            range.upperBound,\n            KeyPresentBehavior.FIRST_PRESENT,\n            KeyAbsentBehavior.NEXT_HIGHER);\n  } else {\n    toIndex = ranges.size();\n  }\n  final int length = toIndex - fromIndex;\n  if (length == 0) {\n    return ImmutableList.of();\n  } else {\n    return new ImmutableList<Range<C>>() {\n      @Override\n      public int size() {\n        return length;\n      }\n\n      @Override\n      public Range<C> get(int index) {\n        checkElementIndex(index, length);\n        if (index == 0 || index == length - 1) {\n          return ranges.get(index + fromIndex).intersection(range);\n        } else {\n          return ranges.get(index + fromIndex);\n        }\n      }\n\n      @Override\n      boolean isPartialView() {\n        return true;\n      }\n    };\n  }\n}",
        "summary_tokens": [
            "returns",
            "a",
            "list",
            "containing",
            "the",
            "nonempty",
            "intersections",
            "of",
            "range",
            "with",
            "the",
            "ranges",
            "in",
            "this",
            "range",
            "set"
        ]
    },
    {
        "id": 877,
        "code": "public ImmutableRangeSet<C> subRangeSet(Range<C> range) {\n  if (!isEmpty()) {\n    Range<C> span = span();\n    if (range.encloses(span)) {\n      return this;\n    } else if (range.isConnected(span)) {\n      return new ImmutableRangeSet<C>(intersectRanges(range));\n    }\n  }\n  return of();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "view",
            "of",
            "the",
            "intersection",
            "of",
            "this",
            "range",
            "set",
            "with",
            "the",
            "given",
            "range"
        ]
    },
    {
        "id": 878,
        "code": "public ImmutableSortedSet<C> asSet(DiscreteDomain<C> domain) {\n  checkNotNull(domain);\n  if (isEmpty()) {\n    return ImmutableSortedSet.of();\n  }\n  Range<C> span = span().canonical(domain);\n  if (!span.hasLowerBound()) {\n      \n      \n    throw new IllegalArgumentException(\n        \"Neither the DiscreteDomain nor this range set are bounded below\");\n  } else if (!span.hasUpperBound()) {\n    try {\n      domain.maxValue();\n    } catch (NoSuchElementException e) {\n      throw new IllegalArgumentException(\n          \"Neither the DiscreteDomain nor this range set are bounded above\");\n    }\n  }\n\n  return new AsSet(domain);\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "sorted",
            "set",
            "containing",
            "the",
            "same",
            "values",
            "in",
            "the",
            "given",
            "domain",
            "range",
            "set",
            "contains",
            "contained",
            "by",
            "this",
            "range",
            "set"
        ]
    },
    {
        "id": 879,
        "code": "boolean isPartialView() {\n  return ranges.isPartialView();\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "this",
            "immutable",
            "range",
            "set",
            "s",
            "implementation",
            "contains",
            "references",
            "to",
            "user",
            "created",
            "objects",
            "that",
            "aren",
            "t",
            "accessible",
            "via",
            "this",
            "range",
            "set",
            "s",
            "methods"
        ]
    },
    {
        "id": 880,
        "code": "public static <C extends Comparable<?>> Builder<C> builder() {\n  return new Builder<C>();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "builder",
            "for",
            "an",
            "immutable",
            "range",
            "set"
        ]
    },
    {
        "id": 881,
        "code": "public static <K, V> ImmutableSetMultimap<K, V> of(\n    K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5) {\n  ImmutableSetMultimap.Builder<K, V> builder = ImmutableSetMultimap.builder();\n  builder.put(k1, v1);\n  builder.put(k2, v2);\n  builder.put(k3, v3);\n  builder.put(k4, v4);\n  builder.put(k5, v5);\n  return builder.build();\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "multimap",
            "containing",
            "the",
            "given",
            "entries",
            "in",
            "order"
        ]
    },
    {
        "id": 882,
        "code": "public static <K, V> Builder<K, V> builder() {\n  return new Builder<>();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "builder"
        ]
    },
    {
        "id": 883,
        "code": "public static <K, V> ImmutableSetMultimap<K, V> copyOf(\n    Iterable<? extends Entry<? extends K, ? extends V>> entries) {\n  return new Builder<K, V>().putAll(entries).build();\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "multimap",
            "containing",
            "the",
            "specified",
            "entries"
        ]
    },
    {
        "id": 884,
        "code": "static <K, V> ImmutableSetMultimap<K, V> fromMapEntries(\n    Collection<? extends Map.Entry<? extends K, ? extends Collection<? extends V>>> mapEntries,\n    @CheckForNull Comparator<? super V> valueComparator) {\n  if (mapEntries.isEmpty()) {\n    return of();\n  }\n  ImmutableMap.Builder<K, ImmutableSet<V>> builder =\n      new ImmutableMap.Builder<>(mapEntries.size());\n  int size = 0;\n\n  for (Entry<? extends K, ? extends Collection<? extends V>> entry : mapEntries) {\n    K key = entry.getKey();\n    Collection<? extends V> values = entry.getValue();\n    ImmutableSet<V> set = valueSet(valueComparator, values);\n    if (!set.isEmpty()) {\n      builder.put(key, set);\n      size += set.size();\n    }\n  }\n\n  return new ImmutableSetMultimap<>(builder.build(), size, valueComparator);\n}",
        "summary_tokens": [
            "creates",
            "an",
            "immutable",
            "set",
            "multimap",
            "from",
            "an",
            "as",
            "map"
        ]
    },
    {
        "id": 885,
        "code": "public ImmutableSet<V> get(K key) {\n    \n  ImmutableSet<V> set = (ImmutableSet<V>) map.get(key);\n  return MoreObjects.firstNonNull(set, emptySet);\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "set",
            "of",
            "the",
            "values",
            "for",
            "the",
            "given",
            "key"
        ]
    },
    {
        "id": 886,
        "code": "public final ImmutableSet<V> removeAll(@CheckForNull Object key) {\n  throw new UnsupportedOperationException();\n}",
        "summary_tokens": [
            "guaranteed",
            "to",
            "throw",
            "an",
            "exception",
            "and",
            "leave",
            "the",
            "multimap",
            "unmodified"
        ]
    },
    {
        "id": 887,
        "code": "public final ImmutableSet<V> replaceValues(K key, Iterable<? extends V> values) {\n  throw new UnsupportedOperationException();\n}",
        "summary_tokens": [
            "guaranteed",
            "to",
            "throw",
            "an",
            "exception",
            "and",
            "leave",
            "the",
            "multimap",
            "unmodified"
        ]
    },
    {
        "id": 888,
        "code": "public ImmutableSet<Entry<K, V>> entries() {\n  ImmutableSet<Entry<K, V>> result = entries;\n  return result == null ? (entries = new EntrySet<>(this)) : result;\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "collection",
            "of",
            "all",
            "key",
            "value",
            "pairs",
            "in",
            "the",
            "multimap"
        ]
    },
    {
        "id": 889,
        "code": "private void writeObject(ObjectOutputStream stream) throws IOException {\n  stream.defaultWriteObject();\n  stream.writeObject(valueComparator());\n  Serialization.writeMultimap(this, stream);\n}",
        "summary_tokens": [
            "number",
            "of",
            "distinct",
            "keys",
            "and",
            "then",
            "for",
            "each",
            "distinct",
            "key",
            "the",
            "key",
            "the",
            "number",
            "of",
            "values",
            "for",
            "that",
            "key",
            "and",
            "the",
            "key",
            "s",
            "values"
        ]
    },
    {
        "id": 890,
        "code": "public static <K, V> ImmutableSortedMap.Builder<K, V> builderWithExpectedSize(int expectedSize) {\n  throw new UnsupportedOperationException();\n}",
        "summary_tokens": [
            "not",
            "supported",
            "for",
            "immutable",
            "sorted",
            "map"
        ]
    },
    {
        "id": 891,
        "code": "public static <E extends Comparable<? super E>> ImmutableSortedMultiset<E> of(\n    E e1, E e2, E e3, E e4, E e5, E e6, E... remaining) {\n  int size = remaining.length + 6;\n  List<E> all = Lists.newArrayListWithCapacity(size);\n  Collections.addAll(all, e1, e2, e3, e4, e5, e6);\n  Collections.addAll(all, remaining);\n  return copyOf(Ordering.natural(), all);\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "sorted",
            "multiset",
            "containing",
            "the",
            "given",
            "elements",
            "sorted",
            "by",
            "their",
            "natural",
            "ordering"
        ]
    },
    {
        "id": 892,
        "code": "public static <E> ImmutableSortedMultiset<E> copyOf(\n    Comparator<? super E> comparator, Iterable<? extends E> elements) {\n  if (elements instanceof ImmutableSortedMultiset) {\n    @SuppressWarnings(\"unchecked\") \n    ImmutableSortedMultiset<E> multiset = (ImmutableSortedMultiset<E>) elements;\n    if (comparator.equals(multiset.comparator())) {\n      if (multiset.isPartialView()) {\n        return copyOfSortedEntries(comparator, multiset.entrySet().asList());\n      } else {\n        return multiset;\n      }\n    }\n  }\n  return new ImmutableSortedMultiset.Builder<E>(comparator).addAll(elements).build();\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "sorted",
            "multiset",
            "containing",
            "the",
            "given",
            "elements",
            "sorted",
            "by",
            "the",
            "given",
            "comparator"
        ]
    },
    {
        "id": 893,
        "code": "public static <E> ImmutableSortedMultiset<E> copyOfSorted(SortedMultiset<E> sortedMultiset) {\n  return copyOfSortedEntries(\n      sortedMultiset.comparator(), Lists.newArrayList(sortedMultiset.entrySet()));\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "sorted",
            "multiset",
            "containing",
            "the",
            "elements",
            "of",
            "a",
            "sorted",
            "multiset",
            "sorted",
            "by",
            "the",
            "same",
            "comparator"
        ]
    },
    {
        "id": 894,
        "code": "public static <E> Builder<E> orderedBy(Comparator<E> comparator) {\n  return new Builder<E>(comparator);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "builder",
            "that",
            "creates",
            "immutable",
            "sorted",
            "multisets",
            "with",
            "an",
            "explicit",
            "comparator"
        ]
    },
    {
        "id": 895,
        "code": "public static <E extends Comparable<?>> Builder<E> reverseOrder() {\n  return new Builder<E>(Ordering.natural().reverse());\n}",
        "summary_tokens": [
            "returns",
            "a",
            "builder",
            "that",
            "creates",
            "immutable",
            "sorted",
            "multisets",
            "whose",
            "elements",
            "are",
            "ordered",
            "by",
            "the",
            "reverse",
            "of",
            "their",
            "natural",
            "ordering"
        ]
    },
    {
        "id": 896,
        "code": "public static <E extends Comparable<?>> Builder<E> naturalOrder() {\n  return new Builder<E>(Ordering.natural());\n}",
        "summary_tokens": [
            "returns",
            "a",
            "builder",
            "that",
            "creates",
            "immutable",
            "sorted",
            "multisets",
            "whose",
            "elements",
            "are",
            "ordered",
            "by",
            "their",
            "natural",
            "ordering"
        ]
    },
    {
        "id": 897,
        "code": "public static <R, C, V> ImmutableTable<R, C, V> of(R rowKey, C columnKey, V value) {\n  return new SingletonImmutableTable<>(rowKey, columnKey, value);\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "table",
            "containing",
            "a",
            "single",
            "cell"
        ]
    },
    {
        "id": 898,
        "code": "public static <R, C, V> ImmutableTable<R, C, V> copyOf(\n    Table<? extends R, ? extends C, ? extends V> table) {\n  if (table instanceof ImmutableTable) {\n    @SuppressWarnings(\"unchecked\")\n    ImmutableTable<R, C, V> parameterizedTable = (ImmutableTable<R, C, V>) table;\n    return parameterizedTable;\n  } else {\n    return copyOf(table.cellSet());\n  }\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "copy",
            "of",
            "the",
            "provided",
            "table"
        ]
    },
    {
        "id": 899,
        "code": "public static <R, C, V> Builder<R, C, V> builder() {\n  return new Builder<>();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "builder"
        ]
    },
    {
        "id": 900,
        "code": "static <R, C, V> Cell<R, C, V> cellOf(R rowKey, C columnKey, V value) {\n  return Tables.immutableCell(\n      checkNotNull(rowKey, \"rowKey\"),\n      checkNotNull(columnKey, \"columnKey\"),\n      checkNotNull(value, \"value\"));\n}",
        "summary_tokens": [
            "verifies",
            "that",
            "row",
            "key",
            "column",
            "key",
            "and",
            "value",
            "are",
            "non",
            "null",
            "and",
            "returns",
            "a",
            "new",
            "entry",
            "with",
            "those",
            "values"
        ]
    },
    {
        "id": 901,
        "code": "public final void clear() {\n  throw new UnsupportedOperationException();\n}",
        "summary_tokens": [
            "guaranteed",
            "to",
            "throw",
            "an",
            "exception",
            "and",
            "leave",
            "the",
            "table",
            "unmodified"
        ]
    },
    {
        "id": 902,
        "code": "public final V put(R rowKey, C columnKey, V value) {\n  throw new UnsupportedOperationException();\n}",
        "summary_tokens": [
            "guaranteed",
            "to",
            "throw",
            "an",
            "exception",
            "and",
            "leave",
            "the",
            "table",
            "unmodified"
        ]
    },
    {
        "id": 903,
        "code": "public final void putAll(Table<? extends R, ? extends C, ? extends V> table) {\n  throw new UnsupportedOperationException();\n}",
        "summary_tokens": [
            "guaranteed",
            "to",
            "throw",
            "an",
            "exception",
            "and",
            "leave",
            "the",
            "table",
            "unmodified"
        ]
    },
    {
        "id": 904,
        "code": "public final V remove(@CheckForNull Object rowKey, @CheckForNull Object columnKey) {\n  throw new UnsupportedOperationException();\n}",
        "summary_tokens": [
            "guaranteed",
            "to",
            "throw",
            "an",
            "exception",
            "and",
            "leave",
            "the",
            "table",
            "unmodified"
        ]
    },
    {
        "id": 905,
        "code": "public static InternerBuilder newBuilder() {\n  return new InternerBuilder();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "fresh",
            "interner",
            "builder",
            "instance"
        ]
    },
    {
        "id": 906,
        "code": "public static <E> Interner<E> newStrongInterner() {\n  return newBuilder().strong().build();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "thread",
            "safe",
            "interner",
            "which",
            "retains",
            "a",
            "strong",
            "reference",
            "to",
            "each",
            "instance",
            "it",
            "has",
            "interned",
            "thus",
            "preventing",
            "these",
            "instances",
            "from",
            "being",
            "garbage",
            "collected"
        ]
    },
    {
        "id": 907,
        "code": "public static <E> Interner<E> newWeakInterner() {\n  return newBuilder().weak().build();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "thread",
            "safe",
            "interner",
            "which",
            "retains",
            "a",
            "weak",
            "reference",
            "to",
            "each",
            "instance",
            "it",
            "has",
            "interned",
            "and",
            "so",
            "does",
            "not",
            "prevent",
            "these",
            "instances",
            "from",
            "being",
            "garbage",
            "collected"
        ]
    },
    {
        "id": 908,
        "code": "public static <E> Function<E, E> asFunction(Interner<E> interner) {\n  return new InternerFunction<>(checkNotNull(interner));\n}",
        "summary_tokens": [
            "returns",
            "a",
            "function",
            "that",
            "delegates",
            "to",
            "the",
            "interner",
            "intern",
            "method",
            "of",
            "the",
            "given",
            "interner"
        ]
    },
    {
        "id": 909,
        "code": "MapMaker keyEquivalence(Equivalence<Object> equivalence) {\n  checkState(keyEquivalence == null, \"key equivalence was already set to %s\", keyEquivalence);\n  keyEquivalence = checkNotNull(equivalence);\n  this.useCustomMap = true;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "a",
            "custom",
            "equivalence",
            "strategy",
            "for",
            "comparing",
            "keys"
        ]
    },
    {
        "id": 910,
        "code": "public MapMaker initialCapacity(int initialCapacity) {\n  checkState(\n      this.initialCapacity == UNSET_INT,\n      \"initial capacity was already set to %s\",\n      this.initialCapacity);\n  checkArgument(initialCapacity >= 0);\n  this.initialCapacity = initialCapacity;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "minimum",
            "total",
            "size",
            "for",
            "the",
            "internal",
            "hash",
            "tables"
        ]
    },
    {
        "id": 911,
        "code": "public MapMaker concurrencyLevel(int concurrencyLevel) {\n  checkState(\n      this.concurrencyLevel == UNSET_INT,\n      \"concurrency level was already set to %s\",\n      this.concurrencyLevel);\n  checkArgument(concurrencyLevel > 0);\n  this.concurrencyLevel = concurrencyLevel;\n  return this;\n}",
        "summary_tokens": [
            "guides",
            "the",
            "allowed",
            "concurrency",
            "among",
            "update",
            "operations"
        ]
    },
    {
        "id": 912,
        "code": "public MapMaker weakKeys() {\n  return setKeyStrength(Strength.WEAK);\n}",
        "summary_tokens": [
            "specifies",
            "that",
            "each",
            "key",
            "not",
            "value",
            "stored",
            "in",
            "the",
            "map",
            "should",
            "be",
            "wrapped",
            "in",
            "a",
            "weak",
            "reference",
            "by",
            "default",
            "strong",
            "references",
            "are",
            "used"
        ]
    },
    {
        "id": 913,
        "code": "public MapMaker weakValues() {\n  return setValueStrength(Strength.WEAK);\n}",
        "summary_tokens": [
            "specifies",
            "that",
            "each",
            "value",
            "not",
            "key",
            "stored",
            "in",
            "the",
            "map",
            "should",
            "be",
            "wrapped",
            "in",
            "a",
            "weak",
            "reference",
            "by",
            "default",
            "strong",
            "references",
            "are",
            "used"
        ]
    },
    {
        "id": 914,
        "code": "public <K, V> ConcurrentMap<K, V> makeMap() {\n  if (!useCustomMap) {\n    return new ConcurrentHashMap<>(getInitialCapacity(), 0.75f, getConcurrencyLevel());\n  }\n  return MapMakerInternalMap.create(this);\n}",
        "summary_tokens": [
            "builds",
            "a",
            "thread",
            "safe",
            "map"
        ]
    },
    {
        "id": 915,
        "code": "public String toString() {\n  MoreObjects.ToStringHelper s = MoreObjects.toStringHelper(this);\n  if (initialCapacity != UNSET_INT) {\n    s.add(\"initialCapacity\", initialCapacity);\n  }\n  if (concurrencyLevel != UNSET_INT) {\n    s.add(\"concurrencyLevel\", concurrencyLevel);\n  }\n  if (keyStrength != null) {\n    s.add(\"keyStrength\", Ascii.toLowerCase(keyStrength.toString()));\n  }\n  if (valueStrength != null) {\n    s.add(\"valueStrength\", Ascii.toLowerCase(valueStrength.toString()));\n  }\n  if (keyEquivalence != null) {\n    s.addValue(\"keyEquivalence\");\n  }\n  return s.toString();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "string",
            "representation",
            "for",
            "this",
            "map",
            "maker",
            "instance"
        ]
    },
    {
        "id": 916,
        "code": "static <K, V> MapMakerInternalMap<K, V, ? extends InternalEntry<K, V, ?>, ?> create(\n    MapMaker builder) {\n  if (builder.getKeyStrength() == Strength.STRONG\n      && builder.getValueStrength() == Strength.STRONG) {\n    return new MapMakerInternalMap<>(builder, StrongKeyStrongValueEntry.Helper.<K, V>instance());\n  }\n  if (builder.getKeyStrength() == Strength.STRONG\n      && builder.getValueStrength() == Strength.WEAK) {\n    return new MapMakerInternalMap<>(builder, StrongKeyWeakValueEntry.Helper.<K, V>instance());\n  }\n  if (builder.getKeyStrength() == Strength.WEAK\n      && builder.getValueStrength() == Strength.STRONG) {\n    return new MapMakerInternalMap<>(builder, WeakKeyStrongValueEntry.Helper.<K, V>instance());\n  }\n  if (builder.getKeyStrength() == Strength.WEAK && builder.getValueStrength() == Strength.WEAK) {\n    return new MapMakerInternalMap<>(builder, WeakKeyWeakValueEntry.Helper.<K, V>instance());\n  }\n  throw new AssertionError();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "fresh",
            "map",
            "maker",
            "internal",
            "map",
            "as",
            "specified",
            "by",
            "the",
            "given",
            "builder"
        ]
    },
    {
        "id": 917,
        "code": "static <K>\n    MapMakerInternalMap<K, Dummy, ? extends InternalEntry<K, Dummy, ?>, ?> createWithDummyValues(\n        MapMaker builder) {\n  if (builder.getKeyStrength() == Strength.STRONG\n      && builder.getValueStrength() == Strength.STRONG) {\n    return new MapMakerInternalMap<>(builder, StrongKeyDummyValueEntry.Helper.<K>instance());\n  }\n  if (builder.getKeyStrength() == Strength.WEAK\n      && builder.getValueStrength() == Strength.STRONG) {\n    return new MapMakerInternalMap<>(builder, WeakKeyDummyValueEntry.Helper.<K>instance());\n  }\n  if (builder.getValueStrength() == Strength.WEAK) {\n    throw new IllegalArgumentException(\"Map cannot have both weak and dummy values\");\n  }\n  throw new AssertionError();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "fresh",
            "map",
            "maker",
            "internal",
            "map",
            "with",
            "map",
            "maker"
        ]
    },
    {
        "id": 918,
        "code": "static int rehash(int h) {\n    \n    \n    \n  h += (h << 15) ^ 0xffffcd7d;\n  h ^= (h >>> 10);\n  h += (h << 3);\n  h ^= (h >>> 6);\n  h += (h << 2) + (h << 14);\n  return h ^ (h >>> 16);\n}",
        "summary_tokens": [
            "applies",
            "a",
            "supplemental",
            "hash",
            "function",
            "to",
            "a",
            "given",
            "hash",
            "code",
            "which",
            "defends",
            "against",
            "poor",
            "quality",
            "hash",
            "functions"
        ]
    },
    {
        "id": 919,
        "code": "E copyEntry(E original, E newNext) {\n  int hash = original.getHash();\n  return segmentFor(hash).copyEntry(original, newNext);\n}",
        "summary_tokens": [
            "this",
            "method",
            "is",
            "a",
            "convenience",
            "for",
            "testing"
        ]
    },
    {
        "id": 920,
        "code": "boolean isLiveForTesting(InternalEntry<K, V, ?> entry) {\n  return segmentFor(entry.getHash()).getLiveValueForTesting(entry) != null;\n}",
        "summary_tokens": [
            "this",
            "method",
            "is",
            "a",
            "convenience",
            "for",
            "testing"
        ]
    },
    {
        "id": 921,
        "code": "Segment<K, V, E, S> segmentFor(int hash) {\n    \n  return segments[(hash >>> segmentShift) & segmentMask];\n}",
        "summary_tokens": [
            "returns",
            "the",
            "segment",
            "that",
            "should",
            "be",
            "used",
            "for",
            "a",
            "key",
            "with",
            "the",
            "given",
            "hash"
        ]
    },
    {
        "id": 922,
        "code": "V getLiveValue(E entry) {\n  if (entry.getKey() == null) {\n    return null;\n  }\n  return entry.getValue();\n}",
        "summary_tokens": [
            "gets",
            "the",
            "value",
            "from",
            "an",
            "entry"
        ]
    },
    {
        "id": 923,
        "code": "E getEntry(@Nullable Object key) {\n  if (key == null) {\n    return null;\n  }\n  int hash = hash(key);\n  return segmentFor(hash).getEntry(key, hash);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "internal",
            "entry",
            "for",
            "the",
            "specified",
            "key"
        ]
    },
    {
        "id": 924,
        "code": "public static <E extends Comparable<E>> MinMaxPriorityQueue<E> create(\n    Iterable<? extends E> initialContents) {\n  return new Builder<E>(Ordering.<E>natural()).create(initialContents);\n}",
        "summary_tokens": [
            "creates",
            "a",
            "new",
            "min",
            "max",
            "priority",
            "queue",
            "using",
            "natural",
            "order",
            "no",
            "maximum",
            "size",
            "and",
            "initially",
            "containing",
            "the",
            "given",
            "elements"
        ]
    },
    {
        "id": 925,
        "code": "public static <B> Builder<B> orderedBy(Comparator<B> comparator) {\n  return new Builder<>(comparator);\n}",
        "summary_tokens": [
            "creates",
            "and",
            "returns",
            "a",
            "new",
            "builder",
            "configured",
            "to",
            "build",
            "min",
            "max",
            "priority",
            "queue",
            "instances",
            "that",
            "use",
            "comparator",
            "to",
            "determine",
            "the",
            "least",
            "and",
            "greatest",
            "elements"
        ]
    },
    {
        "id": 926,
        "code": "public static Builder<Comparable> expectedSize(int expectedSize) {\n  return new Builder<Comparable>(Ordering.natural()).expectedSize(expectedSize);\n}",
        "summary_tokens": [
            "creates",
            "and",
            "returns",
            "a",
            "new",
            "builder",
            "configured",
            "to",
            "build",
            "min",
            "max",
            "priority",
            "queue",
            "instances",
            "sized",
            "appropriately",
            "to",
            "hold",
            "expected",
            "size",
            "elements"
        ]
    },
    {
        "id": 927,
        "code": "public static Builder<Comparable> maximumSize(int maximumSize) {\n  return new Builder<Comparable>(Ordering.natural()).maximumSize(maximumSize);\n}",
        "summary_tokens": [
            "creates",
            "and",
            "returns",
            "a",
            "new",
            "builder",
            "configured",
            "to",
            "build",
            "min",
            "max",
            "priority",
            "queue",
            "instances",
            "that",
            "are",
            "limited",
            "to",
            "maximum",
            "size",
            "elements"
        ]
    },
    {
        "id": 928,
        "code": "public boolean add(E element) {\n  offer(element);\n  return true;\n}",
        "summary_tokens": [
            "adds",
            "the",
            "given",
            "element",
            "to",
            "this",
            "queue"
        ]
    },
    {
        "id": 929,
        "code": "public boolean offer(E element) {\n  checkNotNull(element);\n  modCount++;\n  int insertIndex = size++;\n\n  growIfNeeded();\n\n    \n    \n  heapForIndex(insertIndex).bubbleUp(insertIndex, element);\n  return size <= maximumSize || pollLast() != element;\n}",
        "summary_tokens": [
            "adds",
            "the",
            "given",
            "element",
            "to",
            "this",
            "queue"
        ]
    },
    {
        "id": 930,
        "code": "private int getMaxElementIndex() {\n  switch (size) {\n    case 1:\n      return 0; \n    case 2:\n      return 1; \n    default:\n        \n        \n      return (maxHeap.compareElements(1, 2) <= 0) ? 1 : 2;\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "index",
            "of",
            "the",
            "max",
            "element"
        ]
    },
    {
        "id": 931,
        "code": "public E pollFirst() {\n  return poll();\n}",
        "summary_tokens": [
            "removes",
            "and",
            "returns",
            "the",
            "least",
            "element",
            "of",
            "this",
            "queue",
            "or",
            "returns",
            "null",
            "if",
            "the",
            "queue",
            "is",
            "empty"
        ]
    },
    {
        "id": 932,
        "code": "public E removeFirst() {\n  return remove();\n}",
        "summary_tokens": [
            "removes",
            "and",
            "returns",
            "the",
            "least",
            "element",
            "of",
            "this",
            "queue"
        ]
    },
    {
        "id": 933,
        "code": "public E peekFirst() {\n  return peek();\n}",
        "summary_tokens": [
            "retrieves",
            "but",
            "does",
            "not",
            "remove",
            "the",
            "least",
            "element",
            "of",
            "this",
            "queue",
            "or",
            "returns",
            "null",
            "if",
            "the",
            "queue",
            "is",
            "empty"
        ]
    },
    {
        "id": 934,
        "code": "public E pollLast() {\n  return isEmpty() ? null : removeAndGet(getMaxElementIndex());\n}",
        "summary_tokens": [
            "removes",
            "and",
            "returns",
            "the",
            "greatest",
            "element",
            "of",
            "this",
            "queue",
            "or",
            "returns",
            "null",
            "if",
            "the",
            "queue",
            "is",
            "empty"
        ]
    },
    {
        "id": 935,
        "code": "public E removeLast() {\n  if (isEmpty()) {\n    throw new NoSuchElementException();\n  }\n  return removeAndGet(getMaxElementIndex());\n}",
        "summary_tokens": [
            "removes",
            "and",
            "returns",
            "the",
            "greatest",
            "element",
            "of",
            "this",
            "queue"
        ]
    },
    {
        "id": 936,
        "code": "public E peekLast() {\n  return isEmpty() ? null : elementData(getMaxElementIndex());\n}",
        "summary_tokens": [
            "retrieves",
            "but",
            "does",
            "not",
            "remove",
            "the",
            "greatest",
            "element",
            "of",
            "this",
            "queue",
            "or",
            "returns",
            "null",
            "if",
            "the",
            "queue",
            "is",
            "empty"
        ]
    },
    {
        "id": 937,
        "code": "MoveDesc<E> removeAt(int index) {\n  checkPositionIndex(index, size);\n  modCount++;\n  size--;\n  if (size == index) {\n    queue[size] = null;\n    return null;\n  }\n  E actualLastElement = elementData(size);\n  int lastElementAt = heapForIndex(size).swapWithConceptuallyLastElement(actualLastElement);\n  if (lastElementAt == index) {\n      \n      \n      \n    queue[size] = null;\n    return null;\n  }\n  E toTrickle = elementData(size);\n  queue[size] = null;\n  MoveDesc<E> changes = fillHole(index, toTrickle);\n  if (lastElementAt < index) {\n      \n    if (changes == null) {\n        \n      return new MoveDesc<>(actualLastElement, toTrickle);\n    } else {\n        \n        \n      return new MoveDesc<>(actualLastElement, changes.replaced);\n    }\n  }\n    \n  return changes;\n}",
        "summary_tokens": [
            "removes",
            "the",
            "element",
            "at",
            "position",
            "index"
        ]
    },
    {
        "id": 938,
        "code": "private E removeAndGet(int index) {\n  E value = elementData(index);\n  removeAt(index);\n  return value;\n}",
        "summary_tokens": [
            "removes",
            "and",
            "returns",
            "the",
            "value",
            "at",
            "index"
        ]
    },
    {
        "id": 939,
        "code": "boolean isIntact() {\n  for (int i = 1; i < size; i++) {\n    if (!heapForIndex(i).verifyIndex(i)) {\n      return false;\n    }\n  }\n  return true;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "the",
            "min",
            "max",
            "heap",
            "structure",
            "holds"
        ]
    },
    {
        "id": 940,
        "code": "public Iterator<E> iterator() {\n  return new QueueIterator();\n}",
        "summary_tokens": [
            "returns",
            "an",
            "iterator",
            "over",
            "the",
            "elements",
            "contained",
            "in",
            "this",
            "collection",
            "i",
            "in",
            "no",
            "particular",
            "order",
            "i"
        ]
    },
    {
        "id": 941,
        "code": "public Comparator<? super E> comparator() {\n  return minHeap.ordering;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "comparator",
            "used",
            "to",
            "order",
            "the",
            "elements",
            "in",
            "this",
            "queue"
        ]
    },
    {
        "id": 942,
        "code": "private int calculateNewCapacity() {\n  int oldCapacity = queue.length;\n  int newCapacity =\n      (oldCapacity < 64) ? (oldCapacity + 1) * 2 : IntMath.checkedMultiply(oldCapacity / 2, 3);\n  return capAtMaximumSize(newCapacity, maximumSize);\n}",
        "summary_tokens": [
            "returns",
            "0",
            "x",
            "the",
            "old",
            "capacity",
            "if",
            "small",
            "0"
        ]
    },
    {
        "id": 943,
        "code": "private static int capAtMaximumSize(int queueSize, int maximumSize) {\n  return Math.min(queueSize - 1, maximumSize) + 1; \n}",
        "summary_tokens": [
            "there",
            "s",
            "no",
            "reason",
            "for",
            "the",
            "queue",
            "size",
            "to",
            "ever",
            "be",
            "more",
            "than",
            "max",
            "size",
            "0"
        ]
    },
    {
        "id": 944,
        "code": "public static <C extends Comparable<?>> Range<C> open(C lower, C upper) {\n  return create(Cut.aboveValue(lower), Cut.belowValue(upper));\n}",
        "summary_tokens": [
            "returns",
            "a",
            "range",
            "that",
            "contains",
            "all",
            "values",
            "strictly",
            "greater",
            "than",
            "lower",
            "and",
            "strictly",
            "less",
            "than",
            "upper"
        ]
    },
    {
        "id": 945,
        "code": "public static <C extends Comparable<?>> Range<C> closed(C lower, C upper) {\n  return create(Cut.belowValue(lower), Cut.aboveValue(upper));\n}",
        "summary_tokens": [
            "returns",
            "a",
            "range",
            "that",
            "contains",
            "all",
            "values",
            "greater",
            "than",
            "or",
            "equal",
            "to",
            "lower",
            "and",
            "less",
            "than",
            "or",
            "equal",
            "to",
            "upper"
        ]
    },
    {
        "id": 946,
        "code": "public static <C extends Comparable<?>> Range<C> closedOpen(C lower, C upper) {\n  return create(Cut.belowValue(lower), Cut.belowValue(upper));\n}",
        "summary_tokens": [
            "returns",
            "a",
            "range",
            "that",
            "contains",
            "all",
            "values",
            "greater",
            "than",
            "or",
            "equal",
            "to",
            "lower",
            "and",
            "strictly",
            "less",
            "than",
            "upper"
        ]
    },
    {
        "id": 947,
        "code": "public static <C extends Comparable<?>> Range<C> openClosed(C lower, C upper) {\n  return create(Cut.aboveValue(lower), Cut.aboveValue(upper));\n}",
        "summary_tokens": [
            "returns",
            "a",
            "range",
            "that",
            "contains",
            "all",
            "values",
            "strictly",
            "greater",
            "than",
            "lower",
            "and",
            "less",
            "than",
            "or",
            "equal",
            "to",
            "upper"
        ]
    },
    {
        "id": 948,
        "code": "public static <C extends Comparable<?>> Range<C> range(\n    C lower, BoundType lowerType, C upper, BoundType upperType) {\n  checkNotNull(lowerType);\n  checkNotNull(upperType);\n\n  Cut<C> lowerBound =\n      (lowerType == BoundType.OPEN) ? Cut.aboveValue(lower) : Cut.belowValue(lower);\n  Cut<C> upperBound =\n      (upperType == BoundType.OPEN) ? Cut.belowValue(upper) : Cut.aboveValue(upper);\n  return create(lowerBound, upperBound);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "range",
            "that",
            "contains",
            "any",
            "value",
            "from",
            "lower",
            "to",
            "upper",
            "where",
            "each",
            "endpoint",
            "may",
            "be",
            "either",
            "inclusive",
            "closed",
            "or",
            "exclusive",
            "open"
        ]
    },
    {
        "id": 949,
        "code": "public static <C extends Comparable<?>> Range<C> lessThan(C endpoint) {\n  return create(Cut.<C>belowAll(), Cut.belowValue(endpoint));\n}",
        "summary_tokens": [
            "returns",
            "a",
            "range",
            "that",
            "contains",
            "all",
            "values",
            "strictly",
            "less",
            "than",
            "endpoint"
        ]
    },
    {
        "id": 950,
        "code": "public static <C extends Comparable<?>> Range<C> atMost(C endpoint) {\n  return create(Cut.<C>belowAll(), Cut.aboveValue(endpoint));\n}",
        "summary_tokens": [
            "returns",
            "a",
            "range",
            "that",
            "contains",
            "all",
            "values",
            "less",
            "than",
            "or",
            "equal",
            "to",
            "endpoint"
        ]
    },
    {
        "id": 951,
        "code": "public static <C extends Comparable<?>> Range<C> upTo(C endpoint, BoundType boundType) {\n  switch (boundType) {\n    case OPEN:\n      return lessThan(endpoint);\n    case CLOSED:\n      return atMost(endpoint);\n    default:\n      throw new AssertionError();\n  }\n}",
        "summary_tokens": [
            "returns",
            "a",
            "range",
            "with",
            "no",
            "lower",
            "bound",
            "up",
            "to",
            "the",
            "given",
            "endpoint",
            "which",
            "may",
            "be",
            "either",
            "inclusive",
            "closed",
            "or",
            "exclusive",
            "open"
        ]
    },
    {
        "id": 952,
        "code": "public static <C extends Comparable<?>> Range<C> greaterThan(C endpoint) {\n  return create(Cut.aboveValue(endpoint), Cut.<C>aboveAll());\n}",
        "summary_tokens": [
            "returns",
            "a",
            "range",
            "that",
            "contains",
            "all",
            "values",
            "strictly",
            "greater",
            "than",
            "endpoint"
        ]
    },
    {
        "id": 953,
        "code": "public static <C extends Comparable<?>> Range<C> atLeast(C endpoint) {\n  return create(Cut.belowValue(endpoint), Cut.<C>aboveAll());\n}",
        "summary_tokens": [
            "returns",
            "a",
            "range",
            "that",
            "contains",
            "all",
            "values",
            "greater",
            "than",
            "or",
            "equal",
            "to",
            "endpoint"
        ]
    },
    {
        "id": 954,
        "code": "public static <C extends Comparable<?>> Range<C> downTo(C endpoint, BoundType boundType) {\n  switch (boundType) {\n    case OPEN:\n      return greaterThan(endpoint);\n    case CLOSED:\n      return atLeast(endpoint);\n    default:\n      throw new AssertionError();\n  }\n}",
        "summary_tokens": [
            "returns",
            "a",
            "range",
            "from",
            "the",
            "given",
            "endpoint",
            "which",
            "may",
            "be",
            "either",
            "inclusive",
            "closed",
            "or",
            "exclusive",
            "open",
            "with",
            "no",
            "upper",
            "bound"
        ]
    },
    {
        "id": 955,
        "code": "public static <C extends Comparable<?>> Range<C> all() {\n  return (Range) ALL;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "range",
            "that",
            "contains",
            "every",
            "value",
            "of",
            "type",
            "c"
        ]
    },
    {
        "id": 956,
        "code": "public static <C extends Comparable<?>> Range<C> singleton(C value) {\n  return closed(value, value);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "range",
            "that",
            "range",
            "contains",
            "comparable",
            "contains",
            "only",
            "the",
            "given",
            "value"
        ]
    },
    {
        "id": 957,
        "code": "public static <C extends Comparable<?>> Range<C> encloseAll(Iterable<C> values) {\n  checkNotNull(values);\n  if (values instanceof SortedSet) {\n    SortedSet<C> set = (SortedSet<C>) values;\n    Comparator<?> comparator = set.comparator();\n    if (Ordering.natural().equals(comparator) || comparator == null) {\n      return closed(set.first(), set.last());\n    }\n  }\n  Iterator<C> valueIterator = values.iterator();\n  C min = checkNotNull(valueIterator.next());\n  C max = min;\n  while (valueIterator.hasNext()) {\n    C value = checkNotNull(valueIterator.next());\n    min = Ordering.natural().min(min, value);\n    max = Ordering.natural().max(max, value);\n  }\n  return closed(min, max);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "minimal",
            "range",
            "that",
            "range",
            "contains",
            "comparable",
            "contains",
            "all",
            "of",
            "the",
            "given",
            "values"
        ]
    },
    {
        "id": 958,
        "code": "public boolean hasLowerBound() {\n  return lowerBound != Cut.belowAll();\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "this",
            "range",
            "has",
            "a",
            "lower",
            "endpoint"
        ]
    },
    {
        "id": 959,
        "code": "public C lowerEndpoint() {\n  return lowerBound.endpoint();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "lower",
            "endpoint",
            "of",
            "this",
            "range"
        ]
    },
    {
        "id": 960,
        "code": "public BoundType lowerBoundType() {\n  return lowerBound.typeAsLowerBound();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "type",
            "of",
            "this",
            "range",
            "s",
            "lower",
            "bound",
            "bound",
            "type",
            "closed",
            "if",
            "the",
            "range",
            "includes",
            "its",
            "lower",
            "endpoint",
            "bound",
            "type",
            "open",
            "if",
            "it",
            "does",
            "not"
        ]
    },
    {
        "id": 961,
        "code": "public boolean hasUpperBound() {\n  return upperBound != Cut.aboveAll();\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "this",
            "range",
            "has",
            "an",
            "upper",
            "endpoint"
        ]
    },
    {
        "id": 962,
        "code": "public C upperEndpoint() {\n  return upperBound.endpoint();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "upper",
            "endpoint",
            "of",
            "this",
            "range"
        ]
    },
    {
        "id": 963,
        "code": "public BoundType upperBoundType() {\n  return upperBound.typeAsUpperBound();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "type",
            "of",
            "this",
            "range",
            "s",
            "upper",
            "bound",
            "bound",
            "type",
            "closed",
            "if",
            "the",
            "range",
            "includes",
            "its",
            "upper",
            "endpoint",
            "bound",
            "type",
            "open",
            "if",
            "it",
            "does",
            "not"
        ]
    },
    {
        "id": 964,
        "code": "public boolean isEmpty() {\n  return lowerBound.equals(upperBound);\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "this",
            "range",
            "is",
            "of",
            "the",
            "form",
            "v"
        ]
    },
    {
        "id": 965,
        "code": "public boolean contains(C value) {\n  checkNotNull(value);\n    \n  return lowerBound.isLessThan(value) && !upperBound.isLessThan(value);\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "value",
            "is",
            "within",
            "the",
            "bounds",
            "of",
            "this",
            "range"
        ]
    },
    {
        "id": 966,
        "code": "public boolean apply(C input) {\n  return contains(input);\n}",
        "summary_tokens": [
            "provided",
            "only",
            "to",
            "satisfy",
            "the",
            "predicate",
            "interface",
            "use",
            "contains",
            "instead"
        ]
    },
    {
        "id": 967,
        "code": "public boolean containsAll(Iterable<? extends C> values) {\n  if (Iterables.isEmpty(values)) {\n    return true;\n  }\n\n    \n  if (values instanceof SortedSet) {\n    SortedSet<? extends C> set = (SortedSet<? extends C>) values;\n    Comparator<?> comparator = set.comparator();\n    if (Ordering.natural().equals(comparator) || comparator == null) {\n      return contains(set.first()) && contains(set.last());\n    }\n  }\n\n  for (C value : values) {\n    if (!contains(value)) {\n      return false;\n    }\n  }\n  return true;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "every",
            "element",
            "in",
            "values",
            "is",
            "contains",
            "contained",
            "in",
            "this",
            "range"
        ]
    },
    {
        "id": 968,
        "code": "public boolean encloses(Range<C> other) {\n  return lowerBound.compareTo(other.lowerBound) <= 0\n      && upperBound.compareTo(other.upperBound) >= 0;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "the",
            "bounds",
            "of",
            "other",
            "do",
            "not",
            "extend",
            "outside",
            "the",
            "bounds",
            "of",
            "this",
            "range"
        ]
    },
    {
        "id": 969,
        "code": "public boolean isConnected(Range<C> other) {\n  return lowerBound.compareTo(other.upperBound) <= 0\n      && other.lowerBound.compareTo(upperBound) <= 0;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "there",
            "exists",
            "a",
            "possibly",
            "empty",
            "range",
            "which",
            "is",
            "encloses",
            "enclosed",
            "by",
            "both",
            "this",
            "range",
            "and",
            "other"
        ]
    },
    {
        "id": 970,
        "code": "public Range<C> intersection(Range<C> connectedRange) {\n  int lowerCmp = lowerBound.compareTo(connectedRange.lowerBound);\n  int upperCmp = upperBound.compareTo(connectedRange.upperBound);\n  if (lowerCmp >= 0 && upperCmp <= 0) {\n    return this;\n  } else if (lowerCmp <= 0 && upperCmp >= 0) {\n    return connectedRange;\n  } else {\n    Cut<C> newLower = (lowerCmp >= 0) ? lowerBound : connectedRange.lowerBound;\n    Cut<C> newUpper = (upperCmp <= 0) ? upperBound : connectedRange.upperBound;\n\n      \n    checkArgument(\n        newLower.compareTo(newUpper) <= 0,\n        \"intersection is undefined for disconnected ranges %s and %s\",\n        this,\n        connectedRange);\n\n      \n    return create(newLower, newUpper);\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "maximal",
            "range",
            "encloses",
            "enclosed",
            "by",
            "both",
            "this",
            "range",
            "and",
            "connected",
            "range",
            "if",
            "such",
            "a",
            "range",
            "exists"
        ]
    },
    {
        "id": 971,
        "code": "public Range<C> gap(Range<C> otherRange) {\n    \n  if (lowerBound.compareTo(otherRange.upperBound) < 0\n      && otherRange.lowerBound.compareTo(upperBound) < 0) {\n    throw new IllegalArgumentException(\n        \"Ranges have a nonempty intersection: \" + this + \", \" + otherRange);\n  }\n\n  boolean isThisFirst = this.lowerBound.compareTo(otherRange.lowerBound) < 0;\n  Range<C> firstRange = isThisFirst ? this : otherRange;\n  Range<C> secondRange = isThisFirst ? otherRange : this;\n  return create(firstRange.upperBound, secondRange.lowerBound);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "maximal",
            "range",
            "lying",
            "between",
            "this",
            "range",
            "and",
            "other",
            "range",
            "if",
            "such",
            "a",
            "range",
            "exists"
        ]
    },
    {
        "id": 972,
        "code": "public Range<C> span(Range<C> other) {\n  int lowerCmp = lowerBound.compareTo(other.lowerBound);\n  int upperCmp = upperBound.compareTo(other.upperBound);\n  if (lowerCmp <= 0 && upperCmp >= 0) {\n    return this;\n  } else if (lowerCmp >= 0 && upperCmp <= 0) {\n    return other;\n  } else {\n    Cut<C> newLower = (lowerCmp <= 0) ? lowerBound : other.lowerBound;\n    Cut<C> newUpper = (upperCmp >= 0) ? upperBound : other.upperBound;\n    return create(newLower, newUpper);\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "minimal",
            "range",
            "that",
            "encloses",
            "encloses",
            "both",
            "this",
            "range",
            "and",
            "other"
        ]
    },
    {
        "id": 973,
        "code": "public Range<C> canonical(DiscreteDomain<C> domain) {\n  checkNotNull(domain);\n  Cut<C> lower = lowerBound.canonical(domain);\n  Cut<C> upper = upperBound.canonical(domain);\n  return (lower == lowerBound && upper == upperBound) ? this : create(lower, upper);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "canonical",
            "form",
            "of",
            "this",
            "range",
            "in",
            "the",
            "given",
            "domain"
        ]
    },
    {
        "id": 974,
        "code": "public boolean equals(@CheckForNull Object object) {\n  if (object instanceof Range) {\n    Range<?> other = (Range<?>) object;\n    return lowerBound.equals(other.lowerBound) && upperBound.equals(other.upperBound);\n  }\n  return false;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "object",
            "is",
            "a",
            "range",
            "having",
            "the",
            "same",
            "endpoints",
            "and",
            "bound",
            "types",
            "as",
            "this",
            "range"
        ]
    },
    {
        "id": 975,
        "code": "public int hashCode() {\n  return lowerBound.hashCode() * 31 + upperBound.hashCode();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "hash",
            "code",
            "for",
            "this",
            "range"
        ]
    },
    {
        "id": 976,
        "code": "public String toString() {\n  return toString(lowerBound, upperBound);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "string",
            "representation",
            "of",
            "this",
            "range",
            "such",
            "as",
            "0"
        ]
    },
    {
        "id": 977,
        "code": "private static Object createHashTable(\n    @Nullable Object[] alternatingKeysAndValues, int n, int tableSize, int keyOffset) {\n  if (n == 1) {\n      \n      \n    checkEntryNotNull(\n        requireNonNull(alternatingKeysAndValues[keyOffset]),\n        requireNonNull(alternatingKeysAndValues[keyOffset ^ 1]));\n    return null;\n  }\n  int mask = tableSize - 1;\n  Builder.DuplicateKey duplicateKey = null;\n  if (tableSize <= BYTE_MAX_SIZE) {\n      \n    byte[] hashTable = new byte[tableSize];\n    Arrays.fill(hashTable, ABSENT);\n\n    int outI = 0;\n    entries:\n    for (int i = 0; i < n; i++) {\n      int keyIndex = 2 * i + keyOffset;\n      int outKeyIndex = 2 * outI + keyOffset;\n        \n      Object key = requireNonNull(alternatingKeysAndValues[keyIndex]);\n      Object value = requireNonNull(alternatingKeysAndValues[keyIndex ^ 1]);\n      checkEntryNotNull(key, value);\n      for (int h = Hashing.smear(key.hashCode()); ; h++) {\n        h &= mask;\n        int previousKeyIndex = hashTable[h] & BYTE_MASK; \n        if (previousKeyIndex == BYTE_MASK) { \n          hashTable[h] = (byte) outKeyIndex;\n          break;\n        } else if (key.equals(alternatingKeysAndValues[previousKeyIndex])) {\n          duplicateKey =\n              new Builder.DuplicateKey(\n                  key, value, requireNonNull(alternatingKeysAndValues[previousKeyIndex ^ 1]));\n          alternatingKeysAndValues[previousKeyIndex ^ 1] = value;\n          continue entries;\n        }\n      }\n      if (outI < i) { \n        alternatingKeysAndValues[outKeyIndex] = key;\n        alternatingKeysAndValues[outKeyIndex ^ 1] = value;\n      }\n      outI++;\n    }\n    return outI == n ? hashTable : new Object[] {hashTable, outI, duplicateKey};\n  } else if (tableSize <= SHORT_MAX_SIZE) {\n      \n    short[] hashTable = new short[tableSize];\n    Arrays.fill(hashTable, ABSENT);\n\n    int outI = 0;\n    entries:\n    for (int i = 0; i < n; i++) {\n      int keyIndex = 2 * i + keyOffset;\n      int outKeyIndex = 2 * outI + keyOffset;\n        \n      Object key = requireNonNull(alternatingKeysAndValues[keyIndex]);\n      Object value = requireNonNull(alternatingKeysAndValues[keyIndex ^ 1]);\n      checkEntryNotNull(key, value);\n      for (int h = Hashing.smear(key.hashCode()); ; h++) {\n        h &= mask;\n        int previousKeyIndex = hashTable[h] & SHORT_MASK; \n        if (previousKeyIndex == SHORT_MASK) { \n          hashTable[h] = (short) outKeyIndex;\n          break;\n        } else if (key.equals(alternatingKeysAndValues[previousKeyIndex])) {\n          duplicateKey =\n              new Builder.DuplicateKey(\n                  key, value, requireNonNull(alternatingKeysAndValues[previousKeyIndex ^ 1]));\n          alternatingKeysAndValues[previousKeyIndex ^ 1] = value;\n          continue entries;\n        }\n      }\n      if (outI < i) { \n        alternatingKeysAndValues[outKeyIndex] = key;\n        alternatingKeysAndValues[outKeyIndex ^ 1] = value;\n      }\n      outI++;\n    }\n    return outI == n ? hashTable : new Object[] {hashTable, outI, duplicateKey};\n  } else {\n      \n    int[] hashTable = new int[tableSize];\n    Arrays.fill(hashTable, ABSENT);\n\n    int outI = 0;\n    entries:\n    for (int i = 0; i < n; i++) {\n      int keyIndex = 2 * i + keyOffset;\n      int outKeyIndex = 2 * outI + keyOffset;\n        \n      Object key = requireNonNull(alternatingKeysAndValues[keyIndex]);\n      Object value = requireNonNull(alternatingKeysAndValues[keyIndex ^ 1]);\n      checkEntryNotNull(key, value);\n      for (int h = Hashing.smear(key.hashCode()); ; h++) {\n        h &= mask;\n        int previousKeyIndex = hashTable[h];\n        if (previousKeyIndex == ABSENT) {\n          hashTable[h] = outKeyIndex;\n          break;\n        } else if (key.equals(alternatingKeysAndValues[previousKeyIndex])) {\n          duplicateKey =\n              new Builder.DuplicateKey(\n                  key, value, requireNonNull(alternatingKeysAndValues[previousKeyIndex ^ 1]));\n          alternatingKeysAndValues[previousKeyIndex ^ 1] = value;\n          continue entries;\n        }\n      }\n      if (outI < i) { \n        alternatingKeysAndValues[outKeyIndex] = key;\n        alternatingKeysAndValues[outKeyIndex ^ 1] = value;\n      }\n      outI++;\n    }\n    return outI == n ? hashTable : new Object[] {hashTable, outI, duplicateKey};\n  }\n}",
        "summary_tokens": [
            "returns",
            "a",
            "hash",
            "table",
            "for",
            "the",
            "specified",
            "keys",
            "and",
            "values",
            "and",
            "ensures",
            "that",
            "neither",
            "keys",
            "nor",
            "values",
            "are",
            "null"
        ]
    },
    {
        "id": 978,
        "code": "static <R, C, V> RegularImmutableTable<R, C, V> forOrderedComponents(\n    ImmutableList<Cell<R, C, V>> cellList,\n    ImmutableSet<R> rowSpace,\n    ImmutableSet<C> columnSpace) {\n    \n    \n  return (cellList.size() > (((long) rowSpace.size() * columnSpace.size()) / 2))\n      ? new DenseImmutableTable<R, C, V>(cellList, rowSpace, columnSpace)\n      : new SparseImmutableTable<R, C, V>(cellList, rowSpace, columnSpace);\n}",
        "summary_tokens": [
            "a",
            "factory",
            "that",
            "chooses",
            "the",
            "most",
            "space",
            "efficient",
            "representation",
            "of",
            "the",
            "table"
        ]
    },
    {
        "id": 979,
        "code": "final void checkNoDuplicate(R rowKey, C columnKey, @CheckForNull V existingValue, V newValue) {\n  checkArgument(\n      existingValue == null,\n      \"Duplicate key: (row=%s, column=%s), values: [%s, %s].\",\n      rowKey,\n      columnKey,\n      newValue,\n      existingValue);\n}",
        "summary_tokens": [
            "illegal",
            "argument",
            "exception",
            "if",
            "existing",
            "value",
            "is",
            "not",
            "null"
        ]
    },
    {
        "id": 980,
        "code": "public static <R, C, V> TreeBasedTable<R, C, V> create(TreeBasedTable<R, C, ? extends V> table) {\n  TreeBasedTable<R, C, V> result =\n      new TreeBasedTable<>(table.rowComparator(), table.columnComparator());\n  result.putAll(table);\n  return result;\n}",
        "summary_tokens": [
            "creates",
            "a",
            "tree",
            "based",
            "table",
            "with",
            "the",
            "same",
            "mappings",
            "and",
            "sort",
            "order",
            "as",
            "the",
            "specified",
            "tree",
            "based",
            "table"
        ]
    },
    {
        "id": 981,
        "code": "public Comparator<? super R> rowComparator() {\n    \n  return requireNonNull(rowKeySet().comparator());\n}",
        "summary_tokens": [
            "returns",
            "the",
            "comparator",
            "that",
            "orders",
            "the",
            "rows"
        ]
    },
    {
        "id": 982,
        "code": "public Comparator<? super C> columnComparator() {\n  return columnComparator;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "comparator",
            "that",
            "orders",
            "the",
            "columns"
        ]
    },
    {
        "id": 983,
        "code": "Iterator<C> createColumnKeyIterator() {\n  Comparator<? super C> comparator = columnComparator();\n\n  Iterator<C> merged =\n      Iterators.mergeSorted(\n          Iterables.transform(\n              backingMap.values(), (Map<C, V> input) -> input.keySet().iterator()),\n          comparator);\n\n  return new AbstractIterator<C>() {\n    @CheckForNull C lastValue;\n\n    @Override\n    @CheckForNull\n    protected C computeNext() {\n      while (merged.hasNext()) {\n        C next = merged.next();\n        boolean duplicate = lastValue != null && comparator.compare(next, lastValue) == 0;\n\n          \n        if (!duplicate) {\n          lastValue = next;\n          return lastValue;\n        }\n      }\n\n      lastValue = null; \n      return endOfData();\n    }\n  };\n}",
        "summary_tokens": [
            "overridden",
            "column",
            "iterator",
            "to",
            "return",
            "columns",
            "values",
            "in",
            "globally",
            "sorted",
            "order"
        ]
    },
    {
        "id": 984,
        "code": "private Range<K> coalescedRange(Range<K> range, V value) {\n  Range<K> coalescedRange = range;\n  Entry<Cut<K>, RangeMapEntry<K, V>> lowerEntry =\n      entriesByLowerBound.lowerEntry(range.lowerBound);\n  coalescedRange = coalesce(coalescedRange, value, lowerEntry);\n\n  Entry<Cut<K>, RangeMapEntry<K, V>> higherEntry =\n      entriesByLowerBound.floorEntry(range.upperBound);\n  coalescedRange = coalesce(coalescedRange, value, higherEntry);\n\n  return coalescedRange;\n}",
        "summary_tokens": [
            "computes",
            "the",
            "coalesced",
            "range",
            "for",
            "the",
            "given",
            "range",
            "value",
            "does",
            "not",
            "mutate",
            "the",
            "map"
        ]
    },
    {
        "id": 985,
        "code": "private static <K extends Comparable, V> Range<K> coalesce(\n    Range<K> range, V value, @CheckForNull Entry<Cut<K>, RangeMapEntry<K, V>> entry) {\n  if (entry != null\n      && entry.getValue().getKey().isConnected(range)\n      && entry.getValue().getValue().equals(value)) {\n    return range.span(entry.getValue().getKey());\n  }\n  return range;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "range",
            "that",
            "spans",
            "the",
            "given",
            "range",
            "and",
            "entry",
            "if",
            "the",
            "entry",
            "can",
            "be",
            "coalesced"
        ]
    },
    {
        "id": 986,
        "code": "public static <C extends Comparable<?>> TreeRangeSet<C> create(Iterable<Range<C>> ranges) {\n  TreeRangeSet<C> result = create();\n  result.addAll(ranges);\n  return result;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "tree",
            "range",
            "set",
            "representing",
            "the",
            "union",
            "of",
            "the",
            "specified",
            "ranges"
        ]
    },
    {
        "id": 987,
        "code": "public static <T> TreeTraverser<T> using(\n    final Function<T, ? extends Iterable<T>> nodeToChildrenFunction) {\n  checkNotNull(nodeToChildrenFunction);\n  return new TreeTraverser<T>() {\n    @Override\n    public Iterable<T> children(T root) {\n      return nodeToChildrenFunction.apply(root);\n    }\n  };\n}",
        "summary_tokens": [
            "returns",
            "a",
            "tree",
            "traverser",
            "that",
            "uses",
            "the",
            "given",
            "function",
            "to",
            "navigate",
            "from",
            "a",
            "node",
            "to",
            "its",
            "children"
        ]
    },
    {
        "id": 988,
        "code": "public final FluentIterable<T> preOrderTraversal(final T root) {\n  checkNotNull(root);\n  return new FluentIterable<T>() {\n    @Override\n    public UnmodifiableIterator<T> iterator() {\n      return preOrderIterator(root);\n    }\n\n    @Override\n    public void forEach(Consumer<? super T> action) {\n      checkNotNull(action);\n      new Consumer<T>() {\n        @Override\n        public void accept(T t) {\n          action.accept(t);\n          children(t).forEach(this);\n        }\n      }.accept(root);\n    }\n  };\n}",
        "summary_tokens": [
            "returns",
            "an",
            "unmodifiable",
            "iterable",
            "over",
            "the",
            "nodes",
            "in",
            "a",
            "tree",
            "structure",
            "using",
            "pre",
            "order",
            "traversal"
        ]
    },
    {
        "id": 989,
        "code": "public final FluentIterable<T> postOrderTraversal(final T root) {\n  checkNotNull(root);\n  return new FluentIterable<T>() {\n    @Override\n    public UnmodifiableIterator<T> iterator() {\n      return postOrderIterator(root);\n    }\n\n    @Override\n    public void forEach(Consumer<? super T> action) {\n      checkNotNull(action);\n      new Consumer<T>() {\n        @Override\n        public void accept(T t) {\n          children(t).forEach(this);\n          action.accept(t);\n        }\n      }.accept(root);\n    }\n  };\n}",
        "summary_tokens": [
            "returns",
            "an",
            "unmodifiable",
            "iterable",
            "over",
            "the",
            "nodes",
            "in",
            "a",
            "tree",
            "structure",
            "using",
            "post",
            "order",
            "traversal"
        ]
    },
    {
        "id": 990,
        "code": "public final FluentIterable<T> breadthFirstTraversal(final T root) {\n  checkNotNull(root);\n  return new FluentIterable<T>() {\n    @Override\n    public UnmodifiableIterator<T> iterator() {\n      return new BreadthFirstIterator(root);\n    }\n  };\n}",
        "summary_tokens": [
            "returns",
            "an",
            "unmodifiable",
            "iterable",
            "over",
            "the",
            "nodes",
            "in",
            "a",
            "tree",
            "structure",
            "using",
            "breadth",
            "first",
            "traversal"
        ]
    },
    {
        "id": 991,
        "code": "protected final char[] escape(char c) {\n  if (c < replacementsLength) {\n    char[] chars = replacements[c];\n    if (chars != null) {\n      return chars;\n    }\n  }\n  if (c >= safeMin && c <= safeMax) {\n    return null;\n  }\n  return escapeUnsafe(c);\n}",
        "summary_tokens": [
            "escapes",
            "a",
            "single",
            "character",
            "using",
            "the",
            "replacement",
            "array",
            "and",
            "safe",
            "range",
            "values"
        ]
    },
    {
        "id": 992,
        "code": "public static ArrayBasedEscaperMap create(Map<Character, String> replacements) {\n  return new ArrayBasedEscaperMap(createReplacementArray(replacements));\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "array",
            "based",
            "escaper",
            "map",
            "for",
            "creating",
            "array",
            "based",
            "char",
            "escaper",
            "or",
            "array",
            "based",
            "unicode",
            "escaper",
            "instances"
        ]
    },
    {
        "id": 993,
        "code": "protected final char[] escape(int cp) {\n  if (cp < replacementsLength) {\n    char[] chars = replacements[cp];\n    if (chars != null) {\n      return chars;\n    }\n  }\n  if (cp >= safeMin && cp <= safeMax) {\n    return null;\n  }\n  return escapeUnsafe(cp);\n}",
        "summary_tokens": [
            "escapes",
            "a",
            "single",
            "unicode",
            "code",
            "point",
            "using",
            "the",
            "replacement",
            "array",
            "and",
            "safe",
            "range",
            "values"
        ]
    },
    {
        "id": 994,
        "code": "public String escape(String string) {\n  checkNotNull(string); \n    \n  int length = string.length();\n  for (int index = 0; index < length; index++) {\n    if (escape(string.charAt(index)) != null) {\n      return escapeSlow(string, index);\n    }\n  }\n  return string;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "escaped",
            "form",
            "of",
            "a",
            "given",
            "literal",
            "string"
        ]
    },
    {
        "id": 995,
        "code": "protected final String escapeSlow(String s, int index) {\n  int slen = s.length();\n\n    \n  char[] dest = Platform.charBufferFromThreadLocal();\n  int destSize = dest.length;\n  int destIndex = 0;\n  int lastEscape = 0;\n\n    \n    \n  for (; index < slen; index++) {\n\n      \n    char[] r = escape(s.charAt(index));\n\n      \n    if (r == null) {\n      continue;\n    }\n\n    int rlen = r.length;\n    int charsSkipped = index - lastEscape;\n\n      \n      \n      \n    int sizeNeeded = destIndex + charsSkipped + rlen;\n    if (destSize < sizeNeeded) {\n      destSize = sizeNeeded + DEST_PAD_MULTIPLIER * (slen - index);\n      dest = growBuffer(dest, destIndex, destSize);\n    }\n\n      \n    if (charsSkipped > 0) {\n      s.getChars(lastEscape, index, dest, destIndex);\n      destIndex += charsSkipped;\n    }\n\n      \n    if (rlen > 0) {\n      System.arraycopy(r, 0, dest, destIndex, rlen);\n      destIndex += rlen;\n    }\n    lastEscape = index + 1;\n  }\n\n    \n  int charsLeft = slen - lastEscape;\n  if (charsLeft > 0) {\n    int sizeNeeded = destIndex + charsLeft;\n    if (destSize < sizeNeeded) {\n\n        \n      dest = growBuffer(dest, destIndex, sizeNeeded);\n    }\n    s.getChars(lastEscape, slen, dest, destIndex);\n    destIndex = sizeNeeded;\n  }\n  return new String(dest, 0, destIndex);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "escaped",
            "form",
            "of",
            "a",
            "given",
            "literal",
            "string",
            "starting",
            "at",
            "the",
            "given",
            "index"
        ]
    },
    {
        "id": 996,
        "code": "private static char[] growBuffer(char[] dest, int index, int size) {\n  if (size < 0) { \n    throw new AssertionError(\"Cannot increase internal buffer any further\");\n  }\n  char[] copy = new char[size];\n  if (index > 0) {\n    System.arraycopy(dest, 0, copy, 0, index);\n  }\n  return copy;\n}",
        "summary_tokens": [
            "helper",
            "method",
            "to",
            "grow",
            "the",
            "character",
            "buffer",
            "as",
            "needed",
            "this",
            "only",
            "happens",
            "once",
            "in",
            "a",
            "while",
            "so",
            "it",
            "s",
            "ok",
            "if",
            "it",
            "s",
            "in",
            "a",
            "method",
            "call"
        ]
    },
    {
        "id": 997,
        "code": "public final Function<String, String> asFunction() {\n  return asFunction;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "function",
            "that",
            "invokes",
            "escape",
            "string",
            "on",
            "this",
            "escaper"
        ]
    },
    {
        "id": 998,
        "code": "public static Escaper nullEscaper() {\n  return NULL_ESCAPER;\n}",
        "summary_tokens": [
            "returns",
            "an",
            "escaper",
            "that",
            "does",
            "no",
            "escaping",
            "passing",
            "all",
            "character",
            "data",
            "through",
            "unchanged"
        ]
    },
    {
        "id": 999,
        "code": "public static Builder builder() {\n  return new Builder();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "builder",
            "for",
            "creating",
            "simple",
            "fast",
            "escapers"
        ]
    },
    {
        "id": 1000,
        "code": "static UnicodeEscaper asUnicodeEscaper(Escaper escaper) {\n  checkNotNull(escaper);\n  if (escaper instanceof UnicodeEscaper) {\n    return (UnicodeEscaper) escaper;\n  } else if (escaper instanceof CharEscaper) {\n    return wrap((CharEscaper) escaper);\n  }\n    \n    \n  throw new IllegalArgumentException(\n      \"Cannot create a UnicodeEscaper from: \" + escaper.getClass().getName());\n}",
        "summary_tokens": [
            "returns",
            "a",
            "unicode",
            "escaper",
            "equivalent",
            "to",
            "the",
            "given",
            "escaper",
            "instance"
        ]
    },
    {
        "id": 1001,
        "code": "public static String computeReplacement(UnicodeEscaper escaper, int cp) {\n  return stringOrNull(escaper.escape(cp));\n}",
        "summary_tokens": [
            "returns",
            "a",
            "string",
            "that",
            "would",
            "replace",
            "the",
            "given",
            "character",
            "in",
            "the",
            "specified",
            "escaper",
            "or",
            "null",
            "if",
            "no",
            "replacement",
            "should",
            "be",
            "made"
        ]
    },
    {
        "id": 1002,
        "code": "private static UnicodeEscaper wrap(CharEscaper escaper) {\n  return new UnicodeEscaper() {\n    @Override\n    @CheckForNull\n    protected char[] escape(int cp) {\n        \n      if (cp < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n        return escaper.escape((char) cp);\n      }\n        \n        \n        \n        \n      char[] surrogateChars = new char[2];\n      Character.toChars(cp, surrogateChars, 0);\n      char[] hiChars = escaper.escape(surrogateChars[0]);\n      char[] loChars = escaper.escape(surrogateChars[1]);\n\n        \n        \n        \n        \n      if (hiChars == null && loChars == null) {\n          \n        return null;\n      }\n        \n      int hiCount = hiChars != null ? hiChars.length : 1;\n      int loCount = loChars != null ? loChars.length : 1;\n      char[] output = new char[hiCount + loCount];\n      if (hiChars != null) {\n          \n        for (int n = 0; n < hiChars.length; ++n) {\n          output[n] = hiChars[n];\n        }\n      } else {\n        output[0] = surrogateChars[0];\n      }\n      if (loChars != null) {\n        for (int n = 0; n < loChars.length; ++n) {\n          output[hiCount + n] = loChars[n];\n        }\n      } else {\n        output[hiCount] = surrogateChars[1];\n      }\n      return output;\n    }\n  };\n}",
        "summary_tokens": [
            "private",
            "helper",
            "to",
            "wrap",
            "a",
            "char",
            "escaper",
            "as",
            "a",
            "unicode",
            "escaper"
        ]
    },
    {
        "id": 1003,
        "code": "static char[] charBufferFromThreadLocal() {\n  return DEST_TL.get();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "thread",
            "local",
            "0",
            "char",
            "array"
        ]
    },
    {
        "id": 1004,
        "code": "public String escape(String string) {\n  checkNotNull(string);\n  int end = string.length();\n  int index = nextEscapeIndex(string, 0, end);\n  return index == end ? string : escapeSlow(string, index);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "escaped",
            "form",
            "of",
            "a",
            "given",
            "literal",
            "string"
        ]
    },
    {
        "id": 1005,
        "code": "protected int nextEscapeIndex(CharSequence csq, int start, int end) {\n  int index = start;\n  while (index < end) {\n    int cp = codePointAt(csq, index, end);\n    if (cp < 0 || escape(cp) != null) {\n      break;\n    }\n    index += Character.isSupplementaryCodePoint(cp) ? 2 : 1;\n  }\n  return index;\n}",
        "summary_tokens": [
            "scans",
            "a",
            "sub",
            "sequence",
            "of",
            "characters",
            "from",
            "a",
            "given",
            "char",
            "sequence",
            "returning",
            "the",
            "index",
            "of",
            "the",
            "next",
            "character",
            "that",
            "requires",
            "escaping"
        ]
    },
    {
        "id": 1006,
        "code": "protected final String escapeSlow(String s, int index) {\n  int end = s.length();\n\n    \n  char[] dest = Platform.charBufferFromThreadLocal();\n  int destIndex = 0;\n  int unescapedChunkStart = 0;\n\n  while (index < end) {\n    int cp = codePointAt(s, index, end);\n    if (cp < 0) {\n      throw new IllegalArgumentException(\"Trailing high surrogate at end of input\");\n    }\n      \n      \n      \n    char[] escaped = escape(cp);\n    int nextIndex = index + (Character.isSupplementaryCodePoint(cp) ? 2 : 1);\n    if (escaped != null) {\n      int charsSkipped = index - unescapedChunkStart;\n\n        \n        \n      int sizeNeeded = destIndex + charsSkipped + escaped.length;\n      if (dest.length < sizeNeeded) {\n        int destLength = sizeNeeded + (end - index) + DEST_PAD;\n        dest = growBuffer(dest, destIndex, destLength);\n      }\n        \n      if (charsSkipped > 0) {\n        s.getChars(unescapedChunkStart, index, dest, destIndex);\n        destIndex += charsSkipped;\n      }\n      if (escaped.length > 0) {\n        System.arraycopy(escaped, 0, dest, destIndex, escaped.length);\n        destIndex += escaped.length;\n      }\n        \n      unescapedChunkStart = nextIndex;\n    }\n    index = nextEscapeIndex(s, nextIndex, end);\n  }\n\n    \n    \n  int charsSkipped = end - unescapedChunkStart;\n  if (charsSkipped > 0) {\n    int endIndex = destIndex + charsSkipped;\n    if (dest.length < endIndex) {\n      dest = growBuffer(dest, destIndex, endIndex);\n    }\n    s.getChars(unescapedChunkStart, end, dest, destIndex);\n    destIndex = endIndex;\n  }\n  return new String(dest, 0, destIndex);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "escaped",
            "form",
            "of",
            "a",
            "given",
            "literal",
            "string",
            "starting",
            "at",
            "the",
            "given",
            "index"
        ]
    },
    {
        "id": 1007,
        "code": "protected static int codePointAt(CharSequence seq, int index, int end) {\n  checkNotNull(seq);\n  if (index < end) {\n    char c1 = seq.charAt(index++);\n    if (c1 < Character.MIN_HIGH_SURROGATE || c1 > Character.MAX_LOW_SURROGATE) {\n        \n      return c1;\n    } else if (c1 <= Character.MAX_HIGH_SURROGATE) {\n        \n      if (index == end) {\n        return -c1;\n      }\n        \n      char c2 = seq.charAt(index);\n      if (Character.isLowSurrogate(c2)) {\n        return Character.toCodePoint(c1, c2);\n      }\n      throw new IllegalArgumentException(\n          \"Expected low surrogate but got char '\"\n              + c2\n              + \"' with value \"\n              + (int) c2\n              + \" at index \"\n              + index\n              + \" in '\"\n              + seq\n              + \"'\");\n    } else {\n      throw new IllegalArgumentException(\n          \"Unexpected low surrogate character '\"\n              + c1\n              + \"' with value \"\n              + (int) c1\n              + \" at index \"\n              + (index - 1)\n              + \" in '\"\n              + seq\n              + \"'\");\n    }\n  }\n  throw new IndexOutOfBoundsException(\"Index exceeds specified range\");\n}",
        "summary_tokens": [
            "returns",
            "the",
            "unicode",
            "code",
            "point",
            "of",
            "the",
            "character",
            "at",
            "the",
            "given",
            "index"
        ]
    },
    {
        "id": 1008,
        "code": "private static char[] growBuffer(char[] dest, int index, int size) {\n  if (size < 0) { \n    throw new AssertionError(\"Cannot increase internal buffer any further\");\n  }\n  char[] copy = new char[size];\n  if (index > 0) {\n    System.arraycopy(dest, 0, copy, 0, index);\n  }\n  return copy;\n}",
        "summary_tokens": [
            "helper",
            "method",
            "to",
            "grow",
            "the",
            "character",
            "buffer",
            "as",
            "needed",
            "this",
            "only",
            "happens",
            "once",
            "in",
            "a",
            "while",
            "so",
            "it",
            "s",
            "ok",
            "if",
            "it",
            "s",
            "in",
            "a",
            "method",
            "call"
        ]
    },
    {
        "id": 1009,
        "code": "public Object getSource() {\n  return source;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "object",
            "that",
            "originated",
            "this",
            "event",
            "em",
            "not",
            "em",
            "the",
            "object",
            "that",
            "originated",
            "the",
            "wrapped",
            "event"
        ]
    },
    {
        "id": 1010,
        "code": "public Object getEvent() {\n  return event;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "wrapped",
            "dead",
            "event",
            "which",
            "the",
            "system",
            "was",
            "unable",
            "to",
            "deliver",
            "to",
            "any",
            "registered",
            "subscriber"
        ]
    },
    {
        "id": 1011,
        "code": "static Dispatcher perThreadDispatchQueue() {\n  return new PerThreadQueuedDispatcher();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "dispatcher",
            "that",
            "queues",
            "events",
            "that",
            "are",
            "posted",
            "reentrantly",
            "on",
            "a",
            "thread",
            "that",
            "is",
            "already",
            "dispatching",
            "an",
            "event",
            "guaranteeing",
            "that",
            "all",
            "events",
            "posted",
            "on",
            "a",
            "single",
            "thread",
            "are",
            "dispatched",
            "to",
            "all",
            "subscribers",
            "in",
            "the",
            "order",
            "they",
            "are",
            "posted"
        ]
    },
    {
        "id": 1012,
        "code": "static Dispatcher legacyAsync() {\n  return new LegacyAsyncDispatcher();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "dispatcher",
            "that",
            "queues",
            "events",
            "that",
            "are",
            "posted",
            "in",
            "a",
            "single",
            "global",
            "queue"
        ]
    },
    {
        "id": 1013,
        "code": "static Dispatcher immediate() {\n  return ImmediateDispatcher.INSTANCE;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "dispatcher",
            "that",
            "dispatches",
            "events",
            "to",
            "subscribers",
            "immediately",
            "as",
            "they",
            "re",
            "posted",
            "without",
            "using",
            "an",
            "intermediate",
            "queue",
            "to",
            "change",
            "the",
            "dispatch",
            "order"
        ]
    },
    {
        "id": 1014,
        "code": "public final String identifier() {\n  return identifier;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "identifier",
            "for",
            "this",
            "event",
            "bus"
        ]
    },
    {
        "id": 1015,
        "code": "final Executor executor() {\n  return executor;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "default",
            "executor",
            "this",
            "event",
            "bus",
            "uses",
            "for",
            "dispatching",
            "events",
            "to",
            "subscribers"
        ]
    },
    {
        "id": 1016,
        "code": "void handleSubscriberException(Throwable e, SubscriberExceptionContext context) {\n  checkNotNull(e);\n  checkNotNull(context);\n  try {\n    exceptionHandler.handleException(e, context);\n  } catch (Throwable e2) {\n      \n    logger.log(\n        Level.SEVERE,\n        String.format(Locale.ROOT, \"Exception %s thrown while handling exception: %s\", e2, e),\n        e2);\n  }\n}",
        "summary_tokens": [
            "handles",
            "the",
            "given",
            "exception",
            "thrown",
            "by",
            "a",
            "subscriber",
            "with",
            "the",
            "given",
            "context"
        ]
    },
    {
        "id": 1017,
        "code": "public void register(Object object) {\n  subscribers.register(object);\n}",
        "summary_tokens": [
            "registers",
            "all",
            "subscriber",
            "methods",
            "on",
            "object",
            "to",
            "receive",
            "events"
        ]
    },
    {
        "id": 1018,
        "code": "public void unregister(Object object) {\n  subscribers.unregister(object);\n}",
        "summary_tokens": [
            "unregisters",
            "all",
            "subscriber",
            "methods",
            "on",
            "a",
            "registered",
            "object"
        ]
    },
    {
        "id": 1019,
        "code": "public void post(Object event) {\n  Iterator<Subscriber> eventSubscribers = subscribers.getSubscribers(event);\n  if (eventSubscribers.hasNext()) {\n    dispatcher.dispatch(event, eventSubscribers);\n  } else if (!(event instanceof DeadEvent)) {\n      \n    post(new DeadEvent(this, event));\n  }\n}",
        "summary_tokens": [
            "posts",
            "an",
            "event",
            "to",
            "all",
            "registered",
            "subscribers"
        ]
    },
    {
        "id": 1020,
        "code": "static Subscriber create(EventBus bus, Object listener, Method method) {\n  return isDeclaredThreadSafe(method)\n      ? new Subscriber(bus, listener, method)\n      : new SynchronizedSubscriber(bus, listener, method);\n}",
        "summary_tokens": [
            "creates",
            "a",
            "subscriber",
            "for",
            "method",
            "on",
            "listener"
        ]
    },
    {
        "id": 1021,
        "code": "final void dispatchEvent(Object event) {\n  executor.execute(\n      () -> {\n        try {\n          invokeSubscriberMethod(event);\n        } catch (InvocationTargetException e) {\n          bus.handleSubscriberException(e.getCause(), context(event));\n        }\n      });\n}",
        "summary_tokens": [
            "dispatches",
            "event",
            "to",
            "this",
            "subscriber",
            "using",
            "the",
            "proper",
            "executor"
        ]
    },
    {
        "id": 1022,
        "code": "void invokeSubscriberMethod(Object event) throws InvocationTargetException {\n  try {\n    method.invoke(target, checkNotNull(event));\n  } catch (IllegalArgumentException e) {\n    throw new Error(\"Method rejected target/argument: \" + event, e);\n  } catch (IllegalAccessException e) {\n    throw new Error(\"Method became inaccessible: \" + event, e);\n  } catch (InvocationTargetException e) {\n    if (e.getCause() instanceof Error) {\n      throw (Error) e.getCause();\n    }\n    throw e;\n  }\n}",
        "summary_tokens": [
            "invokes",
            "the",
            "subscriber",
            "method"
        ]
    },
    {
        "id": 1023,
        "code": "private SubscriberExceptionContext context(Object event) {\n  return new SubscriberExceptionContext(bus, event, target, method);\n}",
        "summary_tokens": [
            "gets",
            "the",
            "context",
            "for",
            "the",
            "given",
            "event"
        ]
    },
    {
        "id": 1024,
        "code": "private static boolean isDeclaredThreadSafe(Method method) {\n  return method.getAnnotation(AllowConcurrentEvents.class) != null;\n}",
        "summary_tokens": [
            "checks",
            "whether",
            "method",
            "is",
            "thread",
            "safe",
            "as",
            "indicated",
            "by",
            "the",
            "presence",
            "of",
            "the",
            "allow",
            "concurrent",
            "events",
            "annotation"
        ]
    },
    {
        "id": 1025,
        "code": "public EventBus getEventBus() {\n  return eventBus;\n}",
        "summary_tokens": [
            "the",
            "event",
            "bus",
            "that",
            "handled",
            "the",
            "event",
            "and",
            "the",
            "subscriber"
        ]
    },
    {
        "id": 1026,
        "code": "public Object getEvent() {\n  return event;\n}",
        "summary_tokens": [
            "the",
            "event",
            "object",
            "that",
            "caused",
            "the",
            "subscriber",
            "to",
            "throw"
        ]
    },
    {
        "id": 1027,
        "code": "public Object getSubscriber() {\n  return subscriber;\n}",
        "summary_tokens": [
            "the",
            "object",
            "context",
            "that",
            "the",
            "subscriber",
            "was",
            "called",
            "on"
        ]
    },
    {
        "id": 1028,
        "code": "public Method getSubscriberMethod() {\n  return subscriberMethod;\n}",
        "summary_tokens": [
            "the",
            "subscribed",
            "method",
            "that",
            "threw",
            "the",
            "exception"
        ]
    },
    {
        "id": 1029,
        "code": "void register(Object listener) {\n  Multimap<Class<?>, Subscriber> listenerMethods = findAllSubscribers(listener);\n\n  for (Entry<Class<?>, Collection<Subscriber>> entry : listenerMethods.asMap().entrySet()) {\n    Class<?> eventType = entry.getKey();\n    Collection<Subscriber> eventMethodsInListener = entry.getValue();\n\n    CopyOnWriteArraySet<Subscriber> eventSubscribers = subscribers.get(eventType);\n\n    if (eventSubscribers == null) {\n      CopyOnWriteArraySet<Subscriber> newSet = new CopyOnWriteArraySet<>();\n      eventSubscribers =\n          MoreObjects.firstNonNull(subscribers.putIfAbsent(eventType, newSet), newSet);\n    }\n\n    eventSubscribers.addAll(eventMethodsInListener);\n  }\n}",
        "summary_tokens": [
            "registers",
            "all",
            "subscriber",
            "methods",
            "on",
            "the",
            "given",
            "listener",
            "object"
        ]
    },
    {
        "id": 1030,
        "code": "void unregister(Object listener) {\n  Multimap<Class<?>, Subscriber> listenerMethods = findAllSubscribers(listener);\n\n  for (Entry<Class<?>, Collection<Subscriber>> entry : listenerMethods.asMap().entrySet()) {\n    Class<?> eventType = entry.getKey();\n    Collection<Subscriber> listenerMethodsForType = entry.getValue();\n\n    CopyOnWriteArraySet<Subscriber> currentSubscribers = subscribers.get(eventType);\n    if (currentSubscribers == null || !currentSubscribers.removeAll(listenerMethodsForType)) {\n        \n        \n        \n        \n      throw new IllegalArgumentException(\n          \"missing event subscriber for an annotated method. Is \" + listener + \" registered?\");\n    }\n\n      \n      \n  }\n}",
        "summary_tokens": [
            "unregisters",
            "all",
            "subscribers",
            "on",
            "the",
            "given",
            "listener",
            "object"
        ]
    },
    {
        "id": 1031,
        "code": "Iterator<Subscriber> getSubscribers(Object event) {\n  ImmutableSet<Class<?>> eventTypes = flattenHierarchy(event.getClass());\n\n  List<Iterator<Subscriber>> subscriberIterators =\n      Lists.newArrayListWithCapacity(eventTypes.size());\n\n  for (Class<?> eventType : eventTypes) {\n    CopyOnWriteArraySet<Subscriber> eventSubscribers = subscribers.get(eventType);\n    if (eventSubscribers != null) {\n        \n      subscriberIterators.add(eventSubscribers.iterator());\n    }\n  }\n\n  return Iterators.concat(subscriberIterators.iterator());\n}",
        "summary_tokens": [
            "gets",
            "an",
            "iterator",
            "representing",
            "an",
            "immutable",
            "snapshot",
            "of",
            "all",
            "subscribers",
            "to",
            "the",
            "given",
            "event",
            "at",
            "the",
            "time",
            "this",
            "method",
            "is",
            "called"
        ]
    },
    {
        "id": 1032,
        "code": "private Multimap<Class<?>, Subscriber> findAllSubscribers(Object listener) {\n  Multimap<Class<?>, Subscriber> methodsInListener = HashMultimap.create();\n  Class<?> clazz = listener.getClass();\n  for (Method method : getAnnotatedMethods(clazz)) {\n    Class<?>[] parameterTypes = method.getParameterTypes();\n    Class<?> eventType = parameterTypes[0];\n    methodsInListener.put(eventType, Subscriber.create(bus, listener, method));\n  }\n  return methodsInListener;\n}",
        "summary_tokens": [
            "returns",
            "all",
            "subscribers",
            "for",
            "the",
            "given",
            "listener",
            "grouped",
            "by",
            "the",
            "type",
            "of",
            "event",
            "they",
            "subscribe",
            "to"
        ]
    },
    {
        "id": 1033,
        "code": "static ImmutableSet<Class<?>> flattenHierarchy(Class<?> concreteClass) {\n  try {\n    return flattenHierarchyCache.getUnchecked(concreteClass);\n  } catch (UncheckedExecutionException e) {\n    throw Throwables.propagate(e.getCause());\n  }\n}",
        "summary_tokens": [
            "flattens",
            "a",
            "class",
            "s",
            "type",
            "hierarchy",
            "into",
            "a",
            "set",
            "of",
            "class",
            "objects",
            "including",
            "all",
            "superclasses",
            "transitively",
            "and",
            "all",
            "interfaces",
            "implemented",
            "by",
            "these",
            "superclasses"
        ]
    },
    {
        "id": 1034,
        "code": "protected long edgeCount() {\n  long degreeSum = 0L;\n  for (N node : nodes()) {\n    degreeSum += degree(node);\n  }\n    \n  checkState((degreeSum & 1) == 0);\n  return degreeSum >>> 1;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "edges",
            "in",
            "this",
            "graph",
            "used",
            "to",
            "calculate",
            "the",
            "size",
            "of",
            "edges"
        ]
    },
    {
        "id": 1035,
        "code": "public Set<EndpointPair<N>> edges() {\n  return new AbstractSet<EndpointPair<N>>() {\n    @Override\n    public UnmodifiableIterator<EndpointPair<N>> iterator() {\n      return EndpointPairIterator.of(AbstractBaseGraph.this);\n    }\n\n    @Override\n    public int size() {\n      return Ints.saturatedCast(edgeCount());\n    }\n\n    @Override\n    public boolean remove(@CheckForNull Object o) {\n      throw new UnsupportedOperationException();\n    }\n\n      \n      \n      \n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public boolean contains(@CheckForNull Object obj) {\n      if (!(obj instanceof EndpointPair)) {\n        return false;\n      }\n      EndpointPair<?> endpointPair = (EndpointPair<?>) obj;\n      return isOrderingCompatible(endpointPair)\n          && nodes().contains(endpointPair.nodeU())\n          && successors((N) endpointPair.nodeU()).contains(endpointPair.nodeV());\n    }\n  };\n}",
        "summary_tokens": [
            "an",
            "implementation",
            "of",
            "base",
            "graph",
            "edges",
            "defined",
            "in",
            "terms",
            "of",
            "nodes",
            "and",
            "successors",
            "object"
        ]
    },
    {
        "id": 1036,
        "code": "protected final void validateEndpoints(EndpointPair<?> endpoints) {\n  checkNotNull(endpoints);\n  checkArgument(isOrderingCompatible(endpoints), ENDPOINTS_MISMATCH);\n}",
        "summary_tokens": [
            "throws",
            "illegal",
            "argument",
            "exception",
            "if",
            "the",
            "ordering",
            "of",
            "endpoints",
            "is",
            "not",
            "compatible",
            "with",
            "the",
            "directionality",
            "of",
            "this",
            "graph"
        ]
    },
    {
        "id": 1037,
        "code": "public String toString() {\n  return \"isDirected: \"\n      + isDirected()\n      + \", allowsSelfLoops: \"\n      + allowsSelfLoops()\n      + \", nodes: \"\n      + nodes()\n      + \", edges: \"\n      + edges();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "string",
            "representation",
            "of",
            "this",
            "graph"
        ]
    },
    {
        "id": 1038,
        "code": "protected final void validateEndpoints(EndpointPair<?> endpoints) {\n  checkNotNull(endpoints);\n  checkArgument(isOrderingCompatible(endpoints), ENDPOINTS_MISMATCH);\n}",
        "summary_tokens": [
            "throws",
            "an",
            "illegal",
            "argument",
            "exception",
            "if",
            "the",
            "ordering",
            "of",
            "endpoints",
            "is",
            "not",
            "compatible",
            "with",
            "the",
            "directionality",
            "of",
            "this",
            "graph"
        ]
    },
    {
        "id": 1039,
        "code": "public String toString() {\n  return \"isDirected: \"\n      + isDirected()\n      + \", allowsParallelEdges: \"\n      + allowsParallelEdges()\n      + \", allowsSelfLoops: \"\n      + allowsSelfLoops()\n      + \", nodes: \"\n      + nodes()\n      + \", edges: \"\n      + edgeIncidentNodesMap(this);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "string",
            "representation",
            "of",
            "this",
            "network"
        ]
    },
    {
        "id": 1040,
        "code": "public String toString() {\n  return \"isDirected: \"\n      + isDirected()\n      + \", allowsSelfLoops: \"\n      + allowsSelfLoops()\n      + \", nodes: \"\n      + nodes()\n      + \", edges: \"\n      + edgeValueMap(this);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "string",
            "representation",
            "of",
            "this",
            "graph"
        ]
    },
    {
        "id": 1041,
        "code": "public static <S> ElementOrder<S> unordered() {\n  return new ElementOrder<>(Type.UNORDERED, null);\n}",
        "summary_tokens": [
            "returns",
            "an",
            "instance",
            "which",
            "specifies",
            "that",
            "no",
            "ordering",
            "is",
            "guaranteed"
        ]
    },
    {
        "id": 1042,
        "code": "public static <S> ElementOrder<S> stable() {\n  return new ElementOrder<>(Type.STABLE, null);\n}",
        "summary_tokens": [
            "returns",
            "an",
            "instance",
            "which",
            "specifies",
            "that",
            "ordering",
            "is",
            "guaranteed",
            "to",
            "be",
            "always",
            "be",
            "the",
            "same",
            "across",
            "iterations",
            "and",
            "across",
            "releases"
        ]
    },
    {
        "id": 1043,
        "code": "public static <S> ElementOrder<S> insertion() {\n  return new ElementOrder<>(Type.INSERTION, null);\n}",
        "summary_tokens": [
            "returns",
            "an",
            "instance",
            "which",
            "specifies",
            "that",
            "insertion",
            "ordering",
            "is",
            "guaranteed"
        ]
    },
    {
        "id": 1044,
        "code": "public static <S extends Comparable<? super S>> ElementOrder<S> natural() {\n  return new ElementOrder<>(Type.SORTED, Ordering.<S>natural());\n}",
        "summary_tokens": [
            "returns",
            "an",
            "instance",
            "which",
            "specifies",
            "that",
            "the",
            "natural",
            "ordering",
            "of",
            "the",
            "elements",
            "is",
            "guaranteed"
        ]
    },
    {
        "id": 1045,
        "code": "public static <S> ElementOrder<S> sorted(Comparator<S> comparator) {\n  return new ElementOrder<>(Type.SORTED, checkNotNull(comparator));\n}",
        "summary_tokens": [
            "returns",
            "an",
            "instance",
            "which",
            "specifies",
            "that",
            "the",
            "ordering",
            "of",
            "the",
            "elements",
            "is",
            "guaranteed",
            "to",
            "be",
            "determined",
            "by",
            "comparator"
        ]
    },
    {
        "id": 1046,
        "code": "public Type type() {\n  return type;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "type",
            "of",
            "ordering",
            "used"
        ]
    },
    {
        "id": 1047,
        "code": "public Comparator<T> comparator() {\n  if (comparator != null) {\n    return comparator;\n  }\n  throw new UnsupportedOperationException(\"This ordering does not define a comparator.\");\n}",
        "summary_tokens": [
            "returns",
            "the",
            "comparator",
            "used"
        ]
    },
    {
        "id": 1048,
        "code": "<K extends T, V> Map<K, V> createMap(int expectedSize) {\n  switch (type) {\n    case UNORDERED:\n      return Maps.newHashMapWithExpectedSize(expectedSize);\n    case INSERTION:\n    case STABLE:\n      return Maps.newLinkedHashMapWithExpectedSize(expectedSize);\n    case SORTED:\n      return Maps.newTreeMap(comparator());\n    default:\n      throw new AssertionError();\n  }\n}",
        "summary_tokens": [
            "returns",
            "an",
            "empty",
            "mutable",
            "map",
            "whose",
            "keys",
            "will",
            "respect",
            "this",
            "element",
            "order"
        ]
    },
    {
        "id": 1049,
        "code": "public static <N> EndpointPair<N> ordered(N source, N target) {\n  return new Ordered<>(source, target);\n}",
        "summary_tokens": [
            "returns",
            "an",
            "endpoint",
            "pair",
            "representing",
            "the",
            "endpoints",
            "of",
            "a",
            "directed",
            "edge"
        ]
    },
    {
        "id": 1050,
        "code": "public static <N> EndpointPair<N> unordered(N nodeU, N nodeV) {\n    \n  return new Unordered<>(nodeV, nodeU);\n}",
        "summary_tokens": [
            "returns",
            "an",
            "endpoint",
            "pair",
            "representing",
            "the",
            "endpoints",
            "of",
            "an",
            "undirected",
            "edge"
        ]
    },
    {
        "id": 1051,
        "code": "static <N> EndpointPair<N> of(Network<?, ?> network, N nodeU, N nodeV) {\n  return network.isDirected() ? ordered(nodeU, nodeV) : unordered(nodeU, nodeV);\n}",
        "summary_tokens": [
            "returns",
            "an",
            "endpoint",
            "pair",
            "representing",
            "the",
            "endpoints",
            "of",
            "an",
            "edge",
            "in",
            "network"
        ]
    },
    {
        "id": 1052,
        "code": "public final N nodeU() {\n  return nodeU;\n}",
        "summary_tokens": [
            "if",
            "this",
            "endpoint",
            "pair",
            "is",
            "ordered",
            "returns",
            "the",
            "source",
            "otherwise",
            "returns",
            "an",
            "arbitrary",
            "but",
            "consistent",
            "endpoint",
            "of",
            "the",
            "origin",
            "edge"
        ]
    },
    {
        "id": 1053,
        "code": "public final N nodeV() {\n  return nodeV;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "node",
            "adjacent",
            "node",
            "object",
            "adjacent",
            "to",
            "node",
            "u",
            "along",
            "the",
            "origin",
            "edge"
        ]
    },
    {
        "id": 1054,
        "code": "public final N adjacentNode(N node) {\n  if (node.equals(nodeU)) {\n    return nodeV;\n  } else if (node.equals(nodeV)) {\n    return nodeU;\n  } else {\n    throw new IllegalArgumentException(\"EndpointPair \" + this + \" does not contain node \" + node);\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "node",
            "that",
            "is",
            "adjacent",
            "to",
            "node",
            "along",
            "the",
            "origin",
            "edge"
        ]
    },
    {
        "id": 1055,
        "code": "public final UnmodifiableIterator<N> iterator() {\n  return Iterators.forArray(nodeU, nodeV);\n}",
        "summary_tokens": [
            "iterates",
            "in",
            "the",
            "order",
            "node",
            "u",
            "node",
            "v"
        ]
    },
    {
        "id": 1056,
        "code": "protected long edgeCount() {\n  return delegate().edges().size();\n}",
        "summary_tokens": [
            "defer",
            "to",
            "abstract",
            "graph",
            "edges",
            "based",
            "on",
            "successors",
            "object",
            "for",
            "full",
            "edges",
            "implementation"
        ]
    },
    {
        "id": 1057,
        "code": "protected long edgeCount() {\n  return delegate().edges().size();\n}",
        "summary_tokens": [
            "defer",
            "to",
            "abstract",
            "value",
            "graph",
            "edges",
            "based",
            "on",
            "successors",
            "object",
            "for",
            "full",
            "edges",
            "implementation"
        ]
    },
    {
        "id": 1058,
        "code": "public static GraphBuilder<Object> directed() {\n  return new GraphBuilder<>(true);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "graph",
            "builder",
            "for",
            "building",
            "directed",
            "graphs"
        ]
    },
    {
        "id": 1059,
        "code": "public static GraphBuilder<Object> undirected() {\n  return new GraphBuilder<>(false);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "graph",
            "builder",
            "for",
            "building",
            "undirected",
            "graphs"
        ]
    },
    {
        "id": 1060,
        "code": "public static <N> GraphBuilder<N> from(Graph<N> graph) {\n  return new GraphBuilder<N>(graph.isDirected())\n      .allowsSelfLoops(graph.allowsSelfLoops())\n      .nodeOrder(graph.nodeOrder())\n      .incidentEdgeOrder(graph.incidentEdgeOrder());\n}",
        "summary_tokens": [
            "returns",
            "a",
            "graph",
            "builder",
            "initialized",
            "with",
            "all",
            "properties",
            "queryable",
            "from",
            "graph"
        ]
    },
    {
        "id": 1061,
        "code": "public <N1 extends N> ImmutableGraph.Builder<N1> immutable() {\n  GraphBuilder<N1> castBuilder = cast();\n  return new ImmutableGraph.Builder<>(castBuilder);\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "graph"
        ]
    },
    {
        "id": 1062,
        "code": "public GraphBuilder<N> allowsSelfLoops(boolean allowsSelfLoops) {\n  this.allowsSelfLoops = allowsSelfLoops;\n  return this;\n}",
        "summary_tokens": [
            "specifies",
            "whether",
            "the",
            "graph",
            "will",
            "allow",
            "self",
            "loops",
            "edges",
            "that",
            "connect",
            "a",
            "node",
            "to",
            "itself"
        ]
    },
    {
        "id": 1063,
        "code": "public GraphBuilder<N> expectedNodeCount(int expectedNodeCount) {\n  this.expectedNodeCount = Optional.of(checkNonNegative(expectedNodeCount));\n  return this;\n}",
        "summary_tokens": [
            "specifies",
            "the",
            "expected",
            "number",
            "of",
            "nodes",
            "in",
            "the",
            "graph"
        ]
    },
    {
        "id": 1064,
        "code": "public <N1 extends N> GraphBuilder<N1> nodeOrder(ElementOrder<N1> nodeOrder) {\n  GraphBuilder<N1> newBuilder = cast();\n  newBuilder.nodeOrder = checkNotNull(nodeOrder);\n  return newBuilder;\n}",
        "summary_tokens": [
            "specifies",
            "the",
            "order",
            "of",
            "iteration",
            "for",
            "the",
            "elements",
            "of",
            "graph",
            "nodes"
        ]
    },
    {
        "id": 1065,
        "code": "public <N1 extends N> GraphBuilder<N1> incidentEdgeOrder(ElementOrder<N1> incidentEdgeOrder) {\n  checkArgument(\n      incidentEdgeOrder.type() == ElementOrder.Type.UNORDERED\n          || incidentEdgeOrder.type() == ElementOrder.Type.STABLE,\n      \"The given elementOrder (%s) is unsupported. incidentEdgeOrder() only supports\"\n          + \" ElementOrder.unordered() and ElementOrder.stable().\",\n      incidentEdgeOrder);\n  GraphBuilder<N1> newBuilder = cast();\n  newBuilder.incidentEdgeOrder = checkNotNull(incidentEdgeOrder);\n  return newBuilder;\n}",
        "summary_tokens": [
            "specifies",
            "the",
            "order",
            "of",
            "iteration",
            "for",
            "the",
            "elements",
            "of",
            "graph",
            "edges",
            "graph",
            "adjacent",
            "nodes",
            "object",
            "graph",
            "predecessors",
            "object",
            "graph",
            "successors",
            "object",
            "and",
            "graph",
            "incident",
            "edges",
            "object"
        ]
    },
    {
        "id": 1066,
        "code": "public <N1 extends N> MutableGraph<N1> build() {\n  return new StandardMutableGraph<>(this);\n}",
        "summary_tokens": [
            "returns",
            "an",
            "empty",
            "mutable",
            "graph",
            "with",
            "the",
            "properties",
            "of",
            "this",
            "graph",
            "builder"
        ]
    },
    {
        "id": 1067,
        "code": "public static boolean hasCycle(Network<?, ?> network) {\n    \n    \n  if (!network.isDirected()\n      && network.allowsParallelEdges()\n      && network.edges().size() > network.asGraph().edges().size()) {\n    return true;\n  }\n  return hasCycle(network.asGraph());\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "network",
            "has",
            "at",
            "least",
            "one",
            "cycle"
        ]
    },
    {
        "id": 1068,
        "code": "private static <N> boolean subgraphHasCycle(\n    Graph<N> graph,\n    Map<Object, NodeVisitState> visitedNodes,\n    N node,\n    @CheckForNull N previousNode) {\n  NodeVisitState state = visitedNodes.get(node);\n  if (state == NodeVisitState.COMPLETE) {\n    return false;\n  }\n  if (state == NodeVisitState.PENDING) {\n    return true;\n  }\n\n  visitedNodes.put(node, NodeVisitState.PENDING);\n  for (N nextNode : graph.successors(node)) {\n    if (canTraverseWithoutReusingEdge(graph, nextNode, previousNode)\n        && subgraphHasCycle(graph, visitedNodes, nextNode, node)) {\n      return true;\n    }\n  }\n  visitedNodes.put(node, NodeVisitState.COMPLETE);\n  return false;\n}",
        "summary_tokens": [
            "performs",
            "a",
            "traversal",
            "of",
            "the",
            "nodes",
            "reachable",
            "from",
            "node"
        ]
    },
    {
        "id": 1069,
        "code": "private static boolean canTraverseWithoutReusingEdge(\n    Graph<?> graph, Object nextNode, @CheckForNull Object previousNode) {\n  if (graph.isDirected() || !Objects.equal(previousNode, nextNode)) {\n    return true;\n  }\n    \n    \n  return false;\n}",
        "summary_tokens": [
            "determines",
            "whether",
            "an",
            "edge",
            "has",
            "already",
            "been",
            "used",
            "during",
            "traversal"
        ]
    },
    {
        "id": 1070,
        "code": "public static <N> Graph<N> transitiveClosure(Graph<N> graph) {\n  MutableGraph<N> transitiveClosure = GraphBuilder.from(graph).allowsSelfLoops(true).build();\n    \n    \n\n  if (graph.isDirected()) {\n      \n    for (N node : graph.nodes()) {\n      for (N reachableNode : reachableNodes(graph, node)) {\n        transitiveClosure.putEdge(node, reachableNode);\n      }\n    }\n  } else {\n      \n      \n    Set<N> visitedNodes = new HashSet<N>();\n    for (N node : graph.nodes()) {\n      if (!visitedNodes.contains(node)) {\n        Set<N> reachableNodes = reachableNodes(graph, node);\n        visitedNodes.addAll(reachableNodes);\n        int pairwiseMatch = 1; \n        for (N nodeU : reachableNodes) {\n          for (N nodeV : Iterables.limit(reachableNodes, pairwiseMatch++)) {\n            transitiveClosure.putEdge(nodeU, nodeV);\n          }\n        }\n      }\n    }\n  }\n\n  return transitiveClosure;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "transitive",
            "closure",
            "of",
            "graph"
        ]
    },
    {
        "id": 1071,
        "code": "public static <N> Set<N> reachableNodes(Graph<N> graph, N node) {\n  checkArgument(graph.nodes().contains(node), NODE_NOT_IN_GRAPH, node);\n  return ImmutableSet.copyOf(Traverser.forGraph(graph).breadthFirst(node));\n}",
        "summary_tokens": [
            "returns",
            "the",
            "set",
            "of",
            "nodes",
            "that",
            "are",
            "reachable",
            "from",
            "node"
        ]
    },
    {
        "id": 1072,
        "code": "public static <N, E> Network<N, E> transpose(Network<N, E> network) {\n  if (!network.isDirected()) {\n    return network; \n  }\n\n  if (network instanceof TransposedNetwork) {\n    return ((TransposedNetwork<N, E>) network).network;\n  }\n\n  return new TransposedNetwork<>(network);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "view",
            "of",
            "network",
            "with",
            "the",
            "direction",
            "if",
            "any",
            "of",
            "every",
            "edge",
            "reversed"
        ]
    },
    {
        "id": 1073,
        "code": "public static <N, E> MutableNetwork<N, E> inducedSubgraph(\n    Network<N, E> network, Iterable<? extends N> nodes) {\n  MutableNetwork<N, E> subgraph =\n      (nodes instanceof Collection)\n          ? NetworkBuilder.from(network).expectedNodeCount(((Collection) nodes).size()).build()\n          : NetworkBuilder.from(network).build();\n  for (N node : nodes) {\n    subgraph.addNode(node);\n  }\n  for (N node : subgraph.nodes()) {\n    for (E edge : network.outEdges(node)) {\n      N successorNode = network.incidentNodes(edge).adjacentNode(node);\n      if (subgraph.nodes().contains(successorNode)) {\n        subgraph.addEdge(node, successorNode, edge);\n      }\n    }\n  }\n  return subgraph;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "subgraph",
            "of",
            "network",
            "induced",
            "by",
            "nodes"
        ]
    },
    {
        "id": 1074,
        "code": "public static <N, E> MutableNetwork<N, E> copyOf(Network<N, E> network) {\n  MutableNetwork<N, E> copy =\n      NetworkBuilder.from(network)\n          .expectedNodeCount(network.nodes().size())\n          .expectedEdgeCount(network.edges().size())\n          .build();\n  for (N node : network.nodes()) {\n    copy.addNode(node);\n  }\n  for (E edge : network.edges()) {\n    EndpointPair<N> endpointPair = network.incidentNodes(edge);\n    copy.addEdge(endpointPair.nodeU(), endpointPair.nodeV(), edge);\n  }\n  return copy;\n}",
        "summary_tokens": [
            "creates",
            "a",
            "mutable",
            "copy",
            "of",
            "network",
            "with",
            "the",
            "same",
            "nodes",
            "and",
            "edges"
        ]
    },
    {
        "id": 1075,
        "code": "public static <N> ImmutableGraph<N> copyOf(ImmutableGraph<N> graph) {\n  return checkNotNull(graph);\n}",
        "summary_tokens": [
            "simply",
            "returns",
            "its",
            "argument"
        ]
    },
    {
        "id": 1076,
        "code": "public static <N, E> ImmutableNetwork<N, E> copyOf(ImmutableNetwork<N, E> network) {\n  return checkNotNull(network);\n}",
        "summary_tokens": [
            "simply",
            "returns",
            "its",
            "argument"
        ]
    },
    {
        "id": 1077,
        "code": "public static <N, V> ImmutableValueGraph<N, V> copyOf(ImmutableValueGraph<N, V> graph) {\n  return checkNotNull(graph);\n}",
        "summary_tokens": [
            "simply",
            "returns",
            "its",
            "argument"
        ]
    },
    {
        "id": 1078,
        "code": "public static NetworkBuilder<Object, Object> directed() {\n  return new NetworkBuilder<>(true);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "network",
            "builder",
            "for",
            "building",
            "directed",
            "networks"
        ]
    },
    {
        "id": 1079,
        "code": "public static NetworkBuilder<Object, Object> undirected() {\n  return new NetworkBuilder<>(false);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "network",
            "builder",
            "for",
            "building",
            "undirected",
            "networks"
        ]
    },
    {
        "id": 1080,
        "code": "public static <N, E> NetworkBuilder<N, E> from(Network<N, E> network) {\n  return new NetworkBuilder<N, E>(network.isDirected())\n      .allowsParallelEdges(network.allowsParallelEdges())\n      .allowsSelfLoops(network.allowsSelfLoops())\n      .nodeOrder(network.nodeOrder())\n      .edgeOrder(network.edgeOrder());\n}",
        "summary_tokens": [
            "returns",
            "a",
            "network",
            "builder",
            "initialized",
            "with",
            "all",
            "properties",
            "queryable",
            "from",
            "network"
        ]
    },
    {
        "id": 1081,
        "code": "public <N1 extends N, E1 extends E> ImmutableNetwork.Builder<N1, E1> immutable() {\n  NetworkBuilder<N1, E1> castBuilder = cast();\n  return new ImmutableNetwork.Builder<>(castBuilder);\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "network"
        ]
    },
    {
        "id": 1082,
        "code": "public NetworkBuilder<N, E> allowsParallelEdges(boolean allowsParallelEdges) {\n  this.allowsParallelEdges = allowsParallelEdges;\n  return this;\n}",
        "summary_tokens": [
            "specifies",
            "whether",
            "the",
            "network",
            "will",
            "allow",
            "parallel",
            "edges"
        ]
    },
    {
        "id": 1083,
        "code": "public NetworkBuilder<N, E> allowsSelfLoops(boolean allowsSelfLoops) {\n  this.allowsSelfLoops = allowsSelfLoops;\n  return this;\n}",
        "summary_tokens": [
            "specifies",
            "whether",
            "the",
            "network",
            "will",
            "allow",
            "self",
            "loops",
            "edges",
            "that",
            "connect",
            "a",
            "node",
            "to",
            "itself"
        ]
    },
    {
        "id": 1084,
        "code": "public NetworkBuilder<N, E> expectedNodeCount(int expectedNodeCount) {\n  this.expectedNodeCount = Optional.of(checkNonNegative(expectedNodeCount));\n  return this;\n}",
        "summary_tokens": [
            "specifies",
            "the",
            "expected",
            "number",
            "of",
            "nodes",
            "in",
            "the",
            "network"
        ]
    },
    {
        "id": 1085,
        "code": "public NetworkBuilder<N, E> expectedEdgeCount(int expectedEdgeCount) {\n  this.expectedEdgeCount = Optional.of(checkNonNegative(expectedEdgeCount));\n  return this;\n}",
        "summary_tokens": [
            "specifies",
            "the",
            "expected",
            "number",
            "of",
            "edges",
            "in",
            "the",
            "network"
        ]
    },
    {
        "id": 1086,
        "code": "public <N1 extends N> NetworkBuilder<N1, E> nodeOrder(ElementOrder<N1> nodeOrder) {\n  NetworkBuilder<N1, E> newBuilder = cast();\n  newBuilder.nodeOrder = checkNotNull(nodeOrder);\n  return newBuilder;\n}",
        "summary_tokens": [
            "specifies",
            "the",
            "order",
            "of",
            "iteration",
            "for",
            "the",
            "elements",
            "of",
            "network",
            "nodes"
        ]
    },
    {
        "id": 1087,
        "code": "public <E1 extends E> NetworkBuilder<N, E1> edgeOrder(ElementOrder<E1> edgeOrder) {\n  NetworkBuilder<N, E1> newBuilder = cast();\n  newBuilder.edgeOrder = checkNotNull(edgeOrder);\n  return newBuilder;\n}",
        "summary_tokens": [
            "specifies",
            "the",
            "order",
            "of",
            "iteration",
            "for",
            "the",
            "elements",
            "of",
            "network",
            "edges"
        ]
    },
    {
        "id": 1088,
        "code": "public <N1 extends N, E1 extends E> MutableNetwork<N1, E1> build() {\n  return new StandardMutableNetwork<>(this);\n}",
        "summary_tokens": [
            "returns",
            "an",
            "empty",
            "mutable",
            "network",
            "with",
            "the",
            "properties",
            "of",
            "this",
            "network",
            "builder"
        ]
    },
    {
        "id": 1089,
        "code": "private NetworkConnections<N, E> addNodeInternal(N node) {\n  NetworkConnections<N, E> connections = newConnections();\n  checkState(nodeConnections.put(node, connections) == null);\n  return connections;\n}",
        "summary_tokens": [
            "adds",
            "node",
            "to",
            "the",
            "graph",
            "and",
            "returns",
            "the",
            "associated",
            "network",
            "connections"
        ]
    },
    {
        "id": 1090,
        "code": "private GraphConnections<N, V> addNodeInternal(N node) {\n  GraphConnections<N, V> connections = newConnections();\n  checkState(nodeConnections.put(node, connections) == null);\n  return connections;\n}",
        "summary_tokens": [
            "adds",
            "node",
            "to",
            "the",
            "graph",
            "and",
            "returns",
            "the",
            "associated",
            "graph",
            "connections"
        ]
    },
    {
        "id": 1091,
        "code": "public static <N> Traverser<N> forGraph(SuccessorsFunction<N> graph) {\n  return new Traverser<N>(graph) {\n    @Override\n    Traversal<N> newTraversal() {\n      return Traversal.inGraph(graph);\n    }\n  };\n}",
        "summary_tokens": [
            "creates",
            "a",
            "new",
            "traverser",
            "for",
            "the",
            "given",
            "general",
            "graph"
        ]
    },
    {
        "id": 1092,
        "code": "public static <N> Traverser<N> forTree(SuccessorsFunction<N> tree) {\n  if (tree instanceof BaseGraph) {\n    checkArgument(((BaseGraph<?>) tree).isDirected(), \"Undirected graphs can never be trees.\");\n  }\n  if (tree instanceof Network) {\n    checkArgument(((Network<?, ?>) tree).isDirected(), \"Undirected networks can never be trees.\");\n  }\n  return new Traverser<N>(tree) {\n    @Override\n    Traversal<N> newTraversal() {\n      return Traversal.inTree(tree);\n    }\n  };\n}",
        "summary_tokens": [
            "creates",
            "a",
            "new",
            "traverser",
            "for",
            "a",
            "directed",
            "acyclic",
            "graph",
            "that",
            "has",
            "at",
            "most",
            "one",
            "path",
            "from",
            "the",
            "start",
            "node",
            "s",
            "to",
            "any",
            "node",
            "reachable",
            "from",
            "the",
            "start",
            "node",
            "s",
            "and",
            "has",
            "no",
            "paths",
            "from",
            "any",
            "start",
            "node",
            "to",
            "any",
            "other",
            "start",
            "node",
            "such",
            "as",
            "a",
            "tree",
            "or",
            "forest"
        ]
    },
    {
        "id": 1093,
        "code": "public final Iterable<N> breadthFirst(Iterable<? extends N> startNodes) {\n  ImmutableSet<N> validated = validate(startNodes);\n  return new Iterable<N>() {\n    @Override\n    public Iterator<N> iterator() {\n      return newTraversal().breadthFirst(validated.iterator());\n    }\n  };\n}",
        "summary_tokens": [
            "returns",
            "an",
            "unmodifiable",
            "iterable",
            "over",
            "the",
            "nodes",
            "reachable",
            "from",
            "any",
            "of",
            "the",
            "start",
            "nodes",
            "in",
            "the",
            "order",
            "of",
            "a",
            "breadth",
            "first",
            "traversal"
        ]
    },
    {
        "id": 1094,
        "code": "public final Iterable<N> depthFirstPreOrder(Iterable<? extends N> startNodes) {\n  ImmutableSet<N> validated = validate(startNodes);\n  return new Iterable<N>() {\n    @Override\n    public Iterator<N> iterator() {\n      return newTraversal().preOrder(validated.iterator());\n    }\n  };\n}",
        "summary_tokens": [
            "returns",
            "an",
            "unmodifiable",
            "iterable",
            "over",
            "the",
            "nodes",
            "reachable",
            "from",
            "any",
            "of",
            "the",
            "start",
            "nodes",
            "in",
            "the",
            "order",
            "of",
            "a",
            "depth",
            "first",
            "pre",
            "order",
            "traversal"
        ]
    },
    {
        "id": 1095,
        "code": "public final Iterable<N> depthFirstPostOrder(Iterable<? extends N> startNodes) {\n  ImmutableSet<N> validated = validate(startNodes);\n  return new Iterable<N>() {\n    @Override\n    public Iterator<N> iterator() {\n      return newTraversal().postOrder(validated.iterator());\n    }\n  };\n}",
        "summary_tokens": [
            "returns",
            "an",
            "unmodifiable",
            "iterable",
            "over",
            "the",
            "nodes",
            "reachable",
            "from",
            "any",
            "of",
            "the",
            "start",
            "nodes",
            "in",
            "the",
            "order",
            "of",
            "a",
            "depth",
            "first",
            "post",
            "order",
            "traversal"
        ]
    },
    {
        "id": 1096,
        "code": "public static ValueGraphBuilder<Object, Object> directed() {\n  return new ValueGraphBuilder<>(true);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "value",
            "graph",
            "builder",
            "for",
            "building",
            "directed",
            "graphs"
        ]
    },
    {
        "id": 1097,
        "code": "public static ValueGraphBuilder<Object, Object> undirected() {\n  return new ValueGraphBuilder<>(false);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "value",
            "graph",
            "builder",
            "for",
            "building",
            "undirected",
            "graphs"
        ]
    },
    {
        "id": 1098,
        "code": "public static <N, V> ValueGraphBuilder<N, V> from(ValueGraph<N, V> graph) {\n  return new ValueGraphBuilder<N, V>(graph.isDirected())\n      .allowsSelfLoops(graph.allowsSelfLoops())\n      .nodeOrder(graph.nodeOrder())\n      .incidentEdgeOrder(graph.incidentEdgeOrder());\n}",
        "summary_tokens": [
            "returns",
            "a",
            "value",
            "graph",
            "builder",
            "initialized",
            "with",
            "all",
            "properties",
            "queryable",
            "from",
            "graph"
        ]
    },
    {
        "id": 1099,
        "code": "public <N1 extends N, V1 extends V> ImmutableValueGraph.Builder<N1, V1> immutable() {\n  ValueGraphBuilder<N1, V1> castBuilder = cast();\n  return new ImmutableValueGraph.Builder<>(castBuilder);\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "value",
            "graph"
        ]
    },
    {
        "id": 1100,
        "code": "public ValueGraphBuilder<N, V> allowsSelfLoops(boolean allowsSelfLoops) {\n  this.allowsSelfLoops = allowsSelfLoops;\n  return this;\n}",
        "summary_tokens": [
            "specifies",
            "whether",
            "the",
            "graph",
            "will",
            "allow",
            "self",
            "loops",
            "edges",
            "that",
            "connect",
            "a",
            "node",
            "to",
            "itself"
        ]
    },
    {
        "id": 1101,
        "code": "public ValueGraphBuilder<N, V> expectedNodeCount(int expectedNodeCount) {\n  this.expectedNodeCount = Optional.of(checkNonNegative(expectedNodeCount));\n  return this;\n}",
        "summary_tokens": [
            "specifies",
            "the",
            "expected",
            "number",
            "of",
            "nodes",
            "in",
            "the",
            "graph"
        ]
    },
    {
        "id": 1102,
        "code": "public <N1 extends N> ValueGraphBuilder<N1, V> nodeOrder(ElementOrder<N1> nodeOrder) {\n  ValueGraphBuilder<N1, V> newBuilder = cast();\n  newBuilder.nodeOrder = checkNotNull(nodeOrder);\n  return newBuilder;\n}",
        "summary_tokens": [
            "specifies",
            "the",
            "order",
            "of",
            "iteration",
            "for",
            "the",
            "elements",
            "of",
            "graph",
            "nodes"
        ]
    },
    {
        "id": 1103,
        "code": "public <N1 extends N> ValueGraphBuilder<N1, V> incidentEdgeOrder(\n    ElementOrder<N1> incidentEdgeOrder) {\n  checkArgument(\n      incidentEdgeOrder.type() == ElementOrder.Type.UNORDERED\n          || incidentEdgeOrder.type() == ElementOrder.Type.STABLE,\n      \"The given elementOrder (%s) is unsupported. incidentEdgeOrder() only supports\"\n          + \" ElementOrder.unordered() and ElementOrder.stable().\",\n      incidentEdgeOrder);\n  ValueGraphBuilder<N1, V> newBuilder = cast();\n  newBuilder.incidentEdgeOrder = checkNotNull(incidentEdgeOrder);\n  return newBuilder;\n}",
        "summary_tokens": [
            "specifies",
            "the",
            "order",
            "of",
            "iteration",
            "for",
            "the",
            "elements",
            "of",
            "value",
            "graph",
            "edges",
            "value",
            "graph",
            "adjacent",
            "nodes",
            "object",
            "value",
            "graph",
            "predecessors",
            "object",
            "value",
            "graph",
            "successors",
            "object",
            "and",
            "value",
            "graph",
            "incident",
            "edges",
            "object"
        ]
    },
    {
        "id": 1104,
        "code": "public <N1 extends N, V1 extends V> MutableValueGraph<N1, V1> build() {\n  return new StandardMutableValueGraph<>(this);\n}",
        "summary_tokens": [
            "returns",
            "an",
            "empty",
            "mutable",
            "value",
            "graph",
            "with",
            "the",
            "properties",
            "of",
            "this",
            "value",
            "graph",
            "builder"
        ]
    },
    {
        "id": 1105,
        "code": "private Hasher update(int bytes) {\n  try {\n    update(scratch.array(), 0, bytes);\n  } finally {\n    Java8Compatibility.clear(scratch);\n  }\n  return this;\n}",
        "summary_tokens": [
            "updates",
            "the",
            "sink",
            "with",
            "the",
            "given",
            "number",
            "of",
            "bytes",
            "from",
            "the",
            "buffer"
        ]
    },
    {
        "id": 1106,
        "code": "protected void processRemaining(ByteBuffer bb) {\n  Java8Compatibility.position(bb, bb.limit()); \n  Java8Compatibility.limit(bb, chunkSize + 7); \n  while (bb.position() < chunkSize) {\n    bb.putLong(0);\n  }\n  Java8Compatibility.limit(bb, chunkSize);\n  Java8Compatibility.flip(bb);\n  process(bb);\n}",
        "summary_tokens": [
            "this",
            "is",
            "invoked",
            "for",
            "the",
            "last",
            "bytes",
            "of",
            "the",
            "input",
            "which",
            "are",
            "not",
            "enough",
            "to",
            "fill",
            "a",
            "whole",
            "chunk"
        ]
    },
    {
        "id": 1107,
        "code": "private static void weakHashLength32WithSeeds(\n    byte[] bytes, int offset, long seedA, long seedB, long[] output) {\n  long part1 = load64(bytes, offset);\n  long part2 = load64(bytes, offset + 8);\n  long part3 = load64(bytes, offset + 16);\n  long part4 = load64(bytes, offset + 24);\n\n  seedA += part1;\n  seedB = rotateRight(seedB + seedA + part4, 21);\n  long c = seedA;\n  seedA += part2;\n  seedA += part3;\n  seedB += rotateRight(seedA, 44);\n  output[0] = seedA + part4;\n  output[1] = seedB + c;\n}",
        "summary_tokens": [
            "computes",
            "intermediate",
            "hash",
            "of",
            "0",
            "bytes",
            "of",
            "byte",
            "array",
            "from",
            "the",
            "given",
            "offset"
        ]
    },
    {
        "id": 1108,
        "code": "static long hash128to64(long high, long low) {\n  long a = (low ^ high) * K3;\n  a ^= (a >>> 47);\n  long b = (high ^ a) * K3;\n  b ^= (b >>> 47);\n  b *= K3;\n  return b;\n}",
        "summary_tokens": [
            "implementation",
            "of",
            "hash",
            "0",
            "to",
            "0",
            "from",
            "util",
            "hash",
            "hash",
            "0",
            "to",
            "0"
        ]
    },
    {
        "id": 1109,
        "code": "private static void weakHashLength32WithSeeds(\n    byte[] bytes, int offset, long seedA, long seedB, long[] output) {\n  long part1 = load64(bytes, offset);\n  long part2 = load64(bytes, offset + 8);\n  long part3 = load64(bytes, offset + 16);\n  long part4 = load64(bytes, offset + 24);\n\n  seedA += part1;\n  seedB = rotateRight(seedB + seedA + part4, 51);\n  long c = seedA;\n  seedA += part2;\n  seedA += part3;\n  seedB += rotateRight(seedA, 23);\n  output[0] = seedA + part4;\n  output[1] = seedB + c;\n}",
        "summary_tokens": [
            "computes",
            "intermediate",
            "hash",
            "of",
            "0",
            "bytes",
            "of",
            "byte",
            "array",
            "from",
            "the",
            "given",
            "offset"
        ]
    },
    {
        "id": 1110,
        "code": "public int writeBytesTo(byte[] dest, int offset, int maxLength) {\n  maxLength = Ints.min(maxLength, bits() / 8);\n  Preconditions.checkPositionIndexes(offset, offset + maxLength, dest.length);\n  writeBytesToImpl(dest, offset, maxLength);\n  return maxLength;\n}",
        "summary_tokens": [
            "copies",
            "bytes",
            "from",
            "this",
            "hash",
            "code",
            "into",
            "dest"
        ]
    },
    {
        "id": 1111,
        "code": "byte[] getBytesInternal() {\n  return asBytes();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "mutable",
            "view",
            "of",
            "the",
            "underlying",
            "bytes",
            "for",
            "the",
            "given",
            "hash",
            "code",
            "if",
            "it",
            "is",
            "a",
            "byte",
            "based",
            "hashcode"
        ]
    },
    {
        "id": 1112,
        "code": "public static HashCode fromInt(int hash) {\n  return new IntHashCode(hash);\n}",
        "summary_tokens": [
            "creates",
            "a",
            "0",
            "bit",
            "hash",
            "code",
            "representation",
            "of",
            "the",
            "given",
            "int",
            "value"
        ]
    },
    {
        "id": 1113,
        "code": "public static HashCode fromLong(long hash) {\n  return new LongHashCode(hash);\n}",
        "summary_tokens": [
            "creates",
            "a",
            "0",
            "bit",
            "hash",
            "code",
            "representation",
            "of",
            "the",
            "given",
            "long",
            "value"
        ]
    },
    {
        "id": 1114,
        "code": "public static HashCode fromBytes(byte[] bytes) {\n  checkArgument(bytes.length >= 1, \"A HashCode must contain at least 1 byte.\");\n  return fromBytesNoCopy(bytes.clone());\n}",
        "summary_tokens": [
            "creates",
            "a",
            "hash",
            "code",
            "from",
            "a",
            "byte",
            "array"
        ]
    },
    {
        "id": 1115,
        "code": "static HashCode fromBytesNoCopy(byte[] bytes) {\n  return new BytesHashCode(bytes);\n}",
        "summary_tokens": [
            "creates",
            "a",
            "hash",
            "code",
            "from",
            "a",
            "byte",
            "array"
        ]
    },
    {
        "id": 1116,
        "code": "public static HashCode fromString(String string) {\n  checkArgument(\n      string.length() >= 2, \"input string (%s) must have at least 2 characters\", string);\n  checkArgument(\n      string.length() % 2 == 0,\n      \"input string (%s) must have an even number of characters\",\n      string);\n\n  byte[] bytes = new byte[string.length() / 2];\n  for (int i = 0; i < string.length(); i += 2) {\n    int ch1 = decode(string.charAt(i)) << 4;\n    int ch2 = decode(string.charAt(i + 1));\n    bytes[i / 2] = (byte) (ch1 + ch2);\n  }\n  return fromBytesNoCopy(bytes);\n}",
        "summary_tokens": [
            "creates",
            "a",
            "hash",
            "code",
            "from",
            "a",
            "hexadecimal",
            "base",
            "0",
            "encoded",
            "string"
        ]
    },
    {
        "id": 1117,
        "code": "public final boolean equals(@CheckForNull Object object) {\n  if (object instanceof HashCode) {\n    HashCode that = (HashCode) object;\n    return bits() == that.bits() && equalsSameBits(that);\n  }\n  return false;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "object",
            "is",
            "a",
            "hash",
            "code",
            "instance",
            "with",
            "the",
            "identical",
            "byte",
            "representation",
            "to",
            "this",
            "hash",
            "code"
        ]
    },
    {
        "id": 1118,
        "code": "public final int hashCode() {\n    \n    \n  if (bits() >= 32) {\n    return asInt();\n  }\n    \n  byte[] bytes = getBytesInternal();\n  int val = (bytes[0] & 0xFF);\n  for (int i = 1; i < bytes.length; i++) {\n    val |= ((bytes[i] & 0xFF) << (i * 8));\n  }\n  return val;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "java",
            "hash",
            "code",
            "for",
            "this",
            "hash",
            "code",
            "instance",
            "this",
            "is",
            "well",
            "defined",
            "so",
            "for",
            "example",
            "you",
            "can",
            "safely",
            "put",
            "hash",
            "code",
            "instances",
            "into",
            "a",
            "hash",
            "set",
            "but",
            "is",
            "otherwise",
            "probably",
            "not",
            "what",
            "you",
            "want",
            "to",
            "use"
        ]
    },
    {
        "id": 1119,
        "code": "public final String toString() {\n  byte[] bytes = getBytesInternal();\n  StringBuilder sb = new StringBuilder(2 * bytes.length);\n  for (byte b : bytes) {\n    sb.append(hexDigits[(b >> 4) & 0xf]).append(hexDigits[b & 0xf]);\n  }\n  return sb.toString();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "string",
            "containing",
            "each",
            "byte",
            "of",
            "as",
            "bytes",
            "in",
            "order",
            "as",
            "a",
            "two",
            "digit",
            "unsigned",
            "hexadecimal",
            "number",
            "in",
            "lower",
            "case"
        ]
    },
    {
        "id": 1120,
        "code": "public static HashFunction goodFastHash(int minimumBits) {\n  int bits = checkPositiveAndMakeMultipleOf32(minimumBits);\n\n  if (bits == 32) {\n    return Murmur3_32HashFunction.GOOD_FAST_HASH_32;\n  }\n  if (bits <= 128) {\n    return Murmur3_128HashFunction.GOOD_FAST_HASH_128;\n  }\n\n    \n  int hashFunctionsNeeded = (bits + 127) / 128;\n  HashFunction[] hashFunctions = new HashFunction[hashFunctionsNeeded];\n  hashFunctions[0] = Murmur3_128HashFunction.GOOD_FAST_HASH_128;\n  int seed = GOOD_FAST_HASH_SEED;\n  for (int i = 1; i < hashFunctionsNeeded; i++) {\n    seed += 1500450271; \n    hashFunctions[i] = murmur3_128(seed);\n  }\n  return new ConcatenatedHashFunction(hashFunctions);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "general",
            "purpose",
            "b",
            "temporary",
            "use",
            "b",
            "non",
            "cryptographic",
            "hash",
            "function"
        ]
    },
    {
        "id": 1121,
        "code": "public static HashFunction murmur3_32() {\n  return Murmur3_32HashFunction.MURMUR3_32;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "hash",
            "function",
            "implementing",
            "the",
            "a",
            "href",
            "https",
            "github"
        ]
    },
    {
        "id": 1122,
        "code": "public static HashFunction murmur3_32_fixed() {\n  return Murmur3_32HashFunction.MURMUR3_32_FIXED;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "hash",
            "function",
            "implementing",
            "the",
            "a",
            "href",
            "https",
            "github"
        ]
    },
    {
        "id": 1123,
        "code": "public static HashFunction murmur3_128() {\n  return Murmur3_128HashFunction.MURMUR3_128;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "hash",
            "function",
            "implementing",
            "the",
            "a",
            "href",
            "https",
            "github"
        ]
    },
    {
        "id": 1124,
        "code": "public static HashFunction sipHash24(long k0, long k1) {\n  return new SipHashFunction(2, 4, k0, k1);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "hash",
            "function",
            "implementing",
            "the",
            "a",
            "href",
            "https",
            "0"
        ]
    },
    {
        "id": 1125,
        "code": "public static HashFunction md5() {\n  return Md5Holder.MD5;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "hash",
            "function",
            "implementing",
            "the",
            "md",
            "0",
            "hash",
            "algorithm",
            "0",
            "hash",
            "bits"
        ]
    },
    {
        "id": 1126,
        "code": "public static HashFunction sha1() {\n  return Sha1Holder.SHA_1;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "hash",
            "function",
            "implementing",
            "the",
            "sha",
            "0",
            "algorithm",
            "0",
            "hash",
            "bits"
        ]
    },
    {
        "id": 1127,
        "code": "public static HashFunction sha256() {\n  return Sha256Holder.SHA_256;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "hash",
            "function",
            "implementing",
            "the",
            "sha",
            "0",
            "algorithm",
            "0",
            "hash",
            "bits"
        ]
    },
    {
        "id": 1128,
        "code": "public static HashFunction sha384() {\n  return Sha384Holder.SHA_384;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "hash",
            "function",
            "implementing",
            "the",
            "sha",
            "0",
            "algorithm",
            "0",
            "hash",
            "bits"
        ]
    },
    {
        "id": 1129,
        "code": "public static HashFunction sha512() {\n  return Sha512Holder.SHA_512;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "hash",
            "function",
            "implementing",
            "the",
            "sha",
            "0",
            "algorithm",
            "0",
            "hash",
            "bits"
        ]
    },
    {
        "id": 1130,
        "code": "public static HashFunction hmacMd5(byte[] key) {\n  return hmacMd5(new SecretKeySpec(checkNotNull(key), \"HmacMD5\"));\n}",
        "summary_tokens": [
            "returns",
            "a",
            "hash",
            "function",
            "implementing",
            "the",
            "message",
            "authentication",
            "code",
            "mac",
            "algorithm",
            "using",
            "the",
            "md",
            "0",
            "0",
            "hash",
            "bits",
            "hash",
            "function",
            "and",
            "a",
            "secret",
            "key",
            "spec",
            "created",
            "from",
            "the",
            "given",
            "byte",
            "array",
            "and",
            "the",
            "md",
            "0",
            "algorithm"
        ]
    },
    {
        "id": 1131,
        "code": "public static HashFunction hmacSha1(byte[] key) {\n  return hmacSha1(new SecretKeySpec(checkNotNull(key), \"HmacSHA1\"));\n}",
        "summary_tokens": [
            "returns",
            "a",
            "hash",
            "function",
            "implementing",
            "the",
            "message",
            "authentication",
            "code",
            "mac",
            "algorithm",
            "using",
            "the",
            "sha",
            "0",
            "0",
            "hash",
            "bits",
            "hash",
            "function",
            "and",
            "a",
            "secret",
            "key",
            "spec",
            "created",
            "from",
            "the",
            "given",
            "byte",
            "array",
            "and",
            "the",
            "sha",
            "0",
            "algorithm"
        ]
    },
    {
        "id": 1132,
        "code": "public static HashFunction hmacSha256(byte[] key) {\n  return hmacSha256(new SecretKeySpec(checkNotNull(key), \"HmacSHA256\"));\n}",
        "summary_tokens": [
            "returns",
            "a",
            "hash",
            "function",
            "implementing",
            "the",
            "message",
            "authentication",
            "code",
            "mac",
            "algorithm",
            "using",
            "the",
            "sha",
            "0",
            "0",
            "hash",
            "bits",
            "hash",
            "function",
            "and",
            "a",
            "secret",
            "key",
            "spec",
            "created",
            "from",
            "the",
            "given",
            "byte",
            "array",
            "and",
            "the",
            "sha",
            "0",
            "algorithm"
        ]
    },
    {
        "id": 1133,
        "code": "public static HashFunction hmacSha512(byte[] key) {\n  return hmacSha512(new SecretKeySpec(checkNotNull(key), \"HmacSHA512\"));\n}",
        "summary_tokens": [
            "returns",
            "a",
            "hash",
            "function",
            "implementing",
            "the",
            "message",
            "authentication",
            "code",
            "mac",
            "algorithm",
            "using",
            "the",
            "sha",
            "0",
            "0",
            "hash",
            "bits",
            "hash",
            "function",
            "and",
            "a",
            "secret",
            "key",
            "spec",
            "created",
            "from",
            "the",
            "given",
            "byte",
            "array",
            "and",
            "the",
            "sha",
            "0",
            "algorithm"
        ]
    },
    {
        "id": 1134,
        "code": "public static HashFunction crc32c() {\n  return Crc32cHashFunction.CRC_32_C;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "hash",
            "function",
            "implementing",
            "the",
            "crc",
            "0",
            "c",
            "checksum",
            "algorithm",
            "0",
            "hash",
            "bits",
            "as",
            "described",
            "by",
            "rfc",
            "0",
            "section",
            "0"
        ]
    },
    {
        "id": 1135,
        "code": "public static HashFunction crc32() {\n  return ChecksumType.CRC_32.hashFunction;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "hash",
            "function",
            "implementing",
            "the",
            "crc",
            "0",
            "checksum",
            "algorithm",
            "0",
            "hash",
            "bits"
        ]
    },
    {
        "id": 1136,
        "code": "public static HashFunction adler32() {\n  return ChecksumType.ADLER_32.hashFunction;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "hash",
            "function",
            "implementing",
            "the",
            "adler",
            "0",
            "checksum",
            "algorithm",
            "0",
            "hash",
            "bits"
        ]
    },
    {
        "id": 1137,
        "code": "public static HashFunction farmHashFingerprint64() {\n  return FarmHashFingerprint64.FARMHASH_FINGERPRINT_64;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "hash",
            "function",
            "implementing",
            "farm",
            "hash",
            "s",
            "fingerprint",
            "0",
            "an",
            "open",
            "source",
            "algorithm"
        ]
    },
    {
        "id": 1138,
        "code": "public static HashFunction fingerprint2011() {\n  return Fingerprint2011.FINGERPRINT_2011;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "hash",
            "function",
            "implementing",
            "the",
            "fingerprint",
            "0",
            "hashing",
            "function",
            "0",
            "hash",
            "bits"
        ]
    },
    {
        "id": 1139,
        "code": "public static int consistentHash(long input, int buckets) {\n  checkArgument(buckets > 0, \"buckets must be positive: %s\", buckets);\n  LinearCongruentialGenerator generator = new LinearCongruentialGenerator(input);\n  int candidate = 0;\n  int next;\n\n    \n  while (true) {\n    next = (int) ((candidate + 1) / generator.nextDouble());\n    if (next >= 0 && next < buckets) {\n      candidate = next;\n    } else {\n      return candidate;\n    }\n  }\n}",
        "summary_tokens": [
            "assigns",
            "to",
            "input",
            "a",
            "bucket",
            "in",
            "the",
            "range",
            "0",
            "buckets",
            "in",
            "a",
            "uniform",
            "manner",
            "that",
            "minimizes",
            "the",
            "need",
            "for",
            "remapping",
            "as",
            "buckets",
            "grows"
        ]
    },
    {
        "id": 1140,
        "code": "public static HashCode combineOrdered(Iterable<HashCode> hashCodes) {\n  Iterator<HashCode> iterator = hashCodes.iterator();\n  checkArgument(iterator.hasNext(), \"Must be at least 1 hash code to combine.\");\n  int bits = iterator.next().bits();\n  byte[] resultBytes = new byte[bits / 8];\n  for (HashCode hashCode : hashCodes) {\n    byte[] nextBytes = hashCode.asBytes();\n    checkArgument(\n        nextBytes.length == resultBytes.length, \"All hashcodes must have the same bit length.\");\n    for (int i = 0; i < nextBytes.length; i++) {\n      resultBytes[i] = (byte) (resultBytes[i] * 37 ^ nextBytes[i]);\n    }\n  }\n  return HashCode.fromBytesNoCopy(resultBytes);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "hash",
            "code",
            "having",
            "the",
            "same",
            "bit",
            "length",
            "as",
            "each",
            "of",
            "the",
            "input",
            "hash",
            "codes",
            "that",
            "combines",
            "the",
            "information",
            "of",
            "these",
            "hash",
            "codes",
            "in",
            "an",
            "ordered",
            "fashion"
        ]
    },
    {
        "id": 1141,
        "code": "public static HashCode combineUnordered(Iterable<HashCode> hashCodes) {\n  Iterator<HashCode> iterator = hashCodes.iterator();\n  checkArgument(iterator.hasNext(), \"Must be at least 1 hash code to combine.\");\n  byte[] resultBytes = new byte[iterator.next().bits() / 8];\n  for (HashCode hashCode : hashCodes) {\n    byte[] nextBytes = hashCode.asBytes();\n    checkArgument(\n        nextBytes.length == resultBytes.length, \"All hashcodes must have the same bit length.\");\n    for (int i = 0; i < nextBytes.length; i++) {\n      resultBytes[i] += nextBytes[i];\n    }\n  }\n  return HashCode.fromBytesNoCopy(resultBytes);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "hash",
            "code",
            "having",
            "the",
            "same",
            "bit",
            "length",
            "as",
            "each",
            "of",
            "the",
            "input",
            "hash",
            "codes",
            "that",
            "combines",
            "the",
            "information",
            "of",
            "these",
            "hash",
            "codes",
            "in",
            "an",
            "unordered",
            "fashion"
        ]
    },
    {
        "id": 1142,
        "code": "static int checkPositiveAndMakeMultipleOf32(int bits) {\n  checkArgument(bits > 0, \"Number of bits must be positive\");\n  return (bits + 31) & ~31;\n}",
        "summary_tokens": [
            "checks",
            "that",
            "the",
            "passed",
            "argument",
            "is",
            "positive",
            "and",
            "ceils",
            "it",
            "to",
            "a",
            "multiple",
            "of",
            "0"
        ]
    },
    {
        "id": 1143,
        "code": "public static HashFunction concatenating(Iterable<HashFunction> hashFunctions) {\n  checkNotNull(hashFunctions);\n    \n  List<HashFunction> list = new ArrayList<>();\n  for (HashFunction hashFunction : hashFunctions) {\n    list.add(hashFunction);\n  }\n  checkArgument(list.size() > 0, \"number of hash functions (%s) must be > 0\", list.size());\n  return new ConcatenatedHashFunction(list.toArray(new HashFunction[0]));\n}",
        "summary_tokens": [
            "returns",
            "a",
            "hash",
            "function",
            "which",
            "computes",
            "its",
            "hash",
            "code",
            "by",
            "concatenating",
            "the",
            "hash",
            "codes",
            "of",
            "the",
            "underlying",
            "hash",
            "functions",
            "together"
        ]
    },
    {
        "id": 1144,
        "code": "public int read(byte[] bytes, int off, int len) throws IOException {\n  int numOfBytesRead = in.read(bytes, off, len);\n  if (numOfBytesRead != -1) {\n    hasher.putBytes(bytes, off, numOfBytesRead);\n  }\n  return numOfBytesRead;\n}",
        "summary_tokens": [
            "reads",
            "the",
            "specified",
            "bytes",
            "of",
            "data",
            "from",
            "the",
            "underlying",
            "input",
            "stream",
            "and",
            "updates",
            "the",
            "hasher",
            "with",
            "the",
            "bytes",
            "read"
        ]
    },
    {
        "id": 1145,
        "code": "public boolean markSupported() {\n  return false;\n}",
        "summary_tokens": [
            "mark",
            "is",
            "not",
            "supported",
            "for",
            "hashing",
            "input",
            "stream"
        ]
    },
    {
        "id": 1146,
        "code": "public void mark(int readlimit) {}",
        "summary_tokens": [
            "mark",
            "is",
            "not",
            "supported",
            "for",
            "hashing",
            "input",
            "stream"
        ]
    },
    {
        "id": 1147,
        "code": "public void reset() throws IOException {\n  throw new IOException(\"reset not supported\");\n}",
        "summary_tokens": [
            "reset",
            "is",
            "not",
            "supported",
            "for",
            "hashing",
            "input",
            "stream"
        ]
    },
    {
        "id": 1148,
        "code": "public HashCode hash() {\n  return hasher.hash();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "hash",
            "code",
            "based",
            "on",
            "the",
            "data",
            "read",
            "from",
            "this",
            "stream"
        ]
    },
    {
        "id": 1149,
        "code": "public HashCode hash() {\n  return hasher.hash();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "hash",
            "code",
            "based",
            "on",
            "the",
            "data",
            "written",
            "to",
            "this",
            "stream"
        ]
    },
    {
        "id": 1150,
        "code": "static long load64(byte[] input, int offset) {\n    \n  assert input.length >= offset + 8;\n    \n  return byteArray.getLongLittleEndian(input, offset);\n}",
        "summary_tokens": [
            "load",
            "0",
            "bytes",
            "into",
            "long",
            "in",
            "a",
            "little",
            "endian",
            "manner",
            "from",
            "the",
            "substring",
            "between",
            "position",
            "and",
            "position",
            "0"
        ]
    },
    {
        "id": 1151,
        "code": "static long load64Safely(byte[] input, int offset, int length) {\n  long result = 0;\n    \n    \n\n    \n  int limit = Math.min(length, 8);\n  for (int i = 0; i < limit; i++) {\n      \n    result |= (input[offset + i] & 0xFFL) << (i * 8);\n  }\n  return result;\n}",
        "summary_tokens": [
            "similar",
            "to",
            "load",
            "0",
            "but",
            "allows",
            "offset",
            "0",
            "input"
        ]
    },
    {
        "id": 1152,
        "code": "static void store64(byte[] sink, int offset, long value) {\n    \n  assert offset >= 0 && offset + 8 <= sink.length;\n    \n  byteArray.putLongLittleEndian(sink, offset, value);\n}",
        "summary_tokens": [
            "store",
            "0",
            "bytes",
            "into",
            "the",
            "provided",
            "array",
            "at",
            "the",
            "indicated",
            "offset",
            "using",
            "the",
            "value",
            "provided"
        ]
    },
    {
        "id": 1153,
        "code": "static int load32(byte[] source, int offset) {\n    \n  return (source[offset] & 0xFF)\n      | ((source[offset + 1] & 0xFF) << 8)\n      | ((source[offset + 2] & 0xFF) << 16)\n      | ((source[offset + 3] & 0xFF) << 24);\n}",
        "summary_tokens": [
            "load",
            "0",
            "bytes",
            "from",
            "the",
            "provided",
            "array",
            "at",
            "the",
            "indicated",
            "offset"
        ]
    },
    {
        "id": 1154,
        "code": "static boolean usingUnsafe() {\n  return (byteArray instanceof UnsafeByteArray);\n}",
        "summary_tokens": [
            "indicates",
            "that",
            "the",
            "loading",
            "of",
            "unsafe",
            "was",
            "successful",
            "and",
            "the",
            "load",
            "and",
            "store",
            "operations",
            "will",
            "be",
            "very",
            "efficient"
        ]
    },
    {
        "id": 1155,
        "code": "final long fn(long v, long x) {\n  return v + x;\n}",
        "summary_tokens": [
            "version",
            "of",
            "plus",
            "for",
            "use",
            "in",
            "retry",
            "update"
        ]
    },
    {
        "id": 1156,
        "code": "public void add(long x) {\n  Cell[] as;\n  long b, v;\n  int[] hc;\n  Cell a;\n  int n;\n  if ((as = cells) != null || !casBase(b = base, b + x)) {\n    boolean uncontended = true;\n    if ((hc = threadHashCode.get()) == null\n        || as == null\n        || (n = as.length) < 1\n        || (a = as[(n - 1) & hc[0]]) == null\n        || !(uncontended = a.cas(v = a.value, v + x))) retryUpdate(x, hc, uncontended);\n  }\n}",
        "summary_tokens": [
            "adds",
            "the",
            "given",
            "value"
        ]
    },
    {
        "id": 1157,
        "code": "public void increment() {\n  add(1L);\n}",
        "summary_tokens": [
            "equivalent",
            "to",
            "add",
            "0"
        ]
    },
    {
        "id": 1158,
        "code": "public void decrement() {\n  add(-1L);\n}",
        "summary_tokens": [
            "equivalent",
            "to",
            "add",
            "0"
        ]
    },
    {
        "id": 1159,
        "code": "public long sum() {\n  long sum = base;\n  Cell[] as = cells;\n  if (as != null) {\n    int n = as.length;\n    for (int i = 0; i < n; ++i) {\n      Cell a = as[i];\n      if (a != null) sum += a.value;\n    }\n  }\n  return sum;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "current",
            "sum"
        ]
    },
    {
        "id": 1160,
        "code": "public void reset() {\n  internalReset(0L);\n}",
        "summary_tokens": [
            "resets",
            "variables",
            "maintaining",
            "the",
            "sum",
            "to",
            "zero"
        ]
    },
    {
        "id": 1161,
        "code": "public long sumThenReset() {\n  long sum = base;\n  Cell[] as = cells;\n  base = 0L;\n  if (as != null) {\n    int n = as.length;\n    for (int i = 0; i < n; ++i) {\n      Cell a = as[i];\n      if (a != null) {\n        sum += a.value;\n        a.value = 0L;\n      }\n    }\n  }\n  return sum;\n}",
        "summary_tokens": [
            "equivalent",
            "in",
            "effect",
            "to",
            "sum",
            "followed",
            "by",
            "reset"
        ]
    },
    {
        "id": 1162,
        "code": "public String toString() {\n  return Long.toString(sum());\n}",
        "summary_tokens": [
            "returns",
            "the",
            "string",
            "representation",
            "of",
            "the",
            "sum"
        ]
    },
    {
        "id": 1163,
        "code": "public int intValue() {\n  return (int) sum();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "sum",
            "as",
            "an",
            "int",
            "after",
            "a",
            "narrowing",
            "primitive",
            "conversion"
        ]
    },
    {
        "id": 1164,
        "code": "public float floatValue() {\n  return (float) sum();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "sum",
            "as",
            "a",
            "float",
            "after",
            "a",
            "widening",
            "primitive",
            "conversion"
        ]
    },
    {
        "id": 1165,
        "code": "public double doubleValue() {\n  return (double) sum();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "sum",
            "as",
            "a",
            "double",
            "after",
            "a",
            "widening",
            "primitive",
            "conversion"
        ]
    },
    {
        "id": 1166,
        "code": "public static Escaper htmlEscaper() {\n  return HTML_ESCAPER;\n}",
        "summary_tokens": [
            "returns",
            "an",
            "escaper",
            "instance",
            "that",
            "escapes",
            "html",
            "metacharacters",
            "as",
            "specified",
            "by",
            "a",
            "href",
            "http",
            "www"
        ]
    },
    {
        "id": 1167,
        "code": "public final String encode(byte[] bytes, int off, int len) {\n  checkPositionIndexes(off, off + len, bytes.length);\n  StringBuilder result = new StringBuilder(maxEncodedSize(len));\n  try {\n    encodeTo(result, bytes, off, len);\n  } catch (IOException impossible) {\n    throw new AssertionError(impossible);\n  }\n  return result.toString();\n}",
        "summary_tokens": [
            "encodes",
            "the",
            "specified",
            "range",
            "of",
            "the",
            "specified",
            "byte",
            "array",
            "and",
            "returns",
            "the",
            "encoded",
            "string"
        ]
    },
    {
        "id": 1168,
        "code": "public final ByteSink encodingSink(CharSink encodedSink) {\n  checkNotNull(encodedSink);\n  return new ByteSink() {\n    @Override\n    public OutputStream openStream() throws IOException {\n      return encodingStream(encodedSink.openStream());\n    }\n  };\n}",
        "summary_tokens": [
            "returns",
            "a",
            "byte",
            "sink",
            "that",
            "writes",
            "base",
            "encoded",
            "bytes",
            "to",
            "the",
            "specified",
            "char",
            "sink"
        ]
    },
    {
        "id": 1169,
        "code": "public final byte[] decode(CharSequence chars) {\n  try {\n    return decodeChecked(chars);\n  } catch (DecodingException badInput) {\n    throw new IllegalArgumentException(badInput);\n  }\n}",
        "summary_tokens": [
            "decodes",
            "the",
            "specified",
            "character",
            "sequence",
            "and",
            "returns",
            "the",
            "resulting",
            "byte"
        ]
    },
    {
        "id": 1170,
        "code": "final byte[] decodeChecked(CharSequence chars)\n    throws DecodingException {\n  chars = trimTrailingPadding(chars);\n  byte[] tmp = new byte[maxDecodedSize(chars.length())];\n  int len = decodeTo(tmp, chars);\n  return extract(tmp, len);\n}",
        "summary_tokens": [
            "decodes",
            "the",
            "specified",
            "character",
            "sequence",
            "and",
            "returns",
            "the",
            "resulting",
            "byte"
        ]
    },
    {
        "id": 1171,
        "code": "public final ByteSource decodingSource(CharSource encodedSource) {\n  checkNotNull(encodedSource);\n  return new ByteSource() {\n    @Override\n    public InputStream openStream() throws IOException {\n      return decodingStream(encodedSource.openStream());\n    }\n  };\n}",
        "summary_tokens": [
            "returns",
            "a",
            "byte",
            "source",
            "that",
            "reads",
            "base",
            "encoded",
            "bytes",
            "from",
            "the",
            "specified",
            "char",
            "source"
        ]
    },
    {
        "id": 1172,
        "code": "public static BaseEncoding base64() {\n  return BASE64;\n}",
        "summary_tokens": [
            "the",
            "base",
            "0",
            "base",
            "encoding",
            "specified",
            "by",
            "a",
            "href",
            "http",
            "tools"
        ]
    },
    {
        "id": 1173,
        "code": "public static BaseEncoding base64Url() {\n  return BASE64_URL;\n}",
        "summary_tokens": [
            "the",
            "base",
            "0",
            "url",
            "encoding",
            "specified",
            "by",
            "a",
            "href",
            "http",
            "tools"
        ]
    },
    {
        "id": 1174,
        "code": "public static BaseEncoding base32() {\n  return BASE32;\n}",
        "summary_tokens": [
            "the",
            "base",
            "0",
            "encoding",
            "specified",
            "by",
            "a",
            "href",
            "http",
            "tools"
        ]
    },
    {
        "id": 1175,
        "code": "public static BaseEncoding base32Hex() {\n  return BASE32_HEX;\n}",
        "summary_tokens": [
            "the",
            "base",
            "0",
            "hex",
            "encoding",
            "specified",
            "by",
            "a",
            "href",
            "http",
            "tools"
        ]
    },
    {
        "id": 1176,
        "code": "public static BaseEncoding base16() {\n  return BASE16;\n}",
        "summary_tokens": [
            "the",
            "base",
            "0",
            "encoding",
            "specified",
            "by",
            "a",
            "href",
            "http",
            "tools"
        ]
    },
    {
        "id": 1177,
        "code": "public CharSink asCharSink(Charset charset) {\n  return new AsCharSink(charset);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "char",
            "sink",
            "view",
            "of",
            "this",
            "byte",
            "sink",
            "that",
            "writes",
            "characters",
            "to",
            "this",
            "sink",
            "as",
            "bytes",
            "encoded",
            "with",
            "the",
            "given",
            "charset",
            "charset"
        ]
    },
    {
        "id": 1178,
        "code": "public OutputStream openBufferedStream() throws IOException {\n  OutputStream out = openStream();\n  return (out instanceof BufferedOutputStream)\n      ? (BufferedOutputStream) out\n      : new BufferedOutputStream(out);\n}",
        "summary_tokens": [
            "opens",
            "a",
            "new",
            "buffered",
            "output",
            "stream",
            "for",
            "writing",
            "to",
            "this",
            "sink"
        ]
    },
    {
        "id": 1179,
        "code": "public void write(byte[] bytes) throws IOException {\n  checkNotNull(bytes);\n\n  Closer closer = Closer.create();\n  try {\n    OutputStream out = closer.register(openStream());\n    out.write(bytes);\n    out.flush(); \n  } catch (Throwable e) {\n    throw closer.rethrow(e);\n  } finally {\n    closer.close();\n  }\n}",
        "summary_tokens": [
            "writes",
            "all",
            "the",
            "given",
            "bytes",
            "to",
            "this",
            "sink"
        ]
    },
    {
        "id": 1180,
        "code": "public long writeFrom(InputStream input) throws IOException {\n  checkNotNull(input);\n\n  Closer closer = Closer.create();\n  try {\n    OutputStream out = closer.register(openStream());\n    long written = ByteStreams.copy(input, out);\n    out.flush(); \n    return written;\n  } catch (Throwable e) {\n    throw closer.rethrow(e);\n  } finally {\n    closer.close();\n  }\n}",
        "summary_tokens": [
            "writes",
            "all",
            "the",
            "bytes",
            "from",
            "the",
            "given",
            "input",
            "stream",
            "to",
            "this",
            "sink"
        ]
    },
    {
        "id": 1181,
        "code": "public Writer openBufferedStream() throws IOException {\n  Writer writer = openStream();\n  return (writer instanceof BufferedWriter)\n      ? (BufferedWriter) writer\n      : new BufferedWriter(writer);\n}",
        "summary_tokens": [
            "opens",
            "a",
            "new",
            "buffered",
            "writer",
            "for",
            "writing",
            "to",
            "this",
            "sink"
        ]
    },
    {
        "id": 1182,
        "code": "public void write(CharSequence charSequence) throws IOException {\n  checkNotNull(charSequence);\n\n  Closer closer = Closer.create();\n  try {\n    Writer out = closer.register(openStream());\n    out.append(charSequence);\n    out.flush(); \n  } catch (Throwable e) {\n    throw closer.rethrow(e);\n  } finally {\n    closer.close();\n  }\n}",
        "summary_tokens": [
            "writes",
            "the",
            "given",
            "character",
            "sequence",
            "to",
            "this",
            "sink"
        ]
    },
    {
        "id": 1183,
        "code": "public void writeLines(Stream<? extends CharSequence> lines, String lineSeparator)\n    throws IOException {\n  writeLines(lines.iterator(), lineSeparator);\n}",
        "summary_tokens": [
            "writes",
            "the",
            "given",
            "lines",
            "of",
            "text",
            "to",
            "this",
            "sink",
            "with",
            "each",
            "line",
            "including",
            "the",
            "last",
            "terminated",
            "with",
            "the",
            "given",
            "line",
            "separator"
        ]
    },
    {
        "id": 1184,
        "code": "public long writeFrom(Readable readable) throws IOException {\n  checkNotNull(readable);\n\n  Closer closer = Closer.create();\n  try {\n    Writer out = closer.register(openStream());\n    long written = CharStreams.copy(readable, out);\n    out.flush(); \n    return written;\n  } catch (Throwable e) {\n    throw closer.rethrow(e);\n  } finally {\n    closer.close();\n  }\n}",
        "summary_tokens": [
            "writes",
            "all",
            "the",
            "text",
            "from",
            "the",
            "given",
            "readable",
            "such",
            "as",
            "a",
            "reader",
            "to",
            "this",
            "sink"
        ]
    },
    {
        "id": 1185,
        "code": "public static void close(@CheckForNull Closeable closeable, boolean swallowIOException)\n    throws IOException {\n  if (closeable == null) {\n    return;\n  }\n  try {\n    closeable.close();\n  } catch (IOException e) {\n    if (swallowIOException) {\n      logger.log(Level.WARNING, \"IOException thrown while closing Closeable.\", e);\n    } else {\n      throw e;\n    }\n  }\n}",
        "summary_tokens": [
            "closes",
            "a",
            "closeable",
            "with",
            "control",
            "over",
            "whether",
            "an",
            "ioexception",
            "may",
            "be",
            "thrown"
        ]
    },
    {
        "id": 1186,
        "code": "public static void closeQuietly(@CheckForNull Reader reader) {\n  try {\n    close(reader, true);\n  } catch (IOException impossible) {\n    throw new AssertionError(impossible);\n  }\n}",
        "summary_tokens": [
            "closes",
            "the",
            "given",
            "reader",
            "logging",
            "any",
            "ioexception",
            "that",
            "s",
            "thrown",
            "rather",
            "than",
            "propagating",
            "it"
        ]
    },
    {
        "id": 1187,
        "code": "public long getCount() {\n  return count;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "bytes",
            "read"
        ]
    },
    {
        "id": 1188,
        "code": "public long getCount() {\n  return count;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "bytes",
            "written"
        ]
    },
    {
        "id": 1189,
        "code": "synchronized File getFile() {\n  return file;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "file",
            "holding",
            "the",
            "data",
            "possibly",
            "null"
        ]
    },
    {
        "id": 1190,
        "code": "public ByteSource asByteSource() {\n  return source;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "readable",
            "byte",
            "source",
            "view",
            "of",
            "the",
            "data",
            "that",
            "has",
            "been",
            "written",
            "to",
            "this",
            "stream"
        ]
    },
    {
        "id": 1191,
        "code": "public synchronized void reset() throws IOException {\n  try {\n    close();\n  } finally {\n    if (memory == null) {\n      memory = new MemoryOutput();\n    } else {\n      memory.reset();\n    }\n    out = memory;\n    if (file != null) {\n      File deleteMe = file;\n      file = null;\n      if (!deleteMe.delete()) {\n        throw new IOException(\"Could not delete: \" + deleteMe);\n      }\n    }\n  }\n}",
        "summary_tokens": [
            "calls",
            "close",
            "if",
            "not",
            "already",
            "closed",
            "and",
            "then",
            "resets",
            "this",
            "object",
            "back",
            "to",
            "its",
            "initial",
            "state",
            "for",
            "reuse"
        ]
    },
    {
        "id": 1192,
        "code": "private void update(int len) throws IOException {\n  if (memory != null && (memory.getCount() + len > fileThreshold)) {\n    File temp = File.createTempFile(\"FileBackedOutputStream\", null, parentDirectory);\n    if (resetOnFinalize) {\n        \n        \n      temp.deleteOnExit();\n    }\n    try {\n      FileOutputStream transfer = new FileOutputStream(temp);\n      transfer.write(memory.getBuffer(), 0, memory.getCount());\n      transfer.flush();\n        \n      out = transfer;\n    } catch (IOException e) {\n      temp.delete();\n      throw e;\n    }\n\n    file = temp;\n    memory = null;\n  }\n}",
        "summary_tokens": [
            "checks",
            "if",
            "writing",
            "len",
            "bytes",
            "would",
            "go",
            "over",
            "threshold",
            "and",
            "switches",
            "to",
            "file",
            "buffering",
            "if",
            "so"
        ]
    },
    {
        "id": 1193,
        "code": "public static void flush(Flushable flushable, boolean swallowIOException) throws IOException {\n  try {\n    flushable.flush();\n  } catch (IOException e) {\n    if (swallowIOException) {\n      logger.log(Level.WARNING, \"IOException thrown while flushing Flushable.\", e);\n    } else {\n      throw e;\n    }\n  }\n}",
        "summary_tokens": [
            "flush",
            "a",
            "flushable",
            "with",
            "control",
            "over",
            "whether",
            "an",
            "ioexception",
            "may",
            "be",
            "thrown"
        ]
    },
    {
        "id": 1194,
        "code": "public static void flushQuietly(Flushable flushable) {\n  try {\n    flush(flushable, true);\n  } catch (IOException e) {\n    logger.log(Level.SEVERE, \"IOException should not have been thrown.\", e);\n  }\n}",
        "summary_tokens": [
            "equivalent",
            "to",
            "calling",
            "flush",
            "flushable",
            "true",
            "but",
            "with",
            "no",
            "ioexception",
            "in",
            "the",
            "signature"
        ]
    },
    {
        "id": 1195,
        "code": "protected void add(char[] cbuf, int off, int len) throws IOException {\n  int pos = off;\n  if (sawReturn && len > 0) {\n      \n    if (finishLine(cbuf[pos] == '\\n')) {\n      pos++;\n    }\n  }\n\n  int start = pos;\n  for (int end = off + len; pos < end; pos++) {\n    switch (cbuf[pos]) {\n      case '\\r':\n        line.append(cbuf, start, pos - start);\n        sawReturn = true;\n        if (pos + 1 < end) {\n          if (finishLine(cbuf[pos + 1] == '\\n')) {\n            pos++;\n          }\n        }\n        start = pos + 1;\n        break;\n\n      case '\\n':\n        line.append(cbuf, start, pos - start);\n        finishLine(true);\n        start = pos + 1;\n        break;\n\n      default:\n          \n    }\n  }\n  line.append(cbuf, start, off + len - start);\n}",
        "summary_tokens": [
            "process",
            "additional",
            "characters",
            "from",
            "the",
            "stream"
        ]
    },
    {
        "id": 1196,
        "code": "private boolean finishLine(boolean sawNewline) throws IOException {\n  String separator = sawReturn ? (sawNewline ? \"\\r\\n\" : \"\\r\") : (sawNewline ? \"\\n\" : \"\");\n  handleLine(line.toString(), separator);\n  line = new StringBuilder();\n  sawReturn = false;\n  return sawNewline;\n}",
        "summary_tokens": [
            "called",
            "when",
            "a",
            "line",
            "is",
            "complete"
        ]
    },
    {
        "id": 1197,
        "code": "protected void finish() throws IOException {\n  if (sawReturn || line.length() > 0) {\n    finishLine(false);\n  }\n}",
        "summary_tokens": [
            "subclasses",
            "must",
            "call",
            "this",
            "method",
            "after",
            "finishing",
            "character",
            "processing",
            "in",
            "order",
            "to",
            "ensure",
            "that",
            "any",
            "unterminated",
            "line",
            "in",
            "the",
            "buffer",
            "is",
            "passed",
            "to",
            "handle",
            "line"
        ]
    },
    {
        "id": 1198,
        "code": "public String readLine() throws IOException {\n  while (lines.peek() == null) {\n    Java8Compatibility.clear(cbuf);\n      \n      \n    int read = (reader != null) ? reader.read(buf, 0, buf.length) : readable.read(cbuf);\n    if (read == -1) {\n      lineBuf.finish();\n      break;\n    }\n    lineBuf.add(buf, 0, read);\n  }\n  return lines.poll();\n}",
        "summary_tokens": [
            "reads",
            "a",
            "line",
            "of",
            "text"
        ]
    },
    {
        "id": 1199,
        "code": "public String readLine() {\n  throw new UnsupportedOperationException(\"readLine is not supported\");\n}",
        "summary_tokens": [
            "this",
            "method",
            "will",
            "throw",
            "an",
            "unsupported",
            "operation",
            "exception"
        ]
    },
    {
        "id": 1200,
        "code": "public int readUnsignedShort() throws IOException {\n  byte b1 = readAndCheckByte();\n  byte b2 = readAndCheckByte();\n\n  return Ints.fromBytes((byte) 0, (byte) 0, b2, b1);\n}",
        "summary_tokens": [
            "reads",
            "an",
            "unsigned",
            "short",
            "as",
            "specified",
            "by",
            "data",
            "input",
            "stream",
            "read",
            "unsigned",
            "short",
            "except",
            "using",
            "little",
            "endian",
            "byte",
            "order"
        ]
    },
    {
        "id": 1201,
        "code": "public int readInt() throws IOException {\n  byte b1 = readAndCheckByte();\n  byte b2 = readAndCheckByte();\n  byte b3 = readAndCheckByte();\n  byte b4 = readAndCheckByte();\n\n  return Ints.fromBytes(b4, b3, b2, b1);\n}",
        "summary_tokens": [
            "reads",
            "an",
            "integer",
            "as",
            "specified",
            "by",
            "data",
            "input",
            "stream",
            "read",
            "int",
            "except",
            "using",
            "little",
            "endian",
            "byte",
            "order"
        ]
    },
    {
        "id": 1202,
        "code": "public long readLong() throws IOException {\n  byte b1 = readAndCheckByte();\n  byte b2 = readAndCheckByte();\n  byte b3 = readAndCheckByte();\n  byte b4 = readAndCheckByte();\n  byte b5 = readAndCheckByte();\n  byte b6 = readAndCheckByte();\n  byte b7 = readAndCheckByte();\n  byte b8 = readAndCheckByte();\n\n  return Longs.fromBytes(b8, b7, b6, b5, b4, b3, b2, b1);\n}",
        "summary_tokens": [
            "reads",
            "a",
            "long",
            "as",
            "specified",
            "by",
            "data",
            "input",
            "stream",
            "read",
            "long",
            "except",
            "using",
            "little",
            "endian",
            "byte",
            "order"
        ]
    },
    {
        "id": 1203,
        "code": "public float readFloat() throws IOException {\n  return Float.intBitsToFloat(readInt());\n}",
        "summary_tokens": [
            "reads",
            "a",
            "float",
            "as",
            "specified",
            "by",
            "data",
            "input",
            "stream",
            "read",
            "float",
            "except",
            "using",
            "little",
            "endian",
            "byte",
            "order"
        ]
    },
    {
        "id": 1204,
        "code": "public double readDouble() throws IOException {\n  return Double.longBitsToDouble(readLong());\n}",
        "summary_tokens": [
            "reads",
            "a",
            "double",
            "as",
            "specified",
            "by",
            "data",
            "input",
            "stream",
            "read",
            "double",
            "except",
            "using",
            "little",
            "endian",
            "byte",
            "order"
        ]
    },
    {
        "id": 1205,
        "code": "public short readShort() throws IOException {\n  return (short) readUnsignedShort();\n}",
        "summary_tokens": [
            "reads",
            "a",
            "short",
            "as",
            "specified",
            "by",
            "data",
            "input",
            "stream",
            "read",
            "short",
            "except",
            "using",
            "little",
            "endian",
            "byte",
            "order"
        ]
    },
    {
        "id": 1206,
        "code": "public char readChar() throws IOException {\n  return (char) readUnsignedShort();\n}",
        "summary_tokens": [
            "reads",
            "a",
            "char",
            "as",
            "specified",
            "by",
            "data",
            "input",
            "stream",
            "read",
            "char",
            "except",
            "using",
            "little",
            "endian",
            "byte",
            "order"
        ]
    },
    {
        "id": 1207,
        "code": "private byte readAndCheckByte() throws IOException, EOFException {\n  int b1 = in.read();\n\n  if (-1 == b1) {\n    throw new EOFException();\n  }\n\n  return (byte) b1;\n}",
        "summary_tokens": [
            "reads",
            "a",
            "byte",
            "from",
            "the",
            "input",
            "stream",
            "checking",
            "that",
            "the",
            "end",
            "of",
            "file",
            "eof",
            "has",
            "not",
            "been",
            "encountered"
        ]
    },
    {
        "id": 1208,
        "code": "public void writeBytes(String s) throws IOException {\n  ((DataOutputStream) out).writeBytes(s);\n}",
        "summary_tokens": [
            "the",
            "semantics",
            "of",
            "write",
            "bytes",
            "string",
            "s",
            "are",
            "considered",
            "dangerous"
        ]
    },
    {
        "id": 1209,
        "code": "public void writeChar(int v) throws IOException {\n  writeShort(v);\n}",
        "summary_tokens": [
            "writes",
            "a",
            "char",
            "as",
            "specified",
            "by",
            "data",
            "output",
            "stream",
            "write",
            "char",
            "int",
            "except",
            "using",
            "little",
            "endian",
            "byte",
            "order"
        ]
    },
    {
        "id": 1210,
        "code": "public void writeChars(String s) throws IOException {\n  for (int i = 0; i < s.length(); i++) {\n    writeChar(s.charAt(i));\n  }\n}",
        "summary_tokens": [
            "writes",
            "a",
            "string",
            "as",
            "specified",
            "by",
            "data",
            "output",
            "stream",
            "write",
            "chars",
            "string",
            "except",
            "each",
            "character",
            "is",
            "written",
            "using",
            "little",
            "endian",
            "byte",
            "order"
        ]
    },
    {
        "id": 1211,
        "code": "public void writeDouble(double v) throws IOException {\n  writeLong(Double.doubleToLongBits(v));\n}",
        "summary_tokens": [
            "writes",
            "a",
            "double",
            "as",
            "specified",
            "by",
            "data",
            "output",
            "stream",
            "write",
            "double",
            "double",
            "except",
            "using",
            "little",
            "endian",
            "byte",
            "order"
        ]
    },
    {
        "id": 1212,
        "code": "public void writeFloat(float v) throws IOException {\n  writeInt(Float.floatToIntBits(v));\n}",
        "summary_tokens": [
            "writes",
            "a",
            "float",
            "as",
            "specified",
            "by",
            "data",
            "output",
            "stream",
            "write",
            "float",
            "float",
            "except",
            "using",
            "little",
            "endian",
            "byte",
            "order"
        ]
    },
    {
        "id": 1213,
        "code": "public void writeInt(int v) throws IOException {\n  out.write(0xFF & v);\n  out.write(0xFF & (v >> 8));\n  out.write(0xFF & (v >> 16));\n  out.write(0xFF & (v >> 24));\n}",
        "summary_tokens": [
            "writes",
            "an",
            "int",
            "as",
            "specified",
            "by",
            "data",
            "output",
            "stream",
            "write",
            "int",
            "int",
            "except",
            "using",
            "little",
            "endian",
            "byte",
            "order"
        ]
    },
    {
        "id": 1214,
        "code": "public void writeLong(long v) throws IOException {\n  byte[] bytes = Longs.toByteArray(Long.reverseBytes(v));\n  write(bytes, 0, bytes.length);\n}",
        "summary_tokens": [
            "writes",
            "a",
            "long",
            "as",
            "specified",
            "by",
            "data",
            "output",
            "stream",
            "write",
            "long",
            "long",
            "except",
            "using",
            "little",
            "endian",
            "byte",
            "order"
        ]
    },
    {
        "id": 1215,
        "code": "public void writeShort(int v) throws IOException {\n  out.write(0xFF & v);\n  out.write(0xFF & (v >> 8));\n}",
        "summary_tokens": [
            "writes",
            "a",
            "short",
            "as",
            "specified",
            "by",
            "data",
            "output",
            "stream",
            "write",
            "short",
            "int",
            "except",
            "using",
            "little",
            "endian",
            "byte",
            "order"
        ]
    },
    {
        "id": 1216,
        "code": "private void advance() throws IOException {\n  close();\n  if (it.hasNext()) {\n    in = it.next().openStream();\n  }\n}",
        "summary_tokens": [
            "closes",
            "the",
            "current",
            "input",
            "stream",
            "and",
            "opens",
            "the",
            "next",
            "one",
            "if",
            "any"
        ]
    },
    {
        "id": 1217,
        "code": "private void advance() throws IOException {\n  close();\n  if (it.hasNext()) {\n    current = it.next().openStream();\n  }\n}",
        "summary_tokens": [
            "closes",
            "the",
            "current",
            "reader",
            "and",
            "opens",
            "the",
            "next",
            "one",
            "if",
            "any"
        ]
    },
    {
        "id": 1218,
        "code": "private static CharBuffer grow(CharBuffer buf) {\n  char[] copy = Arrays.copyOf(buf.array(), buf.capacity() * 2);\n  CharBuffer bigger = CharBuffer.wrap(copy);\n  Java8Compatibility.position(bigger, buf.position());\n  Java8Compatibility.limit(bigger, buf.limit());\n  return bigger;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "char",
            "buffer",
            "identical",
            "to",
            "buf",
            "except",
            "twice",
            "the",
            "capacity"
        ]
    },
    {
        "id": 1219,
        "code": "private void readMoreChars() throws IOException {\n    \n    \n    \n    \n    \n    \n    \n\n  if (availableCapacity(charBuffer) == 0) {\n    if (charBuffer.position() > 0) {\n        \n      Java8Compatibility.flip(charBuffer.compact());\n    } else {\n        \n      charBuffer = grow(charBuffer);\n    }\n  }\n\n    \n  int limit = charBuffer.limit();\n  int numChars = reader.read(charBuffer.array(), limit, availableCapacity(charBuffer));\n  if (numChars == -1) {\n    endOfInput = true;\n  } else {\n    Java8Compatibility.limit(charBuffer, limit + numChars);\n  }\n}",
        "summary_tokens": [
            "handle",
            "the",
            "case",
            "of",
            "underflow",
            "caused",
            "by",
            "needing",
            "more",
            "input",
            "characters"
        ]
    },
    {
        "id": 1220,
        "code": "private static int availableCapacity(Buffer buffer) {\n  return buffer.capacity() - buffer.limit();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "elements",
            "between",
            "the",
            "limit",
            "and",
            "capacity"
        ]
    },
    {
        "id": 1221,
        "code": "private void startDraining(boolean overflow) {\n  Java8Compatibility.flip(byteBuffer);\n  if (overflow && byteBuffer.remaining() == 0) {\n    byteBuffer = ByteBuffer.allocate(byteBuffer.capacity() * 2);\n  } else {\n    draining = true;\n  }\n}",
        "summary_tokens": [
            "flips",
            "the",
            "buffer",
            "output",
            "buffer",
            "so",
            "we",
            "can",
            "start",
            "reading",
            "bytes",
            "from",
            "it"
        ]
    },
    {
        "id": 1222,
        "code": "private int drain(byte[] b, int off, int len) {\n  int remaining = Math.min(len, byteBuffer.remaining());\n  byteBuffer.get(b, off, remaining);\n  return remaining;\n}",
        "summary_tokens": [
            "copy",
            "as",
            "much",
            "of",
            "the",
            "byte",
            "buffer",
            "into",
            "the",
            "output",
            "array",
            "as",
            "possible",
            "returning",
            "the",
            "positive",
            "number",
            "of",
            "characters",
            "copied"
        ]
    },
    {
        "id": 1223,
        "code": "public static double roundToDouble(BigDecimal x, RoundingMode mode) {\n  return BigDecimalToDoubleRounder.INSTANCE.roundToDouble(x, mode);\n}",
        "summary_tokens": [
            "returns",
            "x",
            "rounded",
            "to",
            "a",
            "double",
            "with",
            "the",
            "specified",
            "rounding",
            "mode"
        ]
    },
    {
        "id": 1224,
        "code": "public static BigInteger ceilingPowerOfTwo(BigInteger x) {\n  return BigInteger.ZERO.setBit(log2(x, CEILING));\n}",
        "summary_tokens": [
            "returns",
            "the",
            "smallest",
            "power",
            "of",
            "two",
            "greater",
            "than",
            "or",
            "equal",
            "to",
            "x"
        ]
    },
    {
        "id": 1225,
        "code": "public static BigInteger floorPowerOfTwo(BigInteger x) {\n  return BigInteger.ZERO.setBit(log2(x, FLOOR));\n}",
        "summary_tokens": [
            "returns",
            "the",
            "largest",
            "power",
            "of",
            "two",
            "less",
            "than",
            "or",
            "equal",
            "to",
            "x"
        ]
    },
    {
        "id": 1226,
        "code": "public static boolean isPowerOfTwo(BigInteger x) {\n  checkNotNull(x);\n  return x.signum() > 0 && x.getLowestSetBit() == x.bitLength() - 1;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "x",
            "represents",
            "a",
            "power",
            "of",
            "two"
        ]
    },
    {
        "id": 1227,
        "code": "public static int log2(BigInteger x, RoundingMode mode) {\n  checkPositive(\"x\", checkNotNull(x));\n  int logFloor = x.bitLength() - 1;\n  switch (mode) {\n    case UNNECESSARY:\n      checkRoundingUnnecessary(isPowerOfTwo(x)); \n    case DOWN:\n    case FLOOR:\n      return logFloor;\n\n    case UP:\n    case CEILING:\n      return isPowerOfTwo(x) ? logFloor : logFloor + 1;\n\n    case HALF_DOWN:\n    case HALF_UP:\n    case HALF_EVEN:\n      if (logFloor < SQRT2_PRECOMPUTE_THRESHOLD) {\n        BigInteger halfPower =\n            SQRT2_PRECOMPUTED_BITS.shiftRight(SQRT2_PRECOMPUTE_THRESHOLD - logFloor);\n        if (x.compareTo(halfPower) <= 0) {\n          return logFloor;\n        } else {\n          return logFloor + 1;\n        }\n      }\n        \n        \n        \n        \n      BigInteger x2 = x.pow(2);\n      int logX2Floor = x2.bitLength() - 1;\n      return (logX2Floor < 2 * logFloor + 1) ? logFloor : logFloor + 1;\n\n    default:\n      throw new AssertionError();\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "base",
            "0",
            "logarithm",
            "of",
            "x",
            "rounded",
            "according",
            "to",
            "the",
            "specified",
            "rounding",
            "mode"
        ]
    },
    {
        "id": 1228,
        "code": "public static int log10(BigInteger x, RoundingMode mode) {\n  checkPositive(\"x\", x);\n  if (fitsInLong(x)) {\n    return LongMath.log10(x.longValue(), mode);\n  }\n\n  int approxLog10 = (int) (log2(x, FLOOR) * LN_2 / LN_10);\n  BigInteger approxPow = BigInteger.TEN.pow(approxLog10);\n  int approxCmp = approxPow.compareTo(x);\n\n    \n\n  if (approxCmp > 0) {\n      \n    do {\n      approxLog10--;\n      approxPow = approxPow.divide(BigInteger.TEN);\n      approxCmp = approxPow.compareTo(x);\n    } while (approxCmp > 0);\n  } else {\n    BigInteger nextPow = BigInteger.TEN.multiply(approxPow);\n    int nextCmp = nextPow.compareTo(x);\n    while (nextCmp <= 0) {\n      approxLog10++;\n      approxPow = nextPow;\n      approxCmp = nextCmp;\n      nextPow = BigInteger.TEN.multiply(approxPow);\n      nextCmp = nextPow.compareTo(x);\n    }\n  }\n\n  int floorLog = approxLog10;\n  BigInteger floorPow = approxPow;\n  int floorCmp = approxCmp;\n\n  switch (mode) {\n    case UNNECESSARY:\n      checkRoundingUnnecessary(floorCmp == 0);\n        \n    case FLOOR:\n    case DOWN:\n      return floorLog;\n\n    case CEILING:\n    case UP:\n      return floorPow.equals(x) ? floorLog : floorLog + 1;\n\n    case HALF_DOWN:\n    case HALF_UP:\n    case HALF_EVEN:\n        \n      BigInteger x2 = x.pow(2);\n      BigInteger halfPowerSquared = floorPow.pow(2).multiply(BigInteger.TEN);\n      return (x2.compareTo(halfPowerSquared) <= 0) ? floorLog : floorLog + 1;\n    default:\n      throw new AssertionError();\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "base",
            "0",
            "logarithm",
            "of",
            "x",
            "rounded",
            "according",
            "to",
            "the",
            "specified",
            "rounding",
            "mode"
        ]
    },
    {
        "id": 1229,
        "code": "public static BigInteger sqrt(BigInteger x, RoundingMode mode) {\n  checkNonNegative(\"x\", x);\n  if (fitsInLong(x)) {\n    return BigInteger.valueOf(LongMath.sqrt(x.longValue(), mode));\n  }\n  BigInteger sqrtFloor = sqrtFloor(x);\n  switch (mode) {\n    case UNNECESSARY:\n      checkRoundingUnnecessary(sqrtFloor.pow(2).equals(x)); \n    case FLOOR:\n    case DOWN:\n      return sqrtFloor;\n    case CEILING:\n    case UP:\n      int sqrtFloorInt = sqrtFloor.intValue();\n      boolean sqrtFloorIsExact =\n          (sqrtFloorInt * sqrtFloorInt == x.intValue()) \n              && sqrtFloor.pow(2).equals(x); \n      return sqrtFloorIsExact ? sqrtFloor : sqrtFloor.add(BigInteger.ONE);\n    case HALF_DOWN:\n    case HALF_UP:\n    case HALF_EVEN:\n      BigInteger halfSquare = sqrtFloor.pow(2).add(sqrtFloor);\n        \n      return (halfSquare.compareTo(x) >= 0) ? sqrtFloor : sqrtFloor.add(BigInteger.ONE);\n    default:\n      throw new AssertionError();\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "square",
            "root",
            "of",
            "x",
            "rounded",
            "with",
            "the",
            "specified",
            "rounding",
            "mode"
        ]
    },
    {
        "id": 1230,
        "code": "public static double roundToDouble(BigInteger x, RoundingMode mode) {\n  return BigIntegerToDoubleRounder.INSTANCE.roundToDouble(x, mode);\n}",
        "summary_tokens": [
            "returns",
            "x",
            "rounded",
            "to",
            "a",
            "double",
            "with",
            "the",
            "specified",
            "rounding",
            "mode"
        ]
    },
    {
        "id": 1231,
        "code": "public static BigInteger divide(BigInteger p, BigInteger q, RoundingMode mode) {\n  BigDecimal pDec = new BigDecimal(p);\n  BigDecimal qDec = new BigDecimal(q);\n  return pDec.divide(qDec, 0, mode).toBigIntegerExact();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "result",
            "of",
            "dividing",
            "p",
            "by",
            "q",
            "rounding",
            "using",
            "the",
            "specified",
            "rounding",
            "mode"
        ]
    },
    {
        "id": 1232,
        "code": "public static BigInteger factorial(int n) {\n  checkNonNegative(\"n\", n);\n\n    \n  if (n < LongMath.factorials.length) {\n    return BigInteger.valueOf(LongMath.factorials[n]);\n  }\n\n    \n  int approxSize = IntMath.divide(n * IntMath.log2(n, CEILING), Long.SIZE, CEILING);\n  ArrayList<BigInteger> bignums = new ArrayList<>(approxSize);\n\n    \n  int startingNumber = LongMath.factorials.length;\n  long product = LongMath.factorials[startingNumber - 1];\n    \n  int shift = Long.numberOfTrailingZeros(product);\n  product >>= shift;\n\n    \n  int productBits = LongMath.log2(product, FLOOR) + 1;\n  int bits = LongMath.log2(startingNumber, FLOOR) + 1;\n    \n  int nextPowerOfTwo = 1 << (bits - 1);\n\n    \n  for (long num = startingNumber; num <= n; num++) {\n      \n    if ((num & nextPowerOfTwo) != 0) {\n      nextPowerOfTwo <<= 1;\n      bits++;\n    }\n      \n    int tz = Long.numberOfTrailingZeros(num);\n    long normalizedNum = num >> tz;\n    shift += tz;\n      \n    int normalizedBits = bits - tz;\n      \n    if (normalizedBits + productBits >= Long.SIZE) {\n      bignums.add(BigInteger.valueOf(product));\n      product = 1;\n      productBits = 0;\n    }\n    product *= normalizedNum;\n    productBits = LongMath.log2(product, FLOOR) + 1;\n  }\n    \n  if (product > 1) {\n    bignums.add(BigInteger.valueOf(product));\n  }\n    \n  return listProduct(bignums).shiftLeft(shift);\n}",
        "summary_tokens": [
            "returns",
            "n",
            "that",
            "is",
            "the",
            "product",
            "of",
            "the",
            "first",
            "n",
            "positive",
            "integers",
            "or",
            "0",
            "if",
            "n",
            "0"
        ]
    },
    {
        "id": 1233,
        "code": "public static BigInteger binomial(int n, int k) {\n  checkNonNegative(\"n\", n);\n  checkNonNegative(\"k\", k);\n  checkArgument(k <= n, \"k (%s) > n (%s)\", k, n);\n  if (k > (n >> 1)) {\n    k = n - k;\n  }\n  if (k < LongMath.biggestBinomials.length && n <= LongMath.biggestBinomials[k]) {\n    return BigInteger.valueOf(LongMath.binomial(n, k));\n  }\n\n  BigInteger accum = BigInteger.ONE;\n\n  long numeratorAccum = n;\n  long denominatorAccum = 1;\n\n  int bits = LongMath.log2(n, CEILING);\n\n  int numeratorBits = bits;\n\n  for (int i = 1; i < k; i++) {\n    int p = n - i;\n    int q = i + 1;\n\n      \n\n    if (numeratorBits + bits >= Long.SIZE - 1) {\n        \n        \n      accum =\n          accum\n              .multiply(BigInteger.valueOf(numeratorAccum))\n              .divide(BigInteger.valueOf(denominatorAccum));\n      numeratorAccum = p;\n      denominatorAccum = q;\n      numeratorBits = bits;\n    } else {\n        \n      numeratorAccum *= p;\n      denominatorAccum *= q;\n      numeratorBits += bits;\n    }\n  }\n  return accum\n      .multiply(BigInteger.valueOf(numeratorAccum))\n      .divide(BigInteger.valueOf(denominatorAccum));\n}",
        "summary_tokens": [
            "returns",
            "n",
            "choose",
            "k",
            "also",
            "known",
            "as",
            "the",
            "binomial",
            "coefficient",
            "of",
            "n",
            "and",
            "k",
            "that",
            "is",
            "n",
            "k",
            "n",
            "k"
        ]
    },
    {
        "id": 1234,
        "code": "public static int roundToInt(double x, RoundingMode mode) {\n  double z = roundIntermediate(x, mode);\n  checkInRangeForRoundingInputs(\n      z > MIN_INT_AS_DOUBLE - 1.0 & z < MAX_INT_AS_DOUBLE + 1.0, x, mode);\n  return (int) z;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "int",
            "value",
            "that",
            "is",
            "equal",
            "to",
            "x",
            "rounded",
            "with",
            "the",
            "specified",
            "rounding",
            "mode",
            "if",
            "possible"
        ]
    },
    {
        "id": 1235,
        "code": "public static long roundToLong(double x, RoundingMode mode) {\n  double z = roundIntermediate(x, mode);\n  checkInRangeForRoundingInputs(\n      MIN_LONG_AS_DOUBLE - z < 1.0 & z < MAX_LONG_AS_DOUBLE_PLUS_ONE, x, mode);\n  return (long) z;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "long",
            "value",
            "that",
            "is",
            "equal",
            "to",
            "x",
            "rounded",
            "with",
            "the",
            "specified",
            "rounding",
            "mode",
            "if",
            "possible"
        ]
    },
    {
        "id": 1236,
        "code": "public static BigInteger roundToBigInteger(double x, RoundingMode mode) {\n  x = roundIntermediate(x, mode);\n  if (MIN_LONG_AS_DOUBLE - x < 1.0 & x < MAX_LONG_AS_DOUBLE_PLUS_ONE) {\n    return BigInteger.valueOf((long) x);\n  }\n  int exponent = getExponent(x);\n  long significand = getSignificand(x);\n  BigInteger result = BigInteger.valueOf(significand).shiftLeft(exponent - SIGNIFICAND_BITS);\n  return (x < 0) ? result.negate() : result;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "big",
            "integer",
            "value",
            "that",
            "is",
            "equal",
            "to",
            "x",
            "rounded",
            "with",
            "the",
            "specified",
            "rounding",
            "mode",
            "if",
            "possible"
        ]
    },
    {
        "id": 1237,
        "code": "public static boolean isPowerOfTwo(double x) {\n  if (x > 0.0 && isFinite(x)) {\n    long significand = getSignificand(x);\n    return (significand & (significand - 1)) == 0;\n  }\n  return false;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "x",
            "is",
            "exactly",
            "equal",
            "to",
            "0",
            "k",
            "for",
            "some",
            "finite",
            "integer",
            "k"
        ]
    },
    {
        "id": 1238,
        "code": "public static int log2(double x, RoundingMode mode) {\n  checkArgument(x > 0.0 && isFinite(x), \"x must be positive and finite\");\n  int exponent = getExponent(x);\n  if (!isNormal(x)) {\n    return log2(x * IMPLICIT_BIT, mode) - SIGNIFICAND_BITS;\n      \n  }\n    \n  boolean increment;\n  switch (mode) {\n    case UNNECESSARY:\n      checkRoundingUnnecessary(isPowerOfTwo(x));\n        \n    case FLOOR:\n      increment = false;\n      break;\n    case CEILING:\n      increment = !isPowerOfTwo(x);\n      break;\n    case DOWN:\n      increment = exponent < 0 & !isPowerOfTwo(x);\n      break;\n    case UP:\n      increment = exponent >= 0 & !isPowerOfTwo(x);\n      break;\n    case HALF_DOWN:\n    case HALF_EVEN:\n    case HALF_UP:\n      double xScaled = scaleNormalize(x);\n        \n        \n      increment = (xScaled * xScaled) > 2.0;\n      break;\n    default:\n      throw new AssertionError();\n  }\n  return increment ? exponent + 1 : exponent;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "base",
            "0",
            "logarithm",
            "of",
            "a",
            "double",
            "value",
            "rounded",
            "with",
            "the",
            "specified",
            "rounding",
            "mode",
            "to",
            "an",
            "int"
        ]
    },
    {
        "id": 1239,
        "code": "public static boolean isMathematicalInteger(double x) {\n  return isFinite(x)\n      && (x == 0.0\n          || SIGNIFICAND_BITS - Long.numberOfTrailingZeros(getSignificand(x)) <= getExponent(x));\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "x",
            "represents",
            "a",
            "mathematical",
            "integer"
        ]
    },
    {
        "id": 1240,
        "code": "public static double factorial(int n) {\n  checkNonNegative(\"n\", n);\n  if (n > MAX_FACTORIAL) {\n    return Double.POSITIVE_INFINITY;\n  } else {\n      \n      \n    double accum = 1.0;\n    for (int i = 1 + (n & ~0xf); i <= n; i++) {\n      accum *= i;\n    }\n    return accum * everySixteenthFactorial[n >> 4];\n  }\n}",
        "summary_tokens": [
            "returns",
            "n",
            "that",
            "is",
            "the",
            "product",
            "of",
            "the",
            "first",
            "n",
            "positive",
            "integers",
            "0",
            "if",
            "n",
            "0",
            "or",
            "n",
            "or",
            "double",
            "positive",
            "infinity",
            "if",
            "n",
            "double"
        ]
    },
    {
        "id": 1241,
        "code": "public static boolean fuzzyEquals(double a, double b, double tolerance) {\n  MathPreconditions.checkNonNegative(\"tolerance\", tolerance);\n  return Math.copySign(a - b, 1.0) <= tolerance\n        \n      || (a == b) \n      || (Double.isNaN(a) && Double.isNaN(b));\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "a",
            "and",
            "b",
            "are",
            "within",
            "tolerance",
            "of",
            "each",
            "other"
        ]
    },
    {
        "id": 1242,
        "code": "public static int fuzzyCompare(double a, double b, double tolerance) {\n  if (fuzzyEquals(a, b, tolerance)) {\n    return 0;\n  } else if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else {\n    return Booleans.compare(Double.isNaN(a), Double.isNaN(b));\n  }\n}",
        "summary_tokens": [
            "compares",
            "a",
            "and",
            "b",
            "fuzzily",
            "with",
            "a",
            "tolerance",
            "for",
            "nearly",
            "equal",
            "values"
        ]
    },
    {
        "id": 1243,
        "code": "public static double mean(Iterator<? extends Number> values) {\n  checkArgument(values.hasNext(), \"Cannot take mean of 0 values\");\n  long count = 1;\n  double mean = checkFinite(values.next().doubleValue());\n  while (values.hasNext()) {\n    double value = checkFinite(values.next().doubleValue());\n    count++;\n      \n    mean += (value - mean) / count;\n  }\n  return mean;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "a",
            "href",
            "http",
            "en"
        ]
    },
    {
        "id": 1244,
        "code": "static double ensureNonNegative(double value) {\n  checkArgument(!isNaN(value));\n  return Math.max(value, 0.0);\n}",
        "summary_tokens": [
            "returns",
            "its",
            "argument",
            "if",
            "it",
            "is",
            "non",
            "negative",
            "zero",
            "if",
            "it",
            "is",
            "negative"
        ]
    },
    {
        "id": 1245,
        "code": "public static int ceilingPowerOfTwo(int x) {\n  checkPositive(\"x\", x);\n  if (x > MAX_SIGNED_POWER_OF_TWO) {\n    throw new ArithmeticException(\"ceilingPowerOfTwo(\" + x + \") not representable as an int\");\n  }\n  return 1 << -Integer.numberOfLeadingZeros(x - 1);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "smallest",
            "power",
            "of",
            "two",
            "greater",
            "than",
            "or",
            "equal",
            "to",
            "x"
        ]
    },
    {
        "id": 1246,
        "code": "public static int floorPowerOfTwo(int x) {\n  checkPositive(\"x\", x);\n  return Integer.highestOneBit(x);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "largest",
            "power",
            "of",
            "two",
            "less",
            "than",
            "or",
            "equal",
            "to",
            "x"
        ]
    },
    {
        "id": 1247,
        "code": "public static boolean isPowerOfTwo(int x) {\n  return x > 0 & (x & (x - 1)) == 0;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "x",
            "represents",
            "a",
            "power",
            "of",
            "two"
        ]
    },
    {
        "id": 1248,
        "code": "static int lessThanBranchFree(int x, int y) {\n    \n    \n  return ~~(x - y) >>> (Integer.SIZE - 1);\n}",
        "summary_tokens": [
            "returns",
            "0",
            "if",
            "x",
            "y",
            "as",
            "unsigned",
            "integers",
            "and",
            "0",
            "otherwise"
        ]
    },
    {
        "id": 1249,
        "code": "public static int log2(int x, RoundingMode mode) {\n  checkPositive(\"x\", x);\n  switch (mode) {\n    case UNNECESSARY:\n      checkRoundingUnnecessary(isPowerOfTwo(x));\n        \n    case DOWN:\n    case FLOOR:\n      return (Integer.SIZE - 1) - Integer.numberOfLeadingZeros(x);\n\n    case UP:\n    case CEILING:\n      return Integer.SIZE - Integer.numberOfLeadingZeros(x - 1);\n\n    case HALF_DOWN:\n    case HALF_UP:\n    case HALF_EVEN:\n        \n      int leadingZeros = Integer.numberOfLeadingZeros(x);\n      int cmp = MAX_POWER_OF_SQRT2_UNSIGNED >>> leadingZeros;\n        \n      int logFloor = (Integer.SIZE - 1) - leadingZeros;\n      return logFloor + lessThanBranchFree(cmp, x);\n\n    default:\n      throw new AssertionError();\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "base",
            "0",
            "logarithm",
            "of",
            "x",
            "rounded",
            "according",
            "to",
            "the",
            "specified",
            "rounding",
            "mode"
        ]
    },
    {
        "id": 1250,
        "code": "public static int log10(int x, RoundingMode mode) {\n  checkPositive(\"x\", x);\n  int logFloor = log10Floor(x);\n  int floorPow = powersOf10[logFloor];\n  switch (mode) {\n    case UNNECESSARY:\n      checkRoundingUnnecessary(x == floorPow);\n        \n    case FLOOR:\n    case DOWN:\n      return logFloor;\n    case CEILING:\n    case UP:\n      return logFloor + lessThanBranchFree(floorPow, x);\n    case HALF_DOWN:\n    case HALF_UP:\n    case HALF_EVEN:\n        \n      return logFloor + lessThanBranchFree(halfPowersOf10[logFloor], x);\n    default:\n      throw new AssertionError();\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "base",
            "0",
            "logarithm",
            "of",
            "x",
            "rounded",
            "according",
            "to",
            "the",
            "specified",
            "rounding",
            "mode"
        ]
    },
    {
        "id": 1251,
        "code": "public static int pow(int b, int k) {\n  checkNonNegative(\"exponent\", k);\n  switch (b) {\n    case 0:\n      return (k == 0) ? 1 : 0;\n    case 1:\n      return 1;\n    case (-1):\n      return ((k & 1) == 0) ? 1 : -1;\n    case 2:\n      return (k < Integer.SIZE) ? (1 << k) : 0;\n    case (-2):\n      if (k < Integer.SIZE) {\n        return ((k & 1) == 0) ? (1 << k) : -(1 << k);\n      } else {\n        return 0;\n      }\n    default:\n        \n  }\n  for (int accum = 1; ; k >>= 1) {\n    switch (k) {\n      case 0:\n        return accum;\n      case 1:\n        return b * accum;\n      default:\n        accum *= ((k & 1) == 0) ? 1 : b;\n        b *= b;\n    }\n  }\n}",
        "summary_tokens": [
            "returns",
            "b",
            "to",
            "the",
            "k",
            "th",
            "power"
        ]
    },
    {
        "id": 1252,
        "code": "public static int sqrt(int x, RoundingMode mode) {\n  checkNonNegative(\"x\", x);\n  int sqrtFloor = sqrtFloor(x);\n  switch (mode) {\n    case UNNECESSARY:\n      checkRoundingUnnecessary(sqrtFloor * sqrtFloor == x); \n    case FLOOR:\n    case DOWN:\n      return sqrtFloor;\n    case CEILING:\n    case UP:\n      return sqrtFloor + lessThanBranchFree(sqrtFloor * sqrtFloor, x);\n    case HALF_DOWN:\n    case HALF_UP:\n    case HALF_EVEN:\n      int halfSquare = sqrtFloor * sqrtFloor + sqrtFloor;\n        \n      return sqrtFloor + lessThanBranchFree(halfSquare, x);\n    default:\n      throw new AssertionError();\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "square",
            "root",
            "of",
            "x",
            "rounded",
            "with",
            "the",
            "specified",
            "rounding",
            "mode"
        ]
    },
    {
        "id": 1253,
        "code": "public static int divide(int p, int q, RoundingMode mode) {\n  checkNotNull(mode);\n  if (q == 0) {\n    throw new ArithmeticException(\"/ by zero\"); \n  }\n  int div = p / q;\n  int rem = p - q * div; \n\n  if (rem == 0) {\n    return div;\n  }\n\n    \n  int signum = 1 | ((p ^ q) >> (Integer.SIZE - 1));\n  boolean increment;\n  switch (mode) {\n    case UNNECESSARY:\n      checkRoundingUnnecessary(rem == 0);\n        \n    case DOWN:\n      increment = false;\n      break;\n    case UP:\n      increment = true;\n      break;\n    case CEILING:\n      increment = signum > 0;\n      break;\n    case FLOOR:\n      increment = signum < 0;\n      break;\n    case HALF_EVEN:\n    case HALF_DOWN:\n    case HALF_UP:\n      int absRem = abs(rem);\n      int cmpRemToHalfDivisor = absRem - (abs(q) - absRem);\n        \n        \n      if (cmpRemToHalfDivisor == 0) { \n        increment = (mode == HALF_UP || (mode == HALF_EVEN & (div & 1) != 0));\n      } else {\n        increment = cmpRemToHalfDivisor > 0; \n      }\n      break;\n    default:\n      throw new AssertionError();\n  }\n  return increment ? div + signum : div;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "result",
            "of",
            "dividing",
            "p",
            "by",
            "q",
            "rounding",
            "using",
            "the",
            "specified",
            "rounding",
            "mode"
        ]
    },
    {
        "id": 1254,
        "code": "public static int mod(int x, int m) {\n  if (m <= 0) {\n    throw new ArithmeticException(\"Modulus \" + m + \" must be > 0\");\n  }\n  int result = x % m;\n  return (result >= 0) ? result : result + m;\n}",
        "summary_tokens": [
            "returns",
            "x",
            "mod",
            "m",
            "a",
            "non",
            "negative",
            "value",
            "less",
            "than",
            "m"
        ]
    },
    {
        "id": 1255,
        "code": "public static int gcd(int a, int b) {\n    \n  checkNonNegative(\"a\", a);\n  checkNonNegative(\"b\", b);\n  if (a == 0) {\n      \n      \n    return b;\n  } else if (b == 0) {\n    return a; \n  }\n    \n  int aTwos = Integer.numberOfTrailingZeros(a);\n  a >>= aTwos; \n  int bTwos = Integer.numberOfTrailingZeros(b);\n  b >>= bTwos; \n  while (a != b) { \n      \n      \n      \n\n      \n      \n\n    int delta = a - b; \n\n    int minDeltaOrZero = delta & (delta >> (Integer.SIZE - 1));\n      \n\n    a = delta - minDeltaOrZero - minDeltaOrZero; \n      \n\n    b += minDeltaOrZero; \n    a >>= Integer.numberOfTrailingZeros(a); \n  }\n  return a << min(aTwos, bTwos);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "greatest",
            "common",
            "divisor",
            "of",
            "a",
            "b"
        ]
    },
    {
        "id": 1256,
        "code": "public static int checkedAdd(int a, int b) {\n  long result = (long) a + b;\n  checkNoOverflow(result == (int) result, \"checkedAdd\", a, b);\n  return (int) result;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "sum",
            "of",
            "a",
            "and",
            "b",
            "provided",
            "it",
            "does",
            "not",
            "overflow"
        ]
    },
    {
        "id": 1257,
        "code": "public static int checkedSubtract(int a, int b) {\n  long result = (long) a - b;\n  checkNoOverflow(result == (int) result, \"checkedSubtract\", a, b);\n  return (int) result;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "difference",
            "of",
            "a",
            "and",
            "b",
            "provided",
            "it",
            "does",
            "not",
            "overflow"
        ]
    },
    {
        "id": 1258,
        "code": "public static int checkedMultiply(int a, int b) {\n  long result = (long) a * b;\n  checkNoOverflow(result == (int) result, \"checkedMultiply\", a, b);\n  return (int) result;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "product",
            "of",
            "a",
            "and",
            "b",
            "provided",
            "it",
            "does",
            "not",
            "overflow"
        ]
    },
    {
        "id": 1259,
        "code": "public static int checkedPow(int b, int k) {\n  checkNonNegative(\"exponent\", k);\n  switch (b) {\n    case 0:\n      return (k == 0) ? 1 : 0;\n    case 1:\n      return 1;\n    case (-1):\n      return ((k & 1) == 0) ? 1 : -1;\n    case 2:\n      checkNoOverflow(k < Integer.SIZE - 1, \"checkedPow\", b, k);\n      return 1 << k;\n    case (-2):\n      checkNoOverflow(k < Integer.SIZE, \"checkedPow\", b, k);\n      return ((k & 1) == 0) ? 1 << k : -1 << k;\n    default:\n        \n  }\n  int accum = 1;\n  while (true) {\n    switch (k) {\n      case 0:\n        return accum;\n      case 1:\n        return checkedMultiply(accum, b);\n      default:\n        if ((k & 1) != 0) {\n          accum = checkedMultiply(accum, b);\n        }\n        k >>= 1;\n        if (k > 0) {\n          checkNoOverflow(-FLOOR_SQRT_MAX_INT <= b & b <= FLOOR_SQRT_MAX_INT, \"checkedPow\", b, k);\n          b *= b;\n        }\n    }\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "b",
            "to",
            "the",
            "k",
            "th",
            "power",
            "provided",
            "it",
            "does",
            "not",
            "overflow"
        ]
    },
    {
        "id": 1260,
        "code": "public static int saturatedAdd(int a, int b) {\n  return Ints.saturatedCast((long) a + b);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "sum",
            "of",
            "a",
            "and",
            "b",
            "unless",
            "it",
            "would",
            "overflow",
            "or",
            "underflow",
            "in",
            "which",
            "case",
            "integer"
        ]
    },
    {
        "id": 1261,
        "code": "public static int saturatedSubtract(int a, int b) {\n  return Ints.saturatedCast((long) a - b);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "difference",
            "of",
            "a",
            "and",
            "b",
            "unless",
            "it",
            "would",
            "overflow",
            "or",
            "underflow",
            "in",
            "which",
            "case",
            "integer"
        ]
    },
    {
        "id": 1262,
        "code": "public static int saturatedMultiply(int a, int b) {\n  return Ints.saturatedCast((long) a * b);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "product",
            "of",
            "a",
            "and",
            "b",
            "unless",
            "it",
            "would",
            "overflow",
            "or",
            "underflow",
            "in",
            "which",
            "case",
            "integer"
        ]
    },
    {
        "id": 1263,
        "code": "public static int saturatedPow(int b, int k) {\n  checkNonNegative(\"exponent\", k);\n  switch (b) {\n    case 0:\n      return (k == 0) ? 1 : 0;\n    case 1:\n      return 1;\n    case (-1):\n      return ((k & 1) == 0) ? 1 : -1;\n    case 2:\n      if (k >= Integer.SIZE - 1) {\n        return Integer.MAX_VALUE;\n      }\n      return 1 << k;\n    case (-2):\n      if (k >= Integer.SIZE) {\n        return Integer.MAX_VALUE + (k & 1);\n      }\n      return ((k & 1) == 0) ? 1 << k : -1 << k;\n    default:\n        \n  }\n  int accum = 1;\n    \n  int limit = Integer.MAX_VALUE + ((b >>> Integer.SIZE - 1) & (k & 1));\n  while (true) {\n    switch (k) {\n      case 0:\n        return accum;\n      case 1:\n        return saturatedMultiply(accum, b);\n      default:\n        if ((k & 1) != 0) {\n          accum = saturatedMultiply(accum, b);\n        }\n        k >>= 1;\n        if (k > 0) {\n          if (-FLOOR_SQRT_MAX_INT > b | b > FLOOR_SQRT_MAX_INT) {\n            return limit;\n          }\n          b *= b;\n        }\n    }\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "b",
            "to",
            "the",
            "k",
            "th",
            "power",
            "unless",
            "it",
            "would",
            "overflow",
            "or",
            "underflow",
            "in",
            "which",
            "case",
            "integer"
        ]
    },
    {
        "id": 1264,
        "code": "public static int factorial(int n) {\n  checkNonNegative(\"n\", n);\n  return (n < factorials.length) ? factorials[n] : Integer.MAX_VALUE;\n}",
        "summary_tokens": [
            "returns",
            "n",
            "that",
            "is",
            "the",
            "product",
            "of",
            "the",
            "first",
            "n",
            "positive",
            "integers",
            "0",
            "if",
            "n",
            "0",
            "or",
            "integer",
            "max",
            "value",
            "if",
            "the",
            "result",
            "does",
            "not",
            "fit",
            "in",
            "a",
            "int"
        ]
    },
    {
        "id": 1265,
        "code": "public static int binomial(int n, int k) {\n  checkNonNegative(\"n\", n);\n  checkNonNegative(\"k\", k);\n  checkArgument(k <= n, \"k (%s) > n (%s)\", k, n);\n  if (k > (n >> 1)) {\n    k = n - k;\n  }\n  if (k >= biggestBinomials.length || n > biggestBinomials[k]) {\n    return Integer.MAX_VALUE;\n  }\n  switch (k) {\n    case 0:\n      return 1;\n    case 1:\n      return n;\n    default:\n      long result = 1;\n      for (int i = 0; i < k; i++) {\n        result *= n - i;\n        result /= i + 1;\n      }\n      return (int) result;\n  }\n}",
        "summary_tokens": [
            "returns",
            "n",
            "choose",
            "k",
            "also",
            "known",
            "as",
            "the",
            "binomial",
            "coefficient",
            "of",
            "n",
            "and",
            "k",
            "or",
            "integer",
            "max",
            "value",
            "if",
            "the",
            "result",
            "does",
            "not",
            "fit",
            "in",
            "an",
            "int"
        ]
    },
    {
        "id": 1266,
        "code": "public static int mean(int x, int y) {\n    \n    \n    \n  return (x & y) + ((x ^ y) >> 1);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "arithmetic",
            "mean",
            "of",
            "x",
            "and",
            "y",
            "rounded",
            "towards",
            "negative",
            "infinity"
        ]
    },
    {
        "id": 1267,
        "code": "public static boolean isPrime(int n) {\n  return LongMath.isPrime(n);\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "n",
            "is",
            "a",
            "a",
            "href",
            "http",
            "mathworld"
        ]
    },
    {
        "id": 1268,
        "code": "public static LinearTransformationBuilder mapping(double x1, double y1) {\n  checkArgument(isFinite(x1) && isFinite(y1));\n  return new LinearTransformationBuilder(x1, y1);\n}",
        "summary_tokens": [
            "start",
            "building",
            "an",
            "instance",
            "which",
            "maps",
            "x",
            "x",
            "0",
            "to",
            "y",
            "y",
            "0"
        ]
    },
    {
        "id": 1269,
        "code": "public static LinearTransformation vertical(double x) {\n  checkArgument(isFinite(x));\n  return new VerticalLinearTransformation(x);\n}",
        "summary_tokens": [
            "builds",
            "an",
            "instance",
            "representing",
            "a",
            "vertical",
            "transformation",
            "with",
            "a",
            "constant",
            "value",
            "of",
            "x"
        ]
    },
    {
        "id": 1270,
        "code": "public static LinearTransformation horizontal(double y) {\n  checkArgument(isFinite(y));\n  double slope = 0.0;\n  return new RegularLinearTransformation(slope, y);\n}",
        "summary_tokens": [
            "builds",
            "an",
            "instance",
            "representing",
            "a",
            "horizontal",
            "transformation",
            "with",
            "a",
            "constant",
            "value",
            "of",
            "y"
        ]
    },
    {
        "id": 1271,
        "code": "public static LinearTransformation forNaN() {\n  return NaNLinearTransformation.INSTANCE;\n}",
        "summary_tokens": [
            "builds",
            "an",
            "instance",
            "for",
            "datasets",
            "which",
            "contains",
            "double",
            "na",
            "n"
        ]
    },
    {
        "id": 1272,
        "code": "public static long ceilingPowerOfTwo(long x) {\n  checkPositive(\"x\", x);\n  if (x > MAX_SIGNED_POWER_OF_TWO) {\n    throw new ArithmeticException(\"ceilingPowerOfTwo(\" + x + \") is not representable as a long\");\n  }\n  return 1L << -Long.numberOfLeadingZeros(x - 1);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "smallest",
            "power",
            "of",
            "two",
            "greater",
            "than",
            "or",
            "equal",
            "to",
            "x"
        ]
    },
    {
        "id": 1273,
        "code": "public static long floorPowerOfTwo(long x) {\n  checkPositive(\"x\", x);\n\n    \n    \n  return 1L << ((Long.SIZE - 1) - Long.numberOfLeadingZeros(x));\n}",
        "summary_tokens": [
            "returns",
            "the",
            "largest",
            "power",
            "of",
            "two",
            "less",
            "than",
            "or",
            "equal",
            "to",
            "x"
        ]
    },
    {
        "id": 1274,
        "code": "public static boolean isPowerOfTwo(long x) {\n  return x > 0 & (x & (x - 1)) == 0;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "x",
            "represents",
            "a",
            "power",
            "of",
            "two"
        ]
    },
    {
        "id": 1275,
        "code": "static int lessThanBranchFree(long x, long y) {\n    \n  return (int) (~~(x - y) >>> (Long.SIZE - 1));\n}",
        "summary_tokens": [
            "returns",
            "0",
            "if",
            "x",
            "y",
            "as",
            "unsigned",
            "longs",
            "and",
            "0",
            "otherwise"
        ]
    },
    {
        "id": 1276,
        "code": "public static int log2(long x, RoundingMode mode) {\n  checkPositive(\"x\", x);\n  switch (mode) {\n    case UNNECESSARY:\n      checkRoundingUnnecessary(isPowerOfTwo(x));\n        \n    case DOWN:\n    case FLOOR:\n      return (Long.SIZE - 1) - Long.numberOfLeadingZeros(x);\n\n    case UP:\n    case CEILING:\n      return Long.SIZE - Long.numberOfLeadingZeros(x - 1);\n\n    case HALF_DOWN:\n    case HALF_UP:\n    case HALF_EVEN:\n        \n      int leadingZeros = Long.numberOfLeadingZeros(x);\n      long cmp = MAX_POWER_OF_SQRT2_UNSIGNED >>> leadingZeros;\n        \n      int logFloor = (Long.SIZE - 1) - leadingZeros;\n      return logFloor + lessThanBranchFree(cmp, x);\n\n    default:\n      throw new AssertionError(\"impossible\");\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "base",
            "0",
            "logarithm",
            "of",
            "x",
            "rounded",
            "according",
            "to",
            "the",
            "specified",
            "rounding",
            "mode"
        ]
    },
    {
        "id": 1277,
        "code": "public static int log10(long x, RoundingMode mode) {\n  checkPositive(\"x\", x);\n  int logFloor = log10Floor(x);\n  long floorPow = powersOf10[logFloor];\n  switch (mode) {\n    case UNNECESSARY:\n      checkRoundingUnnecessary(x == floorPow);\n        \n    case FLOOR:\n    case DOWN:\n      return logFloor;\n    case CEILING:\n    case UP:\n      return logFloor + lessThanBranchFree(floorPow, x);\n    case HALF_DOWN:\n    case HALF_UP:\n    case HALF_EVEN:\n        \n      return logFloor + lessThanBranchFree(halfPowersOf10[logFloor], x);\n    default:\n      throw new AssertionError();\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "base",
            "0",
            "logarithm",
            "of",
            "x",
            "rounded",
            "according",
            "to",
            "the",
            "specified",
            "rounding",
            "mode"
        ]
    },
    {
        "id": 1278,
        "code": "public static long pow(long b, int k) {\n  checkNonNegative(\"exponent\", k);\n  if (-2 <= b && b <= 2) {\n    switch ((int) b) {\n      case 0:\n        return (k == 0) ? 1 : 0;\n      case 1:\n        return 1;\n      case (-1):\n        return ((k & 1) == 0) ? 1 : -1;\n      case 2:\n        return (k < Long.SIZE) ? 1L << k : 0;\n      case (-2):\n        if (k < Long.SIZE) {\n          return ((k & 1) == 0) ? 1L << k : -(1L << k);\n        } else {\n          return 0;\n        }\n      default:\n        throw new AssertionError();\n    }\n  }\n  for (long accum = 1; ; k >>= 1) {\n    switch (k) {\n      case 0:\n        return accum;\n      case 1:\n        return accum * b;\n      default:\n        accum *= ((k & 1) == 0) ? 1 : b;\n        b *= b;\n    }\n  }\n}",
        "summary_tokens": [
            "returns",
            "b",
            "to",
            "the",
            "k",
            "th",
            "power"
        ]
    },
    {
        "id": 1279,
        "code": "public static long sqrt(long x, RoundingMode mode) {\n  checkNonNegative(\"x\", x);\n  if (fitsInInt(x)) {\n    return IntMath.sqrt((int) x, mode);\n  }\n    \n  long guess = (long) Math.sqrt(x);\n    \n  long guessSquared = guess * guess;\n    \n    \n  switch (mode) {\n    case UNNECESSARY:\n      checkRoundingUnnecessary(guessSquared == x);\n      return guess;\n    case FLOOR:\n    case DOWN:\n      if (x < guessSquared) {\n        return guess - 1;\n      }\n      return guess;\n    case CEILING:\n    case UP:\n      if (x > guessSquared) {\n        return guess + 1;\n      }\n      return guess;\n    case HALF_DOWN:\n    case HALF_UP:\n    case HALF_EVEN:\n      long sqrtFloor = guess - ((x < guessSquared) ? 1 : 0);\n      long halfSquare = sqrtFloor * sqrtFloor + sqrtFloor;\n        \n      return sqrtFloor + lessThanBranchFree(halfSquare, x);\n    default:\n      throw new AssertionError();\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "square",
            "root",
            "of",
            "x",
            "rounded",
            "with",
            "the",
            "specified",
            "rounding",
            "mode"
        ]
    },
    {
        "id": 1280,
        "code": "public static long divide(long p, long q, RoundingMode mode) {\n  checkNotNull(mode);\n  long div = p / q; \n  long rem = p - q * div; \n\n  if (rem == 0) {\n    return div;\n  }\n\n    \n  int signum = 1 | (int) ((p ^ q) >> (Long.SIZE - 1));\n  boolean increment;\n  switch (mode) {\n    case UNNECESSARY:\n      checkRoundingUnnecessary(rem == 0);\n        \n    case DOWN:\n      increment = false;\n      break;\n    case UP:\n      increment = true;\n      break;\n    case CEILING:\n      increment = signum > 0;\n      break;\n    case FLOOR:\n      increment = signum < 0;\n      break;\n    case HALF_EVEN:\n    case HALF_DOWN:\n    case HALF_UP:\n      long absRem = abs(rem);\n      long cmpRemToHalfDivisor = absRem - (abs(q) - absRem);\n        \n        \n      if (cmpRemToHalfDivisor == 0) { \n        increment = (mode == HALF_UP || (mode == HALF_EVEN && (div & 1) != 0));\n      } else {\n        increment = cmpRemToHalfDivisor > 0; \n      }\n      break;\n    default:\n      throw new AssertionError();\n  }\n  return increment ? div + signum : div;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "result",
            "of",
            "dividing",
            "p",
            "by",
            "q",
            "rounding",
            "using",
            "the",
            "specified",
            "rounding",
            "mode"
        ]
    },
    {
        "id": 1281,
        "code": "public static long mod(long x, long m) {\n  if (m <= 0) {\n    throw new ArithmeticException(\"Modulus must be positive\");\n  }\n  long result = x % m;\n  return (result >= 0) ? result : result + m;\n}",
        "summary_tokens": [
            "returns",
            "x",
            "mod",
            "m",
            "a",
            "non",
            "negative",
            "value",
            "less",
            "than",
            "m"
        ]
    },
    {
        "id": 1282,
        "code": "public static long gcd(long a, long b) {\n    \n  checkNonNegative(\"a\", a);\n  checkNonNegative(\"b\", b);\n  if (a == 0) {\n      \n      \n    return b;\n  } else if (b == 0) {\n    return a; \n  }\n    \n  int aTwos = Long.numberOfTrailingZeros(a);\n  a >>= aTwos; \n  int bTwos = Long.numberOfTrailingZeros(b);\n  b >>= bTwos; \n  while (a != b) { \n      \n      \n      \n\n      \n      \n\n    long delta = a - b; \n\n    long minDeltaOrZero = delta & (delta >> (Long.SIZE - 1));\n      \n\n    a = delta - minDeltaOrZero - minDeltaOrZero; \n      \n\n    b += minDeltaOrZero; \n    a >>= Long.numberOfTrailingZeros(a); \n  }\n  return a << min(aTwos, bTwos);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "greatest",
            "common",
            "divisor",
            "of",
            "a",
            "b"
        ]
    },
    {
        "id": 1283,
        "code": "public static long checkedAdd(long a, long b) {\n  long result = a + b;\n  checkNoOverflow((a ^ b) < 0 | (a ^ result) >= 0, \"checkedAdd\", a, b);\n  return result;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "sum",
            "of",
            "a",
            "and",
            "b",
            "provided",
            "it",
            "does",
            "not",
            "overflow"
        ]
    },
    {
        "id": 1284,
        "code": "public static long checkedSubtract(long a, long b) {\n  long result = a - b;\n  checkNoOverflow((a ^ b) >= 0 | (a ^ result) >= 0, \"checkedSubtract\", a, b);\n  return result;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "difference",
            "of",
            "a",
            "and",
            "b",
            "provided",
            "it",
            "does",
            "not",
            "overflow"
        ]
    },
    {
        "id": 1285,
        "code": "public static long checkedMultiply(long a, long b) {\n    \n  int leadingZeros =\n      Long.numberOfLeadingZeros(a)\n          + Long.numberOfLeadingZeros(~a)\n          + Long.numberOfLeadingZeros(b)\n          + Long.numberOfLeadingZeros(~b);\n    \n  if (leadingZeros > Long.SIZE + 1) {\n    return a * b;\n  }\n  checkNoOverflow(leadingZeros >= Long.SIZE, \"checkedMultiply\", a, b);\n  checkNoOverflow(a >= 0 | b != Long.MIN_VALUE, \"checkedMultiply\", a, b);\n  long result = a * b;\n  checkNoOverflow(a == 0 || result / a == b, \"checkedMultiply\", a, b);\n  return result;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "product",
            "of",
            "a",
            "and",
            "b",
            "provided",
            "it",
            "does",
            "not",
            "overflow"
        ]
    },
    {
        "id": 1286,
        "code": "public static long checkedPow(long b, int k) {\n  checkNonNegative(\"exponent\", k);\n  if (b >= -2 & b <= 2) {\n    switch ((int) b) {\n      case 0:\n        return (k == 0) ? 1 : 0;\n      case 1:\n        return 1;\n      case (-1):\n        return ((k & 1) == 0) ? 1 : -1;\n      case 2:\n        checkNoOverflow(k < Long.SIZE - 1, \"checkedPow\", b, k);\n        return 1L << k;\n      case (-2):\n        checkNoOverflow(k < Long.SIZE, \"checkedPow\", b, k);\n        return ((k & 1) == 0) ? (1L << k) : (-1L << k);\n      default:\n        throw new AssertionError();\n    }\n  }\n  long accum = 1;\n  while (true) {\n    switch (k) {\n      case 0:\n        return accum;\n      case 1:\n        return checkedMultiply(accum, b);\n      default:\n        if ((k & 1) != 0) {\n          accum = checkedMultiply(accum, b);\n        }\n        k >>= 1;\n        if (k > 0) {\n          checkNoOverflow(\n              -FLOOR_SQRT_MAX_LONG <= b && b <= FLOOR_SQRT_MAX_LONG, \"checkedPow\", b, k);\n          b *= b;\n        }\n    }\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "b",
            "to",
            "the",
            "k",
            "th",
            "power",
            "provided",
            "it",
            "does",
            "not",
            "overflow"
        ]
    },
    {
        "id": 1287,
        "code": "public static long saturatedAdd(long a, long b) {\n  long naiveSum = a + b;\n  if ((a ^ b) < 0 | (a ^ naiveSum) >= 0) {\n      \n      \n    return naiveSum;\n  }\n    \n  return Long.MAX_VALUE + ((naiveSum >>> (Long.SIZE - 1)) ^ 1);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "sum",
            "of",
            "a",
            "and",
            "b",
            "unless",
            "it",
            "would",
            "overflow",
            "or",
            "underflow",
            "in",
            "which",
            "case",
            "long"
        ]
    },
    {
        "id": 1288,
        "code": "public static long saturatedSubtract(long a, long b) {\n  long naiveDifference = a - b;\n  if ((a ^ b) >= 0 | (a ^ naiveDifference) >= 0) {\n      \n      \n    return naiveDifference;\n  }\n    \n  return Long.MAX_VALUE + ((naiveDifference >>> (Long.SIZE - 1)) ^ 1);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "difference",
            "of",
            "a",
            "and",
            "b",
            "unless",
            "it",
            "would",
            "overflow",
            "or",
            "underflow",
            "in",
            "which",
            "case",
            "long"
        ]
    },
    {
        "id": 1289,
        "code": "public static long saturatedMultiply(long a, long b) {\n    \n  int leadingZeros =\n      Long.numberOfLeadingZeros(a)\n          + Long.numberOfLeadingZeros(~a)\n          + Long.numberOfLeadingZeros(b)\n          + Long.numberOfLeadingZeros(~b);\n  if (leadingZeros > Long.SIZE + 1) {\n    return a * b;\n  }\n    \n  long limit = Long.MAX_VALUE + ((a ^ b) >>> (Long.SIZE - 1));\n  if (leadingZeros < Long.SIZE | (a < 0 & b == Long.MIN_VALUE)) {\n      \n    return limit;\n  }\n  long result = a * b;\n  if (a == 0 || result / a == b) {\n    return result;\n  }\n  return limit;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "product",
            "of",
            "a",
            "and",
            "b",
            "unless",
            "it",
            "would",
            "overflow",
            "or",
            "underflow",
            "in",
            "which",
            "case",
            "long"
        ]
    },
    {
        "id": 1290,
        "code": "public static long saturatedPow(long b, int k) {\n  checkNonNegative(\"exponent\", k);\n  if (b >= -2 & b <= 2) {\n    switch ((int) b) {\n      case 0:\n        return (k == 0) ? 1 : 0;\n      case 1:\n        return 1;\n      case (-1):\n        return ((k & 1) == 0) ? 1 : -1;\n      case 2:\n        if (k >= Long.SIZE - 1) {\n          return Long.MAX_VALUE;\n        }\n        return 1L << k;\n      case (-2):\n        if (k >= Long.SIZE) {\n          return Long.MAX_VALUE + (k & 1);\n        }\n        return ((k & 1) == 0) ? (1L << k) : (-1L << k);\n      default:\n        throw new AssertionError();\n    }\n  }\n  long accum = 1;\n    \n  long limit = Long.MAX_VALUE + ((b >>> Long.SIZE - 1) & (k & 1));\n  while (true) {\n    switch (k) {\n      case 0:\n        return accum;\n      case 1:\n        return saturatedMultiply(accum, b);\n      default:\n        if ((k & 1) != 0) {\n          accum = saturatedMultiply(accum, b);\n        }\n        k >>= 1;\n        if (k > 0) {\n          if (-FLOOR_SQRT_MAX_LONG > b | b > FLOOR_SQRT_MAX_LONG) {\n            return limit;\n          }\n          b *= b;\n        }\n    }\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "b",
            "to",
            "the",
            "k",
            "th",
            "power",
            "unless",
            "it",
            "would",
            "overflow",
            "or",
            "underflow",
            "in",
            "which",
            "case",
            "long"
        ]
    },
    {
        "id": 1291,
        "code": "public static long factorial(int n) {\n  checkNonNegative(\"n\", n);\n  return (n < factorials.length) ? factorials[n] : Long.MAX_VALUE;\n}",
        "summary_tokens": [
            "returns",
            "n",
            "that",
            "is",
            "the",
            "product",
            "of",
            "the",
            "first",
            "n",
            "positive",
            "integers",
            "0",
            "if",
            "n",
            "0",
            "or",
            "long",
            "max",
            "value",
            "if",
            "the",
            "result",
            "does",
            "not",
            "fit",
            "in",
            "a",
            "long"
        ]
    },
    {
        "id": 1292,
        "code": "public static long binomial(int n, int k) {\n  checkNonNegative(\"n\", n);\n  checkNonNegative(\"k\", k);\n  checkArgument(k <= n, \"k (%s) > n (%s)\", k, n);\n  if (k > (n >> 1)) {\n    k = n - k;\n  }\n  switch (k) {\n    case 0:\n      return 1;\n    case 1:\n      return n;\n    default:\n      if (n < factorials.length) {\n        return factorials[n] / (factorials[k] * factorials[n - k]);\n      } else if (k >= biggestBinomials.length || n > biggestBinomials[k]) {\n        return Long.MAX_VALUE;\n      } else if (k < biggestSimpleBinomials.length && n <= biggestSimpleBinomials[k]) {\n          \n        long result = n--;\n        for (int i = 2; i <= k; n--, i++) {\n          result *= n;\n          result /= i;\n        }\n        return result;\n      } else {\n        int nBits = LongMath.log2(n, RoundingMode.CEILING);\n\n        long result = 1;\n        long numerator = n--;\n        long denominator = 1;\n\n        int numeratorBits = nBits;\n          \n\n          \n        for (int i = 2; i <= k; i++, n--) {\n          if (numeratorBits + nBits < Long.SIZE - 1) {\n              \n            numerator *= n;\n            denominator *= i;\n            numeratorBits += nBits;\n          } else {\n              \n              \n            result = multiplyFraction(result, numerator, denominator);\n            numerator = n;\n            denominator = i;\n            numeratorBits = nBits;\n          }\n        }\n        return multiplyFraction(result, numerator, denominator);\n      }\n  }\n}",
        "summary_tokens": [
            "returns",
            "n",
            "choose",
            "k",
            "also",
            "known",
            "as",
            "the",
            "binomial",
            "coefficient",
            "of",
            "n",
            "and",
            "k",
            "or",
            "long",
            "max",
            "value",
            "if",
            "the",
            "result",
            "does",
            "not",
            "fit",
            "in",
            "a",
            "long"
        ]
    },
    {
        "id": 1293,
        "code": "static long multiplyFraction(long x, long numerator, long denominator) {\n  if (x == 1) {\n    return numerator / denominator;\n  }\n  long commonDivisor = gcd(x, denominator);\n  x /= commonDivisor;\n  denominator /= commonDivisor;\n    \n    \n  return x * (numerator / denominator);\n}",
        "summary_tokens": [
            "returns",
            "x",
            "numerator",
            "denominator",
            "which",
            "is",
            "assumed",
            "to",
            "come",
            "out",
            "to",
            "an",
            "integral",
            "value"
        ]
    },
    {
        "id": 1294,
        "code": "public static long mean(long x, long y) {\n    \n    \n    \n  return (x & y) + ((x ^ y) >> 1);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "arithmetic",
            "mean",
            "of",
            "x",
            "and",
            "y",
            "rounded",
            "toward",
            "negative",
            "infinity"
        ]
    },
    {
        "id": 1295,
        "code": "public static boolean isPrime(long n) {\n  if (n < 2) {\n    checkNonNegative(\"n\", n);\n    return false;\n  }\n  if (n < 66) {\n      \n    long mask =\n        (1L << (2 - 2))\n            | (1L << (3 - 2))\n            | (1L << (5 - 2))\n            | (1L << (7 - 2))\n            | (1L << (11 - 2))\n            | (1L << (13 - 2))\n            | (1L << (17 - 2))\n            | (1L << (19 - 2))\n            | (1L << (23 - 2))\n            | (1L << (29 - 2))\n            | (1L << (31 - 2))\n            | (1L << (37 - 2))\n            | (1L << (41 - 2))\n            | (1L << (43 - 2))\n            | (1L << (47 - 2))\n            | (1L << (53 - 2))\n            | (1L << (59 - 2))\n            | (1L << (61 - 2));\n      \n    return ((mask >> ((int) n - 2)) & 1) != 0;\n  }\n\n  if ((SIEVE_30 & (1 << (n % 30))) != 0) {\n    return false;\n  }\n  if (n % 7 == 0 || n % 11 == 0 || n % 13 == 0) {\n    return false;\n  }\n  if (n < 17 * 17) {\n    return true;\n  }\n\n  for (long[] baseSet : millerRabinBaseSets) {\n    if (n <= baseSet[0]) {\n      for (int i = 1; i < baseSet.length; i++) {\n        if (!MillerRabinTester.test(baseSet[i], n)) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }\n  throw new AssertionError();\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "n",
            "is",
            "a",
            "a",
            "href",
            "http",
            "mathworld"
        ]
    },
    {
        "id": 1296,
        "code": "public static double roundToDouble(long x, RoundingMode mode) {\n    \n  double roundArbitrarily = (double) x;\n  long roundArbitrarilyAsLong = (long) roundArbitrarily;\n  int cmpXToRoundArbitrarily;\n\n  if (roundArbitrarilyAsLong == Long.MAX_VALUE) {\n      \n    cmpXToRoundArbitrarily = -1;\n  } else {\n    cmpXToRoundArbitrarily = Longs.compare(x, roundArbitrarilyAsLong);\n  }\n\n  switch (mode) {\n    case UNNECESSARY:\n      checkRoundingUnnecessary(cmpXToRoundArbitrarily == 0);\n      return roundArbitrarily;\n    case FLOOR:\n      return (cmpXToRoundArbitrarily >= 0)\n          ? roundArbitrarily\n          : DoubleUtils.nextDown(roundArbitrarily);\n    case CEILING:\n      return (cmpXToRoundArbitrarily <= 0) ? roundArbitrarily : Math.nextUp(roundArbitrarily);\n    case DOWN:\n      if (x >= 0) {\n        return (cmpXToRoundArbitrarily >= 0)\n            ? roundArbitrarily\n            : DoubleUtils.nextDown(roundArbitrarily);\n      } else {\n        return (cmpXToRoundArbitrarily <= 0) ? roundArbitrarily : Math.nextUp(roundArbitrarily);\n      }\n    case UP:\n      if (x >= 0) {\n        return (cmpXToRoundArbitrarily <= 0) ? roundArbitrarily : Math.nextUp(roundArbitrarily);\n      } else {\n        return (cmpXToRoundArbitrarily >= 0)\n            ? roundArbitrarily\n            : DoubleUtils.nextDown(roundArbitrarily);\n      }\n    case HALF_DOWN:\n    case HALF_UP:\n    case HALF_EVEN:\n      {\n        long roundFloor;\n        double roundFloorAsDouble;\n        long roundCeiling;\n        double roundCeilingAsDouble;\n\n        if (cmpXToRoundArbitrarily >= 0) {\n          roundFloorAsDouble = roundArbitrarily;\n          roundFloor = roundArbitrarilyAsLong;\n          roundCeilingAsDouble = Math.nextUp(roundArbitrarily);\n          roundCeiling = (long) Math.ceil(roundCeilingAsDouble);\n        } else {\n          roundCeilingAsDouble = roundArbitrarily;\n          roundCeiling = roundArbitrarilyAsLong;\n          roundFloorAsDouble = DoubleUtils.nextDown(roundArbitrarily);\n          roundFloor = (long) Math.floor(roundFloorAsDouble);\n        }\n\n        long deltaToFloor = x - roundFloor;\n        long deltaToCeiling = roundCeiling - x;\n\n        if (roundCeiling == Long.MAX_VALUE) {\n            \n            \n          deltaToCeiling++;\n        }\n\n        int diff = Longs.compare(deltaToFloor, deltaToCeiling);\n        if (diff < 0) { \n          return roundFloorAsDouble;\n        } else if (diff > 0) { \n          return roundCeilingAsDouble;\n        }\n          \n        switch (mode) {\n          case HALF_EVEN:\n            return ((DoubleUtils.getSignificand(roundFloorAsDouble) & 1L) == 0)\n                ? roundFloorAsDouble\n                : roundCeilingAsDouble;\n          case HALF_DOWN:\n            return (x >= 0) ? roundFloorAsDouble : roundCeilingAsDouble;\n          case HALF_UP:\n            return (x >= 0) ? roundCeilingAsDouble : roundFloorAsDouble;\n          default:\n            throw new AssertionError(\"impossible\");\n        }\n      }\n  }\n  throw new AssertionError(\"impossible\");\n}",
        "summary_tokens": [
            "returns",
            "x",
            "rounded",
            "to",
            "a",
            "double",
            "with",
            "the",
            "specified",
            "rounding",
            "mode"
        ]
    },
    {
        "id": 1297,
        "code": "public long count() {\n  return xStats.count();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "pairs",
            "in",
            "the",
            "dataset"
        ]
    },
    {
        "id": 1298,
        "code": "public Stats xStats() {\n  return xStats;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "statistics",
            "on",
            "the",
            "x",
            "values",
            "alone"
        ]
    },
    {
        "id": 1299,
        "code": "public Stats yStats() {\n  return yStats;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "statistics",
            "on",
            "the",
            "y",
            "values",
            "alone"
        ]
    },
    {
        "id": 1300,
        "code": "public double populationCovariance() {\n  checkState(count() != 0);\n  return sumOfProductsOfDeltas / count();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "population",
            "covariance",
            "of",
            "the",
            "values"
        ]
    },
    {
        "id": 1301,
        "code": "public double sampleCovariance() {\n  checkState(count() > 1);\n  return sumOfProductsOfDeltas / (count() - 1);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "sample",
            "covariance",
            "of",
            "the",
            "values"
        ]
    },
    {
        "id": 1302,
        "code": "public double pearsonsCorrelationCoefficient() {\n  checkState(count() > 1);\n  if (isNaN(sumOfProductsOfDeltas)) {\n    return NaN;\n  }\n  double xSumOfSquaresOfDeltas = xStats().sumOfSquaresOfDeltas();\n  double ySumOfSquaresOfDeltas = yStats().sumOfSquaresOfDeltas();\n  checkState(xSumOfSquaresOfDeltas > 0.0);\n  checkState(ySumOfSquaresOfDeltas > 0.0);\n    \n    \n  double productOfSumsOfSquaresOfDeltas =\n      ensurePositive(xSumOfSquaresOfDeltas * ySumOfSquaresOfDeltas);\n  return ensureInUnitRange(sumOfProductsOfDeltas / Math.sqrt(productOfSumsOfSquaresOfDeltas));\n}",
        "summary_tokens": [
            "returns",
            "the",
            "a",
            "href",
            "http",
            "mathworld"
        ]
    },
    {
        "id": 1303,
        "code": "public LinearTransformation leastSquaresFit() {\n  checkState(count() > 1);\n  if (isNaN(sumOfProductsOfDeltas)) {\n    return LinearTransformation.forNaN();\n  }\n  double xSumOfSquaresOfDeltas = xStats.sumOfSquaresOfDeltas();\n  if (xSumOfSquaresOfDeltas > 0.0) {\n    if (yStats.sumOfSquaresOfDeltas() > 0.0) {\n      return LinearTransformation.mapping(xStats.mean(), yStats.mean())\n          .withSlope(sumOfProductsOfDeltas / xSumOfSquaresOfDeltas);\n    } else {\n      return LinearTransformation.horizontal(yStats.mean());\n    }\n  } else {\n    checkState(yStats.sumOfSquaresOfDeltas() > 0.0);\n    return LinearTransformation.vertical(xStats.mean());\n  }\n}",
        "summary_tokens": [
            "returns",
            "a",
            "linear",
            "transformation",
            "giving",
            "the",
            "best",
            "fit",
            "to",
            "the",
            "data",
            "according",
            "to",
            "a",
            "href",
            "http",
            "mathworld"
        ]
    },
    {
        "id": 1304,
        "code": "public byte[] toByteArray() {\n  ByteBuffer buffer = ByteBuffer.allocate(BYTES).order(ByteOrder.LITTLE_ENDIAN);\n  xStats.writeTo(buffer);\n  yStats.writeTo(buffer);\n  buffer.putDouble(sumOfProductsOfDeltas);\n  return buffer.array();\n}",
        "summary_tokens": [
            "gets",
            "a",
            "byte",
            "array",
            "representation",
            "of",
            "this",
            "instance"
        ]
    },
    {
        "id": 1305,
        "code": "public static PairedStats fromByteArray(byte[] byteArray) {\n  checkNotNull(byteArray);\n  checkArgument(\n      byteArray.length == BYTES,\n      \"Expected PairedStats.BYTES = %s, got %s\",\n      BYTES,\n      byteArray.length);\n  ByteBuffer buffer = ByteBuffer.wrap(byteArray).order(ByteOrder.LITTLE_ENDIAN);\n  Stats xStats = Stats.readFrom(buffer);\n  Stats yStats = Stats.readFrom(buffer);\n  double sumOfProductsOfDeltas = buffer.getDouble();\n  return new PairedStats(xStats, yStats, sumOfProductsOfDeltas);\n}",
        "summary_tokens": [
            "creates",
            "a",
            "paired",
            "stats",
            "instance",
            "from",
            "the",
            "given",
            "byte",
            "representation",
            "which",
            "was",
            "obtained",
            "by",
            "to",
            "byte",
            "array"
        ]
    },
    {
        "id": 1306,
        "code": "public void add(double x, double y) {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n  xStats.add(x);\n  if (isFinite(x) && isFinite(y)) {\n    if (xStats.count() > 1) {\n      sumOfProductsOfDeltas += (x - xStats.mean()) * (y - yStats.mean());\n    }\n  } else {\n    sumOfProductsOfDeltas = NaN;\n  }\n  yStats.add(y);\n}",
        "summary_tokens": [
            "adds",
            "the",
            "given",
            "pair",
            "of",
            "values",
            "to",
            "the",
            "dataset"
        ]
    },
    {
        "id": 1307,
        "code": "public void addAll(PairedStats values) {\n  if (values.count() == 0) {\n    return;\n  }\n\n  xStats.addAll(values.xStats());\n  if (yStats.count() == 0) {\n    sumOfProductsOfDeltas = values.sumOfProductsOfDeltas();\n  } else {\n      \n      \n      \n    sumOfProductsOfDeltas +=\n        values.sumOfProductsOfDeltas()\n            + (values.xStats().mean() - xStats.mean())\n                * (values.yStats().mean() - yStats.mean())\n                * values.count();\n  }\n  yStats.addAll(values.yStats());\n}",
        "summary_tokens": [
            "adds",
            "the",
            "given",
            "statistics",
            "to",
            "the",
            "dataset",
            "as",
            "if",
            "the",
            "individual",
            "values",
            "used",
            "to",
            "compute",
            "the",
            "statistics",
            "had",
            "been",
            "added",
            "directly"
        ]
    },
    {
        "id": 1308,
        "code": "public PairedStats snapshot() {\n  return new PairedStats(xStats.snapshot(), yStats.snapshot(), sumOfProductsOfDeltas);\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "snapshot",
            "of",
            "the",
            "current",
            "statistics"
        ]
    },
    {
        "id": 1309,
        "code": "public long count() {\n  return xStats.count();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "pairs",
            "in",
            "the",
            "dataset"
        ]
    },
    {
        "id": 1310,
        "code": "public Stats xStats() {\n  return xStats.snapshot();\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "snapshot",
            "of",
            "the",
            "statistics",
            "on",
            "the",
            "x",
            "values",
            "alone"
        ]
    },
    {
        "id": 1311,
        "code": "public Stats yStats() {\n  return yStats.snapshot();\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "snapshot",
            "of",
            "the",
            "statistics",
            "on",
            "the",
            "y",
            "values",
            "alone"
        ]
    },
    {
        "id": 1312,
        "code": "public double populationCovariance() {\n  checkState(count() != 0);\n  return sumOfProductsOfDeltas / count();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "population",
            "covariance",
            "of",
            "the",
            "values"
        ]
    },
    {
        "id": 1313,
        "code": "public final double sampleCovariance() {\n  checkState(count() > 1);\n  return sumOfProductsOfDeltas / (count() - 1);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "sample",
            "covariance",
            "of",
            "the",
            "values"
        ]
    },
    {
        "id": 1314,
        "code": "public final double pearsonsCorrelationCoefficient() {\n  checkState(count() > 1);\n  if (isNaN(sumOfProductsOfDeltas)) {\n    return NaN;\n  }\n  double xSumOfSquaresOfDeltas = xStats.sumOfSquaresOfDeltas();\n  double ySumOfSquaresOfDeltas = yStats.sumOfSquaresOfDeltas();\n  checkState(xSumOfSquaresOfDeltas > 0.0);\n  checkState(ySumOfSquaresOfDeltas > 0.0);\n    \n    \n  double productOfSumsOfSquaresOfDeltas =\n      ensurePositive(xSumOfSquaresOfDeltas * ySumOfSquaresOfDeltas);\n  return ensureInUnitRange(sumOfProductsOfDeltas / Math.sqrt(productOfSumsOfSquaresOfDeltas));\n}",
        "summary_tokens": [
            "returns",
            "the",
            "a",
            "href",
            "http",
            "mathworld"
        ]
    },
    {
        "id": 1315,
        "code": "public final LinearTransformation leastSquaresFit() {\n  checkState(count() > 1);\n  if (isNaN(sumOfProductsOfDeltas)) {\n    return LinearTransformation.forNaN();\n  }\n  double xSumOfSquaresOfDeltas = xStats.sumOfSquaresOfDeltas();\n  if (xSumOfSquaresOfDeltas > 0.0) {\n    if (yStats.sumOfSquaresOfDeltas() > 0.0) {\n      return LinearTransformation.mapping(xStats.mean(), yStats.mean())\n          .withSlope(sumOfProductsOfDeltas / xSumOfSquaresOfDeltas);\n    } else {\n      return LinearTransformation.horizontal(yStats.mean());\n    }\n  } else {\n    checkState(yStats.sumOfSquaresOfDeltas() > 0.0);\n    return LinearTransformation.vertical(xStats.mean());\n  }\n}",
        "summary_tokens": [
            "returns",
            "a",
            "linear",
            "transformation",
            "giving",
            "the",
            "best",
            "fit",
            "to",
            "the",
            "data",
            "according",
            "to",
            "a",
            "href",
            "http",
            "mathworld"
        ]
    },
    {
        "id": 1316,
        "code": "public static ScaleAndIndex median() {\n  return scale(2).index(1);\n}",
        "summary_tokens": [
            "specifies",
            "the",
            "computation",
            "of",
            "a",
            "median",
            "i"
        ]
    },
    {
        "id": 1317,
        "code": "public static Scale quartiles() {\n  return scale(4);\n}",
        "summary_tokens": [
            "specifies",
            "the",
            "computation",
            "of",
            "quartiles",
            "i"
        ]
    },
    {
        "id": 1318,
        "code": "public static Scale percentiles() {\n  return scale(100);\n}",
        "summary_tokens": [
            "specifies",
            "the",
            "computation",
            "of",
            "percentiles",
            "i"
        ]
    },
    {
        "id": 1319,
        "code": "public static Scale scale(int scale) {\n  return new Scale(scale);\n}",
        "summary_tokens": [
            "specifies",
            "the",
            "computation",
            "of",
            "q",
            "quantiles"
        ]
    },
    {
        "id": 1320,
        "code": "private static boolean containsNaN(double... dataset) {\n  for (double value : dataset) {\n    if (Double.isNaN(value)) {\n      return true;\n    }\n  }\n  return false;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "any",
            "of",
            "the",
            "values",
            "in",
            "dataset",
            "are",
            "na",
            "n"
        ]
    },
    {
        "id": 1321,
        "code": "private static double interpolate(double lower, double upper, double remainder, double scale) {\n  if (lower == NEGATIVE_INFINITY) {\n    if (upper == POSITIVE_INFINITY) {\n        \n      return NaN;\n    }\n      \n    return NEGATIVE_INFINITY;\n  }\n  if (upper == POSITIVE_INFINITY) {\n      \n    return POSITIVE_INFINITY;\n  }\n  return lower + (upper - lower) * remainder / scale;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "value",
            "a",
            "fraction",
            "remainder",
            "scale",
            "of",
            "the",
            "way",
            "between",
            "lower",
            "and",
            "upper"
        ]
    },
    {
        "id": 1322,
        "code": "private static void selectInPlace(int required, double[] array, int from, int to) {\n    \n    \n    \n  if (required == from) {\n    int min = from;\n    for (int index = from + 1; index <= to; index++) {\n      if (array[min] > array[index]) {\n        min = index;\n      }\n    }\n    if (min != from) {\n      swap(array, min, from);\n    }\n    return;\n  }\n\n    \n    \n  while (to > from) {\n    int partitionPoint = partition(array, from, to);\n    if (partitionPoint >= required) {\n      to = partitionPoint - 1;\n    }\n    if (partitionPoint <= required) {\n      from = partitionPoint + 1;\n    }\n  }\n}",
        "summary_tokens": [
            "performs",
            "an",
            "in",
            "place",
            "selection",
            "to",
            "find",
            "the",
            "element",
            "which",
            "would",
            "appear",
            "at",
            "a",
            "given",
            "index",
            "in",
            "a",
            "dataset",
            "if",
            "it",
            "were",
            "sorted"
        ]
    },
    {
        "id": 1323,
        "code": "private static int partition(double[] array, int from, int to) {\n    \n  movePivotToStartOfSlice(array, from, to);\n  double pivot = array[from];\n\n    \n    \n  int partitionPoint = to;\n  for (int i = to; i > from; i--) {\n    if (array[i] > pivot) {\n      swap(array, partitionPoint, i);\n      partitionPoint--;\n    }\n  }\n\n    \n    \n    \n  swap(array, from, partitionPoint);\n  return partitionPoint;\n}",
        "summary_tokens": [
            "performs",
            "a",
            "partition",
            "operation",
            "on",
            "the",
            "slice",
            "of",
            "array",
            "with",
            "elements",
            "in",
            "the",
            "range",
            "from",
            "to"
        ]
    },
    {
        "id": 1324,
        "code": "private static void movePivotToStartOfSlice(double[] array, int from, int to) {\n  int mid = (from + to) >>> 1;\n    \n    \n    \n    \n  boolean toLessThanMid = (array[to] < array[mid]);\n  boolean midLessThanFrom = (array[mid] < array[from]);\n  boolean toLessThanFrom = (array[to] < array[from]);\n  if (toLessThanMid == midLessThanFrom) {\n      \n    swap(array, mid, from);\n  } else if (toLessThanMid != toLessThanFrom) {\n      \n    swap(array, from, to);\n  }\n    \n}",
        "summary_tokens": [
            "selects",
            "the",
            "pivot",
            "to",
            "use",
            "namely",
            "the",
            "median",
            "of",
            "the",
            "values",
            "at",
            "from",
            "to",
            "and",
            "halfway",
            "between",
            "the",
            "two",
            "rounded",
            "down",
            "from",
            "array",
            "and",
            "ensure",
            "by",
            "swapping",
            "elements",
            "if",
            "necessary",
            "that",
            "that",
            "pivot",
            "value",
            "appears",
            "at",
            "the",
            "start",
            "of",
            "the",
            "slice",
            "i"
        ]
    },
    {
        "id": 1325,
        "code": "private static void selectAllInPlace(\n    int[] allRequired, int requiredFrom, int requiredTo, double[] array, int from, int to) {\n    \n  int requiredChosen = chooseNextSelection(allRequired, requiredFrom, requiredTo, from, to);\n  int required = allRequired[requiredChosen];\n\n    \n  selectInPlace(required, array, from, to);\n\n    \n  int requiredBelow = requiredChosen - 1;\n  while (requiredBelow >= requiredFrom && allRequired[requiredBelow] == required) {\n    requiredBelow--; \n  }\n  if (requiredBelow >= requiredFrom) {\n    selectAllInPlace(allRequired, requiredFrom, requiredBelow, array, from, required - 1);\n  }\n\n    \n  int requiredAbove = requiredChosen + 1;\n  while (requiredAbove <= requiredTo && allRequired[requiredAbove] == required) {\n    requiredAbove++; \n  }\n  if (requiredAbove <= requiredTo) {\n    selectAllInPlace(allRequired, requiredAbove, requiredTo, array, required + 1, to);\n  }\n}",
        "summary_tokens": [
            "performs",
            "an",
            "in",
            "place",
            "selection",
            "like",
            "select",
            "in",
            "place",
            "to",
            "select",
            "all",
            "the",
            "indexes",
            "all",
            "required",
            "i",
            "for",
            "i",
            "in",
            "the",
            "range",
            "required",
            "from",
            "required",
            "to"
        ]
    },
    {
        "id": 1326,
        "code": "private static int chooseNextSelection(\n    int[] allRequired, int requiredFrom, int requiredTo, int from, int to) {\n  if (requiredFrom == requiredTo) {\n    return requiredFrom; \n  }\n\n    \n    \n  int centerFloor = (from + to) >>> 1;\n\n    \n    \n    \n    \n    \n  int low = requiredFrom;\n  int high = requiredTo;\n  while (high > low + 1) {\n    int mid = (low + high) >>> 1;\n    if (allRequired[mid] > centerFloor) {\n      high = mid;\n    } else if (allRequired[mid] < centerFloor) {\n      low = mid;\n    } else {\n      return mid; \n    }\n  }\n\n    \n  if (from + to - allRequired[low] - allRequired[high] > 0) {\n    return high;\n  } else {\n    return low;\n  }\n}",
        "summary_tokens": [
            "chooses",
            "the",
            "next",
            "selection",
            "to",
            "do",
            "from",
            "the",
            "required",
            "selections"
        ]
    },
    {
        "id": 1327,
        "code": "private static void swap(double[] array, int i, int j) {\n  double temp = array[i];\n  array[i] = array[j];\n  array[j] = temp;\n}",
        "summary_tokens": [
            "swaps",
            "the",
            "values",
            "at",
            "i",
            "and",
            "j",
            "in",
            "array"
        ]
    },
    {
        "id": 1328,
        "code": "public static Stats of(LongStream values) {\n  return values\n      .collect(StatsAccumulator::new, StatsAccumulator::add, StatsAccumulator::addAll)\n      .snapshot();\n}",
        "summary_tokens": [
            "returns",
            "statistics",
            "over",
            "a",
            "dataset",
            "containing",
            "the",
            "given",
            "values"
        ]
    },
    {
        "id": 1329,
        "code": "public long count() {\n  return count;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "values"
        ]
    },
    {
        "id": 1330,
        "code": "public double mean() {\n  checkState(count != 0);\n  return mean;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "a",
            "href",
            "http",
            "en"
        ]
    },
    {
        "id": 1331,
        "code": "public double sum() {\n  return mean * count;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "sum",
            "of",
            "the",
            "values"
        ]
    },
    {
        "id": 1332,
        "code": "public double populationVariance() {\n  checkState(count > 0);\n  if (isNaN(sumOfSquaresOfDeltas)) {\n    return NaN;\n  }\n  if (count == 1) {\n    return 0.0;\n  }\n  return ensureNonNegative(sumOfSquaresOfDeltas) / count();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "a",
            "href",
            "http",
            "en"
        ]
    },
    {
        "id": 1333,
        "code": "public double populationStandardDeviation() {\n  return Math.sqrt(populationVariance());\n}",
        "summary_tokens": [
            "returns",
            "the",
            "a",
            "href",
            "http",
            "en"
        ]
    },
    {
        "id": 1334,
        "code": "public double sampleVariance() {\n  checkState(count > 1);\n  if (isNaN(sumOfSquaresOfDeltas)) {\n    return NaN;\n  }\n  return ensureNonNegative(sumOfSquaresOfDeltas) / (count - 1);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "a",
            "href",
            "http",
            "en"
        ]
    },
    {
        "id": 1335,
        "code": "public double sampleStandardDeviation() {\n  return Math.sqrt(sampleVariance());\n}",
        "summary_tokens": [
            "returns",
            "the",
            "a",
            "href",
            "http",
            "en"
        ]
    },
    {
        "id": 1336,
        "code": "public double min() {\n  checkState(count != 0);\n  return min;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "lowest",
            "value",
            "in",
            "the",
            "dataset"
        ]
    },
    {
        "id": 1337,
        "code": "public double max() {\n  checkState(count != 0);\n  return max;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "highest",
            "value",
            "in",
            "the",
            "dataset"
        ]
    },
    {
        "id": 1338,
        "code": "public static double meanOf(long... values) {\n  checkArgument(values.length > 0);\n  double mean = values[0];\n  for (int index = 1; index < values.length; index++) {\n    double value = values[index];\n    if (isFinite(value) && isFinite(mean)) {\n        \n      mean += (value - mean) / (index + 1);\n    } else {\n      mean = calculateNewMeanNonFinite(mean, value);\n    }\n  }\n  return mean;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "a",
            "href",
            "http",
            "en"
        ]
    },
    {
        "id": 1339,
        "code": "public byte[] toByteArray() {\n  ByteBuffer buff = ByteBuffer.allocate(BYTES).order(ByteOrder.LITTLE_ENDIAN);\n  writeTo(buff);\n  return buff.array();\n}",
        "summary_tokens": [
            "gets",
            "a",
            "byte",
            "array",
            "representation",
            "of",
            "this",
            "instance"
        ]
    },
    {
        "id": 1340,
        "code": "void writeTo(ByteBuffer buffer) {\n  checkNotNull(buffer);\n  checkArgument(\n      buffer.remaining() >= BYTES,\n      \"Expected at least Stats.BYTES = %s remaining , got %s\",\n      BYTES,\n      buffer.remaining());\n  buffer\n      .putLong(count)\n      .putDouble(mean)\n      .putDouble(sumOfSquaresOfDeltas)\n      .putDouble(min)\n      .putDouble(max);\n}",
        "summary_tokens": [
            "writes",
            "to",
            "the",
            "given",
            "byte",
            "buffer",
            "a",
            "byte",
            "representation",
            "of",
            "this",
            "instance"
        ]
    },
    {
        "id": 1341,
        "code": "public static Stats fromByteArray(byte[] byteArray) {\n  checkNotNull(byteArray);\n  checkArgument(\n      byteArray.length == BYTES,\n      \"Expected Stats.BYTES = %s remaining , got %s\",\n      BYTES,\n      byteArray.length);\n  return readFrom(ByteBuffer.wrap(byteArray).order(ByteOrder.LITTLE_ENDIAN));\n}",
        "summary_tokens": [
            "creates",
            "a",
            "stats",
            "instance",
            "from",
            "the",
            "given",
            "byte",
            "representation",
            "which",
            "was",
            "obtained",
            "by",
            "to",
            "byte",
            "array"
        ]
    },
    {
        "id": 1342,
        "code": "static Stats readFrom(ByteBuffer buffer) {\n  checkNotNull(buffer);\n  checkArgument(\n      buffer.remaining() >= BYTES,\n      \"Expected at least Stats.BYTES = %s remaining , got %s\",\n      BYTES,\n      buffer.remaining());\n  return new Stats(\n      buffer.getLong(),\n      buffer.getDouble(),\n      buffer.getDouble(),\n      buffer.getDouble(),\n      buffer.getDouble());\n}",
        "summary_tokens": [
            "creates",
            "a",
            "stats",
            "instance",
            "from",
            "the",
            "byte",
            "representation",
            "read",
            "from",
            "the",
            "given",
            "byte",
            "buffer"
        ]
    },
    {
        "id": 1343,
        "code": "public void add(double value) {\n  if (count == 0) {\n    count = 1;\n    mean = value;\n    min = value;\n    max = value;\n    if (!isFinite(value)) {\n      sumOfSquaresOfDeltas = NaN;\n    }\n  } else {\n    count++;\n    if (isFinite(value) && isFinite(mean)) {\n        \n      double delta = value - mean;\n      mean += delta / count;\n      sumOfSquaresOfDeltas += delta * (value - mean);\n    } else {\n      mean = calculateNewMeanNonFinite(mean, value);\n      sumOfSquaresOfDeltas = NaN;\n    }\n    min = Math.min(min, value);\n    max = Math.max(max, value);\n  }\n}",
        "summary_tokens": [
            "adds",
            "the",
            "given",
            "value",
            "to",
            "the",
            "dataset"
        ]
    },
    {
        "id": 1344,
        "code": "public void addAll(StatsAccumulator values) {\n  if (values.count() == 0) {\n    return;\n  }\n  merge(values.count(), values.mean(), values.sumOfSquaresOfDeltas(), values.min(), values.max());\n}",
        "summary_tokens": [
            "adds",
            "the",
            "given",
            "statistics",
            "to",
            "the",
            "dataset",
            "as",
            "if",
            "the",
            "individual",
            "values",
            "used",
            "to",
            "compute",
            "the",
            "statistics",
            "had",
            "been",
            "added",
            "directly"
        ]
    },
    {
        "id": 1345,
        "code": "public Stats snapshot() {\n  return new Stats(count, mean, sumOfSquaresOfDeltas, min, max);\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "snapshot",
            "of",
            "the",
            "current",
            "statistics"
        ]
    },
    {
        "id": 1346,
        "code": "public long count() {\n  return count;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "values"
        ]
    },
    {
        "id": 1347,
        "code": "public double mean() {\n  checkState(count != 0);\n  return mean;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "a",
            "href",
            "http",
            "en"
        ]
    },
    {
        "id": 1348,
        "code": "public final double sum() {\n  return mean * count;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "sum",
            "of",
            "the",
            "values"
        ]
    },
    {
        "id": 1349,
        "code": "public final double populationVariance() {\n  checkState(count != 0);\n  if (isNaN(sumOfSquaresOfDeltas)) {\n    return NaN;\n  }\n  if (count == 1) {\n    return 0.0;\n  }\n  return ensureNonNegative(sumOfSquaresOfDeltas) / count;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "a",
            "href",
            "http",
            "en"
        ]
    },
    {
        "id": 1350,
        "code": "public final double populationStandardDeviation() {\n  return Math.sqrt(populationVariance());\n}",
        "summary_tokens": [
            "returns",
            "the",
            "a",
            "href",
            "http",
            "en"
        ]
    },
    {
        "id": 1351,
        "code": "public final double sampleVariance() {\n  checkState(count > 1);\n  if (isNaN(sumOfSquaresOfDeltas)) {\n    return NaN;\n  }\n  return ensureNonNegative(sumOfSquaresOfDeltas) / (count - 1);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "a",
            "href",
            "http",
            "en"
        ]
    },
    {
        "id": 1352,
        "code": "public final double sampleStandardDeviation() {\n  return Math.sqrt(sampleVariance());\n}",
        "summary_tokens": [
            "returns",
            "the",
            "a",
            "href",
            "http",
            "en"
        ]
    },
    {
        "id": 1353,
        "code": "public double min() {\n  checkState(count != 0);\n  return min;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "lowest",
            "value",
            "in",
            "the",
            "dataset"
        ]
    },
    {
        "id": 1354,
        "code": "public double max() {\n  checkState(count != 0);\n  return max;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "highest",
            "value",
            "in",
            "the",
            "dataset"
        ]
    },
    {
        "id": 1355,
        "code": "static double calculateNewMeanNonFinite(double previousMean, double value) {\n    \n  if (isFinite(previousMean)) {\n      \n    return value;\n  } else if (isFinite(value) || previousMean == value) {\n      \n    return previousMean;\n  } else {\n      \n    return NaN;\n  }\n}",
        "summary_tokens": [
            "calculates",
            "the",
            "new",
            "value",
            "for",
            "the",
            "accumulated",
            "mean",
            "when",
            "a",
            "value",
            "is",
            "added",
            "in",
            "the",
            "case",
            "where",
            "at",
            "least",
            "one",
            "of",
            "the",
            "previous",
            "mean",
            "and",
            "the",
            "value",
            "is",
            "non",
            "finite"
        ]
    },
    {
        "id": 1356,
        "code": "final double roundToDouble(X x, RoundingMode mode) {\n  checkNotNull(x, \"x\");\n  checkNotNull(mode, \"mode\");\n  double roundArbitrarily = roundToDoubleArbitrarily(x);\n  if (Double.isInfinite(roundArbitrarily)) {\n    switch (mode) {\n      case DOWN:\n      case HALF_EVEN:\n      case HALF_DOWN:\n      case HALF_UP:\n        return Double.MAX_VALUE * sign(x);\n      case FLOOR:\n        return (roundArbitrarily == Double.POSITIVE_INFINITY)\n            ? Double.MAX_VALUE\n            : Double.NEGATIVE_INFINITY;\n      case CEILING:\n        return (roundArbitrarily == Double.POSITIVE_INFINITY)\n            ? Double.POSITIVE_INFINITY\n            : -Double.MAX_VALUE;\n      case UP:\n        return roundArbitrarily;\n      case UNNECESSARY:\n        throw new ArithmeticException(x + \" cannot be represented precisely as a double\");\n    }\n  }\n  X roundArbitrarilyAsX = toX(roundArbitrarily, RoundingMode.UNNECESSARY);\n  int cmpXToRoundArbitrarily = x.compareTo(roundArbitrarilyAsX);\n  switch (mode) {\n    case UNNECESSARY:\n      checkRoundingUnnecessary(cmpXToRoundArbitrarily == 0);\n      return roundArbitrarily;\n    case FLOOR:\n      return (cmpXToRoundArbitrarily >= 0)\n          ? roundArbitrarily\n          : DoubleUtils.nextDown(roundArbitrarily);\n    case CEILING:\n      return (cmpXToRoundArbitrarily <= 0) ? roundArbitrarily : Math.nextUp(roundArbitrarily);\n    case DOWN:\n      if (sign(x) >= 0) {\n        return (cmpXToRoundArbitrarily >= 0)\n            ? roundArbitrarily\n            : DoubleUtils.nextDown(roundArbitrarily);\n      } else {\n        return (cmpXToRoundArbitrarily <= 0) ? roundArbitrarily : Math.nextUp(roundArbitrarily);\n      }\n    case UP:\n      if (sign(x) >= 0) {\n        return (cmpXToRoundArbitrarily <= 0) ? roundArbitrarily : Math.nextUp(roundArbitrarily);\n      } else {\n        return (cmpXToRoundArbitrarily >= 0)\n            ? roundArbitrarily\n            : DoubleUtils.nextDown(roundArbitrarily);\n      }\n    case HALF_DOWN:\n    case HALF_UP:\n    case HALF_EVEN:\n      {\n        X roundFloor;\n        double roundFloorAsDouble;\n        X roundCeiling;\n        double roundCeilingAsDouble;\n\n        if (cmpXToRoundArbitrarily >= 0) {\n          roundFloorAsDouble = roundArbitrarily;\n          roundFloor = roundArbitrarilyAsX;\n          roundCeilingAsDouble = Math.nextUp(roundArbitrarily);\n          if (roundCeilingAsDouble == Double.POSITIVE_INFINITY) {\n            return roundFloorAsDouble;\n          }\n          roundCeiling = toX(roundCeilingAsDouble, RoundingMode.CEILING);\n        } else {\n          roundCeilingAsDouble = roundArbitrarily;\n          roundCeiling = roundArbitrarilyAsX;\n          roundFloorAsDouble = DoubleUtils.nextDown(roundArbitrarily);\n          if (roundFloorAsDouble == Double.NEGATIVE_INFINITY) {\n            return roundCeilingAsDouble;\n          }\n          roundFloor = toX(roundFloorAsDouble, RoundingMode.FLOOR);\n        }\n\n        X deltaToFloor = minus(x, roundFloor);\n        X deltaToCeiling = minus(roundCeiling, x);\n        int diff = deltaToFloor.compareTo(deltaToCeiling);\n        if (diff < 0) { \n          return roundFloorAsDouble;\n        } else if (diff > 0) { \n          return roundCeilingAsDouble;\n        }\n          \n        switch (mode) {\n          case HALF_EVEN:\n              \n              \n            return ((Double.doubleToRawLongBits(roundFloorAsDouble) & 1L) == 0)\n                ? roundFloorAsDouble\n                : roundCeilingAsDouble;\n          case HALF_DOWN:\n            return (sign(x) >= 0) ? roundFloorAsDouble : roundCeilingAsDouble;\n          case HALF_UP:\n            return (sign(x) >= 0) ? roundCeilingAsDouble : roundFloorAsDouble;\n          default:\n            throw new AssertionError(\"impossible\");\n        }\n      }\n  }\n  throw new AssertionError(\"impossible\");\n}",
        "summary_tokens": [
            "rounds",
            "x",
            "to",
            "a",
            "double"
        ]
    },
    {
        "id": 1357,
        "code": "public String getHost() {\n  return host;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "portion",
            "of",
            "this",
            "host",
            "and",
            "port",
            "instance",
            "that",
            "should",
            "represent",
            "the",
            "hostname",
            "or",
            "ipv",
            "0",
            "ipv",
            "0",
            "literal"
        ]
    },
    {
        "id": 1358,
        "code": "public boolean hasPort() {\n  return port >= 0;\n}",
        "summary_tokens": [
            "return",
            "true",
            "if",
            "this",
            "instance",
            "has",
            "a",
            "defined",
            "port"
        ]
    },
    {
        "id": 1359,
        "code": "public int getPort() {\n  checkState(hasPort());\n  return port;\n}",
        "summary_tokens": [
            "get",
            "the",
            "current",
            "port",
            "number",
            "failing",
            "if",
            "no",
            "port",
            "is",
            "defined"
        ]
    },
    {
        "id": 1360,
        "code": "public int getPortOrDefault(int defaultPort) {\n  return hasPort() ? port : defaultPort;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "current",
            "port",
            "number",
            "with",
            "a",
            "default",
            "if",
            "no",
            "port",
            "is",
            "defined"
        ]
    },
    {
        "id": 1361,
        "code": "public static HostAndPort fromParts(String host, int port) {\n  checkArgument(isValidPort(port), \"Port out of range: %s\", port);\n  HostAndPort parsedHost = fromString(host);\n  checkArgument(!parsedHost.hasPort(), \"Host has a port: %s\", host);\n  return new HostAndPort(parsedHost.host, port, parsedHost.hasBracketlessColons);\n}",
        "summary_tokens": [
            "build",
            "a",
            "host",
            "and",
            "port",
            "instance",
            "from",
            "separate",
            "host",
            "and",
            "port",
            "values"
        ]
    },
    {
        "id": 1362,
        "code": "public static HostAndPort fromHost(String host) {\n  HostAndPort parsedHost = fromString(host);\n  checkArgument(!parsedHost.hasPort(), \"Host has a port: %s\", host);\n  return parsedHost;\n}",
        "summary_tokens": [
            "build",
            "a",
            "host",
            "and",
            "port",
            "instance",
            "from",
            "a",
            "host",
            "only"
        ]
    },
    {
        "id": 1363,
        "code": "public static HostAndPort fromString(String hostPortString) {\n  checkNotNull(hostPortString);\n  String host;\n  String portString = null;\n  boolean hasBracketlessColons = false;\n\n  if (hostPortString.startsWith(\"[\")) {\n    String[] hostAndPort = getHostAndPortFromBracketedHost(hostPortString);\n    host = hostAndPort[0];\n    portString = hostAndPort[1];\n  } else {\n    int colonPos = hostPortString.indexOf(':');\n    if (colonPos >= 0 && hostPortString.indexOf(':', colonPos + 1) == -1) {\n        \n      host = hostPortString.substring(0, colonPos);\n      portString = hostPortString.substring(colonPos + 1);\n    } else {\n        \n      host = hostPortString;\n      hasBracketlessColons = (colonPos >= 0);\n    }\n  }\n\n  int port = NO_PORT;\n  if (!Strings.isNullOrEmpty(portString)) {\n      \n      \n    checkArgument(\n        !portString.startsWith(\"+\") && CharMatcher.ascii().matchesAllOf(portString),\n        \"Unparseable port number: %s\",\n        hostPortString);\n    try {\n      port = Integer.parseInt(portString);\n    } catch (NumberFormatException e) {\n      throw new IllegalArgumentException(\"Unparseable port number: \" + hostPortString);\n    }\n    checkArgument(isValidPort(port), \"Port number out of range: %s\", hostPortString);\n  }\n\n  return new HostAndPort(host, port, hasBracketlessColons);\n}",
        "summary_tokens": [
            "split",
            "a",
            "freeform",
            "string",
            "into",
            "a",
            "host",
            "and",
            "port",
            "without",
            "strict",
            "validation"
        ]
    },
    {
        "id": 1364,
        "code": "private static String[] getHostAndPortFromBracketedHost(String hostPortString) {\n  checkArgument(\n      hostPortString.charAt(0) == '[',\n      \"Bracketed host-port string must start with a bracket: %s\",\n      hostPortString);\n  int colonIndex = hostPortString.indexOf(':');\n  int closeBracketIndex = hostPortString.lastIndexOf(']');\n  checkArgument(\n      colonIndex > -1 && closeBracketIndex > colonIndex,\n      \"Invalid bracketed host/port: %s\",\n      hostPortString);\n\n  String host = hostPortString.substring(1, closeBracketIndex);\n  if (closeBracketIndex + 1 == hostPortString.length()) {\n    return new String[] {host, \"\"};\n  } else {\n    checkArgument(\n        hostPortString.charAt(closeBracketIndex + 1) == ':',\n        \"Only a colon may follow a close bracket: %s\",\n        hostPortString);\n    for (int i = closeBracketIndex + 2; i < hostPortString.length(); ++i) {\n      checkArgument(\n          Character.isDigit(hostPortString.charAt(i)),\n          \"Port must be numeric: %s\",\n          hostPortString);\n    }\n    return new String[] {host, hostPortString.substring(closeBracketIndex + 2)};\n  }\n}",
        "summary_tokens": [
            "parses",
            "a",
            "bracketed",
            "host",
            "port",
            "string",
            "throwing",
            "illegal",
            "argument",
            "exception",
            "if",
            "parsing",
            "fails"
        ]
    },
    {
        "id": 1365,
        "code": "public HostAndPort withDefaultPort(int defaultPort) {\n  checkArgument(isValidPort(defaultPort));\n  if (hasPort()) {\n    return this;\n  }\n  return new HostAndPort(host, defaultPort, hasBracketlessColons);\n}",
        "summary_tokens": [
            "provide",
            "a",
            "default",
            "port",
            "if",
            "the",
            "parsed",
            "string",
            "contained",
            "only",
            "a",
            "host"
        ]
    },
    {
        "id": 1366,
        "code": "public HostAndPort requireBracketsForIPv6() {\n  checkArgument(!hasBracketlessColons, \"Possible bracketless IPv6 literal: %s\", host);\n  return this;\n}",
        "summary_tokens": [
            "generate",
            "an",
            "error",
            "if",
            "the",
            "host",
            "might",
            "be",
            "a",
            "non",
            "bracketed",
            "ipv",
            "0",
            "literal"
        ]
    },
    {
        "id": 1367,
        "code": "public String toString() {\n    \n  StringBuilder builder = new StringBuilder(host.length() + 8);\n  if (host.indexOf(':') >= 0) {\n    builder.append('[').append(host).append(']');\n  } else {\n    builder.append(host);\n  }\n  if (hasPort()) {\n    builder.append(':').append(port);\n  }\n  return builder.toString();\n}",
        "summary_tokens": [
            "rebuild",
            "the",
            "host",
            "port",
            "string",
            "including",
            "brackets",
            "if",
            "necessary"
        ]
    },
    {
        "id": 1368,
        "code": "private static boolean isValidPort(int port) {\n  return port >= 0 && port <= 65535;\n}",
        "summary_tokens": [
            "return",
            "true",
            "for",
            "valid",
            "port",
            "numbers"
        ]
    },
    {
        "id": 1369,
        "code": "public static HostSpecifier fromValid(String specifier) {\n    \n    \n  HostAndPort parsedHost = HostAndPort.fromString(specifier);\n  Preconditions.checkArgument(!parsedHost.hasPort());\n  String host = parsedHost.getHost();\n\n    \n    \n    \n    \n  InetAddress addr = null;\n  try {\n    addr = InetAddresses.forString(host);\n  } catch (IllegalArgumentException e) {\n      \n  }\n\n  if (addr != null) {\n    return new HostSpecifier(InetAddresses.toUriString(addr));\n  }\n\n    \n\n    \n  InternetDomainName domain = InternetDomainName.from(host);\n\n  if (domain.hasPublicSuffix()) {\n    return new HostSpecifier(domain.toString());\n  }\n\n  throw new IllegalArgumentException(\n      \"Domain name does not have a recognized public suffix: \" + host);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "host",
            "specifier",
            "built",
            "from",
            "the",
            "provided",
            "specifier",
            "which",
            "is",
            "already",
            "known",
            "to",
            "be",
            "valid"
        ]
    },
    {
        "id": 1370,
        "code": "public static HostSpecifier from(String specifier) throws ParseException {\n  try {\n    return fromValid(specifier);\n  } catch (IllegalArgumentException e) {\n      \n      \n      \n\n    ParseException parseException = new ParseException(\"Invalid host specifier: \" + specifier, 0);\n    parseException.initCause(e);\n    throw parseException;\n  }\n}",
        "summary_tokens": [
            "attempts",
            "to",
            "return",
            "a",
            "host",
            "specifier",
            "for",
            "the",
            "given",
            "string",
            "throwing",
            "an",
            "exception",
            "if",
            "parsing",
            "fails"
        ]
    },
    {
        "id": 1371,
        "code": "public static boolean isValid(String specifier) {\n  try {\n    fromValid(specifier);\n    return true;\n  } catch (IllegalArgumentException e) {\n    return false;\n  }\n}",
        "summary_tokens": [
            "determines",
            "whether",
            "specifier",
            "represents",
            "a",
            "valid",
            "host",
            "specifier",
            "as",
            "described",
            "in",
            "the",
            "documentation",
            "for",
            "from",
            "valid",
            "string"
        ]
    },
    {
        "id": 1372,
        "code": "public String toString() {\n  return canonicalForm;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "string",
            "representation",
            "of",
            "the",
            "host",
            "specifier",
            "suitable",
            "for",
            "inclusion",
            "in",
            "a",
            "uri"
        ]
    },
    {
        "id": 1373,
        "code": "private static Inet4Address getInet4Address(byte[] bytes) {\n  checkArgument(\n      bytes.length == 4,\n      \"Byte array has invalid length for an IPv4 address: %s != 4.\",\n      bytes.length);\n\n    \n  return (Inet4Address) bytesToInetAddress(bytes);\n}",
        "summary_tokens": [
            "returns",
            "an",
            "inet",
            "0",
            "address",
            "given",
            "a",
            "byte",
            "array",
            "representation",
            "of",
            "the",
            "ipv",
            "0",
            "address"
        ]
    },
    {
        "id": 1374,
        "code": "public static InetAddress forString(String ipString) {\n  byte[] addr = ipStringToBytes(ipString);\n\n    \n  if (addr == null) {\n    throw formatIllegalArgumentException(\"'%s' is not an IP string literal.\", ipString);\n  }\n\n  return bytesToInetAddress(addr);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "inet",
            "address",
            "having",
            "the",
            "given",
            "string",
            "representation"
        ]
    },
    {
        "id": 1375,
        "code": "public static boolean isInetAddress(String ipString) {\n  return ipStringToBytes(ipString) != null;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "the",
            "supplied",
            "string",
            "is",
            "a",
            "valid",
            "ip",
            "string",
            "literal",
            "false",
            "otherwise"
        ]
    },
    {
        "id": 1376,
        "code": "private static byte[] ipStringToBytes(String ipStringParam) {\n  String ipString = ipStringParam;\n    \n  boolean hasColon = false;\n  boolean hasDot = false;\n  int percentIndex = -1;\n  for (int i = 0; i < ipString.length(); i++) {\n    char c = ipString.charAt(i);\n    if (c == '.') {\n      hasDot = true;\n    } else if (c == ':') {\n      if (hasDot) {\n        return null; \n      }\n      hasColon = true;\n    } else if (c == '%') {\n      percentIndex = i;\n      break; \n    } else if (Character.digit(c, 16) == -1) {\n      return null; \n    }\n  }\n\n    \n  if (hasColon) {\n    if (hasDot) {\n      ipString = convertDottedQuadToHex(ipString);\n      if (ipString == null) {\n        return null;\n      }\n    }\n    if (percentIndex != -1) {\n      ipString = ipString.substring(0, percentIndex);\n    }\n    return textToNumericFormatV6(ipString);\n  } else if (hasDot) {\n    if (percentIndex != -1) {\n      return null; \n    }\n    return textToNumericFormatV4(ipString);\n  }\n  return null;\n}",
        "summary_tokens": [
            "returns",
            "null",
            "if",
            "unable",
            "to",
            "parse",
            "into",
            "a",
            "byte"
        ]
    },
    {
        "id": 1377,
        "code": "private static InetAddress bytesToInetAddress(byte[] addr) {\n  try {\n    return InetAddress.getByAddress(addr);\n  } catch (UnknownHostException e) {\n    throw new AssertionError(e);\n  }\n}",
        "summary_tokens": [
            "convert",
            "a",
            "byte",
            "array",
            "into",
            "an",
            "inet",
            "address"
        ]
    },
    {
        "id": 1378,
        "code": "public static String toAddrString(InetAddress ip) {\n  checkNotNull(ip);\n  if (ip instanceof Inet4Address) {\n      \n    return ip.getHostAddress();\n  }\n  checkArgument(ip instanceof Inet6Address);\n  byte[] bytes = ip.getAddress();\n  int[] hextets = new int[IPV6_PART_COUNT];\n  for (int i = 0; i < hextets.length; i++) {\n    hextets[i] = Ints.fromBytes((byte) 0, (byte) 0, bytes[2 * i], bytes[2 * i + 1]);\n  }\n  compressLongestRunOfZeroes(hextets);\n  return hextetsToIPv6String(hextets);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "string",
            "representation",
            "of",
            "an",
            "inet",
            "address"
        ]
    },
    {
        "id": 1379,
        "code": "private static void compressLongestRunOfZeroes(int[] hextets) {\n  int bestRunStart = -1;\n  int bestRunLength = -1;\n  int runStart = -1;\n  for (int i = 0; i < hextets.length + 1; i++) {\n    if (i < hextets.length && hextets[i] == 0) {\n      if (runStart < 0) {\n        runStart = i;\n      }\n    } else if (runStart >= 0) {\n      int runLength = i - runStart;\n      if (runLength > bestRunLength) {\n        bestRunStart = runStart;\n        bestRunLength = runLength;\n      }\n      runStart = -1;\n    }\n  }\n  if (bestRunLength >= 2) {\n    Arrays.fill(hextets, bestRunStart, bestRunStart + bestRunLength, -1);\n  }\n}",
        "summary_tokens": [
            "identify",
            "and",
            "mark",
            "the",
            "longest",
            "run",
            "of",
            "zeroes",
            "in",
            "an",
            "ipv",
            "0",
            "address"
        ]
    },
    {
        "id": 1380,
        "code": "private static String hextetsToIPv6String(int[] hextets) {\n    \n    \n    \n    \n  StringBuilder buf = new StringBuilder(39);\n  boolean lastWasNumber = false;\n  for (int i = 0; i < hextets.length; i++) {\n    boolean thisIsNumber = hextets[i] >= 0;\n    if (thisIsNumber) {\n      if (lastWasNumber) {\n        buf.append(':');\n      }\n      buf.append(Integer.toHexString(hextets[i]));\n    } else {\n      if (i == 0 || lastWasNumber) {\n        buf.append(\"::\");\n      }\n    }\n    lastWasNumber = thisIsNumber;\n  }\n  return buf.toString();\n}",
        "summary_tokens": [
            "convert",
            "a",
            "list",
            "of",
            "hextets",
            "into",
            "a",
            "human",
            "readable",
            "ipv",
            "0",
            "address"
        ]
    },
    {
        "id": 1381,
        "code": "public static String toUriString(InetAddress ip) {\n  if (ip instanceof Inet6Address) {\n    return \"[\" + toAddrString(ip) + \"]\";\n  }\n  return toAddrString(ip);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "string",
            "representation",
            "of",
            "an",
            "inet",
            "address",
            "suitable",
            "for",
            "inclusion",
            "in",
            "a",
            "uri"
        ]
    },
    {
        "id": 1382,
        "code": "public static InetAddress forUriString(String hostAddr) {\n  InetAddress addr = forUriStringNoThrow(hostAddr);\n  if (addr == null) {\n    throw formatIllegalArgumentException(\"Not a valid URI IP literal: '%s'\", hostAddr);\n  }\n\n  return addr;\n}",
        "summary_tokens": [
            "returns",
            "an",
            "inet",
            "address",
            "representing",
            "the",
            "literal",
            "ipv",
            "0",
            "or",
            "ipv",
            "0",
            "host",
            "portion",
            "of",
            "a",
            "url",
            "encoded",
            "in",
            "the",
            "format",
            "specified",
            "by",
            "rfc",
            "0",
            "section",
            "0"
        ]
    },
    {
        "id": 1383,
        "code": "public static boolean isUriInetAddress(String ipString) {\n  return forUriStringNoThrow(ipString) != null;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "the",
            "supplied",
            "string",
            "is",
            "a",
            "valid",
            "uri",
            "ip",
            "string",
            "literal",
            "false",
            "otherwise"
        ]
    },
    {
        "id": 1384,
        "code": "public static boolean isCompatIPv4Address(Inet6Address ip) {\n  if (!ip.isIPv4CompatibleAddress()) {\n    return false;\n  }\n\n  byte[] bytes = ip.getAddress();\n  if ((bytes[12] == 0)\n      && (bytes[13] == 0)\n      && (bytes[14] == 0)\n      && ((bytes[15] == 0) || (bytes[15] == 1))) {\n    return false;\n  }\n\n  return true;\n}",
        "summary_tokens": [
            "evaluates",
            "whether",
            "the",
            "argument",
            "is",
            "an",
            "ipv",
            "0",
            "compat",
            "address"
        ]
    },
    {
        "id": 1385,
        "code": "public static Inet4Address getCompatIPv4Address(Inet6Address ip) {\n  checkArgument(\n      isCompatIPv4Address(ip), \"Address '%s' is not IPv4-compatible.\", toAddrString(ip));\n\n  return getInet4Address(Arrays.copyOfRange(ip.getAddress(), 12, 16));\n}",
        "summary_tokens": [
            "returns",
            "the",
            "ipv",
            "0",
            "address",
            "embedded",
            "in",
            "an",
            "ipv",
            "0",
            "compatible",
            "address"
        ]
    },
    {
        "id": 1386,
        "code": "public static boolean is6to4Address(Inet6Address ip) {\n  byte[] bytes = ip.getAddress();\n  return (bytes[0] == (byte) 0x20) && (bytes[1] == (byte) 0x02);\n}",
        "summary_tokens": [
            "evaluates",
            "whether",
            "the",
            "argument",
            "is",
            "a",
            "0",
            "to",
            "0",
            "address"
        ]
    },
    {
        "id": 1387,
        "code": "public static Inet4Address get6to4IPv4Address(Inet6Address ip) {\n  checkArgument(is6to4Address(ip), \"Address '%s' is not a 6to4 address.\", toAddrString(ip));\n\n  return getInet4Address(Arrays.copyOfRange(ip.getAddress(), 2, 6));\n}",
        "summary_tokens": [
            "returns",
            "the",
            "ipv",
            "0",
            "address",
            "embedded",
            "in",
            "a",
            "0",
            "to",
            "0",
            "address"
        ]
    },
    {
        "id": 1388,
        "code": "public static boolean isTeredoAddress(Inet6Address ip) {\n  byte[] bytes = ip.getAddress();\n  return (bytes[0] == (byte) 0x20)\n      && (bytes[1] == (byte) 0x01)\n      && (bytes[2] == 0)\n      && (bytes[3] == 0);\n}",
        "summary_tokens": [
            "evaluates",
            "whether",
            "the",
            "argument",
            "is",
            "a",
            "teredo",
            "address"
        ]
    },
    {
        "id": 1389,
        "code": "public static TeredoInfo getTeredoInfo(Inet6Address ip) {\n  checkArgument(isTeredoAddress(ip), \"Address '%s' is not a Teredo address.\", toAddrString(ip));\n\n  byte[] bytes = ip.getAddress();\n  Inet4Address server = getInet4Address(Arrays.copyOfRange(bytes, 4, 8));\n\n  int flags = ByteStreams.newDataInput(bytes, 8).readShort() & 0xffff;\n\n    \n  int port = ~ByteStreams.newDataInput(bytes, 10).readShort() & 0xffff;\n\n  byte[] clientBytes = Arrays.copyOfRange(bytes, 12, 16);\n  for (int i = 0; i < clientBytes.length; i++) {\n      \n    clientBytes[i] = (byte) ~clientBytes[i];\n  }\n  Inet4Address client = getInet4Address(clientBytes);\n\n  return new TeredoInfo(server, client, port, flags);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "teredo",
            "information",
            "embedded",
            "in",
            "a",
            "teredo",
            "address"
        ]
    },
    {
        "id": 1390,
        "code": "public static boolean isIsatapAddress(Inet6Address ip) {\n\n    \n    \n  if (isTeredoAddress(ip)) {\n    return false;\n  }\n\n  byte[] bytes = ip.getAddress();\n\n  if ((bytes[8] | (byte) 0x03) != (byte) 0x03) {\n\n      \n      \n    return false;\n  }\n\n  return (bytes[9] == (byte) 0x00) && (bytes[10] == (byte) 0x5e) && (bytes[11] == (byte) 0xfe);\n}",
        "summary_tokens": [
            "evaluates",
            "whether",
            "the",
            "argument",
            "is",
            "an",
            "isatap",
            "address"
        ]
    },
    {
        "id": 1391,
        "code": "public static Inet4Address getIsatapIPv4Address(Inet6Address ip) {\n  checkArgument(isIsatapAddress(ip), \"Address '%s' is not an ISATAP address.\", toAddrString(ip));\n\n  return getInet4Address(Arrays.copyOfRange(ip.getAddress(), 12, 16));\n}",
        "summary_tokens": [
            "returns",
            "the",
            "ipv",
            "0",
            "address",
            "embedded",
            "in",
            "an",
            "isatap",
            "address"
        ]
    },
    {
        "id": 1392,
        "code": "public static boolean hasEmbeddedIPv4ClientAddress(Inet6Address ip) {\n  return isCompatIPv4Address(ip) || is6to4Address(ip) || isTeredoAddress(ip);\n}",
        "summary_tokens": [
            "examines",
            "the",
            "inet",
            "0",
            "address",
            "to",
            "determine",
            "if",
            "it",
            "is",
            "an",
            "ipv",
            "0",
            "address",
            "of",
            "one",
            "of",
            "the",
            "specified",
            "address",
            "types",
            "that",
            "contain",
            "an",
            "embedded",
            "ipv",
            "0",
            "address"
        ]
    },
    {
        "id": 1393,
        "code": "public static Inet4Address getEmbeddedIPv4ClientAddress(Inet6Address ip) {\n  if (isCompatIPv4Address(ip)) {\n    return getCompatIPv4Address(ip);\n  }\n\n  if (is6to4Address(ip)) {\n    return get6to4IPv4Address(ip);\n  }\n\n  if (isTeredoAddress(ip)) {\n    return getTeredoInfo(ip).getClient();\n  }\n\n  throw formatIllegalArgumentException(\"'%s' has no embedded IPv4 address.\", toAddrString(ip));\n}",
        "summary_tokens": [
            "examines",
            "the",
            "inet",
            "0",
            "address",
            "to",
            "extract",
            "the",
            "embedded",
            "ipv",
            "0",
            "client",
            "address",
            "if",
            "the",
            "inet",
            "address",
            "is",
            "an",
            "ipv",
            "0",
            "address",
            "of",
            "one",
            "of",
            "the",
            "specified",
            "address",
            "types",
            "that",
            "contain",
            "an",
            "embedded",
            "ipv",
            "0",
            "address"
        ]
    },
    {
        "id": 1394,
        "code": "public static boolean isMappedIPv4Address(String ipString) {\n  byte[] bytes = ipStringToBytes(ipString);\n  if (bytes != null && bytes.length == 16) {\n    for (int i = 0; i < 10; i++) {\n      if (bytes[i] != 0) {\n        return false;\n      }\n    }\n    for (int i = 10; i < 12; i++) {\n      if (bytes[i] != (byte) 0xff) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return false;\n}",
        "summary_tokens": [
            "evaluates",
            "whether",
            "the",
            "argument",
            "is",
            "an",
            "ipv",
            "0",
            "mapped",
            "ipv",
            "0",
            "address"
        ]
    },
    {
        "id": 1395,
        "code": "public static Inet4Address getCoercedIPv4Address(InetAddress ip) {\n  if (ip instanceof Inet4Address) {\n    return (Inet4Address) ip;\n  }\n\n    \n  byte[] bytes = ip.getAddress();\n  boolean leadingBytesOfZero = true;\n  for (int i = 0; i < 15; ++i) {\n    if (bytes[i] != 0) {\n      leadingBytesOfZero = false;\n      break;\n    }\n  }\n  if (leadingBytesOfZero && (bytes[15] == 1)) {\n    return LOOPBACK4; \n  } else if (leadingBytesOfZero && (bytes[15] == 0)) {\n    return ANY4; \n  }\n\n  Inet6Address ip6 = (Inet6Address) ip;\n  long addressAsLong = 0;\n  if (hasEmbeddedIPv4ClientAddress(ip6)) {\n    addressAsLong = getEmbeddedIPv4ClientAddress(ip6).hashCode();\n  } else {\n      \n    addressAsLong = ByteBuffer.wrap(ip6.getAddress(), 0, 8).getLong();\n  }\n\n    \n  int coercedHash = Hashing.murmur3_32_fixed().hashLong(addressAsLong).asInt();\n\n    \n  coercedHash |= 0xe0000000;\n\n    \n    \n  if (coercedHash == 0xffffffff) {\n    coercedHash = 0xfffffffe;\n  }\n\n  return getInet4Address(Ints.toByteArray(coercedHash));\n}",
        "summary_tokens": [
            "coerces",
            "an",
            "ipv",
            "0",
            "address",
            "into",
            "an",
            "ipv",
            "0",
            "address"
        ]
    },
    {
        "id": 1396,
        "code": "public static int coerceToInteger(InetAddress ip) {\n  return ByteStreams.newDataInput(getCoercedIPv4Address(ip).getAddress()).readInt();\n}",
        "summary_tokens": [
            "returns",
            "an",
            "integer",
            "representing",
            "an",
            "ipv",
            "0",
            "address",
            "regardless",
            "of",
            "whether",
            "the",
            "supplied",
            "argument",
            "is",
            "an",
            "ipv",
            "0",
            "address",
            "or",
            "not"
        ]
    },
    {
        "id": 1397,
        "code": "public static BigInteger toBigInteger(InetAddress address) {\n  return new BigInteger(1, address.getAddress());\n}",
        "summary_tokens": [
            "returns",
            "a",
            "big",
            "integer",
            "representing",
            "the",
            "address"
        ]
    },
    {
        "id": 1398,
        "code": "public static Inet4Address fromInteger(int address) {\n  return getInet4Address(Ints.toByteArray(address));\n}",
        "summary_tokens": [
            "returns",
            "an",
            "inet",
            "0",
            "address",
            "having",
            "the",
            "integer",
            "value",
            "specified",
            "by",
            "the",
            "argument"
        ]
    },
    {
        "id": 1399,
        "code": "public static Inet4Address fromIPv4BigInteger(BigInteger address) {\n  return (Inet4Address) fromBigInteger(address, false);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "inet",
            "0",
            "address",
            "corresponding",
            "to",
            "a",
            "given",
            "big",
            "integer"
        ]
    },
    {
        "id": 1400,
        "code": "public static Inet6Address fromIPv6BigInteger(BigInteger address) {\n  return (Inet6Address) fromBigInteger(address, true);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "inet",
            "0",
            "address",
            "corresponding",
            "to",
            "a",
            "given",
            "big",
            "integer"
        ]
    },
    {
        "id": 1401,
        "code": "private static InetAddress fromBigInteger(BigInteger address, boolean isIpv6) {\n  checkArgument(address.signum() >= 0, \"BigInteger must be greater than or equal to 0\");\n\n  int numBytes = isIpv6 ? 16 : 4;\n\n  byte[] addressBytes = address.toByteArray();\n  byte[] targetCopyArray = new byte[numBytes];\n\n  int srcPos = Math.max(0, addressBytes.length - numBytes);\n  int copyLength = addressBytes.length - srcPos;\n  int destPos = numBytes - copyLength;\n\n    \n  for (int i = 0; i < srcPos; i++) {\n    if (addressBytes[i] != 0x00) {\n      throw formatIllegalArgumentException(\n          \"BigInteger cannot be converted to InetAddress because it has more than %d\"\n              + \" bytes: %s\",\n          numBytes, address);\n    }\n  }\n\n    \n  System.arraycopy(addressBytes, srcPos, targetCopyArray, destPos, copyLength);\n\n  try {\n    return InetAddress.getByAddress(targetCopyArray);\n  } catch (UnknownHostException impossible) {\n    throw new AssertionError(impossible);\n  }\n}",
        "summary_tokens": [
            "converts",
            "a",
            "big",
            "integer",
            "to",
            "either",
            "an",
            "ipv",
            "0",
            "or",
            "ipv",
            "0",
            "address"
        ]
    },
    {
        "id": 1402,
        "code": "public static InetAddress fromLittleEndianByteArray(byte[] addr) throws UnknownHostException {\n  byte[] reversed = new byte[addr.length];\n  for (int i = 0; i < addr.length; i++) {\n    reversed[i] = addr[addr.length - i - 1];\n  }\n  return InetAddress.getByAddress(reversed);\n}",
        "summary_tokens": [
            "returns",
            "an",
            "address",
            "from",
            "a",
            "b",
            "little",
            "endian",
            "ordered",
            "b",
            "byte",
            "array",
            "the",
            "opposite",
            "of",
            "what",
            "inet",
            "address",
            "get",
            "by",
            "address",
            "expects"
        ]
    },
    {
        "id": 1403,
        "code": "public static InetAddress decrement(InetAddress address) {\n  byte[] addr = address.getAddress();\n  int i = addr.length - 1;\n  while (i >= 0 && addr[i] == (byte) 0x00) {\n    addr[i] = (byte) 0xff;\n    i--;\n  }\n\n  checkArgument(i >= 0, \"Decrementing %s would wrap.\", address);\n\n  addr[i]--;\n  return bytesToInetAddress(addr);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "inet",
            "address",
            "that",
            "is",
            "one",
            "less",
            "than",
            "the",
            "passed",
            "in",
            "address"
        ]
    },
    {
        "id": 1404,
        "code": "public static InetAddress increment(InetAddress address) {\n  byte[] addr = address.getAddress();\n  int i = addr.length - 1;\n  while (i >= 0 && addr[i] == (byte) 0xff) {\n    addr[i] = 0;\n    i--;\n  }\n\n  checkArgument(i >= 0, \"Incrementing %s would wrap.\", address);\n\n  addr[i]++;\n  return bytesToInetAddress(addr);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "inet",
            "address",
            "that",
            "is",
            "one",
            "more",
            "than",
            "the",
            "passed",
            "in",
            "address"
        ]
    },
    {
        "id": 1405,
        "code": "public static boolean isMaximum(InetAddress address) {\n  byte[] addr = address.getAddress();\n  for (byte b : addr) {\n    if (b != (byte) 0xff) {\n      return false;\n    }\n  }\n  return true;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "the",
            "inet",
            "address",
            "is",
            "either",
            "0"
        ]
    },
    {
        "id": 1406,
        "code": "private int findSuffixOfType(Optional<PublicSuffixType> desiredType) {\n  int partsSize = parts.size();\n\n  for (int i = 0; i < partsSize; i++) {\n    String ancestorName = DOT_JOINER.join(parts.subList(i, partsSize));\n\n    if (matchesType(\n        desiredType, Optional.fromNullable(PublicSuffixPatterns.EXACT.get(ancestorName)))) {\n      return i;\n    }\n\n      \n      \n\n    if (PublicSuffixPatterns.EXCLUDED.containsKey(ancestorName)) {\n      return i + 1;\n    }\n\n    if (matchesWildcardSuffixType(desiredType, ancestorName)) {\n      return i;\n    }\n  }\n\n  return NO_SUFFIX_FOUND;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "index",
            "of",
            "the",
            "leftmost",
            "part",
            "of",
            "the",
            "suffix",
            "or",
            "0",
            "if",
            "not",
            "found"
        ]
    },
    {
        "id": 1407,
        "code": "public static InternetDomainName from(String domain) {\n  return new InternetDomainName(checkNotNull(domain));\n}",
        "summary_tokens": [
            "returns",
            "an",
            "instance",
            "of",
            "internet",
            "domain",
            "name",
            "after",
            "lenient",
            "validation"
        ]
    },
    {
        "id": 1408,
        "code": "private static boolean validateSyntax(List<String> parts) {\n  int lastIndex = parts.size() - 1;\n\n    \n\n  if (!validatePart(parts.get(lastIndex), true)) {\n    return false;\n  }\n\n  for (int i = 0; i < lastIndex; i++) {\n    String part = parts.get(i);\n    if (!validatePart(part, false)) {\n      return false;\n    }\n  }\n\n  return true;\n}",
        "summary_tokens": [
            "validation",
            "method",
            "used",
            "by",
            "from",
            "to",
            "ensure",
            "that",
            "the",
            "domain",
            "name",
            "is",
            "syntactically",
            "valid",
            "according",
            "to",
            "rfc",
            "0"
        ]
    },
    {
        "id": 1409,
        "code": "private static boolean validatePart(String part, boolean isFinalPart) {\n\n    \n    \n\n  if (part.length() < 1 || part.length() > MAX_DOMAIN_PART_LENGTH) {\n    return false;\n  }\n\n    \n\n  String asciiChars = CharMatcher.ascii().retainFrom(part);\n\n  if (!PART_CHAR_MATCHER.matchesAllOf(asciiChars)) {\n    return false;\n  }\n\n    \n\n  if (DASH_MATCHER.matches(part.charAt(0))\n      || DASH_MATCHER.matches(part.charAt(part.length() - 1))) {\n    return false;\n  }\n\n    \n\n  if (isFinalPart && DIGIT_MATCHER.matches(part.charAt(0))) {\n    return false;\n  }\n\n  return true;\n}",
        "summary_tokens": [
            "helper",
            "method",
            "for",
            "validate",
            "syntax",
            "list"
        ]
    },
    {
        "id": 1410,
        "code": "public ImmutableList<String> parts() {\n  return parts;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "individual",
            "components",
            "of",
            "this",
            "domain",
            "name",
            "normalized",
            "to",
            "all",
            "lower",
            "case"
        ]
    },
    {
        "id": 1411,
        "code": "public boolean isPublicSuffix() {\n  return publicSuffixIndex == 0;\n}",
        "summary_tokens": [
            "indicates",
            "whether",
            "this",
            "domain",
            "name",
            "represents",
            "a",
            "i",
            "public",
            "suffix",
            "i",
            "as",
            "defined",
            "by",
            "the",
            "mozilla",
            "foundation",
            "s",
            "a",
            "href",
            "http",
            "publicsuffix"
        ]
    },
    {
        "id": 1412,
        "code": "public boolean hasPublicSuffix() {\n  return publicSuffixIndex != NO_SUFFIX_FOUND;\n}",
        "summary_tokens": [
            "indicates",
            "whether",
            "this",
            "domain",
            "name",
            "ends",
            "in",
            "a",
            "is",
            "public",
            "suffix",
            "public",
            "suffix",
            "including",
            "if",
            "it",
            "is",
            "a",
            "public",
            "suffix",
            "itself"
        ]
    },
    {
        "id": 1413,
        "code": "public InternetDomainName publicSuffix() {\n  return hasPublicSuffix() ? ancestor(publicSuffixIndex) : null;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "is",
            "public",
            "suffix",
            "public",
            "suffix",
            "portion",
            "of",
            "the",
            "domain",
            "name",
            "or",
            "null",
            "if",
            "no",
            "public",
            "suffix",
            "is",
            "present"
        ]
    },
    {
        "id": 1414,
        "code": "public boolean isUnderPublicSuffix() {\n  return publicSuffixIndex > 0;\n}",
        "summary_tokens": [
            "indicates",
            "whether",
            "this",
            "domain",
            "name",
            "ends",
            "in",
            "a",
            "is",
            "public",
            "suffix",
            "public",
            "suffix",
            "while",
            "not",
            "being",
            "a",
            "public",
            "suffix",
            "itself"
        ]
    },
    {
        "id": 1415,
        "code": "public boolean isTopPrivateDomain() {\n  return publicSuffixIndex == 1;\n}",
        "summary_tokens": [
            "indicates",
            "whether",
            "this",
            "domain",
            "name",
            "is",
            "composed",
            "of",
            "exactly",
            "one",
            "subdomain",
            "component",
            "followed",
            "by",
            "a",
            "is",
            "public",
            "suffix",
            "public",
            "suffix"
        ]
    },
    {
        "id": 1416,
        "code": "public InternetDomainName topPrivateDomain() {\n  if (isTopPrivateDomain()) {\n    return this;\n  }\n  checkState(isUnderPublicSuffix(), \"Not under a public suffix: %s\", name);\n  return ancestor(publicSuffixIndex - 1);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "portion",
            "of",
            "this",
            "domain",
            "name",
            "that",
            "is",
            "one",
            "level",
            "beneath",
            "the",
            "is",
            "public",
            "suffix",
            "public",
            "suffix"
        ]
    },
    {
        "id": 1417,
        "code": "public boolean isRegistrySuffix() {\n  return registrySuffixIndex == 0;\n}",
        "summary_tokens": [
            "indicates",
            "whether",
            "this",
            "domain",
            "name",
            "represents",
            "a",
            "i",
            "registry",
            "suffix",
            "i",
            "as",
            "defined",
            "by",
            "a",
            "subset",
            "of",
            "the",
            "mozilla",
            "foundation",
            "s",
            "a",
            "href",
            "http",
            "publicsuffix"
        ]
    },
    {
        "id": 1418,
        "code": "public boolean hasRegistrySuffix() {\n  return registrySuffixIndex != NO_SUFFIX_FOUND;\n}",
        "summary_tokens": [
            "indicates",
            "whether",
            "this",
            "domain",
            "name",
            "ends",
            "in",
            "a",
            "is",
            "registry",
            "suffix",
            "registry",
            "suffix",
            "including",
            "if",
            "it",
            "is",
            "a",
            "registry",
            "suffix",
            "itself"
        ]
    },
    {
        "id": 1419,
        "code": "public InternetDomainName registrySuffix() {\n  return hasRegistrySuffix() ? ancestor(registrySuffixIndex) : null;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "is",
            "registry",
            "suffix",
            "registry",
            "suffix",
            "portion",
            "of",
            "the",
            "domain",
            "name",
            "or",
            "null",
            "if",
            "no",
            "registry",
            "suffix",
            "is",
            "present"
        ]
    },
    {
        "id": 1420,
        "code": "public boolean isUnderRegistrySuffix() {\n  return registrySuffixIndex > 0;\n}",
        "summary_tokens": [
            "indicates",
            "whether",
            "this",
            "domain",
            "name",
            "ends",
            "in",
            "a",
            "is",
            "registry",
            "suffix",
            "registry",
            "suffix",
            "while",
            "not",
            "being",
            "a",
            "registry",
            "suffix",
            "itself"
        ]
    },
    {
        "id": 1421,
        "code": "public boolean isTopDomainUnderRegistrySuffix() {\n  return registrySuffixIndex == 1;\n}",
        "summary_tokens": [
            "indicates",
            "whether",
            "this",
            "domain",
            "name",
            "is",
            "composed",
            "of",
            "exactly",
            "one",
            "subdomain",
            "component",
            "followed",
            "by",
            "a",
            "is",
            "registry",
            "suffix",
            "registry",
            "suffix"
        ]
    },
    {
        "id": 1422,
        "code": "public InternetDomainName topDomainUnderRegistrySuffix() {\n  if (isTopDomainUnderRegistrySuffix()) {\n    return this;\n  }\n  checkState(isUnderRegistrySuffix(), \"Not under a registry suffix: %s\", name);\n  return ancestor(registrySuffixIndex - 1);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "portion",
            "of",
            "this",
            "domain",
            "name",
            "that",
            "is",
            "one",
            "level",
            "beneath",
            "the",
            "is",
            "registry",
            "suffix",
            "registry",
            "suffix"
        ]
    },
    {
        "id": 1423,
        "code": "public boolean hasParent() {\n  return parts.size() > 1;\n}",
        "summary_tokens": [
            "indicates",
            "whether",
            "this",
            "domain",
            "is",
            "composed",
            "of",
            "two",
            "or",
            "more",
            "parts"
        ]
    },
    {
        "id": 1424,
        "code": "public InternetDomainName parent() {\n  checkState(hasParent(), \"Domain '%s' has no parent\", name);\n  return ancestor(1);\n}",
        "summary_tokens": [
            "returns",
            "an",
            "internet",
            "domain",
            "name",
            "that",
            "is",
            "the",
            "immediate",
            "ancestor",
            "of",
            "this",
            "one",
            "that",
            "is",
            "the",
            "current",
            "domain",
            "with",
            "the",
            "leftmost",
            "part",
            "removed"
        ]
    },
    {
        "id": 1425,
        "code": "private InternetDomainName ancestor(int levels) {\n  return from(DOT_JOINER.join(parts.subList(levels, parts.size())));\n}",
        "summary_tokens": [
            "returns",
            "the",
            "ancestor",
            "of",
            "the",
            "current",
            "domain",
            "at",
            "the",
            "given",
            "number",
            "of",
            "levels",
            "higher",
            "rightward",
            "in",
            "the",
            "subdomain",
            "list"
        ]
    },
    {
        "id": 1426,
        "code": "public InternetDomainName child(String leftParts) {\n  return from(checkNotNull(leftParts) + \".\" + name);\n}",
        "summary_tokens": [
            "creates",
            "and",
            "returns",
            "a",
            "new",
            "internet",
            "domain",
            "name",
            "by",
            "prepending",
            "the",
            "argument",
            "and",
            "a",
            "dot",
            "to",
            "the",
            "current",
            "name"
        ]
    },
    {
        "id": 1427,
        "code": "public static boolean isValid(String name) {\n  try {\n    from(name);\n    return true;\n  } catch (IllegalArgumentException e) {\n    return false;\n  }\n}",
        "summary_tokens": [
            "indicates",
            "whether",
            "the",
            "argument",
            "is",
            "a",
            "syntactically",
            "valid",
            "domain",
            "name",
            "using",
            "lenient",
            "validation"
        ]
    },
    {
        "id": 1428,
        "code": "private static boolean matchesWildcardSuffixType(\n    Optional<PublicSuffixType> desiredType, String domain) {\n  List<String> pieces = DOT_SPLITTER.limit(2).splitToList(domain);\n  return pieces.size() == 2\n      && matchesType(\n          desiredType, Optional.fromNullable(PublicSuffixPatterns.UNDER.get(pieces.get(1))));\n}",
        "summary_tokens": [
            "does",
            "the",
            "domain",
            "name",
            "match",
            "one",
            "of",
            "the",
            "wildcard",
            "patterns",
            "e"
        ]
    },
    {
        "id": 1429,
        "code": "private static boolean matchesType(\n    Optional<PublicSuffixType> desiredType, Optional<PublicSuffixType> actualType) {\n  return desiredType.isPresent() ? desiredType.equals(actualType) : actualType.isPresent();\n}",
        "summary_tokens": [
            "if",
            "a",
            "desired",
            "type",
            "is",
            "specified",
            "returns",
            "true",
            "only",
            "if",
            "the",
            "actual",
            "type",
            "is",
            "identical"
        ]
    },
    {
        "id": 1430,
        "code": "public String toString() {\n  return name;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "domain",
            "name",
            "normalized",
            "to",
            "all",
            "lower",
            "case"
        ]
    },
    {
        "id": 1431,
        "code": "public boolean equals(@CheckForNull Object object) {\n  if (object == this) {\n    return true;\n  }\n\n  if (object instanceof InternetDomainName) {\n    InternetDomainName that = (InternetDomainName) object;\n    return this.name.equals(that.name);\n  }\n\n  return false;\n}",
        "summary_tokens": [
            "equality",
            "testing",
            "is",
            "based",
            "on",
            "the",
            "text",
            "supplied",
            "by",
            "the",
            "caller",
            "after",
            "normalization",
            "as",
            "described",
            "in",
            "the",
            "class",
            "documentation"
        ]
    },
    {
        "id": 1432,
        "code": "public String type() {\n  return type;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "top",
            "level",
            "media",
            "type"
        ]
    },
    {
        "id": 1433,
        "code": "public String subtype() {\n  return subtype;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "media",
            "subtype"
        ]
    },
    {
        "id": 1434,
        "code": "public ImmutableListMultimap<String, String> parameters() {\n  return parameters;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "multimap",
            "containing",
            "the",
            "parameters",
            "of",
            "this",
            "media",
            "type"
        ]
    },
    {
        "id": 1435,
        "code": "public Optional<Charset> charset() {\n    \n  Optional<Charset> local = parsedCharset;\n  if (local == null) {\n    String value = null;\n    local = Optional.absent();\n    for (String currentValue : parameters.get(CHARSET_ATTRIBUTE)) {\n      if (value == null) {\n        value = currentValue;\n        local = Optional.of(Charset.forName(value));\n      } else if (!value.equals(currentValue)) {\n        throw new IllegalStateException(\n            \"Multiple charset values defined: \" + value + \", \" + currentValue);\n      }\n    }\n    parsedCharset = local;\n  }\n  return local;\n}",
        "summary_tokens": [
            "returns",
            "an",
            "optional",
            "charset",
            "for",
            "the",
            "value",
            "of",
            "the",
            "charset",
            "parameter",
            "if",
            "it",
            "is",
            "specified"
        ]
    },
    {
        "id": 1436,
        "code": "public MediaType withoutParameters() {\n  return parameters.isEmpty() ? this : create(type, subtype);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "instance",
            "with",
            "the",
            "same",
            "type",
            "and",
            "subtype",
            "as",
            "this",
            "instance",
            "but",
            "without",
            "any",
            "parameters"
        ]
    },
    {
        "id": 1437,
        "code": "public MediaType withParameters(String attribute, Iterable<String> values) {\n  checkNotNull(attribute);\n  checkNotNull(values);\n  String normalizedAttribute = normalizeToken(attribute);\n  ImmutableListMultimap.Builder<String, String> builder = ImmutableListMultimap.builder();\n  for (Entry<String, String> entry : parameters.entries()) {\n    String key = entry.getKey();\n    if (!normalizedAttribute.equals(key)) {\n      builder.put(key, entry.getValue());\n    }\n  }\n  for (String value : values) {\n    builder.put(normalizedAttribute, normalizeParameterValue(normalizedAttribute, value));\n  }\n  MediaType mediaType = new MediaType(type, subtype, builder.build());\n    \n  if (!normalizedAttribute.equals(CHARSET_ATTRIBUTE)) {\n    mediaType.parsedCharset = this.parsedCharset;\n  }\n    \n  return MoreObjects.firstNonNull(KNOWN_TYPES.get(mediaType), mediaType);\n}",
        "summary_tokens": [
            "em",
            "replaces",
            "em",
            "all",
            "parameters",
            "with",
            "the",
            "given",
            "attribute",
            "with",
            "parameters",
            "using",
            "the",
            "given",
            "values"
        ]
    },
    {
        "id": 1438,
        "code": "public MediaType withParameter(String attribute, String value) {\n  return withParameters(attribute, ImmutableSet.of(value));\n}",
        "summary_tokens": [
            "em",
            "replaces",
            "em",
            "all",
            "parameters",
            "with",
            "the",
            "given",
            "attribute",
            "with",
            "a",
            "single",
            "parameter",
            "with",
            "the",
            "given",
            "value"
        ]
    },
    {
        "id": 1439,
        "code": "public MediaType withCharset(Charset charset) {\n  checkNotNull(charset);\n  MediaType withCharset = withParameter(CHARSET_ATTRIBUTE, charset.name());\n    \n  withCharset.parsedCharset = Optional.of(charset);\n  return withCharset;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "instance",
            "with",
            "the",
            "same",
            "type",
            "and",
            "subtype",
            "as",
            "this",
            "instance",
            "with",
            "the",
            "charset",
            "parameter",
            "set",
            "to",
            "the",
            "charset",
            "name",
            "name",
            "of",
            "the",
            "given",
            "charset"
        ]
    },
    {
        "id": 1440,
        "code": "public boolean hasWildcard() {\n  return WILDCARD.equals(type) || WILDCARD.equals(subtype);\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "either",
            "the",
            "type",
            "or",
            "subtype",
            "is",
            "the",
            "wildcard"
        ]
    },
    {
        "id": 1441,
        "code": "public boolean is(MediaType mediaTypeRange) {\n  return (mediaTypeRange.type.equals(WILDCARD) || mediaTypeRange.type.equals(this.type))\n      && (mediaTypeRange.subtype.equals(WILDCARD) || mediaTypeRange.subtype.equals(this.subtype))\n      && this.parameters.entries().containsAll(mediaTypeRange.parameters.entries());\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "this",
            "instance",
            "falls",
            "within",
            "the",
            "range",
            "as",
            "defined",
            "by",
            "a",
            "href",
            "http",
            "www"
        ]
    },
    {
        "id": 1442,
        "code": "public static MediaType create(String type, String subtype) {\n  MediaType mediaType = create(type, subtype, ImmutableListMultimap.<String, String>of());\n  mediaType.parsedCharset = Optional.absent();\n  return mediaType;\n}",
        "summary_tokens": [
            "creates",
            "a",
            "new",
            "media",
            "type",
            "with",
            "the",
            "given",
            "type",
            "and",
            "subtype"
        ]
    },
    {
        "id": 1443,
        "code": "static MediaType createApplicationType(String subtype) {\n  return create(APPLICATION_TYPE, subtype);\n}",
        "summary_tokens": [
            "creates",
            "a",
            "media",
            "type",
            "with",
            "the",
            "application",
            "type",
            "and",
            "the",
            "given",
            "subtype"
        ]
    },
    {
        "id": 1444,
        "code": "static MediaType createAudioType(String subtype) {\n  return create(AUDIO_TYPE, subtype);\n}",
        "summary_tokens": [
            "creates",
            "a",
            "media",
            "type",
            "with",
            "the",
            "audio",
            "type",
            "and",
            "the",
            "given",
            "subtype"
        ]
    },
    {
        "id": 1445,
        "code": "static MediaType createFontType(String subtype) {\n  return create(FONT_TYPE, subtype);\n}",
        "summary_tokens": [
            "creates",
            "a",
            "media",
            "type",
            "with",
            "the",
            "font",
            "type",
            "and",
            "the",
            "given",
            "subtype"
        ]
    },
    {
        "id": 1446,
        "code": "static MediaType createImageType(String subtype) {\n  return create(IMAGE_TYPE, subtype);\n}",
        "summary_tokens": [
            "creates",
            "a",
            "media",
            "type",
            "with",
            "the",
            "image",
            "type",
            "and",
            "the",
            "given",
            "subtype"
        ]
    },
    {
        "id": 1447,
        "code": "static MediaType createTextType(String subtype) {\n  return create(TEXT_TYPE, subtype);\n}",
        "summary_tokens": [
            "creates",
            "a",
            "media",
            "type",
            "with",
            "the",
            "text",
            "type",
            "and",
            "the",
            "given",
            "subtype"
        ]
    },
    {
        "id": 1448,
        "code": "static MediaType createVideoType(String subtype) {\n  return create(VIDEO_TYPE, subtype);\n}",
        "summary_tokens": [
            "creates",
            "a",
            "media",
            "type",
            "with",
            "the",
            "video",
            "type",
            "and",
            "the",
            "given",
            "subtype"
        ]
    },
    {
        "id": 1449,
        "code": "public static MediaType parse(String input) {\n  checkNotNull(input);\n  Tokenizer tokenizer = new Tokenizer(input);\n  try {\n    String type = tokenizer.consumeToken(TOKEN_MATCHER);\n    tokenizer.consumeCharacter('/');\n    String subtype = tokenizer.consumeToken(TOKEN_MATCHER);\n    ImmutableListMultimap.Builder<String, String> parameters = ImmutableListMultimap.builder();\n    while (tokenizer.hasMore()) {\n      tokenizer.consumeTokenIfPresent(LINEAR_WHITE_SPACE);\n      tokenizer.consumeCharacter(';');\n      tokenizer.consumeTokenIfPresent(LINEAR_WHITE_SPACE);\n      String attribute = tokenizer.consumeToken(TOKEN_MATCHER);\n      tokenizer.consumeCharacter('=');\n      String value;\n      if ('\"' == tokenizer.previewChar()) {\n        tokenizer.consumeCharacter('\"');\n        StringBuilder valueBuilder = new StringBuilder();\n        while ('\"' != tokenizer.previewChar()) {\n          if ('\\\\' == tokenizer.previewChar()) {\n            tokenizer.consumeCharacter('\\\\');\n            valueBuilder.append(tokenizer.consumeCharacter(ascii()));\n          } else {\n            valueBuilder.append(tokenizer.consumeToken(QUOTED_TEXT_MATCHER));\n          }\n        }\n        value = valueBuilder.toString();\n        tokenizer.consumeCharacter('\"');\n      } else {\n        value = tokenizer.consumeToken(TOKEN_MATCHER);\n      }\n      parameters.put(attribute, value);\n    }\n    return create(type, subtype, parameters.build());\n  } catch (IllegalStateException e) {\n    throw new IllegalArgumentException(\"Could not parse '\" + input + \"'\", e);\n  }\n}",
        "summary_tokens": [
            "parses",
            "a",
            "media",
            "type",
            "from",
            "its",
            "string",
            "representation"
        ]
    },
    {
        "id": 1450,
        "code": "public String toString() {\n    \n  String result = toString;\n  if (result == null) {\n    result = computeToString();\n    toString = result;\n  }\n  return result;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "string",
            "representation",
            "of",
            "this",
            "media",
            "type",
            "in",
            "the",
            "format",
            "described",
            "in",
            "a",
            "href",
            "http",
            "www"
        ]
    },
    {
        "id": 1451,
        "code": "private static boolean[] createSafeOctets(String safeChars) {\n  int maxChar = -1;\n  char[] safeCharArray = safeChars.toCharArray();\n  for (char c : safeCharArray) {\n    maxChar = Math.max(c, maxChar);\n  }\n  boolean[] octets = new boolean[maxChar + 1];\n  for (char c : safeCharArray) {\n    octets[c] = true;\n  }\n  return octets;\n}",
        "summary_tokens": [
            "creates",
            "a",
            "boolean",
            "array",
            "with",
            "entries",
            "corresponding",
            "to",
            "the",
            "character",
            "values",
            "specified",
            "in",
            "safe",
            "chars",
            "set",
            "to",
            "true"
        ]
    },
    {
        "id": 1452,
        "code": "protected char[] escape(int cp) {\n    \n    \n  if (cp < safeOctets.length && safeOctets[cp]) {\n    return null;\n  } else if (cp == ' ' && plusForSpace) {\n    return PLUS_SIGN;\n  } else if (cp <= 0x7F) {\n      \n      \n    char[] dest = new char[3];\n    dest[0] = '%';\n    dest[2] = UPPER_HEX_DIGITS[cp & 0xF];\n    dest[1] = UPPER_HEX_DIGITS[cp >>> 4];\n    return dest;\n  } else if (cp <= 0x7ff) {\n      \n      \n    char[] dest = new char[6];\n    dest[0] = '%';\n    dest[3] = '%';\n    dest[5] = UPPER_HEX_DIGITS[cp & 0xF];\n    cp >>>= 4;\n    dest[4] = UPPER_HEX_DIGITS[0x8 | (cp & 0x3)];\n    cp >>>= 2;\n    dest[2] = UPPER_HEX_DIGITS[cp & 0xF];\n    cp >>>= 4;\n    dest[1] = UPPER_HEX_DIGITS[0xC | cp];\n    return dest;\n  } else if (cp <= 0xffff) {\n      \n      \n    char[] dest = new char[9];\n    dest[0] = '%';\n    dest[1] = 'E';\n    dest[3] = '%';\n    dest[6] = '%';\n    dest[8] = UPPER_HEX_DIGITS[cp & 0xF];\n    cp >>>= 4;\n    dest[7] = UPPER_HEX_DIGITS[0x8 | (cp & 0x3)];\n    cp >>>= 2;\n    dest[5] = UPPER_HEX_DIGITS[cp & 0xF];\n    cp >>>= 4;\n    dest[4] = UPPER_HEX_DIGITS[0x8 | (cp & 0x3)];\n    cp >>>= 2;\n    dest[2] = UPPER_HEX_DIGITS[cp];\n    return dest;\n  } else if (cp <= 0x10ffff) {\n    char[] dest = new char[12];\n      \n      \n    dest[0] = '%';\n    dest[1] = 'F';\n    dest[3] = '%';\n    dest[6] = '%';\n    dest[9] = '%';\n    dest[11] = UPPER_HEX_DIGITS[cp & 0xF];\n    cp >>>= 4;\n    dest[10] = UPPER_HEX_DIGITS[0x8 | (cp & 0x3)];\n    cp >>>= 2;\n    dest[8] = UPPER_HEX_DIGITS[cp & 0xF];\n    cp >>>= 4;\n    dest[7] = UPPER_HEX_DIGITS[0x8 | (cp & 0x3)];\n    cp >>>= 2;\n    dest[5] = UPPER_HEX_DIGITS[cp & 0xF];\n    cp >>>= 4;\n    dest[4] = UPPER_HEX_DIGITS[0x8 | (cp & 0x3)];\n    cp >>>= 2;\n    dest[2] = UPPER_HEX_DIGITS[cp & 0x7];\n    return dest;\n  } else {\n      \n    throw new IllegalArgumentException(\"Invalid unicode character value \" + cp);\n  }\n}",
        "summary_tokens": [
            "escapes",
            "the",
            "given",
            "unicode",
            "code",
            "point",
            "in",
            "utf",
            "0"
        ]
    },
    {
        "id": 1453,
        "code": "public static Escaper urlFormParameterEscaper() {\n  return URL_FORM_PARAMETER_ESCAPER;\n}",
        "summary_tokens": [
            "returns",
            "an",
            "escaper",
            "instance",
            "that",
            "escapes",
            "strings",
            "so",
            "they",
            "can",
            "be",
            "safely",
            "included",
            "in",
            "a",
            "href",
            "https",
            "goo"
        ]
    },
    {
        "id": 1454,
        "code": "public static Escaper urlPathSegmentEscaper() {\n  return URL_PATH_SEGMENT_ESCAPER;\n}",
        "summary_tokens": [
            "returns",
            "an",
            "escaper",
            "instance",
            "that",
            "escapes",
            "strings",
            "so",
            "they",
            "can",
            "be",
            "safely",
            "included",
            "in",
            "a",
            "href",
            "https",
            "goo"
        ]
    },
    {
        "id": 1455,
        "code": "public static Escaper urlFragmentEscaper() {\n  return URL_FRAGMENT_ESCAPER;\n}",
        "summary_tokens": [
            "returns",
            "an",
            "escaper",
            "instance",
            "that",
            "escapes",
            "strings",
            "so",
            "they",
            "can",
            "be",
            "safely",
            "included",
            "in",
            "a",
            "a",
            "href",
            "https",
            "goo"
        ]
    },
    {
        "id": 1456,
        "code": "public static Comparator<Boolean> trueFirst() {\n  return BooleanComparator.TRUE_FIRST;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "comparator",
            "boolean",
            "that",
            "sorts",
            "true",
            "before",
            "false"
        ]
    },
    {
        "id": 1457,
        "code": "public static Comparator<Boolean> falseFirst() {\n  return BooleanComparator.FALSE_FIRST;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "comparator",
            "boolean",
            "that",
            "sorts",
            "false",
            "before",
            "true"
        ]
    },
    {
        "id": 1458,
        "code": "public static int hashCode(boolean value) {\n  return value ? 1231 : 1237;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "hash",
            "code",
            "for",
            "value",
            "equal",
            "to",
            "the",
            "result",
            "of",
            "invoking",
            "boolean",
            "value"
        ]
    },
    {
        "id": 1459,
        "code": "public static int compare(boolean a, boolean b) {\n  return (a == b) ? 0 : (a ? 1 : -1);\n}",
        "summary_tokens": [
            "compares",
            "the",
            "two",
            "specified",
            "boolean",
            "values",
            "in",
            "the",
            "standard",
            "way",
            "false",
            "is",
            "considered",
            "less",
            "than",
            "true"
        ]
    },
    {
        "id": 1460,
        "code": "public static boolean contains(boolean[] array, boolean target) {\n  for (boolean value : array) {\n    if (value == target) {\n      return true;\n    }\n  }\n  return false;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "target",
            "is",
            "present",
            "as",
            "an",
            "element",
            "anywhere",
            "in",
            "array"
        ]
    },
    {
        "id": 1461,
        "code": "public static int indexOf(boolean[] array, boolean[] target) {\n  checkNotNull(array, \"array\");\n  checkNotNull(target, \"target\");\n  if (target.length == 0) {\n    return 0;\n  }\n\n  outer:\n  for (int i = 0; i < array.length - target.length + 1; i++) {\n    for (int j = 0; j < target.length; j++) {\n      if (array[i + j] != target[j]) {\n        continue outer;\n      }\n    }\n    return i;\n  }\n  return -1;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "start",
            "position",
            "of",
            "the",
            "first",
            "occurrence",
            "of",
            "the",
            "specified",
            "target",
            "within",
            "array",
            "or",
            "0",
            "if",
            "there",
            "is",
            "no",
            "such",
            "occurrence"
        ]
    },
    {
        "id": 1462,
        "code": "public static int lastIndexOf(boolean[] array, boolean target) {\n  return lastIndexOf(array, target, 0, array.length);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "index",
            "of",
            "the",
            "last",
            "appearance",
            "of",
            "the",
            "value",
            "target",
            "in",
            "array"
        ]
    },
    {
        "id": 1463,
        "code": "public static boolean[] concat(boolean[]... arrays) {\n  int length = 0;\n  for (boolean[] array : arrays) {\n    length += array.length;\n  }\n  boolean[] result = new boolean[length];\n  int pos = 0;\n  for (boolean[] array : arrays) {\n    System.arraycopy(array, 0, result, pos, array.length);\n    pos += array.length;\n  }\n  return result;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "values",
            "from",
            "each",
            "provided",
            "array",
            "combined",
            "into",
            "a",
            "single",
            "array"
        ]
    },
    {
        "id": 1464,
        "code": "public static boolean[] ensureCapacity(boolean[] array, int minLength, int padding) {\n  checkArgument(minLength >= 0, \"Invalid minLength: %s\", minLength);\n  checkArgument(padding >= 0, \"Invalid padding: %s\", padding);\n  return (array.length < minLength) ? Arrays.copyOf(array, minLength + padding) : array;\n}",
        "summary_tokens": [
            "returns",
            "an",
            "array",
            "containing",
            "the",
            "same",
            "values",
            "as",
            "array",
            "but",
            "guaranteed",
            "to",
            "be",
            "of",
            "a",
            "specified",
            "minimum",
            "length"
        ]
    },
    {
        "id": 1465,
        "code": "public static String join(String separator, boolean... array) {\n  checkNotNull(separator);\n  if (array.length == 0) {\n    return \"\";\n  }\n\n    \n  StringBuilder builder = new StringBuilder(array.length * 7);\n  builder.append(array[0]);\n  for (int i = 1; i < array.length; i++) {\n    builder.append(separator).append(array[i]);\n  }\n  return builder.toString();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "string",
            "containing",
            "the",
            "supplied",
            "boolean",
            "values",
            "separated",
            "by",
            "separator"
        ]
    },
    {
        "id": 1466,
        "code": "public static Comparator<boolean[]> lexicographicalComparator() {\n  return LexicographicalComparator.INSTANCE;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "comparator",
            "that",
            "compares",
            "two",
            "boolean",
            "arrays",
            "a",
            "href",
            "http",
            "en"
        ]
    },
    {
        "id": 1467,
        "code": "public static boolean[] toArray(Collection<Boolean> collection) {\n  if (collection instanceof BooleanArrayAsList) {\n    return ((BooleanArrayAsList) collection).toBooleanArray();\n  }\n\n  Object[] boxedArray = collection.toArray();\n  int len = boxedArray.length;\n  boolean[] array = new boolean[len];\n  for (int i = 0; i < len; i++) {\n      \n    array[i] = (Boolean) checkNotNull(boxedArray[i]);\n  }\n  return array;\n}",
        "summary_tokens": [
            "copies",
            "a",
            "collection",
            "of",
            "boolean",
            "instances",
            "into",
            "a",
            "new",
            "array",
            "of",
            "primitive",
            "boolean",
            "values"
        ]
    },
    {
        "id": 1468,
        "code": "public static List<Boolean> asList(boolean... backingArray) {\n  if (backingArray.length == 0) {\n    return Collections.emptyList();\n  }\n  return new BooleanArrayAsList(backingArray);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "fixed",
            "size",
            "list",
            "backed",
            "by",
            "the",
            "specified",
            "array",
            "similar",
            "to",
            "arrays",
            "as",
            "list",
            "object"
        ]
    },
    {
        "id": 1469,
        "code": "public static int countTrue(boolean... values) {\n  int count = 0;\n  for (boolean value : values) {\n    if (value) {\n      count++;\n    }\n  }\n  return count;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "values",
            "that",
            "are",
            "true"
        ]
    },
    {
        "id": 1470,
        "code": "public static void reverse(boolean[] array, int fromIndex, int toIndex) {\n  checkNotNull(array);\n  checkPositionIndexes(fromIndex, toIndex, array.length);\n  for (int i = fromIndex, j = toIndex - 1; i < j; i++, j--) {\n    boolean tmp = array[i];\n    array[i] = array[j];\n    array[j] = tmp;\n  }\n}",
        "summary_tokens": [
            "reverses",
            "the",
            "elements",
            "of",
            "array",
            "between",
            "from",
            "index",
            "inclusive",
            "and",
            "to",
            "index",
            "exclusive"
        ]
    },
    {
        "id": 1471,
        "code": "public static int hashCode(byte value) {\n  return value;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "hash",
            "code",
            "for",
            "value",
            "equal",
            "to",
            "the",
            "result",
            "of",
            "invoking",
            "byte",
            "value"
        ]
    },
    {
        "id": 1472,
        "code": "public static boolean contains(byte[] array, byte target) {\n  for (byte value : array) {\n    if (value == target) {\n      return true;\n    }\n  }\n  return false;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "target",
            "is",
            "present",
            "as",
            "an",
            "element",
            "anywhere",
            "in",
            "array"
        ]
    },
    {
        "id": 1473,
        "code": "public static int indexOf(byte[] array, byte[] target) {\n  checkNotNull(array, \"array\");\n  checkNotNull(target, \"target\");\n  if (target.length == 0) {\n    return 0;\n  }\n\n  outer:\n  for (int i = 0; i < array.length - target.length + 1; i++) {\n    for (int j = 0; j < target.length; j++) {\n      if (array[i + j] != target[j]) {\n        continue outer;\n      }\n    }\n    return i;\n  }\n  return -1;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "start",
            "position",
            "of",
            "the",
            "first",
            "occurrence",
            "of",
            "the",
            "specified",
            "target",
            "within",
            "array",
            "or",
            "0",
            "if",
            "there",
            "is",
            "no",
            "such",
            "occurrence"
        ]
    },
    {
        "id": 1474,
        "code": "public static int lastIndexOf(byte[] array, byte target) {\n  return lastIndexOf(array, target, 0, array.length);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "index",
            "of",
            "the",
            "last",
            "appearance",
            "of",
            "the",
            "value",
            "target",
            "in",
            "array"
        ]
    },
    {
        "id": 1475,
        "code": "public static byte[] concat(byte[]... arrays) {\n  int length = 0;\n  for (byte[] array : arrays) {\n    length += array.length;\n  }\n  byte[] result = new byte[length];\n  int pos = 0;\n  for (byte[] array : arrays) {\n    System.arraycopy(array, 0, result, pos, array.length);\n    pos += array.length;\n  }\n  return result;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "values",
            "from",
            "each",
            "provided",
            "array",
            "combined",
            "into",
            "a",
            "single",
            "array"
        ]
    },
    {
        "id": 1476,
        "code": "public static byte[] ensureCapacity(byte[] array, int minLength, int padding) {\n  checkArgument(minLength >= 0, \"Invalid minLength: %s\", minLength);\n  checkArgument(padding >= 0, \"Invalid padding: %s\", padding);\n  return (array.length < minLength) ? Arrays.copyOf(array, minLength + padding) : array;\n}",
        "summary_tokens": [
            "returns",
            "an",
            "array",
            "containing",
            "the",
            "same",
            "values",
            "as",
            "array",
            "but",
            "guaranteed",
            "to",
            "be",
            "of",
            "a",
            "specified",
            "minimum",
            "length"
        ]
    },
    {
        "id": 1477,
        "code": "public static byte[] toArray(Collection<? extends Number> collection) {\n  if (collection instanceof ByteArrayAsList) {\n    return ((ByteArrayAsList) collection).toByteArray();\n  }\n\n  Object[] boxedArray = collection.toArray();\n  int len = boxedArray.length;\n  byte[] array = new byte[len];\n  for (int i = 0; i < len; i++) {\n      \n    array[i] = ((Number) checkNotNull(boxedArray[i])).byteValue();\n  }\n  return array;\n}",
        "summary_tokens": [
            "returns",
            "an",
            "array",
            "containing",
            "each",
            "value",
            "of",
            "collection",
            "converted",
            "to",
            "a",
            "byte",
            "value",
            "in",
            "the",
            "manner",
            "of",
            "number",
            "byte",
            "value"
        ]
    },
    {
        "id": 1478,
        "code": "public static List<Byte> asList(byte... backingArray) {\n  if (backingArray.length == 0) {\n    return Collections.emptyList();\n  }\n  return new ByteArrayAsList(backingArray);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "fixed",
            "size",
            "list",
            "backed",
            "by",
            "the",
            "specified",
            "array",
            "similar",
            "to",
            "arrays",
            "as",
            "list",
            "object"
        ]
    },
    {
        "id": 1479,
        "code": "public static void reverse(byte[] array, int fromIndex, int toIndex) {\n  checkNotNull(array);\n  checkPositionIndexes(fromIndex, toIndex, array.length);\n  for (int i = fromIndex, j = toIndex - 1; i < j; i++, j--) {\n    byte tmp = array[i];\n    array[i] = array[j];\n    array[j] = tmp;\n  }\n}",
        "summary_tokens": [
            "reverses",
            "the",
            "elements",
            "of",
            "array",
            "between",
            "from",
            "index",
            "inclusive",
            "and",
            "to",
            "index",
            "exclusive"
        ]
    },
    {
        "id": 1480,
        "code": "public static int hashCode(char value) {\n  return value;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "hash",
            "code",
            "for",
            "value",
            "equal",
            "to",
            "the",
            "result",
            "of",
            "invoking",
            "character",
            "value"
        ]
    },
    {
        "id": 1481,
        "code": "public static char checkedCast(long value) {\n  char result = (char) value;\n  checkArgument(result == value, \"Out of range: %s\", value);\n  return result;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "char",
            "value",
            "that",
            "is",
            "equal",
            "to",
            "value",
            "if",
            "possible"
        ]
    },
    {
        "id": 1482,
        "code": "public static char saturatedCast(long value) {\n  if (value > Character.MAX_VALUE) {\n    return Character.MAX_VALUE;\n  }\n  if (value < Character.MIN_VALUE) {\n    return Character.MIN_VALUE;\n  }\n  return (char) value;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "char",
            "nearest",
            "in",
            "value",
            "to",
            "value"
        ]
    },
    {
        "id": 1483,
        "code": "public static int compare(char a, char b) {\n  return a - b; \n}",
        "summary_tokens": [
            "compares",
            "the",
            "two",
            "specified",
            "char",
            "values"
        ]
    },
    {
        "id": 1484,
        "code": "public static boolean contains(char[] array, char target) {\n  for (char value : array) {\n    if (value == target) {\n      return true;\n    }\n  }\n  return false;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "target",
            "is",
            "present",
            "as",
            "an",
            "element",
            "anywhere",
            "in",
            "array"
        ]
    },
    {
        "id": 1485,
        "code": "public static int indexOf(char[] array, char[] target) {\n  checkNotNull(array, \"array\");\n  checkNotNull(target, \"target\");\n  if (target.length == 0) {\n    return 0;\n  }\n\n  outer:\n  for (int i = 0; i < array.length - target.length + 1; i++) {\n    for (int j = 0; j < target.length; j++) {\n      if (array[i + j] != target[j]) {\n        continue outer;\n      }\n    }\n    return i;\n  }\n  return -1;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "start",
            "position",
            "of",
            "the",
            "first",
            "occurrence",
            "of",
            "the",
            "specified",
            "target",
            "within",
            "array",
            "or",
            "0",
            "if",
            "there",
            "is",
            "no",
            "such",
            "occurrence"
        ]
    },
    {
        "id": 1486,
        "code": "public static int lastIndexOf(char[] array, char target) {\n  return lastIndexOf(array, target, 0, array.length);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "index",
            "of",
            "the",
            "last",
            "appearance",
            "of",
            "the",
            "value",
            "target",
            "in",
            "array"
        ]
    },
    {
        "id": 1487,
        "code": "public static char min(char... array) {\n  checkArgument(array.length > 0);\n  char min = array[0];\n  for (int i = 1; i < array.length; i++) {\n    if (array[i] < min) {\n      min = array[i];\n    }\n  }\n  return min;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "least",
            "value",
            "present",
            "in",
            "array"
        ]
    },
    {
        "id": 1488,
        "code": "public static char max(char... array) {\n  checkArgument(array.length > 0);\n  char max = array[0];\n  for (int i = 1; i < array.length; i++) {\n    if (array[i] > max) {\n      max = array[i];\n    }\n  }\n  return max;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "greatest",
            "value",
            "present",
            "in",
            "array"
        ]
    },
    {
        "id": 1489,
        "code": "public static char constrainToRange(char value, char min, char max) {\n  checkArgument(min <= max, \"min (%s) must be less than or equal to max (%s)\", min, max);\n  return value < min ? min : value < max ? value : max;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "value",
            "nearest",
            "to",
            "value",
            "which",
            "is",
            "within",
            "the",
            "closed",
            "range",
            "min"
        ]
    },
    {
        "id": 1490,
        "code": "public static char[] concat(char[]... arrays) {\n  int length = 0;\n  for (char[] array : arrays) {\n    length += array.length;\n  }\n  char[] result = new char[length];\n  int pos = 0;\n  for (char[] array : arrays) {\n    System.arraycopy(array, 0, result, pos, array.length);\n    pos += array.length;\n  }\n  return result;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "values",
            "from",
            "each",
            "provided",
            "array",
            "combined",
            "into",
            "a",
            "single",
            "array"
        ]
    },
    {
        "id": 1491,
        "code": "public static byte[] toByteArray(char value) {\n  return new byte[] {(byte) (value >> 8), (byte) value};\n}",
        "summary_tokens": [
            "returns",
            "a",
            "big",
            "endian",
            "representation",
            "of",
            "value",
            "in",
            "a",
            "0",
            "element",
            "byte",
            "array",
            "equivalent",
            "to",
            "byte",
            "buffer"
        ]
    },
    {
        "id": 1492,
        "code": "public static char fromByteArray(byte[] bytes) {\n  checkArgument(bytes.length >= BYTES, \"array too small: %s < %s\", bytes.length, BYTES);\n  return fromBytes(bytes[0], bytes[1]);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "char",
            "value",
            "whose",
            "big",
            "endian",
            "representation",
            "is",
            "stored",
            "in",
            "the",
            "first",
            "0",
            "bytes",
            "of",
            "bytes",
            "equivalent",
            "to",
            "byte",
            "buffer"
        ]
    },
    {
        "id": 1493,
        "code": "public static char fromBytes(byte b1, byte b2) {\n  return (char) ((b1 << 8) | (b2 & 0xFF));\n}",
        "summary_tokens": [
            "returns",
            "the",
            "char",
            "value",
            "whose",
            "byte",
            "representation",
            "is",
            "the",
            "given",
            "0",
            "bytes",
            "in",
            "big",
            "endian",
            "order",
            "equivalent",
            "to",
            "chars"
        ]
    },
    {
        "id": 1494,
        "code": "public static char[] ensureCapacity(char[] array, int minLength, int padding) {\n  checkArgument(minLength >= 0, \"Invalid minLength: %s\", minLength);\n  checkArgument(padding >= 0, \"Invalid padding: %s\", padding);\n  return (array.length < minLength) ? Arrays.copyOf(array, minLength + padding) : array;\n}",
        "summary_tokens": [
            "returns",
            "an",
            "array",
            "containing",
            "the",
            "same",
            "values",
            "as",
            "array",
            "but",
            "guaranteed",
            "to",
            "be",
            "of",
            "a",
            "specified",
            "minimum",
            "length"
        ]
    },
    {
        "id": 1495,
        "code": "public static String join(String separator, char... array) {\n  checkNotNull(separator);\n  int len = array.length;\n  if (len == 0) {\n    return \"\";\n  }\n\n  StringBuilder builder = new StringBuilder(len + separator.length() * (len - 1));\n  builder.append(array[0]);\n  for (int i = 1; i < len; i++) {\n    builder.append(separator).append(array[i]);\n  }\n  return builder.toString();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "string",
            "containing",
            "the",
            "supplied",
            "char",
            "values",
            "separated",
            "by",
            "separator"
        ]
    },
    {
        "id": 1496,
        "code": "public static Comparator<char[]> lexicographicalComparator() {\n  return LexicographicalComparator.INSTANCE;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "comparator",
            "that",
            "compares",
            "two",
            "char",
            "arrays",
            "a",
            "href",
            "http",
            "en"
        ]
    },
    {
        "id": 1497,
        "code": "public static char[] toArray(Collection<Character> collection) {\n  if (collection instanceof CharArrayAsList) {\n    return ((CharArrayAsList) collection).toCharArray();\n  }\n\n  Object[] boxedArray = collection.toArray();\n  int len = boxedArray.length;\n  char[] array = new char[len];\n  for (int i = 0; i < len; i++) {\n      \n    array[i] = (Character) checkNotNull(boxedArray[i]);\n  }\n  return array;\n}",
        "summary_tokens": [
            "copies",
            "a",
            "collection",
            "of",
            "character",
            "instances",
            "into",
            "a",
            "new",
            "array",
            "of",
            "primitive",
            "char",
            "values"
        ]
    },
    {
        "id": 1498,
        "code": "public static void sortDescending(char[] array, int fromIndex, int toIndex) {\n  checkNotNull(array);\n  checkPositionIndexes(fromIndex, toIndex, array.length);\n  Arrays.sort(array, fromIndex, toIndex);\n  reverse(array, fromIndex, toIndex);\n}",
        "summary_tokens": [
            "sorts",
            "the",
            "elements",
            "of",
            "array",
            "between",
            "from",
            "index",
            "inclusive",
            "and",
            "to",
            "index",
            "exclusive",
            "in",
            "descending",
            "order"
        ]
    },
    {
        "id": 1499,
        "code": "public static void reverse(char[] array, int fromIndex, int toIndex) {\n  checkNotNull(array);\n  checkPositionIndexes(fromIndex, toIndex, array.length);\n  for (int i = fromIndex, j = toIndex - 1; i < j; i++, j--) {\n    char tmp = array[i];\n    array[i] = array[j];\n    array[j] = tmp;\n  }\n}",
        "summary_tokens": [
            "reverses",
            "the",
            "elements",
            "of",
            "array",
            "between",
            "from",
            "index",
            "inclusive",
            "and",
            "to",
            "index",
            "exclusive"
        ]
    },
    {
        "id": 1500,
        "code": "public static List<Character> asList(char... backingArray) {\n  if (backingArray.length == 0) {\n    return Collections.emptyList();\n  }\n  return new CharArrayAsList(backingArray);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "fixed",
            "size",
            "list",
            "backed",
            "by",
            "the",
            "specified",
            "array",
            "similar",
            "to",
            "arrays",
            "as",
            "list",
            "object"
        ]
    },
    {
        "id": 1501,
        "code": "public static int hashCode(double value) {\n  return ((Double) value).hashCode();\n    \n    \n    \n}",
        "summary_tokens": [
            "returns",
            "a",
            "hash",
            "code",
            "for",
            "value",
            "equal",
            "to",
            "the",
            "result",
            "of",
            "invoking",
            "double",
            "value"
        ]
    },
    {
        "id": 1502,
        "code": "public static int compare(double a, double b) {\n  return Double.compare(a, b);\n}",
        "summary_tokens": [
            "compares",
            "the",
            "two",
            "specified",
            "double",
            "values"
        ]
    },
    {
        "id": 1503,
        "code": "public static boolean isFinite(double value) {\n  return NEGATIVE_INFINITY < value && value < POSITIVE_INFINITY;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "value",
            "represents",
            "a",
            "real",
            "number"
        ]
    },
    {
        "id": 1504,
        "code": "public static boolean contains(double[] array, double target) {\n  for (double value : array) {\n    if (value == target) {\n      return true;\n    }\n  }\n  return false;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "target",
            "is",
            "present",
            "as",
            "an",
            "element",
            "anywhere",
            "in",
            "array"
        ]
    },
    {
        "id": 1505,
        "code": "public static int indexOf(double[] array, double[] target) {\n  checkNotNull(array, \"array\");\n  checkNotNull(target, \"target\");\n  if (target.length == 0) {\n    return 0;\n  }\n\n  outer:\n  for (int i = 0; i < array.length - target.length + 1; i++) {\n    for (int j = 0; j < target.length; j++) {\n      if (array[i + j] != target[j]) {\n        continue outer;\n      }\n    }\n    return i;\n  }\n  return -1;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "start",
            "position",
            "of",
            "the",
            "first",
            "occurrence",
            "of",
            "the",
            "specified",
            "target",
            "within",
            "array",
            "or",
            "0",
            "if",
            "there",
            "is",
            "no",
            "such",
            "occurrence"
        ]
    },
    {
        "id": 1506,
        "code": "public static int lastIndexOf(double[] array, double target) {\n  return lastIndexOf(array, target, 0, array.length);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "index",
            "of",
            "the",
            "last",
            "appearance",
            "of",
            "the",
            "value",
            "target",
            "in",
            "array"
        ]
    },
    {
        "id": 1507,
        "code": "public static double min(double... array) {\n  checkArgument(array.length > 0);\n  double min = array[0];\n  for (int i = 1; i < array.length; i++) {\n    min = Math.min(min, array[i]);\n  }\n  return min;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "least",
            "value",
            "present",
            "in",
            "array",
            "using",
            "the",
            "same",
            "rules",
            "of",
            "comparison",
            "as",
            "math",
            "min",
            "double",
            "double"
        ]
    },
    {
        "id": 1508,
        "code": "public static double max(double... array) {\n  checkArgument(array.length > 0);\n  double max = array[0];\n  for (int i = 1; i < array.length; i++) {\n    max = Math.max(max, array[i]);\n  }\n  return max;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "greatest",
            "value",
            "present",
            "in",
            "array",
            "using",
            "the",
            "same",
            "rules",
            "of",
            "comparison",
            "as",
            "math",
            "max",
            "double",
            "double"
        ]
    },
    {
        "id": 1509,
        "code": "public static double constrainToRange(double value, double min, double max) {\n    \n    \n  if (min <= max) {\n    return Math.min(Math.max(value, min), max);\n  }\n  throw new IllegalArgumentException(\n      lenientFormat(\"min (%s) must be less than or equal to max (%s)\", min, max));\n}",
        "summary_tokens": [
            "returns",
            "the",
            "value",
            "nearest",
            "to",
            "value",
            "which",
            "is",
            "within",
            "the",
            "closed",
            "range",
            "min"
        ]
    },
    {
        "id": 1510,
        "code": "public static double[] concat(double[]... arrays) {\n  int length = 0;\n  for (double[] array : arrays) {\n    length += array.length;\n  }\n  double[] result = new double[length];\n  int pos = 0;\n  for (double[] array : arrays) {\n    System.arraycopy(array, 0, result, pos, array.length);\n    pos += array.length;\n  }\n  return result;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "values",
            "from",
            "each",
            "provided",
            "array",
            "combined",
            "into",
            "a",
            "single",
            "array"
        ]
    },
    {
        "id": 1511,
        "code": "public static Converter<String, Double> stringConverter() {\n  return DoubleConverter.INSTANCE;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "serializable",
            "converter",
            "object",
            "that",
            "converts",
            "between",
            "strings",
            "and",
            "doubles",
            "using",
            "double",
            "value",
            "of",
            "and",
            "double",
            "to",
            "string"
        ]
    },
    {
        "id": 1512,
        "code": "public static double[] ensureCapacity(double[] array, int minLength, int padding) {\n  checkArgument(minLength >= 0, \"Invalid minLength: %s\", minLength);\n  checkArgument(padding >= 0, \"Invalid padding: %s\", padding);\n  return (array.length < minLength) ? Arrays.copyOf(array, minLength + padding) : array;\n}",
        "summary_tokens": [
            "returns",
            "an",
            "array",
            "containing",
            "the",
            "same",
            "values",
            "as",
            "array",
            "but",
            "guaranteed",
            "to",
            "be",
            "of",
            "a",
            "specified",
            "minimum",
            "length"
        ]
    },
    {
        "id": 1513,
        "code": "public static String join(String separator, double... array) {\n  checkNotNull(separator);\n  if (array.length == 0) {\n    return \"\";\n  }\n\n    \n  StringBuilder builder = new StringBuilder(array.length * 12);\n  builder.append(array[0]);\n  for (int i = 1; i < array.length; i++) {\n    builder.append(separator).append(array[i]);\n  }\n  return builder.toString();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "string",
            "containing",
            "the",
            "supplied",
            "double",
            "values",
            "converted",
            "to",
            "strings",
            "as",
            "specified",
            "by",
            "double",
            "to",
            "string",
            "double",
            "and",
            "separated",
            "by",
            "separator"
        ]
    },
    {
        "id": 1514,
        "code": "public static Comparator<double[]> lexicographicalComparator() {\n  return LexicographicalComparator.INSTANCE;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "comparator",
            "that",
            "compares",
            "two",
            "double",
            "arrays",
            "a",
            "href",
            "http",
            "en"
        ]
    },
    {
        "id": 1515,
        "code": "public static void sortDescending(double[] array, int fromIndex, int toIndex) {\n  checkNotNull(array);\n  checkPositionIndexes(fromIndex, toIndex, array.length);\n  Arrays.sort(array, fromIndex, toIndex);\n  reverse(array, fromIndex, toIndex);\n}",
        "summary_tokens": [
            "sorts",
            "the",
            "elements",
            "of",
            "array",
            "between",
            "from",
            "index",
            "inclusive",
            "and",
            "to",
            "index",
            "exclusive",
            "in",
            "descending",
            "order"
        ]
    },
    {
        "id": 1516,
        "code": "public static void reverse(double[] array, int fromIndex, int toIndex) {\n  checkNotNull(array);\n  checkPositionIndexes(fromIndex, toIndex, array.length);\n  for (int i = fromIndex, j = toIndex - 1; i < j; i++, j--) {\n    double tmp = array[i];\n    array[i] = array[j];\n    array[j] = tmp;\n  }\n}",
        "summary_tokens": [
            "reverses",
            "the",
            "elements",
            "of",
            "array",
            "between",
            "from",
            "index",
            "inclusive",
            "and",
            "to",
            "index",
            "exclusive"
        ]
    },
    {
        "id": 1517,
        "code": "public static double[] toArray(Collection<? extends Number> collection) {\n  if (collection instanceof DoubleArrayAsList) {\n    return ((DoubleArrayAsList) collection).toDoubleArray();\n  }\n\n  Object[] boxedArray = collection.toArray();\n  int len = boxedArray.length;\n  double[] array = new double[len];\n  for (int i = 0; i < len; i++) {\n      \n    array[i] = ((Number) checkNotNull(boxedArray[i])).doubleValue();\n  }\n  return array;\n}",
        "summary_tokens": [
            "returns",
            "an",
            "array",
            "containing",
            "each",
            "value",
            "of",
            "collection",
            "converted",
            "to",
            "a",
            "double",
            "value",
            "in",
            "the",
            "manner",
            "of",
            "number",
            "double",
            "value"
        ]
    },
    {
        "id": 1518,
        "code": "public static List<Double> asList(double... backingArray) {\n  if (backingArray.length == 0) {\n    return Collections.emptyList();\n  }\n  return new DoubleArrayAsList(backingArray);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "fixed",
            "size",
            "list",
            "backed",
            "by",
            "the",
            "specified",
            "array",
            "similar",
            "to",
            "arrays",
            "as",
            "list",
            "object"
        ]
    },
    {
        "id": 1519,
        "code": "public static Double tryParse(String string) {\n  if (FLOATING_POINT_PATTERN.matcher(string).matches()) {\n      \n      \n    try {\n      return Double.parseDouble(string);\n    } catch (NumberFormatException e) {\n        \n        \n    }\n  }\n  return null;\n}",
        "summary_tokens": [
            "parses",
            "the",
            "specified",
            "string",
            "as",
            "a",
            "double",
            "precision",
            "floating",
            "point",
            "value"
        ]
    },
    {
        "id": 1520,
        "code": "public static int hashCode(float value) {\n    \n  return ((Float) value).hashCode();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "hash",
            "code",
            "for",
            "value",
            "equal",
            "to",
            "the",
            "result",
            "of",
            "invoking",
            "float",
            "value"
        ]
    },
    {
        "id": 1521,
        "code": "public static int compare(float a, float b) {\n  return Float.compare(a, b);\n}",
        "summary_tokens": [
            "compares",
            "the",
            "two",
            "specified",
            "float",
            "values",
            "using",
            "float",
            "compare",
            "float",
            "float"
        ]
    },
    {
        "id": 1522,
        "code": "public static boolean isFinite(float value) {\n  return NEGATIVE_INFINITY < value && value < POSITIVE_INFINITY;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "value",
            "represents",
            "a",
            "real",
            "number"
        ]
    },
    {
        "id": 1523,
        "code": "public static boolean contains(float[] array, float target) {\n  for (float value : array) {\n    if (value == target) {\n      return true;\n    }\n  }\n  return false;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "target",
            "is",
            "present",
            "as",
            "an",
            "element",
            "anywhere",
            "in",
            "array"
        ]
    },
    {
        "id": 1524,
        "code": "public static int indexOf(float[] array, float[] target) {\n  checkNotNull(array, \"array\");\n  checkNotNull(target, \"target\");\n  if (target.length == 0) {\n    return 0;\n  }\n\n  outer:\n  for (int i = 0; i < array.length - target.length + 1; i++) {\n    for (int j = 0; j < target.length; j++) {\n      if (array[i + j] != target[j]) {\n        continue outer;\n      }\n    }\n    return i;\n  }\n  return -1;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "start",
            "position",
            "of",
            "the",
            "first",
            "occurrence",
            "of",
            "the",
            "specified",
            "target",
            "within",
            "array",
            "or",
            "0",
            "if",
            "there",
            "is",
            "no",
            "such",
            "occurrence"
        ]
    },
    {
        "id": 1525,
        "code": "public static int lastIndexOf(float[] array, float target) {\n  return lastIndexOf(array, target, 0, array.length);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "index",
            "of",
            "the",
            "last",
            "appearance",
            "of",
            "the",
            "value",
            "target",
            "in",
            "array"
        ]
    },
    {
        "id": 1526,
        "code": "public static float min(float... array) {\n  checkArgument(array.length > 0);\n  float min = array[0];\n  for (int i = 1; i < array.length; i++) {\n    min = Math.min(min, array[i]);\n  }\n  return min;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "least",
            "value",
            "present",
            "in",
            "array",
            "using",
            "the",
            "same",
            "rules",
            "of",
            "comparison",
            "as",
            "math",
            "min",
            "float",
            "float"
        ]
    },
    {
        "id": 1527,
        "code": "public static float max(float... array) {\n  checkArgument(array.length > 0);\n  float max = array[0];\n  for (int i = 1; i < array.length; i++) {\n    max = Math.max(max, array[i]);\n  }\n  return max;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "greatest",
            "value",
            "present",
            "in",
            "array",
            "using",
            "the",
            "same",
            "rules",
            "of",
            "comparison",
            "as",
            "math",
            "max",
            "float",
            "float"
        ]
    },
    {
        "id": 1528,
        "code": "public static float constrainToRange(float value, float min, float max) {\n    \n    \n  if (min <= max) {\n    return Math.min(Math.max(value, min), max);\n  }\n  throw new IllegalArgumentException(\n      lenientFormat(\"min (%s) must be less than or equal to max (%s)\", min, max));\n}",
        "summary_tokens": [
            "returns",
            "the",
            "value",
            "nearest",
            "to",
            "value",
            "which",
            "is",
            "within",
            "the",
            "closed",
            "range",
            "min"
        ]
    },
    {
        "id": 1529,
        "code": "public static float[] concat(float[]... arrays) {\n  int length = 0;\n  for (float[] array : arrays) {\n    length += array.length;\n  }\n  float[] result = new float[length];\n  int pos = 0;\n  for (float[] array : arrays) {\n    System.arraycopy(array, 0, result, pos, array.length);\n    pos += array.length;\n  }\n  return result;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "values",
            "from",
            "each",
            "provided",
            "array",
            "combined",
            "into",
            "a",
            "single",
            "array"
        ]
    },
    {
        "id": 1530,
        "code": "public static Converter<String, Float> stringConverter() {\n  return FloatConverter.INSTANCE;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "serializable",
            "converter",
            "object",
            "that",
            "converts",
            "between",
            "strings",
            "and",
            "floats",
            "using",
            "float",
            "value",
            "of",
            "and",
            "float",
            "to",
            "string"
        ]
    },
    {
        "id": 1531,
        "code": "public static float[] ensureCapacity(float[] array, int minLength, int padding) {\n  checkArgument(minLength >= 0, \"Invalid minLength: %s\", minLength);\n  checkArgument(padding >= 0, \"Invalid padding: %s\", padding);\n  return (array.length < minLength) ? Arrays.copyOf(array, minLength + padding) : array;\n}",
        "summary_tokens": [
            "returns",
            "an",
            "array",
            "containing",
            "the",
            "same",
            "values",
            "as",
            "array",
            "but",
            "guaranteed",
            "to",
            "be",
            "of",
            "a",
            "specified",
            "minimum",
            "length"
        ]
    },
    {
        "id": 1532,
        "code": "public static String join(String separator, float... array) {\n  checkNotNull(separator);\n  if (array.length == 0) {\n    return \"\";\n  }\n\n    \n  StringBuilder builder = new StringBuilder(array.length * 12);\n  builder.append(array[0]);\n  for (int i = 1; i < array.length; i++) {\n    builder.append(separator).append(array[i]);\n  }\n  return builder.toString();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "string",
            "containing",
            "the",
            "supplied",
            "float",
            "values",
            "converted",
            "to",
            "strings",
            "as",
            "specified",
            "by",
            "float",
            "to",
            "string",
            "float",
            "and",
            "separated",
            "by",
            "separator"
        ]
    },
    {
        "id": 1533,
        "code": "public static Comparator<float[]> lexicographicalComparator() {\n  return LexicographicalComparator.INSTANCE;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "comparator",
            "that",
            "compares",
            "two",
            "float",
            "arrays",
            "a",
            "href",
            "http",
            "en"
        ]
    },
    {
        "id": 1534,
        "code": "public static void sortDescending(float[] array, int fromIndex, int toIndex) {\n  checkNotNull(array);\n  checkPositionIndexes(fromIndex, toIndex, array.length);\n  Arrays.sort(array, fromIndex, toIndex);\n  reverse(array, fromIndex, toIndex);\n}",
        "summary_tokens": [
            "sorts",
            "the",
            "elements",
            "of",
            "array",
            "between",
            "from",
            "index",
            "inclusive",
            "and",
            "to",
            "index",
            "exclusive",
            "in",
            "descending",
            "order"
        ]
    },
    {
        "id": 1535,
        "code": "public static void reverse(float[] array, int fromIndex, int toIndex) {\n  checkNotNull(array);\n  checkPositionIndexes(fromIndex, toIndex, array.length);\n  for (int i = fromIndex, j = toIndex - 1; i < j; i++, j--) {\n    float tmp = array[i];\n    array[i] = array[j];\n    array[j] = tmp;\n  }\n}",
        "summary_tokens": [
            "reverses",
            "the",
            "elements",
            "of",
            "array",
            "between",
            "from",
            "index",
            "inclusive",
            "and",
            "to",
            "index",
            "exclusive"
        ]
    },
    {
        "id": 1536,
        "code": "public static float[] toArray(Collection<? extends Number> collection) {\n  if (collection instanceof FloatArrayAsList) {\n    return ((FloatArrayAsList) collection).toFloatArray();\n  }\n\n  Object[] boxedArray = collection.toArray();\n  int len = boxedArray.length;\n  float[] array = new float[len];\n  for (int i = 0; i < len; i++) {\n      \n    array[i] = ((Number) checkNotNull(boxedArray[i])).floatValue();\n  }\n  return array;\n}",
        "summary_tokens": [
            "returns",
            "an",
            "array",
            "containing",
            "each",
            "value",
            "of",
            "collection",
            "converted",
            "to",
            "a",
            "float",
            "value",
            "in",
            "the",
            "manner",
            "of",
            "number",
            "float",
            "value"
        ]
    },
    {
        "id": 1537,
        "code": "public static List<Float> asList(float... backingArray) {\n  if (backingArray.length == 0) {\n    return Collections.emptyList();\n  }\n  return new FloatArrayAsList(backingArray);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "fixed",
            "size",
            "list",
            "backed",
            "by",
            "the",
            "specified",
            "array",
            "similar",
            "to",
            "arrays",
            "as",
            "list",
            "object"
        ]
    },
    {
        "id": 1538,
        "code": "public static Float tryParse(String string) {\n  if (Doubles.FLOATING_POINT_PATTERN.matcher(string).matches()) {\n      \n      \n    try {\n      return Float.parseFloat(string);\n    } catch (NumberFormatException e) {\n        \n        \n    }\n  }\n  return null;\n}",
        "summary_tokens": [
            "parses",
            "the",
            "specified",
            "string",
            "as",
            "a",
            "single",
            "precision",
            "floating",
            "point",
            "value"
        ]
    },
    {
        "id": 1539,
        "code": "public static ImmutableDoubleArray of(double first, double... rest) {\n  checkArgument(\n      rest.length <= Integer.MAX_VALUE - 1, \"the total number of elements must fit in an int\");\n  double[] array = new double[rest.length + 1];\n  array[0] = first;\n  System.arraycopy(rest, 0, array, 1, rest.length);\n  return new ImmutableDoubleArray(array);\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "array",
            "containing",
            "the",
            "given",
            "values",
            "in",
            "order"
        ]
    },
    {
        "id": 1540,
        "code": "public static ImmutableDoubleArray copyOf(DoubleStream stream) {\n    \n  double[] array = stream.toArray();\n  return (array.length == 0) ? EMPTY : new ImmutableDoubleArray(array);\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "array",
            "containing",
            "all",
            "the",
            "values",
            "from",
            "stream",
            "in",
            "order"
        ]
    },
    {
        "id": 1541,
        "code": "public static Builder builder() {\n  return new Builder(10);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "empty",
            "builder",
            "for",
            "immutable",
            "double",
            "array",
            "instances",
            "with",
            "a",
            "default",
            "initial",
            "capacity"
        ]
    },
    {
        "id": 1542,
        "code": "public int length() {\n  return end - start;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "values",
            "in",
            "this",
            "array"
        ]
    },
    {
        "id": 1543,
        "code": "public boolean isEmpty() {\n  return end == start;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "there",
            "are",
            "no",
            "values",
            "in",
            "this",
            "array",
            "length",
            "is",
            "zero"
        ]
    },
    {
        "id": 1544,
        "code": "public double get(int index) {\n  Preconditions.checkElementIndex(index, length());\n  return array[start + index];\n}",
        "summary_tokens": [
            "returns",
            "the",
            "double",
            "value",
            "present",
            "at",
            "the",
            "given",
            "index"
        ]
    },
    {
        "id": 1545,
        "code": "public int indexOf(double target) {\n  for (int i = start; i < end; i++) {\n    if (areEqual(array[i], target)) {\n      return i - start;\n    }\n  }\n  return -1;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "smallest",
            "index",
            "for",
            "which",
            "get",
            "returns",
            "target",
            "or",
            "0",
            "if",
            "no",
            "such",
            "index",
            "exists"
        ]
    },
    {
        "id": 1546,
        "code": "public int lastIndexOf(double target) {\n  for (int i = end - 1; i >= start; i--) {\n    if (areEqual(array[i], target)) {\n      return i - start;\n    }\n  }\n  return -1;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "largest",
            "index",
            "for",
            "which",
            "get",
            "returns",
            "target",
            "or",
            "0",
            "if",
            "no",
            "such",
            "index",
            "exists"
        ]
    },
    {
        "id": 1547,
        "code": "public boolean contains(double target) {\n  return indexOf(target) >= 0;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "target",
            "is",
            "present",
            "at",
            "any",
            "index",
            "in",
            "this",
            "array"
        ]
    },
    {
        "id": 1548,
        "code": "public double[] toArray() {\n  return Arrays.copyOfRange(array, start, end);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "mutable",
            "copy",
            "of",
            "this",
            "array",
            "s",
            "values",
            "as",
            "a",
            "primitive",
            "double"
        ]
    },
    {
        "id": 1549,
        "code": "public ImmutableDoubleArray subArray(int startIndex, int endIndex) {\n  Preconditions.checkPositionIndexes(startIndex, endIndex, length());\n  return startIndex == endIndex\n      ? EMPTY\n      : new ImmutableDoubleArray(array, start + startIndex, start + endIndex);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "immutable",
            "array",
            "containing",
            "the",
            "values",
            "in",
            "the",
            "specified",
            "range"
        ]
    },
    {
        "id": 1550,
        "code": "public List<Double> asList() {\n    \n  return new AsList(this);\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "i",
            "view",
            "i",
            "of",
            "this",
            "array",
            "s",
            "values",
            "as",
            "a",
            "list",
            "note",
            "that",
            "double",
            "values",
            "are",
            "boxed",
            "into",
            "double",
            "instances",
            "on",
            "demand",
            "which",
            "can",
            "be",
            "very",
            "expensive"
        ]
    },
    {
        "id": 1551,
        "code": "public boolean equals(@CheckForNull Object object) {\n  if (object == this) {\n    return true;\n  }\n  if (!(object instanceof ImmutableDoubleArray)) {\n    return false;\n  }\n  ImmutableDoubleArray that = (ImmutableDoubleArray) object;\n  if (this.length() != that.length()) {\n    return false;\n  }\n  for (int i = 0; i < length(); i++) {\n    if (!areEqual(this.get(i), that.get(i))) {\n      return false;\n    }\n  }\n  return true;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "object",
            "is",
            "an",
            "immutable",
            "double",
            "array",
            "containing",
            "the",
            "same",
            "values",
            "as",
            "this",
            "one",
            "in",
            "the",
            "same",
            "order"
        ]
    },
    {
        "id": 1552,
        "code": "public int hashCode() {\n  int hash = 1;\n  for (int i = start; i < end; i++) {\n    hash *= 31;\n    hash += Doubles.hashCode(array[i]);\n  }\n  return hash;\n}",
        "summary_tokens": [
            "returns",
            "an",
            "unspecified",
            "hash",
            "code",
            "for",
            "the",
            "contents",
            "of",
            "this",
            "immutable",
            "array"
        ]
    },
    {
        "id": 1553,
        "code": "public String toString() {\n  if (isEmpty()) {\n    return \"[]\";\n  }\n  StringBuilder builder = new StringBuilder(length() * 5); \n  builder.append('[').append(array[start]);\n\n  for (int i = start + 1; i < end; i++) {\n    builder.append(\", \").append(array[i]);\n  }\n  builder.append(']');\n  return builder.toString();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "string",
            "representation",
            "of",
            "this",
            "array",
            "in",
            "the",
            "same",
            "form",
            "as",
            "arrays",
            "to",
            "string",
            "double",
            "for",
            "example",
            "0",
            "0",
            "0"
        ]
    },
    {
        "id": 1554,
        "code": "public ImmutableDoubleArray trimmed() {\n  return isPartialView() ? new ImmutableDoubleArray(toArray()) : this;\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "array",
            "containing",
            "the",
            "same",
            "values",
            "as",
            "this",
            "array"
        ]
    },
    {
        "id": 1555,
        "code": "public static ImmutableIntArray of(int first, int... rest) {\n  checkArgument(\n      rest.length <= Integer.MAX_VALUE - 1, \"the total number of elements must fit in an int\");\n  int[] array = new int[rest.length + 1];\n  array[0] = first;\n  System.arraycopy(rest, 0, array, 1, rest.length);\n  return new ImmutableIntArray(array);\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "array",
            "containing",
            "the",
            "given",
            "values",
            "in",
            "order"
        ]
    },
    {
        "id": 1556,
        "code": "public static ImmutableIntArray copyOf(IntStream stream) {\n    \n  int[] array = stream.toArray();\n  return (array.length == 0) ? EMPTY : new ImmutableIntArray(array);\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "array",
            "containing",
            "all",
            "the",
            "values",
            "from",
            "stream",
            "in",
            "order"
        ]
    },
    {
        "id": 1557,
        "code": "public static Builder builder() {\n  return new Builder(10);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "empty",
            "builder",
            "for",
            "immutable",
            "int",
            "array",
            "instances",
            "with",
            "a",
            "default",
            "initial",
            "capacity"
        ]
    },
    {
        "id": 1558,
        "code": "public int length() {\n  return end - start;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "values",
            "in",
            "this",
            "array"
        ]
    },
    {
        "id": 1559,
        "code": "public boolean isEmpty() {\n  return end == start;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "there",
            "are",
            "no",
            "values",
            "in",
            "this",
            "array",
            "length",
            "is",
            "zero"
        ]
    },
    {
        "id": 1560,
        "code": "public int get(int index) {\n  Preconditions.checkElementIndex(index, length());\n  return array[start + index];\n}",
        "summary_tokens": [
            "returns",
            "the",
            "int",
            "value",
            "present",
            "at",
            "the",
            "given",
            "index"
        ]
    },
    {
        "id": 1561,
        "code": "public int indexOf(int target) {\n  for (int i = start; i < end; i++) {\n    if (array[i] == target) {\n      return i - start;\n    }\n  }\n  return -1;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "smallest",
            "index",
            "for",
            "which",
            "get",
            "returns",
            "target",
            "or",
            "0",
            "if",
            "no",
            "such",
            "index",
            "exists"
        ]
    },
    {
        "id": 1562,
        "code": "public int lastIndexOf(int target) {\n  for (int i = end - 1; i >= start; i--) {\n    if (array[i] == target) {\n      return i - start;\n    }\n  }\n  return -1;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "largest",
            "index",
            "for",
            "which",
            "get",
            "returns",
            "target",
            "or",
            "0",
            "if",
            "no",
            "such",
            "index",
            "exists"
        ]
    },
    {
        "id": 1563,
        "code": "public boolean contains(int target) {\n  return indexOf(target) >= 0;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "target",
            "is",
            "present",
            "at",
            "any",
            "index",
            "in",
            "this",
            "array"
        ]
    },
    {
        "id": 1564,
        "code": "public int[] toArray() {\n  return Arrays.copyOfRange(array, start, end);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "mutable",
            "copy",
            "of",
            "this",
            "array",
            "s",
            "values",
            "as",
            "a",
            "primitive",
            "int"
        ]
    },
    {
        "id": 1565,
        "code": "public ImmutableIntArray subArray(int startIndex, int endIndex) {\n  Preconditions.checkPositionIndexes(startIndex, endIndex, length());\n  return startIndex == endIndex\n      ? EMPTY\n      : new ImmutableIntArray(array, start + startIndex, start + endIndex);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "immutable",
            "array",
            "containing",
            "the",
            "values",
            "in",
            "the",
            "specified",
            "range"
        ]
    },
    {
        "id": 1566,
        "code": "public List<Integer> asList() {\n    \n  return new AsList(this);\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "i",
            "view",
            "i",
            "of",
            "this",
            "array",
            "s",
            "values",
            "as",
            "a",
            "list",
            "note",
            "that",
            "int",
            "values",
            "are",
            "boxed",
            "into",
            "integer",
            "instances",
            "on",
            "demand",
            "which",
            "can",
            "be",
            "very",
            "expensive"
        ]
    },
    {
        "id": 1567,
        "code": "public boolean equals(@CheckForNull Object object) {\n  if (object == this) {\n    return true;\n  }\n  if (!(object instanceof ImmutableIntArray)) {\n    return false;\n  }\n  ImmutableIntArray that = (ImmutableIntArray) object;\n  if (this.length() != that.length()) {\n    return false;\n  }\n  for (int i = 0; i < length(); i++) {\n    if (this.get(i) != that.get(i)) {\n      return false;\n    }\n  }\n  return true;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "object",
            "is",
            "an",
            "immutable",
            "int",
            "array",
            "containing",
            "the",
            "same",
            "values",
            "as",
            "this",
            "one",
            "in",
            "the",
            "same",
            "order"
        ]
    },
    {
        "id": 1568,
        "code": "public int hashCode() {\n  int hash = 1;\n  for (int i = start; i < end; i++) {\n    hash *= 31;\n    hash += Ints.hashCode(array[i]);\n  }\n  return hash;\n}",
        "summary_tokens": [
            "returns",
            "an",
            "unspecified",
            "hash",
            "code",
            "for",
            "the",
            "contents",
            "of",
            "this",
            "immutable",
            "array"
        ]
    },
    {
        "id": 1569,
        "code": "public String toString() {\n  if (isEmpty()) {\n    return \"[]\";\n  }\n  StringBuilder builder = new StringBuilder(length() * 5); \n  builder.append('[').append(array[start]);\n\n  for (int i = start + 1; i < end; i++) {\n    builder.append(\", \").append(array[i]);\n  }\n  builder.append(']');\n  return builder.toString();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "string",
            "representation",
            "of",
            "this",
            "array",
            "in",
            "the",
            "same",
            "form",
            "as",
            "arrays",
            "to",
            "string",
            "int",
            "for",
            "example",
            "0",
            "0",
            "0"
        ]
    },
    {
        "id": 1570,
        "code": "public ImmutableIntArray trimmed() {\n  return isPartialView() ? new ImmutableIntArray(toArray()) : this;\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "array",
            "containing",
            "the",
            "same",
            "values",
            "as",
            "this",
            "array"
        ]
    },
    {
        "id": 1571,
        "code": "public static ImmutableLongArray of(long first, long... rest) {\n  checkArgument(\n      rest.length <= Integer.MAX_VALUE - 1, \"the total number of elements must fit in an int\");\n  long[] array = new long[rest.length + 1];\n  array[0] = first;\n  System.arraycopy(rest, 0, array, 1, rest.length);\n  return new ImmutableLongArray(array);\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "array",
            "containing",
            "the",
            "given",
            "values",
            "in",
            "order"
        ]
    },
    {
        "id": 1572,
        "code": "public static ImmutableLongArray copyOf(LongStream stream) {\n    \n  long[] array = stream.toArray();\n  return (array.length == 0) ? EMPTY : new ImmutableLongArray(array);\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "array",
            "containing",
            "all",
            "the",
            "values",
            "from",
            "stream",
            "in",
            "order"
        ]
    },
    {
        "id": 1573,
        "code": "public static Builder builder() {\n  return new Builder(10);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "empty",
            "builder",
            "for",
            "immutable",
            "long",
            "array",
            "instances",
            "with",
            "a",
            "default",
            "initial",
            "capacity"
        ]
    },
    {
        "id": 1574,
        "code": "public int length() {\n  return end - start;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "values",
            "in",
            "this",
            "array"
        ]
    },
    {
        "id": 1575,
        "code": "public boolean isEmpty() {\n  return end == start;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "there",
            "are",
            "no",
            "values",
            "in",
            "this",
            "array",
            "length",
            "is",
            "zero"
        ]
    },
    {
        "id": 1576,
        "code": "public long get(int index) {\n  Preconditions.checkElementIndex(index, length());\n  return array[start + index];\n}",
        "summary_tokens": [
            "returns",
            "the",
            "long",
            "value",
            "present",
            "at",
            "the",
            "given",
            "index"
        ]
    },
    {
        "id": 1577,
        "code": "public int indexOf(long target) {\n  for (int i = start; i < end; i++) {\n    if (array[i] == target) {\n      return i - start;\n    }\n  }\n  return -1;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "smallest",
            "index",
            "for",
            "which",
            "get",
            "returns",
            "target",
            "or",
            "0",
            "if",
            "no",
            "such",
            "index",
            "exists"
        ]
    },
    {
        "id": 1578,
        "code": "public int lastIndexOf(long target) {\n  for (int i = end - 1; i >= start; i--) {\n    if (array[i] == target) {\n      return i - start;\n    }\n  }\n  return -1;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "largest",
            "index",
            "for",
            "which",
            "get",
            "returns",
            "target",
            "or",
            "0",
            "if",
            "no",
            "such",
            "index",
            "exists"
        ]
    },
    {
        "id": 1579,
        "code": "public boolean contains(long target) {\n  return indexOf(target) >= 0;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "target",
            "is",
            "present",
            "at",
            "any",
            "index",
            "in",
            "this",
            "array"
        ]
    },
    {
        "id": 1580,
        "code": "public long[] toArray() {\n  return Arrays.copyOfRange(array, start, end);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "mutable",
            "copy",
            "of",
            "this",
            "array",
            "s",
            "values",
            "as",
            "a",
            "primitive",
            "long"
        ]
    },
    {
        "id": 1581,
        "code": "public ImmutableLongArray subArray(int startIndex, int endIndex) {\n  Preconditions.checkPositionIndexes(startIndex, endIndex, length());\n  return startIndex == endIndex\n      ? EMPTY\n      : new ImmutableLongArray(array, start + startIndex, start + endIndex);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "immutable",
            "array",
            "containing",
            "the",
            "values",
            "in",
            "the",
            "specified",
            "range"
        ]
    },
    {
        "id": 1582,
        "code": "public List<Long> asList() {\n    \n  return new AsList(this);\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "i",
            "view",
            "i",
            "of",
            "this",
            "array",
            "s",
            "values",
            "as",
            "a",
            "list",
            "note",
            "that",
            "long",
            "values",
            "are",
            "boxed",
            "into",
            "long",
            "instances",
            "on",
            "demand",
            "which",
            "can",
            "be",
            "very",
            "expensive"
        ]
    },
    {
        "id": 1583,
        "code": "public boolean equals(@CheckForNull Object object) {\n  if (object == this) {\n    return true;\n  }\n  if (!(object instanceof ImmutableLongArray)) {\n    return false;\n  }\n  ImmutableLongArray that = (ImmutableLongArray) object;\n  if (this.length() != that.length()) {\n    return false;\n  }\n  for (int i = 0; i < length(); i++) {\n    if (this.get(i) != that.get(i)) {\n      return false;\n    }\n  }\n  return true;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "object",
            "is",
            "an",
            "immutable",
            "long",
            "array",
            "containing",
            "the",
            "same",
            "values",
            "as",
            "this",
            "one",
            "in",
            "the",
            "same",
            "order"
        ]
    },
    {
        "id": 1584,
        "code": "public int hashCode() {\n  int hash = 1;\n  for (int i = start; i < end; i++) {\n    hash *= 31;\n    hash += Longs.hashCode(array[i]);\n  }\n  return hash;\n}",
        "summary_tokens": [
            "returns",
            "an",
            "unspecified",
            "hash",
            "code",
            "for",
            "the",
            "contents",
            "of",
            "this",
            "immutable",
            "array"
        ]
    },
    {
        "id": 1585,
        "code": "public String toString() {\n  if (isEmpty()) {\n    return \"[]\";\n  }\n  StringBuilder builder = new StringBuilder(length() * 5); \n  builder.append('[').append(array[start]);\n\n  for (int i = start + 1; i < end; i++) {\n    builder.append(\", \").append(array[i]);\n  }\n  builder.append(']');\n  return builder.toString();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "string",
            "representation",
            "of",
            "this",
            "array",
            "in",
            "the",
            "same",
            "form",
            "as",
            "arrays",
            "to",
            "string",
            "long",
            "for",
            "example",
            "0",
            "0",
            "0"
        ]
    },
    {
        "id": 1586,
        "code": "public ImmutableLongArray trimmed() {\n  return isPartialView() ? new ImmutableLongArray(toArray()) : this;\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "array",
            "containing",
            "the",
            "same",
            "values",
            "as",
            "this",
            "array"
        ]
    },
    {
        "id": 1587,
        "code": "public static int hashCode(int value) {\n  return value;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "hash",
            "code",
            "for",
            "value",
            "equal",
            "to",
            "the",
            "result",
            "of",
            "invoking",
            "integer",
            "value"
        ]
    },
    {
        "id": 1588,
        "code": "public static int checkedCast(long value) {\n  int result = (int) value;\n  checkArgument(result == value, \"Out of range: %s\", value);\n  return result;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "int",
            "value",
            "that",
            "is",
            "equal",
            "to",
            "value",
            "if",
            "possible"
        ]
    },
    {
        "id": 1589,
        "code": "public static int saturatedCast(long value) {\n  if (value > Integer.MAX_VALUE) {\n    return Integer.MAX_VALUE;\n  }\n  if (value < Integer.MIN_VALUE) {\n    return Integer.MIN_VALUE;\n  }\n  return (int) value;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "int",
            "nearest",
            "in",
            "value",
            "to",
            "value"
        ]
    },
    {
        "id": 1590,
        "code": "public static int compare(int a, int b) {\n  return (a < b) ? -1 : ((a > b) ? 1 : 0);\n}",
        "summary_tokens": [
            "compares",
            "the",
            "two",
            "specified",
            "int",
            "values"
        ]
    },
    {
        "id": 1591,
        "code": "public static boolean contains(int[] array, int target) {\n  for (int value : array) {\n    if (value == target) {\n      return true;\n    }\n  }\n  return false;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "target",
            "is",
            "present",
            "as",
            "an",
            "element",
            "anywhere",
            "in",
            "array"
        ]
    },
    {
        "id": 1592,
        "code": "public static int indexOf(int[] array, int[] target) {\n  checkNotNull(array, \"array\");\n  checkNotNull(target, \"target\");\n  if (target.length == 0) {\n    return 0;\n  }\n\n  outer:\n  for (int i = 0; i < array.length - target.length + 1; i++) {\n    for (int j = 0; j < target.length; j++) {\n      if (array[i + j] != target[j]) {\n        continue outer;\n      }\n    }\n    return i;\n  }\n  return -1;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "start",
            "position",
            "of",
            "the",
            "first",
            "occurrence",
            "of",
            "the",
            "specified",
            "target",
            "within",
            "array",
            "or",
            "0",
            "if",
            "there",
            "is",
            "no",
            "such",
            "occurrence"
        ]
    },
    {
        "id": 1593,
        "code": "public static int lastIndexOf(int[] array, int target) {\n  return lastIndexOf(array, target, 0, array.length);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "index",
            "of",
            "the",
            "last",
            "appearance",
            "of",
            "the",
            "value",
            "target",
            "in",
            "array"
        ]
    },
    {
        "id": 1594,
        "code": "public static int min(int... array) {\n  checkArgument(array.length > 0);\n  int min = array[0];\n  for (int i = 1; i < array.length; i++) {\n    if (array[i] < min) {\n      min = array[i];\n    }\n  }\n  return min;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "least",
            "value",
            "present",
            "in",
            "array"
        ]
    },
    {
        "id": 1595,
        "code": "public static int max(int... array) {\n  checkArgument(array.length > 0);\n  int max = array[0];\n  for (int i = 1; i < array.length; i++) {\n    if (array[i] > max) {\n      max = array[i];\n    }\n  }\n  return max;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "greatest",
            "value",
            "present",
            "in",
            "array"
        ]
    },
    {
        "id": 1596,
        "code": "public static int constrainToRange(int value, int min, int max) {\n  checkArgument(min <= max, \"min (%s) must be less than or equal to max (%s)\", min, max);\n  return Math.min(Math.max(value, min), max);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "value",
            "nearest",
            "to",
            "value",
            "which",
            "is",
            "within",
            "the",
            "closed",
            "range",
            "min"
        ]
    },
    {
        "id": 1597,
        "code": "public static int[] concat(int[]... arrays) {\n  int length = 0;\n  for (int[] array : arrays) {\n    length += array.length;\n  }\n  int[] result = new int[length];\n  int pos = 0;\n  for (int[] array : arrays) {\n    System.arraycopy(array, 0, result, pos, array.length);\n    pos += array.length;\n  }\n  return result;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "values",
            "from",
            "each",
            "provided",
            "array",
            "combined",
            "into",
            "a",
            "single",
            "array"
        ]
    },
    {
        "id": 1598,
        "code": "public static byte[] toByteArray(int value) {\n  return new byte[] {\n    (byte) (value >> 24), (byte) (value >> 16), (byte) (value >> 8), (byte) value\n  };\n}",
        "summary_tokens": [
            "returns",
            "a",
            "big",
            "endian",
            "representation",
            "of",
            "value",
            "in",
            "a",
            "0",
            "element",
            "byte",
            "array",
            "equivalent",
            "to",
            "byte",
            "buffer"
        ]
    },
    {
        "id": 1599,
        "code": "public static int fromByteArray(byte[] bytes) {\n  checkArgument(bytes.length >= BYTES, \"array too small: %s < %s\", bytes.length, BYTES);\n  return fromBytes(bytes[0], bytes[1], bytes[2], bytes[3]);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "int",
            "value",
            "whose",
            "big",
            "endian",
            "representation",
            "is",
            "stored",
            "in",
            "the",
            "first",
            "0",
            "bytes",
            "of",
            "bytes",
            "equivalent",
            "to",
            "byte",
            "buffer"
        ]
    },
    {
        "id": 1600,
        "code": "public static int fromBytes(byte b1, byte b2, byte b3, byte b4) {\n  return b1 << 24 | (b2 & 0xFF) << 16 | (b3 & 0xFF) << 8 | (b4 & 0xFF);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "int",
            "value",
            "whose",
            "byte",
            "representation",
            "is",
            "the",
            "given",
            "0",
            "bytes",
            "in",
            "big",
            "endian",
            "order",
            "equivalent",
            "to",
            "ints"
        ]
    },
    {
        "id": 1601,
        "code": "public static Converter<String, Integer> stringConverter() {\n  return IntConverter.INSTANCE;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "serializable",
            "converter",
            "object",
            "that",
            "converts",
            "between",
            "strings",
            "and",
            "integers",
            "using",
            "integer",
            "decode",
            "and",
            "integer",
            "to",
            "string"
        ]
    },
    {
        "id": 1602,
        "code": "public static int[] ensureCapacity(int[] array, int minLength, int padding) {\n  checkArgument(minLength >= 0, \"Invalid minLength: %s\", minLength);\n  checkArgument(padding >= 0, \"Invalid padding: %s\", padding);\n  return (array.length < minLength) ? Arrays.copyOf(array, minLength + padding) : array;\n}",
        "summary_tokens": [
            "returns",
            "an",
            "array",
            "containing",
            "the",
            "same",
            "values",
            "as",
            "array",
            "but",
            "guaranteed",
            "to",
            "be",
            "of",
            "a",
            "specified",
            "minimum",
            "length"
        ]
    },
    {
        "id": 1603,
        "code": "public static String join(String separator, int... array) {\n  checkNotNull(separator);\n  if (array.length == 0) {\n    return \"\";\n  }\n\n    \n  StringBuilder builder = new StringBuilder(array.length * 5);\n  builder.append(array[0]);\n  for (int i = 1; i < array.length; i++) {\n    builder.append(separator).append(array[i]);\n  }\n  return builder.toString();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "string",
            "containing",
            "the",
            "supplied",
            "int",
            "values",
            "separated",
            "by",
            "separator"
        ]
    },
    {
        "id": 1604,
        "code": "public static Comparator<int[]> lexicographicalComparator() {\n  return LexicographicalComparator.INSTANCE;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "comparator",
            "that",
            "compares",
            "two",
            "int",
            "arrays",
            "a",
            "href",
            "http",
            "en"
        ]
    },
    {
        "id": 1605,
        "code": "public static void sortDescending(int[] array, int fromIndex, int toIndex) {\n  checkNotNull(array);\n  checkPositionIndexes(fromIndex, toIndex, array.length);\n  Arrays.sort(array, fromIndex, toIndex);\n  reverse(array, fromIndex, toIndex);\n}",
        "summary_tokens": [
            "sorts",
            "the",
            "elements",
            "of",
            "array",
            "between",
            "from",
            "index",
            "inclusive",
            "and",
            "to",
            "index",
            "exclusive",
            "in",
            "descending",
            "order"
        ]
    },
    {
        "id": 1606,
        "code": "public static void reverse(int[] array, int fromIndex, int toIndex) {\n  checkNotNull(array);\n  checkPositionIndexes(fromIndex, toIndex, array.length);\n  for (int i = fromIndex, j = toIndex - 1; i < j; i++, j--) {\n    int tmp = array[i];\n    array[i] = array[j];\n    array[j] = tmp;\n  }\n}",
        "summary_tokens": [
            "reverses",
            "the",
            "elements",
            "of",
            "array",
            "between",
            "from",
            "index",
            "inclusive",
            "and",
            "to",
            "index",
            "exclusive"
        ]
    },
    {
        "id": 1607,
        "code": "public static int[] toArray(Collection<? extends Number> collection) {\n  if (collection instanceof IntArrayAsList) {\n    return ((IntArrayAsList) collection).toIntArray();\n  }\n\n  Object[] boxedArray = collection.toArray();\n  int len = boxedArray.length;\n  int[] array = new int[len];\n  for (int i = 0; i < len; i++) {\n      \n    array[i] = ((Number) checkNotNull(boxedArray[i])).intValue();\n  }\n  return array;\n}",
        "summary_tokens": [
            "returns",
            "an",
            "array",
            "containing",
            "each",
            "value",
            "of",
            "collection",
            "converted",
            "to",
            "a",
            "int",
            "value",
            "in",
            "the",
            "manner",
            "of",
            "number",
            "int",
            "value"
        ]
    },
    {
        "id": 1608,
        "code": "public static List<Integer> asList(int... backingArray) {\n  if (backingArray.length == 0) {\n    return Collections.emptyList();\n  }\n  return new IntArrayAsList(backingArray);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "fixed",
            "size",
            "list",
            "backed",
            "by",
            "the",
            "specified",
            "array",
            "similar",
            "to",
            "arrays",
            "as",
            "list",
            "object"
        ]
    },
    {
        "id": 1609,
        "code": "public static Integer tryParse(String string, int radix) {\n  Long result = Longs.tryParse(string, radix);\n  if (result == null || result.longValue() != result.intValue()) {\n    return null;\n  } else {\n    return result.intValue();\n  }\n}",
        "summary_tokens": [
            "parses",
            "the",
            "specified",
            "string",
            "as",
            "a",
            "signed",
            "integer",
            "value",
            "using",
            "the",
            "specified",
            "radix"
        ]
    },
    {
        "id": 1610,
        "code": "public static int hashCode(long value) {\n  return (int) (value ^ (value >>> 32));\n}",
        "summary_tokens": [
            "returns",
            "a",
            "hash",
            "code",
            "for",
            "value",
            "equal",
            "to",
            "the",
            "result",
            "of",
            "invoking",
            "long",
            "value"
        ]
    },
    {
        "id": 1611,
        "code": "public static int compare(long a, long b) {\n  return (a < b) ? -1 : ((a > b) ? 1 : 0);\n}",
        "summary_tokens": [
            "compares",
            "the",
            "two",
            "specified",
            "long",
            "values"
        ]
    },
    {
        "id": 1612,
        "code": "public static boolean contains(long[] array, long target) {\n  for (long value : array) {\n    if (value == target) {\n      return true;\n    }\n  }\n  return false;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "target",
            "is",
            "present",
            "as",
            "an",
            "element",
            "anywhere",
            "in",
            "array"
        ]
    },
    {
        "id": 1613,
        "code": "public static int indexOf(long[] array, long[] target) {\n  checkNotNull(array, \"array\");\n  checkNotNull(target, \"target\");\n  if (target.length == 0) {\n    return 0;\n  }\n\n  outer:\n  for (int i = 0; i < array.length - target.length + 1; i++) {\n    for (int j = 0; j < target.length; j++) {\n      if (array[i + j] != target[j]) {\n        continue outer;\n      }\n    }\n    return i;\n  }\n  return -1;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "start",
            "position",
            "of",
            "the",
            "first",
            "occurrence",
            "of",
            "the",
            "specified",
            "target",
            "within",
            "array",
            "or",
            "0",
            "if",
            "there",
            "is",
            "no",
            "such",
            "occurrence"
        ]
    },
    {
        "id": 1614,
        "code": "public static int lastIndexOf(long[] array, long target) {\n  return lastIndexOf(array, target, 0, array.length);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "index",
            "of",
            "the",
            "last",
            "appearance",
            "of",
            "the",
            "value",
            "target",
            "in",
            "array"
        ]
    },
    {
        "id": 1615,
        "code": "public static long min(long... array) {\n  checkArgument(array.length > 0);\n  long min = array[0];\n  for (int i = 1; i < array.length; i++) {\n    if (array[i] < min) {\n      min = array[i];\n    }\n  }\n  return min;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "least",
            "value",
            "present",
            "in",
            "array"
        ]
    },
    {
        "id": 1616,
        "code": "public static long max(long... array) {\n  checkArgument(array.length > 0);\n  long max = array[0];\n  for (int i = 1; i < array.length; i++) {\n    if (array[i] > max) {\n      max = array[i];\n    }\n  }\n  return max;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "greatest",
            "value",
            "present",
            "in",
            "array"
        ]
    },
    {
        "id": 1617,
        "code": "public static long constrainToRange(long value, long min, long max) {\n  checkArgument(min <= max, \"min (%s) must be less than or equal to max (%s)\", min, max);\n  return Math.min(Math.max(value, min), max);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "value",
            "nearest",
            "to",
            "value",
            "which",
            "is",
            "within",
            "the",
            "closed",
            "range",
            "min"
        ]
    },
    {
        "id": 1618,
        "code": "public static long[] concat(long[]... arrays) {\n  int length = 0;\n  for (long[] array : arrays) {\n    length += array.length;\n  }\n  long[] result = new long[length];\n  int pos = 0;\n  for (long[] array : arrays) {\n    System.arraycopy(array, 0, result, pos, array.length);\n    pos += array.length;\n  }\n  return result;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "values",
            "from",
            "each",
            "provided",
            "array",
            "combined",
            "into",
            "a",
            "single",
            "array"
        ]
    },
    {
        "id": 1619,
        "code": "public static byte[] toByteArray(long value) {\n    \n    \n  byte[] result = new byte[8];\n  for (int i = 7; i >= 0; i--) {\n    result[i] = (byte) (value & 0xffL);\n    value >>= 8;\n  }\n  return result;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "big",
            "endian",
            "representation",
            "of",
            "value",
            "in",
            "an",
            "0",
            "element",
            "byte",
            "array",
            "equivalent",
            "to",
            "byte",
            "buffer"
        ]
    },
    {
        "id": 1620,
        "code": "public static long fromByteArray(byte[] bytes) {\n  checkArgument(bytes.length >= BYTES, \"array too small: %s < %s\", bytes.length, BYTES);\n  return fromBytes(\n      bytes[0], bytes[1], bytes[2], bytes[3], bytes[4], bytes[5], bytes[6], bytes[7]);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "long",
            "value",
            "whose",
            "big",
            "endian",
            "representation",
            "is",
            "stored",
            "in",
            "the",
            "first",
            "0",
            "bytes",
            "of",
            "bytes",
            "equivalent",
            "to",
            "byte",
            "buffer"
        ]
    },
    {
        "id": 1621,
        "code": "public static long fromBytes(\n    byte b1, byte b2, byte b3, byte b4, byte b5, byte b6, byte b7, byte b8) {\n  return (b1 & 0xFFL) << 56\n      | (b2 & 0xFFL) << 48\n      | (b3 & 0xFFL) << 40\n      | (b4 & 0xFFL) << 32\n      | (b5 & 0xFFL) << 24\n      | (b6 & 0xFFL) << 16\n      | (b7 & 0xFFL) << 8\n      | (b8 & 0xFFL);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "long",
            "value",
            "whose",
            "byte",
            "representation",
            "is",
            "the",
            "given",
            "0",
            "bytes",
            "in",
            "big",
            "endian",
            "order",
            "equivalent",
            "to",
            "longs"
        ]
    },
    {
        "id": 1622,
        "code": "public static Long tryParse(String string, int radix) {\n  if (checkNotNull(string).isEmpty()) {\n    return null;\n  }\n  if (radix < Character.MIN_RADIX || radix > Character.MAX_RADIX) {\n    throw new IllegalArgumentException(\n        \"radix must be between MIN_RADIX and MAX_RADIX but was \" + radix);\n  }\n  boolean negative = string.charAt(0) == '-';\n  int index = negative ? 1 : 0;\n  if (index == string.length()) {\n    return null;\n  }\n  int digit = AsciiDigits.digit(string.charAt(index++));\n  if (digit < 0 || digit >= radix) {\n    return null;\n  }\n  long accum = -digit;\n\n  long cap = Long.MIN_VALUE / radix;\n\n  while (index < string.length()) {\n    digit = AsciiDigits.digit(string.charAt(index++));\n    if (digit < 0 || digit >= radix || accum < cap) {\n      return null;\n    }\n    accum *= radix;\n    if (accum < Long.MIN_VALUE + digit) {\n      return null;\n    }\n    accum -= digit;\n  }\n\n  if (negative) {\n    return accum;\n  } else if (accum == Long.MIN_VALUE) {\n    return null;\n  } else {\n    return -accum;\n  }\n}",
        "summary_tokens": [
            "parses",
            "the",
            "specified",
            "string",
            "as",
            "a",
            "signed",
            "long",
            "value",
            "using",
            "the",
            "specified",
            "radix"
        ]
    },
    {
        "id": 1623,
        "code": "public static Converter<String, Long> stringConverter() {\n  return LongConverter.INSTANCE;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "serializable",
            "converter",
            "object",
            "that",
            "converts",
            "between",
            "strings",
            "and",
            "longs",
            "using",
            "long",
            "decode",
            "and",
            "long",
            "to",
            "string"
        ]
    },
    {
        "id": 1624,
        "code": "public static long[] ensureCapacity(long[] array, int minLength, int padding) {\n  checkArgument(minLength >= 0, \"Invalid minLength: %s\", minLength);\n  checkArgument(padding >= 0, \"Invalid padding: %s\", padding);\n  return (array.length < minLength) ? Arrays.copyOf(array, minLength + padding) : array;\n}",
        "summary_tokens": [
            "returns",
            "an",
            "array",
            "containing",
            "the",
            "same",
            "values",
            "as",
            "array",
            "but",
            "guaranteed",
            "to",
            "be",
            "of",
            "a",
            "specified",
            "minimum",
            "length"
        ]
    },
    {
        "id": 1625,
        "code": "public static String join(String separator, long... array) {\n  checkNotNull(separator);\n  if (array.length == 0) {\n    return \"\";\n  }\n\n    \n  StringBuilder builder = new StringBuilder(array.length * 10);\n  builder.append(array[0]);\n  for (int i = 1; i < array.length; i++) {\n    builder.append(separator).append(array[i]);\n  }\n  return builder.toString();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "string",
            "containing",
            "the",
            "supplied",
            "long",
            "values",
            "separated",
            "by",
            "separator"
        ]
    },
    {
        "id": 1626,
        "code": "public static Comparator<long[]> lexicographicalComparator() {\n  return LexicographicalComparator.INSTANCE;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "comparator",
            "that",
            "compares",
            "two",
            "long",
            "arrays",
            "a",
            "href",
            "http",
            "en"
        ]
    },
    {
        "id": 1627,
        "code": "public static void sortDescending(long[] array, int fromIndex, int toIndex) {\n  checkNotNull(array);\n  checkPositionIndexes(fromIndex, toIndex, array.length);\n  Arrays.sort(array, fromIndex, toIndex);\n  reverse(array, fromIndex, toIndex);\n}",
        "summary_tokens": [
            "sorts",
            "the",
            "elements",
            "of",
            "array",
            "between",
            "from",
            "index",
            "inclusive",
            "and",
            "to",
            "index",
            "exclusive",
            "in",
            "descending",
            "order"
        ]
    },
    {
        "id": 1628,
        "code": "public static void reverse(long[] array, int fromIndex, int toIndex) {\n  checkNotNull(array);\n  checkPositionIndexes(fromIndex, toIndex, array.length);\n  for (int i = fromIndex, j = toIndex - 1; i < j; i++, j--) {\n    long tmp = array[i];\n    array[i] = array[j];\n    array[j] = tmp;\n  }\n}",
        "summary_tokens": [
            "reverses",
            "the",
            "elements",
            "of",
            "array",
            "between",
            "from",
            "index",
            "inclusive",
            "and",
            "to",
            "index",
            "exclusive"
        ]
    },
    {
        "id": 1629,
        "code": "public static long[] toArray(Collection<? extends Number> collection) {\n  if (collection instanceof LongArrayAsList) {\n    return ((LongArrayAsList) collection).toLongArray();\n  }\n\n  Object[] boxedArray = collection.toArray();\n  int len = boxedArray.length;\n  long[] array = new long[len];\n  for (int i = 0; i < len; i++) {\n      \n    array[i] = ((Number) checkNotNull(boxedArray[i])).longValue();\n  }\n  return array;\n}",
        "summary_tokens": [
            "returns",
            "an",
            "array",
            "containing",
            "each",
            "value",
            "of",
            "collection",
            "converted",
            "to",
            "a",
            "long",
            "value",
            "in",
            "the",
            "manner",
            "of",
            "number",
            "long",
            "value"
        ]
    },
    {
        "id": 1630,
        "code": "public static List<Long> asList(long... backingArray) {\n  if (backingArray.length == 0) {\n    return Collections.emptyList();\n  }\n  return new LongArrayAsList(backingArray);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "fixed",
            "size",
            "list",
            "backed",
            "by",
            "the",
            "specified",
            "array",
            "similar",
            "to",
            "arrays",
            "as",
            "list",
            "object"
        ]
    },
    {
        "id": 1631,
        "code": "public static Set<Class<?>> allPrimitiveTypes() {\n  return PRIMITIVE_TO_WRAPPER_TYPE.keySet();\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "set",
            "of",
            "all",
            "nine",
            "primitive",
            "types",
            "including",
            "void"
        ]
    },
    {
        "id": 1632,
        "code": "public static Set<Class<?>> allWrapperTypes() {\n  return WRAPPER_TO_PRIMITIVE_TYPE.keySet();\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "set",
            "of",
            "all",
            "nine",
            "primitive",
            "wrapper",
            "types",
            "including",
            "void"
        ]
    },
    {
        "id": 1633,
        "code": "public static boolean isWrapperType(Class<?> type) {\n  return WRAPPER_TO_PRIMITIVE_TYPE.containsKey(checkNotNull(type));\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "type",
            "is",
            "one",
            "of",
            "the",
            "nine",
            "primitive",
            "wrapper",
            "types",
            "such",
            "as",
            "integer"
        ]
    },
    {
        "id": 1634,
        "code": "public static <T> Class<T> wrap(Class<T> type) {\n  checkNotNull(type);\n\n    \n  @SuppressWarnings(\"unchecked\")\n  Class<T> wrapped = (Class<T>) PRIMITIVE_TO_WRAPPER_TYPE.get(type);\n  return (wrapped == null) ? type : wrapped;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "corresponding",
            "wrapper",
            "type",
            "of",
            "type",
            "if",
            "it",
            "is",
            "a",
            "primitive",
            "type",
            "otherwise",
            "returns",
            "type",
            "itself"
        ]
    },
    {
        "id": 1635,
        "code": "public static <T> Class<T> unwrap(Class<T> type) {\n  checkNotNull(type);\n\n    \n  @SuppressWarnings(\"unchecked\")\n  Class<T> unwrapped = (Class<T>) WRAPPER_TO_PRIMITIVE_TYPE.get(type);\n  return (unwrapped == null) ? type : unwrapped;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "corresponding",
            "primitive",
            "type",
            "of",
            "type",
            "if",
            "it",
            "is",
            "a",
            "wrapper",
            "type",
            "otherwise",
            "returns",
            "type",
            "itself"
        ]
    },
    {
        "id": 1636,
        "code": "public static int hashCode(short value) {\n  return value;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "hash",
            "code",
            "for",
            "value",
            "equal",
            "to",
            "the",
            "result",
            "of",
            "invoking",
            "short",
            "value"
        ]
    },
    {
        "id": 1637,
        "code": "public static short checkedCast(long value) {\n  short result = (short) value;\n  checkArgument(result == value, \"Out of range: %s\", value);\n  return result;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "short",
            "value",
            "that",
            "is",
            "equal",
            "to",
            "value",
            "if",
            "possible"
        ]
    },
    {
        "id": 1638,
        "code": "public static short saturatedCast(long value) {\n  if (value > Short.MAX_VALUE) {\n    return Short.MAX_VALUE;\n  }\n  if (value < Short.MIN_VALUE) {\n    return Short.MIN_VALUE;\n  }\n  return (short) value;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "short",
            "nearest",
            "in",
            "value",
            "to",
            "value"
        ]
    },
    {
        "id": 1639,
        "code": "public static int compare(short a, short b) {\n  return a - b; \n}",
        "summary_tokens": [
            "compares",
            "the",
            "two",
            "specified",
            "short",
            "values"
        ]
    },
    {
        "id": 1640,
        "code": "public static boolean contains(short[] array, short target) {\n  for (short value : array) {\n    if (value == target) {\n      return true;\n    }\n  }\n  return false;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "target",
            "is",
            "present",
            "as",
            "an",
            "element",
            "anywhere",
            "in",
            "array"
        ]
    },
    {
        "id": 1641,
        "code": "public static int indexOf(short[] array, short[] target) {\n  checkNotNull(array, \"array\");\n  checkNotNull(target, \"target\");\n  if (target.length == 0) {\n    return 0;\n  }\n\n  outer:\n  for (int i = 0; i < array.length - target.length + 1; i++) {\n    for (int j = 0; j < target.length; j++) {\n      if (array[i + j] != target[j]) {\n        continue outer;\n      }\n    }\n    return i;\n  }\n  return -1;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "start",
            "position",
            "of",
            "the",
            "first",
            "occurrence",
            "of",
            "the",
            "specified",
            "target",
            "within",
            "array",
            "or",
            "0",
            "if",
            "there",
            "is",
            "no",
            "such",
            "occurrence"
        ]
    },
    {
        "id": 1642,
        "code": "public static int lastIndexOf(short[] array, short target) {\n  return lastIndexOf(array, target, 0, array.length);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "index",
            "of",
            "the",
            "last",
            "appearance",
            "of",
            "the",
            "value",
            "target",
            "in",
            "array"
        ]
    },
    {
        "id": 1643,
        "code": "public static short min(short... array) {\n  checkArgument(array.length > 0);\n  short min = array[0];\n  for (int i = 1; i < array.length; i++) {\n    if (array[i] < min) {\n      min = array[i];\n    }\n  }\n  return min;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "least",
            "value",
            "present",
            "in",
            "array"
        ]
    },
    {
        "id": 1644,
        "code": "public static short max(short... array) {\n  checkArgument(array.length > 0);\n  short max = array[0];\n  for (int i = 1; i < array.length; i++) {\n    if (array[i] > max) {\n      max = array[i];\n    }\n  }\n  return max;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "greatest",
            "value",
            "present",
            "in",
            "array"
        ]
    },
    {
        "id": 1645,
        "code": "public static short constrainToRange(short value, short min, short max) {\n  checkArgument(min <= max, \"min (%s) must be less than or equal to max (%s)\", min, max);\n  return value < min ? min : value < max ? value : max;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "value",
            "nearest",
            "to",
            "value",
            "which",
            "is",
            "within",
            "the",
            "closed",
            "range",
            "min"
        ]
    },
    {
        "id": 1646,
        "code": "public static short[] concat(short[]... arrays) {\n  int length = 0;\n  for (short[] array : arrays) {\n    length += array.length;\n  }\n  short[] result = new short[length];\n  int pos = 0;\n  for (short[] array : arrays) {\n    System.arraycopy(array, 0, result, pos, array.length);\n    pos += array.length;\n  }\n  return result;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "values",
            "from",
            "each",
            "provided",
            "array",
            "combined",
            "into",
            "a",
            "single",
            "array"
        ]
    },
    {
        "id": 1647,
        "code": "public static byte[] toByteArray(short value) {\n  return new byte[] {(byte) (value >> 8), (byte) value};\n}",
        "summary_tokens": [
            "returns",
            "a",
            "big",
            "endian",
            "representation",
            "of",
            "value",
            "in",
            "a",
            "0",
            "element",
            "byte",
            "array",
            "equivalent",
            "to",
            "byte",
            "buffer"
        ]
    },
    {
        "id": 1648,
        "code": "public static short fromByteArray(byte[] bytes) {\n  checkArgument(bytes.length >= BYTES, \"array too small: %s < %s\", bytes.length, BYTES);\n  return fromBytes(bytes[0], bytes[1]);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "short",
            "value",
            "whose",
            "big",
            "endian",
            "representation",
            "is",
            "stored",
            "in",
            "the",
            "first",
            "0",
            "bytes",
            "of",
            "bytes",
            "equivalent",
            "to",
            "byte",
            "buffer"
        ]
    },
    {
        "id": 1649,
        "code": "public static short fromBytes(byte b1, byte b2) {\n  return (short) ((b1 << 8) | (b2 & 0xFF));\n}",
        "summary_tokens": [
            "returns",
            "the",
            "short",
            "value",
            "whose",
            "byte",
            "representation",
            "is",
            "the",
            "given",
            "0",
            "bytes",
            "in",
            "big",
            "endian",
            "order",
            "equivalent",
            "to",
            "shorts"
        ]
    },
    {
        "id": 1650,
        "code": "public static Converter<String, Short> stringConverter() {\n  return ShortConverter.INSTANCE;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "serializable",
            "converter",
            "object",
            "that",
            "converts",
            "between",
            "strings",
            "and",
            "shorts",
            "using",
            "short",
            "decode",
            "and",
            "short",
            "to",
            "string"
        ]
    },
    {
        "id": 1651,
        "code": "public static short[] ensureCapacity(short[] array, int minLength, int padding) {\n  checkArgument(minLength >= 0, \"Invalid minLength: %s\", minLength);\n  checkArgument(padding >= 0, \"Invalid padding: %s\", padding);\n  return (array.length < minLength) ? Arrays.copyOf(array, minLength + padding) : array;\n}",
        "summary_tokens": [
            "returns",
            "an",
            "array",
            "containing",
            "the",
            "same",
            "values",
            "as",
            "array",
            "but",
            "guaranteed",
            "to",
            "be",
            "of",
            "a",
            "specified",
            "minimum",
            "length"
        ]
    },
    {
        "id": 1652,
        "code": "public static String join(String separator, short... array) {\n  checkNotNull(separator);\n  if (array.length == 0) {\n    return \"\";\n  }\n\n    \n  StringBuilder builder = new StringBuilder(array.length * 6);\n  builder.append(array[0]);\n  for (int i = 1; i < array.length; i++) {\n    builder.append(separator).append(array[i]);\n  }\n  return builder.toString();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "string",
            "containing",
            "the",
            "supplied",
            "short",
            "values",
            "separated",
            "by",
            "separator"
        ]
    },
    {
        "id": 1653,
        "code": "public static Comparator<short[]> lexicographicalComparator() {\n  return LexicographicalComparator.INSTANCE;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "comparator",
            "that",
            "compares",
            "two",
            "short",
            "arrays",
            "a",
            "href",
            "http",
            "en"
        ]
    },
    {
        "id": 1654,
        "code": "public static void sortDescending(short[] array, int fromIndex, int toIndex) {\n  checkNotNull(array);\n  checkPositionIndexes(fromIndex, toIndex, array.length);\n  Arrays.sort(array, fromIndex, toIndex);\n  reverse(array, fromIndex, toIndex);\n}",
        "summary_tokens": [
            "sorts",
            "the",
            "elements",
            "of",
            "array",
            "between",
            "from",
            "index",
            "inclusive",
            "and",
            "to",
            "index",
            "exclusive",
            "in",
            "descending",
            "order"
        ]
    },
    {
        "id": 1655,
        "code": "public static void reverse(short[] array, int fromIndex, int toIndex) {\n  checkNotNull(array);\n  checkPositionIndexes(fromIndex, toIndex, array.length);\n  for (int i = fromIndex, j = toIndex - 1; i < j; i++, j--) {\n    short tmp = array[i];\n    array[i] = array[j];\n    array[j] = tmp;\n  }\n}",
        "summary_tokens": [
            "reverses",
            "the",
            "elements",
            "of",
            "array",
            "between",
            "from",
            "index",
            "inclusive",
            "and",
            "to",
            "index",
            "exclusive"
        ]
    },
    {
        "id": 1656,
        "code": "public static short[] toArray(Collection<? extends Number> collection) {\n  if (collection instanceof ShortArrayAsList) {\n    return ((ShortArrayAsList) collection).toShortArray();\n  }\n\n  Object[] boxedArray = collection.toArray();\n  int len = boxedArray.length;\n  short[] array = new short[len];\n  for (int i = 0; i < len; i++) {\n      \n    array[i] = ((Number) checkNotNull(boxedArray[i])).shortValue();\n  }\n  return array;\n}",
        "summary_tokens": [
            "returns",
            "an",
            "array",
            "containing",
            "each",
            "value",
            "of",
            "collection",
            "converted",
            "to",
            "a",
            "short",
            "value",
            "in",
            "the",
            "manner",
            "of",
            "number",
            "short",
            "value"
        ]
    },
    {
        "id": 1657,
        "code": "public static List<Short> asList(short... backingArray) {\n  if (backingArray.length == 0) {\n    return Collections.emptyList();\n  }\n  return new ShortArrayAsList(backingArray);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "fixed",
            "size",
            "list",
            "backed",
            "by",
            "the",
            "specified",
            "array",
            "similar",
            "to",
            "arrays",
            "as",
            "list",
            "object"
        ]
    },
    {
        "id": 1658,
        "code": "public static byte checkedCast(long value) {\n  byte result = (byte) value;\n  checkArgument(result == value, \"Out of range: %s\", value);\n  return result;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "byte",
            "value",
            "that",
            "is",
            "equal",
            "to",
            "value",
            "if",
            "possible"
        ]
    },
    {
        "id": 1659,
        "code": "public static byte saturatedCast(long value) {\n  if (value > Byte.MAX_VALUE) {\n    return Byte.MAX_VALUE;\n  }\n  if (value < Byte.MIN_VALUE) {\n    return Byte.MIN_VALUE;\n  }\n  return (byte) value;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "byte",
            "nearest",
            "in",
            "value",
            "to",
            "value"
        ]
    },
    {
        "id": 1660,
        "code": "public static int compare(byte a, byte b) {\n  return a - b; \n}",
        "summary_tokens": [
            "compares",
            "the",
            "two",
            "specified",
            "byte",
            "values"
        ]
    },
    {
        "id": 1661,
        "code": "public static byte min(byte... array) {\n  checkArgument(array.length > 0);\n  byte min = array[0];\n  for (int i = 1; i < array.length; i++) {\n    if (array[i] < min) {\n      min = array[i];\n    }\n  }\n  return min;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "least",
            "value",
            "present",
            "in",
            "array"
        ]
    },
    {
        "id": 1662,
        "code": "public static byte max(byte... array) {\n  checkArgument(array.length > 0);\n  byte max = array[0];\n  for (int i = 1; i < array.length; i++) {\n    if (array[i] > max) {\n      max = array[i];\n    }\n  }\n  return max;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "greatest",
            "value",
            "present",
            "in",
            "array"
        ]
    },
    {
        "id": 1663,
        "code": "public static String join(String separator, byte... array) {\n  checkNotNull(separator);\n  if (array.length == 0) {\n    return \"\";\n  }\n\n    \n  StringBuilder builder = new StringBuilder(array.length * 5);\n  builder.append(array[0]);\n  for (int i = 1; i < array.length; i++) {\n    builder.append(separator).append(array[i]);\n  }\n  return builder.toString();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "string",
            "containing",
            "the",
            "supplied",
            "byte",
            "values",
            "separated",
            "by",
            "separator"
        ]
    },
    {
        "id": 1664,
        "code": "public static Comparator<byte[]> lexicographicalComparator() {\n  return LexicographicalComparator.INSTANCE;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "comparator",
            "that",
            "compares",
            "two",
            "byte",
            "arrays",
            "a",
            "href",
            "http",
            "en"
        ]
    },
    {
        "id": 1665,
        "code": "public static void sortDescending(byte[] array, int fromIndex, int toIndex) {\n  checkNotNull(array);\n  checkPositionIndexes(fromIndex, toIndex, array.length);\n  Arrays.sort(array, fromIndex, toIndex);\n  Bytes.reverse(array, fromIndex, toIndex);\n}",
        "summary_tokens": [
            "sorts",
            "the",
            "elements",
            "of",
            "array",
            "between",
            "from",
            "index",
            "inclusive",
            "and",
            "to",
            "index",
            "exclusive",
            "in",
            "descending",
            "order"
        ]
    },
    {
        "id": 1666,
        "code": "public static int toInt(byte value) {\n  return value & UNSIGNED_MASK;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "value",
            "of",
            "the",
            "given",
            "byte",
            "as",
            "an",
            "integer",
            "when",
            "treated",
            "as",
            "unsigned"
        ]
    },
    {
        "id": 1667,
        "code": "public static byte checkedCast(long value) {\n  checkArgument(value >> Byte.SIZE == 0, \"out of range: %s\", value);\n  return (byte) value;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "byte",
            "value",
            "that",
            "when",
            "treated",
            "as",
            "unsigned",
            "is",
            "equal",
            "to",
            "value",
            "if",
            "possible"
        ]
    },
    {
        "id": 1668,
        "code": "public static byte saturatedCast(long value) {\n  if (value > toInt(MAX_VALUE)) {\n    return MAX_VALUE; \n  }\n  if (value < 0) {\n    return (byte) 0;\n  }\n  return (byte) value;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "byte",
            "value",
            "that",
            "when",
            "treated",
            "as",
            "unsigned",
            "is",
            "nearest",
            "in",
            "value",
            "to",
            "value"
        ]
    },
    {
        "id": 1669,
        "code": "public static int compare(byte a, byte b) {\n  return toInt(a) - toInt(b);\n}",
        "summary_tokens": [
            "compares",
            "the",
            "two",
            "specified",
            "byte",
            "values",
            "treating",
            "them",
            "as",
            "unsigned",
            "values",
            "between",
            "0",
            "and",
            "0",
            "inclusive"
        ]
    },
    {
        "id": 1670,
        "code": "public static byte min(byte... array) {\n  checkArgument(array.length > 0);\n  int min = toInt(array[0]);\n  for (int i = 1; i < array.length; i++) {\n    int next = toInt(array[i]);\n    if (next < min) {\n      min = next;\n    }\n  }\n  return (byte) min;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "least",
            "value",
            "present",
            "in",
            "array",
            "treating",
            "values",
            "as",
            "unsigned"
        ]
    },
    {
        "id": 1671,
        "code": "public static byte max(byte... array) {\n  checkArgument(array.length > 0);\n  int max = toInt(array[0]);\n  for (int i = 1; i < array.length; i++) {\n    int next = toInt(array[i]);\n    if (next > max) {\n      max = next;\n    }\n  }\n  return (byte) max;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "greatest",
            "value",
            "present",
            "in",
            "array",
            "treating",
            "values",
            "as",
            "unsigned"
        ]
    },
    {
        "id": 1672,
        "code": "public static String toString(byte x, int radix) {\n  checkArgument(\n      radix >= Character.MIN_RADIX && radix <= Character.MAX_RADIX,\n      \"radix (%s) must be between Character.MIN_RADIX and Character.MAX_RADIX\",\n      radix);\n    \n  return Integer.toString(toInt(x), radix);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "string",
            "representation",
            "of",
            "x",
            "for",
            "the",
            "given",
            "radix",
            "where",
            "x",
            "is",
            "treated",
            "as",
            "unsigned"
        ]
    },
    {
        "id": 1673,
        "code": "public static byte parseUnsignedByte(String string, int radix) {\n  int parse = Integer.parseInt(checkNotNull(string), radix);\n    \n  if (parse >> Byte.SIZE == 0) {\n    return (byte) parse;\n  } else {\n    throw new NumberFormatException(\"out of range: \" + parse);\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "unsigned",
            "byte",
            "value",
            "represented",
            "by",
            "a",
            "string",
            "with",
            "the",
            "given",
            "radix"
        ]
    },
    {
        "id": 1674,
        "code": "public static String join(String separator, byte... array) {\n  checkNotNull(separator);\n  if (array.length == 0) {\n    return \"\";\n  }\n\n    \n  StringBuilder builder = new StringBuilder(array.length * (3 + separator.length()));\n  builder.append(toInt(array[0]));\n  for (int i = 1; i < array.length; i++) {\n    builder.append(separator).append(toString(array[i]));\n  }\n  return builder.toString();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "string",
            "containing",
            "the",
            "supplied",
            "byte",
            "values",
            "separated",
            "by",
            "separator"
        ]
    },
    {
        "id": 1675,
        "code": "public static Comparator<byte[]> lexicographicalComparator() {\n  return LexicographicalComparatorHolder.BEST_COMPARATOR;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "comparator",
            "that",
            "compares",
            "two",
            "byte",
            "arrays",
            "a",
            "href",
            "http",
            "en"
        ]
    },
    {
        "id": 1676,
        "code": "public static void sort(byte[] array, int fromIndex, int toIndex) {\n  checkNotNull(array);\n  checkPositionIndexes(fromIndex, toIndex, array.length);\n  for (int i = fromIndex; i < toIndex; i++) {\n    array[i] = flip(array[i]);\n  }\n  Arrays.sort(array, fromIndex, toIndex);\n  for (int i = fromIndex; i < toIndex; i++) {\n    array[i] = flip(array[i]);\n  }\n}",
        "summary_tokens": [
            "sorts",
            "the",
            "array",
            "between",
            "from",
            "index",
            "inclusive",
            "and",
            "to",
            "index",
            "exclusive",
            "treating",
            "its",
            "elements",
            "as",
            "unsigned",
            "bytes"
        ]
    },
    {
        "id": 1677,
        "code": "public static void sortDescending(byte[] array, int fromIndex, int toIndex) {\n  checkNotNull(array);\n  checkPositionIndexes(fromIndex, toIndex, array.length);\n  for (int i = fromIndex; i < toIndex; i++) {\n    array[i] ^= Byte.MAX_VALUE;\n  }\n  Arrays.sort(array, fromIndex, toIndex);\n  for (int i = fromIndex; i < toIndex; i++) {\n    array[i] ^= Byte.MAX_VALUE;\n  }\n}",
        "summary_tokens": [
            "sorts",
            "the",
            "elements",
            "of",
            "array",
            "between",
            "from",
            "index",
            "inclusive",
            "and",
            "to",
            "index",
            "exclusive",
            "in",
            "descending",
            "order",
            "interpreting",
            "them",
            "as",
            "unsigned",
            "0",
            "bit",
            "integers"
        ]
    },
    {
        "id": 1678,
        "code": "public static UnsignedInteger fromIntBits(int bits) {\n  return new UnsignedInteger(bits);\n}",
        "summary_tokens": [
            "returns",
            "an",
            "unsigned",
            "integer",
            "corresponding",
            "to",
            "a",
            "given",
            "bit",
            "representation"
        ]
    },
    {
        "id": 1679,
        "code": "public static UnsignedInteger valueOf(String string, int radix) {\n  return fromIntBits(UnsignedInts.parseUnsignedInt(string, radix));\n}",
        "summary_tokens": [
            "returns",
            "an",
            "unsigned",
            "integer",
            "holding",
            "the",
            "value",
            "of",
            "the",
            "specified",
            "string",
            "parsed",
            "as",
            "an",
            "unsigned",
            "int",
            "value",
            "in",
            "the",
            "specified",
            "radix"
        ]
    },
    {
        "id": 1680,
        "code": "public UnsignedInteger plus(UnsignedInteger val) {\n  return fromIntBits(this.value + checkNotNull(val).value);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "result",
            "of",
            "adding",
            "this",
            "and",
            "val"
        ]
    },
    {
        "id": 1681,
        "code": "public UnsignedInteger minus(UnsignedInteger val) {\n  return fromIntBits(value - checkNotNull(val).value);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "result",
            "of",
            "subtracting",
            "this",
            "and",
            "val"
        ]
    },
    {
        "id": 1682,
        "code": "public UnsignedInteger times(UnsignedInteger val) {\n    \n  return fromIntBits(value * checkNotNull(val).value);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "result",
            "of",
            "multiplying",
            "this",
            "and",
            "val"
        ]
    },
    {
        "id": 1683,
        "code": "public UnsignedInteger dividedBy(UnsignedInteger val) {\n  return fromIntBits(UnsignedInts.divide(value, checkNotNull(val).value));\n}",
        "summary_tokens": [
            "returns",
            "the",
            "result",
            "of",
            "dividing",
            "this",
            "by",
            "val"
        ]
    },
    {
        "id": 1684,
        "code": "public UnsignedInteger mod(UnsignedInteger val) {\n  return fromIntBits(UnsignedInts.remainder(value, checkNotNull(val).value));\n}",
        "summary_tokens": [
            "returns",
            "this",
            "mod",
            "val"
        ]
    },
    {
        "id": 1685,
        "code": "public int intValue() {\n  return value;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "value",
            "of",
            "this",
            "unsigned",
            "integer",
            "as",
            "an",
            "int"
        ]
    },
    {
        "id": 1686,
        "code": "public long longValue() {\n  return toLong(value);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "value",
            "of",
            "this",
            "unsigned",
            "integer",
            "as",
            "a",
            "long"
        ]
    },
    {
        "id": 1687,
        "code": "public float floatValue() {\n  return longValue();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "value",
            "of",
            "this",
            "unsigned",
            "integer",
            "as",
            "a",
            "float",
            "analogous",
            "to",
            "a",
            "widening",
            "primitive",
            "conversion",
            "from",
            "int",
            "to",
            "float",
            "and",
            "correctly",
            "rounded"
        ]
    },
    {
        "id": 1688,
        "code": "public double doubleValue() {\n  return longValue();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "value",
            "of",
            "this",
            "unsigned",
            "integer",
            "as",
            "a",
            "float",
            "analogous",
            "to",
            "a",
            "widening",
            "primitive",
            "conversion",
            "from",
            "int",
            "to",
            "double",
            "and",
            "correctly",
            "rounded"
        ]
    },
    {
        "id": 1689,
        "code": "public BigInteger bigIntegerValue() {\n  return BigInteger.valueOf(longValue());\n}",
        "summary_tokens": [
            "returns",
            "the",
            "value",
            "of",
            "this",
            "unsigned",
            "integer",
            "as",
            "a",
            "big",
            "integer"
        ]
    },
    {
        "id": 1690,
        "code": "public int compareTo(UnsignedInteger other) {\n  checkNotNull(other);\n  return compare(value, other.value);\n}",
        "summary_tokens": [
            "compares",
            "this",
            "unsigned",
            "integer",
            "to",
            "another",
            "unsigned",
            "integer"
        ]
    },
    {
        "id": 1691,
        "code": "public String toString(int radix) {\n  return UnsignedInts.toString(value, radix);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "string",
            "representation",
            "of",
            "the",
            "unsigned",
            "integer",
            "value",
            "in",
            "base",
            "radix"
        ]
    },
    {
        "id": 1692,
        "code": "public static int compare(int a, int b) {\n  return Ints.compare(flip(a), flip(b));\n}",
        "summary_tokens": [
            "compares",
            "the",
            "two",
            "specified",
            "int",
            "values",
            "treating",
            "them",
            "as",
            "unsigned",
            "values",
            "between",
            "0",
            "and",
            "0",
            "0",
            "0",
            "inclusive"
        ]
    },
    {
        "id": 1693,
        "code": "public static long toLong(int value) {\n  return value & INT_MASK;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "value",
            "of",
            "the",
            "given",
            "int",
            "as",
            "a",
            "long",
            "when",
            "treated",
            "as",
            "unsigned"
        ]
    },
    {
        "id": 1694,
        "code": "public static int checkedCast(long value) {\n  checkArgument((value >> Integer.SIZE) == 0, \"out of range: %s\", value);\n  return (int) value;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "int",
            "value",
            "that",
            "when",
            "treated",
            "as",
            "unsigned",
            "is",
            "equal",
            "to",
            "value",
            "if",
            "possible"
        ]
    },
    {
        "id": 1695,
        "code": "public static int saturatedCast(long value) {\n  if (value <= 0) {\n    return 0;\n  } else if (value >= (1L << 32)) {\n    return -1;\n  } else {\n    return (int) value;\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "int",
            "value",
            "that",
            "when",
            "treated",
            "as",
            "unsigned",
            "is",
            "nearest",
            "in",
            "value",
            "to",
            "value"
        ]
    },
    {
        "id": 1696,
        "code": "public static int min(int... array) {\n  checkArgument(array.length > 0);\n  int min = flip(array[0]);\n  for (int i = 1; i < array.length; i++) {\n    int next = flip(array[i]);\n    if (next < min) {\n      min = next;\n    }\n  }\n  return flip(min);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "least",
            "value",
            "present",
            "in",
            "array",
            "treating",
            "values",
            "as",
            "unsigned"
        ]
    },
    {
        "id": 1697,
        "code": "public static int max(int... array) {\n  checkArgument(array.length > 0);\n  int max = flip(array[0]);\n  for (int i = 1; i < array.length; i++) {\n    int next = flip(array[i]);\n    if (next > max) {\n      max = next;\n    }\n  }\n  return flip(max);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "greatest",
            "value",
            "present",
            "in",
            "array",
            "treating",
            "values",
            "as",
            "unsigned"
        ]
    },
    {
        "id": 1698,
        "code": "public static String join(String separator, int... array) {\n  checkNotNull(separator);\n  if (array.length == 0) {\n    return \"\";\n  }\n\n    \n  StringBuilder builder = new StringBuilder(array.length * 5);\n  builder.append(toString(array[0]));\n  for (int i = 1; i < array.length; i++) {\n    builder.append(separator).append(toString(array[i]));\n  }\n  return builder.toString();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "string",
            "containing",
            "the",
            "supplied",
            "unsigned",
            "int",
            "values",
            "separated",
            "by",
            "separator"
        ]
    },
    {
        "id": 1699,
        "code": "public static Comparator<int[]> lexicographicalComparator() {\n  return LexicographicalComparator.INSTANCE;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "comparator",
            "that",
            "compares",
            "two",
            "arrays",
            "of",
            "unsigned",
            "int",
            "values",
            "a",
            "href",
            "http",
            "en"
        ]
    },
    {
        "id": 1700,
        "code": "public static void sort(int[] array, int fromIndex, int toIndex) {\n  checkNotNull(array);\n  checkPositionIndexes(fromIndex, toIndex, array.length);\n  for (int i = fromIndex; i < toIndex; i++) {\n    array[i] = flip(array[i]);\n  }\n  Arrays.sort(array, fromIndex, toIndex);\n  for (int i = fromIndex; i < toIndex; i++) {\n    array[i] = flip(array[i]);\n  }\n}",
        "summary_tokens": [
            "sorts",
            "the",
            "array",
            "between",
            "from",
            "index",
            "inclusive",
            "and",
            "to",
            "index",
            "exclusive",
            "treating",
            "its",
            "elements",
            "as",
            "unsigned",
            "0",
            "bit",
            "integers"
        ]
    },
    {
        "id": 1701,
        "code": "public static void sortDescending(int[] array, int fromIndex, int toIndex) {\n  checkNotNull(array);\n  checkPositionIndexes(fromIndex, toIndex, array.length);\n  for (int i = fromIndex; i < toIndex; i++) {\n    array[i] ^= Integer.MAX_VALUE;\n  }\n  Arrays.sort(array, fromIndex, toIndex);\n  for (int i = fromIndex; i < toIndex; i++) {\n    array[i] ^= Integer.MAX_VALUE;\n  }\n}",
        "summary_tokens": [
            "sorts",
            "the",
            "elements",
            "of",
            "array",
            "between",
            "from",
            "index",
            "inclusive",
            "and",
            "to",
            "index",
            "exclusive",
            "in",
            "descending",
            "order",
            "interpreting",
            "them",
            "as",
            "unsigned",
            "0",
            "bit",
            "integers"
        ]
    },
    {
        "id": 1702,
        "code": "public static int divide(int dividend, int divisor) {\n  return (int) (toLong(dividend) / toLong(divisor));\n}",
        "summary_tokens": [
            "returns",
            "dividend",
            "divisor",
            "where",
            "the",
            "dividend",
            "and",
            "divisor",
            "are",
            "treated",
            "as",
            "unsigned",
            "0",
            "bit",
            "quantities"
        ]
    },
    {
        "id": 1703,
        "code": "public static int remainder(int dividend, int divisor) {\n  return (int) (toLong(dividend) % toLong(divisor));\n}",
        "summary_tokens": [
            "returns",
            "dividend",
            "divisor",
            "where",
            "the",
            "dividend",
            "and",
            "divisor",
            "are",
            "treated",
            "as",
            "unsigned",
            "0",
            "bit",
            "quantities"
        ]
    },
    {
        "id": 1704,
        "code": "public static int decode(String stringValue) {\n  ParseRequest request = ParseRequest.fromString(stringValue);\n\n  try {\n    return parseUnsignedInt(request.rawValue, request.radix);\n  } catch (NumberFormatException e) {\n    NumberFormatException decodeException =\n        new NumberFormatException(\"Error parsing value: \" + stringValue);\n    decodeException.initCause(e);\n    throw decodeException;\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "unsigned",
            "int",
            "value",
            "represented",
            "by",
            "the",
            "given",
            "string"
        ]
    },
    {
        "id": 1705,
        "code": "public static int parseUnsignedInt(String string, int radix) {\n  checkNotNull(string);\n  long result = Long.parseLong(string, radix);\n  if ((result & INT_MASK) != result) {\n    throw new NumberFormatException(\n        \"Input \" + string + \" in base \" + radix + \" is not in the range of an unsigned integer\");\n  }\n  return (int) result;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "unsigned",
            "int",
            "value",
            "represented",
            "by",
            "a",
            "string",
            "with",
            "the",
            "given",
            "radix"
        ]
    },
    {
        "id": 1706,
        "code": "public static String toString(int x, int radix) {\n  long asLong = x & INT_MASK;\n  return Long.toString(asLong, radix);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "string",
            "representation",
            "of",
            "x",
            "for",
            "the",
            "given",
            "radix",
            "where",
            "x",
            "is",
            "treated",
            "as",
            "unsigned"
        ]
    },
    {
        "id": 1707,
        "code": "public static UnsignedLong fromLongBits(long bits) {\n    \n  return new UnsignedLong(bits);\n}",
        "summary_tokens": [
            "returns",
            "an",
            "unsigned",
            "long",
            "corresponding",
            "to",
            "a",
            "given",
            "bit",
            "representation"
        ]
    },
    {
        "id": 1708,
        "code": "public static UnsignedLong valueOf(String string, int radix) {\n  return fromLongBits(UnsignedLongs.parseUnsignedLong(string, radix));\n}",
        "summary_tokens": [
            "returns",
            "an",
            "unsigned",
            "long",
            "holding",
            "the",
            "value",
            "of",
            "the",
            "specified",
            "string",
            "parsed",
            "as",
            "an",
            "unsigned",
            "long",
            "value",
            "in",
            "the",
            "specified",
            "radix"
        ]
    },
    {
        "id": 1709,
        "code": "public UnsignedLong plus(UnsignedLong val) {\n  return fromLongBits(this.value + checkNotNull(val).value);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "result",
            "of",
            "adding",
            "this",
            "and",
            "val"
        ]
    },
    {
        "id": 1710,
        "code": "public UnsignedLong minus(UnsignedLong val) {\n  return fromLongBits(this.value - checkNotNull(val).value);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "result",
            "of",
            "subtracting",
            "this",
            "and",
            "val"
        ]
    },
    {
        "id": 1711,
        "code": "public UnsignedLong times(UnsignedLong val) {\n  return fromLongBits(value * checkNotNull(val).value);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "result",
            "of",
            "multiplying",
            "this",
            "and",
            "val"
        ]
    },
    {
        "id": 1712,
        "code": "public UnsignedLong dividedBy(UnsignedLong val) {\n  return fromLongBits(UnsignedLongs.divide(value, checkNotNull(val).value));\n}",
        "summary_tokens": [
            "returns",
            "the",
            "result",
            "of",
            "dividing",
            "this",
            "by",
            "val"
        ]
    },
    {
        "id": 1713,
        "code": "public UnsignedLong mod(UnsignedLong val) {\n  return fromLongBits(UnsignedLongs.remainder(value, checkNotNull(val).value));\n}",
        "summary_tokens": [
            "returns",
            "this",
            "modulo",
            "val"
        ]
    },
    {
        "id": 1714,
        "code": "public int intValue() {\n  return (int) value;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "value",
            "of",
            "this",
            "unsigned",
            "long",
            "as",
            "an",
            "int"
        ]
    },
    {
        "id": 1715,
        "code": "public long longValue() {\n  return value;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "value",
            "of",
            "this",
            "unsigned",
            "long",
            "as",
            "a",
            "long"
        ]
    },
    {
        "id": 1716,
        "code": "public float floatValue() {\n  if (value >= 0) {\n    return (float) value;\n  }\n    \n    \n  return (float) ((value >>> 1) | (value & 1)) * 2f;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "value",
            "of",
            "this",
            "unsigned",
            "long",
            "as",
            "a",
            "float",
            "analogous",
            "to",
            "a",
            "widening",
            "primitive",
            "conversion",
            "from",
            "long",
            "to",
            "float",
            "and",
            "correctly",
            "rounded"
        ]
    },
    {
        "id": 1717,
        "code": "public double doubleValue() {\n  if (value >= 0) {\n    return (double) value;\n  }\n    \n    \n    \n    \n    \n  return (double) ((value >>> 1) | (value & 1)) * 2.0;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "value",
            "of",
            "this",
            "unsigned",
            "long",
            "as",
            "a",
            "double",
            "analogous",
            "to",
            "a",
            "widening",
            "primitive",
            "conversion",
            "from",
            "long",
            "to",
            "double",
            "and",
            "correctly",
            "rounded"
        ]
    },
    {
        "id": 1718,
        "code": "public BigInteger bigIntegerValue() {\n  BigInteger bigInt = BigInteger.valueOf(value & UNSIGNED_MASK);\n  if (value < 0) {\n    bigInt = bigInt.setBit(Long.SIZE - 1);\n  }\n  return bigInt;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "value",
            "of",
            "this",
            "unsigned",
            "long",
            "as",
            "a",
            "big",
            "integer"
        ]
    },
    {
        "id": 1719,
        "code": "public String toString(int radix) {\n  return UnsignedLongs.toString(value, radix);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "string",
            "representation",
            "of",
            "the",
            "unsigned",
            "long",
            "value",
            "in",
            "base",
            "radix"
        ]
    },
    {
        "id": 1720,
        "code": "private static long flip(long a) {\n  return a ^ Long.MIN_VALUE;\n}",
        "summary_tokens": [
            "a",
            "self",
            "inverse",
            "bijection",
            "which",
            "converts",
            "the",
            "ordering",
            "on",
            "unsigned",
            "longs",
            "to",
            "the",
            "ordering",
            "on",
            "longs",
            "that",
            "is",
            "a",
            "b",
            "as",
            "unsigned",
            "longs",
            "if",
            "and",
            "only",
            "if",
            "flip",
            "a",
            "flip",
            "b",
            "as",
            "signed",
            "longs"
        ]
    },
    {
        "id": 1721,
        "code": "public static int compare(long a, long b) {\n  return Longs.compare(flip(a), flip(b));\n}",
        "summary_tokens": [
            "compares",
            "the",
            "two",
            "specified",
            "long",
            "values",
            "treating",
            "them",
            "as",
            "unsigned",
            "values",
            "between",
            "0",
            "and",
            "0",
            "0",
            "0",
            "inclusive"
        ]
    },
    {
        "id": 1722,
        "code": "public static long min(long... array) {\n  checkArgument(array.length > 0);\n  long min = flip(array[0]);\n  for (int i = 1; i < array.length; i++) {\n    long next = flip(array[i]);\n    if (next < min) {\n      min = next;\n    }\n  }\n  return flip(min);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "least",
            "value",
            "present",
            "in",
            "array",
            "treating",
            "values",
            "as",
            "unsigned"
        ]
    },
    {
        "id": 1723,
        "code": "public static long max(long... array) {\n  checkArgument(array.length > 0);\n  long max = flip(array[0]);\n  for (int i = 1; i < array.length; i++) {\n    long next = flip(array[i]);\n    if (next > max) {\n      max = next;\n    }\n  }\n  return flip(max);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "greatest",
            "value",
            "present",
            "in",
            "array",
            "treating",
            "values",
            "as",
            "unsigned"
        ]
    },
    {
        "id": 1724,
        "code": "public static String join(String separator, long... array) {\n  checkNotNull(separator);\n  if (array.length == 0) {\n    return \"\";\n  }\n\n    \n  StringBuilder builder = new StringBuilder(array.length * 5);\n  builder.append(toString(array[0]));\n  for (int i = 1; i < array.length; i++) {\n    builder.append(separator).append(toString(array[i]));\n  }\n  return builder.toString();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "string",
            "containing",
            "the",
            "supplied",
            "unsigned",
            "long",
            "values",
            "separated",
            "by",
            "separator"
        ]
    },
    {
        "id": 1725,
        "code": "public static Comparator<long[]> lexicographicalComparator() {\n  return LexicographicalComparator.INSTANCE;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "comparator",
            "that",
            "compares",
            "two",
            "arrays",
            "of",
            "unsigned",
            "long",
            "values",
            "a",
            "href",
            "http",
            "en"
        ]
    },
    {
        "id": 1726,
        "code": "public static void sort(long[] array, int fromIndex, int toIndex) {\n  checkNotNull(array);\n  checkPositionIndexes(fromIndex, toIndex, array.length);\n  for (int i = fromIndex; i < toIndex; i++) {\n    array[i] = flip(array[i]);\n  }\n  Arrays.sort(array, fromIndex, toIndex);\n  for (int i = fromIndex; i < toIndex; i++) {\n    array[i] = flip(array[i]);\n  }\n}",
        "summary_tokens": [
            "sorts",
            "the",
            "array",
            "between",
            "from",
            "index",
            "inclusive",
            "and",
            "to",
            "index",
            "exclusive",
            "treating",
            "its",
            "elements",
            "as",
            "unsigned",
            "0",
            "bit",
            "integers"
        ]
    },
    {
        "id": 1727,
        "code": "public static void sortDescending(long[] array, int fromIndex, int toIndex) {\n  checkNotNull(array);\n  checkPositionIndexes(fromIndex, toIndex, array.length);\n  for (int i = fromIndex; i < toIndex; i++) {\n    array[i] ^= Long.MAX_VALUE;\n  }\n  Arrays.sort(array, fromIndex, toIndex);\n  for (int i = fromIndex; i < toIndex; i++) {\n    array[i] ^= Long.MAX_VALUE;\n  }\n}",
        "summary_tokens": [
            "sorts",
            "the",
            "elements",
            "of",
            "array",
            "between",
            "from",
            "index",
            "inclusive",
            "and",
            "to",
            "index",
            "exclusive",
            "in",
            "descending",
            "order",
            "interpreting",
            "them",
            "as",
            "unsigned",
            "0",
            "bit",
            "integers"
        ]
    },
    {
        "id": 1728,
        "code": "public static long divide(long dividend, long divisor) {\n  if (divisor < 0) { \n    if (compare(dividend, divisor) < 0) {\n      return 0; \n    } else {\n      return 1; \n    }\n  }\n\n    \n  if (dividend >= 0) {\n    return dividend / divisor;\n  }\n\n    \n  long quotient = ((dividend >>> 1) / divisor) << 1;\n  long rem = dividend - quotient * divisor;\n  return quotient + (compare(rem, divisor) >= 0 ? 1 : 0);\n}",
        "summary_tokens": [
            "returns",
            "dividend",
            "divisor",
            "where",
            "the",
            "dividend",
            "and",
            "divisor",
            "are",
            "treated",
            "as",
            "unsigned",
            "0",
            "bit",
            "quantities"
        ]
    },
    {
        "id": 1729,
        "code": "public static long remainder(long dividend, long divisor) {\n  if (divisor < 0) { \n    if (compare(dividend, divisor) < 0) {\n      return dividend; \n    } else {\n      return dividend - divisor; \n    }\n  }\n\n    \n  if (dividend >= 0) {\n    return dividend % divisor;\n  }\n\n    \n  long quotient = ((dividend >>> 1) / divisor) << 1;\n  long rem = dividend - quotient * divisor;\n  return rem - (compare(rem, divisor) >= 0 ? divisor : 0);\n}",
        "summary_tokens": [
            "returns",
            "dividend",
            "divisor",
            "where",
            "the",
            "dividend",
            "and",
            "divisor",
            "are",
            "treated",
            "as",
            "unsigned",
            "0",
            "bit",
            "quantities"
        ]
    },
    {
        "id": 1730,
        "code": "public static long parseUnsignedLong(String string, int radix) {\n  checkNotNull(string);\n  if (string.length() == 0) {\n    throw new NumberFormatException(\"empty string\");\n  }\n  if (radix < Character.MIN_RADIX || radix > Character.MAX_RADIX) {\n    throw new NumberFormatException(\"illegal radix: \" + radix);\n  }\n\n  int maxSafePos = ParseOverflowDetection.maxSafeDigits[radix] - 1;\n  long value = 0;\n  for (int pos = 0; pos < string.length(); pos++) {\n    int digit = Character.digit(string.charAt(pos), radix);\n    if (digit == -1) {\n      throw new NumberFormatException(string);\n    }\n    if (pos > maxSafePos && ParseOverflowDetection.overflowInParse(value, digit, radix)) {\n      throw new NumberFormatException(\"Too large for unsigned long: \" + string);\n    }\n    value = (value * radix) + digit;\n  }\n\n  return value;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "unsigned",
            "long",
            "value",
            "represented",
            "by",
            "a",
            "string",
            "with",
            "the",
            "given",
            "radix"
        ]
    },
    {
        "id": 1731,
        "code": "public static long decode(String stringValue) {\n  ParseRequest request = ParseRequest.fromString(stringValue);\n\n  try {\n    return parseUnsignedLong(request.rawValue, request.radix);\n  } catch (NumberFormatException e) {\n    NumberFormatException decodeException =\n        new NumberFormatException(\"Error parsing value: \" + stringValue);\n    decodeException.initCause(e);\n    throw decodeException;\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "unsigned",
            "long",
            "value",
            "represented",
            "by",
            "the",
            "given",
            "string"
        ]
    },
    {
        "id": 1732,
        "code": "public static String toString(long x, int radix) {\n  checkArgument(\n      radix >= Character.MIN_RADIX && radix <= Character.MAX_RADIX,\n      \"radix (%s) must be between Character.MIN_RADIX and Character.MAX_RADIX\",\n      radix);\n  if (x == 0) {\n      \n    return \"0\";\n  } else if (x > 0) {\n    return Long.toString(x, radix);\n  } else {\n    char[] buf = new char[64];\n    int i = buf.length;\n    if ((radix & (radix - 1)) == 0) {\n        \n      int shift = Integer.numberOfTrailingZeros(radix);\n      int mask = radix - 1;\n      do {\n        buf[--i] = Character.forDigit(((int) x) & mask, radix);\n        x >>>= shift;\n      } while (x != 0);\n    } else {\n        \n        \n      long quotient;\n      if ((radix & 1) == 0) {\n          \n        quotient = (x >>> 1) / (radix >>> 1);\n      } else {\n        quotient = divide(x, radix);\n      }\n      long rem = x - quotient * radix;\n      buf[--i] = Character.forDigit((int) rem, radix);\n      x = quotient;\n        \n      while (x > 0) {\n        buf[--i] = Character.forDigit((int) (x % radix), radix);\n        x /= radix;\n      }\n    }\n      \n    return new String(buf, i, buf.length - i);\n  }\n}",
        "summary_tokens": [
            "returns",
            "a",
            "string",
            "representation",
            "of",
            "x",
            "for",
            "the",
            "given",
            "radix",
            "where",
            "x",
            "is",
            "treated",
            "as",
            "unsigned"
        ]
    },
    {
        "id": 1733,
        "code": "public boolean equals(@CheckForNull Object obj) {\n  return super.equals(obj);\n}",
        "summary_tokens": [
            "by",
            "default",
            "delegates",
            "to",
            "object",
            "equals",
            "so",
            "instances",
            "are",
            "only",
            "equal",
            "if",
            "they",
            "are",
            "identical"
        ]
    },
    {
        "id": 1734,
        "code": "public int hashCode() {\n  return super.hashCode();\n}",
        "summary_tokens": [
            "by",
            "default",
            "delegates",
            "to",
            "object",
            "hash",
            "code"
        ]
    },
    {
        "id": 1735,
        "code": "public String toString() {\n  return super.toString();\n}",
        "summary_tokens": [
            "by",
            "default",
            "delegates",
            "to",
            "object",
            "to",
            "string"
        ]
    },
    {
        "id": 1736,
        "code": "public static ClassPath from(ClassLoader classloader) throws IOException {\n  ImmutableSet<LocationInfo> locations = locationsFrom(classloader);\n\n    \n    \n  Set<File> scanned = new HashSet<>();\n  for (LocationInfo location : locations) {\n    scanned.add(location.file());\n  }\n\n    \n  ImmutableSet.Builder<ResourceInfo> builder = ImmutableSet.builder();\n  for (LocationInfo location : locations) {\n    builder.addAll(location.scanResources(scanned));\n  }\n  return new ClassPath(builder.build());\n}",
        "summary_tokens": [
            "returns",
            "a",
            "class",
            "path",
            "representing",
            "all",
            "classes",
            "and",
            "resources",
            "loadable",
            "from",
            "classloader",
            "and",
            "its",
            "ancestor",
            "class",
            "loaders"
        ]
    },
    {
        "id": 1737,
        "code": "public ImmutableSet<ResourceInfo> getResources() {\n  return resources;\n}",
        "summary_tokens": [
            "returns",
            "all",
            "resources",
            "loadable",
            "from",
            "the",
            "current",
            "class",
            "path",
            "including",
            "the",
            "class",
            "files",
            "of",
            "all",
            "loadable",
            "classes",
            "but",
            "excluding",
            "the",
            "meta",
            "inf",
            "manifest"
        ]
    },
    {
        "id": 1738,
        "code": "public ImmutableSet<ClassInfo> getAllClasses() {\n  return FluentIterable.from(resources).filter(ClassInfo.class).toSet();\n}",
        "summary_tokens": [
            "returns",
            "all",
            "classes",
            "loadable",
            "from",
            "the",
            "current",
            "class",
            "path"
        ]
    },
    {
        "id": 1739,
        "code": "public ImmutableSet<ClassInfo> getTopLevelClasses(String packageName) {\n  checkNotNull(packageName);\n  ImmutableSet.Builder<ClassInfo> builder = ImmutableSet.builder();\n  for (ClassInfo classInfo : getTopLevelClasses()) {\n    if (classInfo.getPackageName().equals(packageName)) {\n      builder.add(classInfo);\n    }\n  }\n  return builder.build();\n}",
        "summary_tokens": [
            "returns",
            "all",
            "top",
            "level",
            "classes",
            "whose",
            "package",
            "name",
            "is",
            "package",
            "name"
        ]
    },
    {
        "id": 1740,
        "code": "public ImmutableSet<ClassInfo> getTopLevelClassesRecursive(String packageName) {\n  checkNotNull(packageName);\n  String packagePrefix = packageName + '.';\n  ImmutableSet.Builder<ClassInfo> builder = ImmutableSet.builder();\n  for (ClassInfo classInfo : getTopLevelClasses()) {\n    if (classInfo.getName().startsWith(packagePrefix)) {\n      builder.add(classInfo);\n    }\n  }\n  return builder.build();\n}",
        "summary_tokens": [
            "returns",
            "all",
            "top",
            "level",
            "classes",
            "whose",
            "package",
            "name",
            "is",
            "package",
            "name",
            "or",
            "starts",
            "with",
            "package",
            "name",
            "followed",
            "by",
            "a"
        ]
    },
    {
        "id": 1741,
        "code": "static ImmutableSet<LocationInfo> locationsFrom(ClassLoader classloader) {\n  ImmutableSet.Builder<LocationInfo> builder = ImmutableSet.builder();\n  for (Map.Entry<File, ClassLoader> entry : getClassPathEntries(classloader).entrySet()) {\n    builder.add(new LocationInfo(entry.getKey(), entry.getValue()));\n  }\n  return builder.build();\n}",
        "summary_tokens": [
            "returns",
            "all",
            "locations",
            "that",
            "classloader",
            "and",
            "parent",
            "loaders",
            "load",
            "classes",
            "and",
            "resources",
            "from"
        ]
    },
    {
        "id": 1742,
        "code": "static ImmutableSet<File> getClassPathFromManifest(\n    File jarFile, @CheckForNull Manifest manifest) {\n  if (manifest == null) {\n    return ImmutableSet.of();\n  }\n  ImmutableSet.Builder<File> builder = ImmutableSet.builder();\n  String classpathAttribute =\n      manifest.getMainAttributes().getValue(Attributes.Name.CLASS_PATH.toString());\n  if (classpathAttribute != null) {\n    for (String path : CLASS_PATH_ATTRIBUTE_SEPARATOR.split(classpathAttribute)) {\n      URL url;\n      try {\n        url = getClassPathEntry(jarFile, path);\n      } catch (MalformedURLException e) {\n          \n        logger.warning(\"Invalid Class-Path entry: \" + path);\n        continue;\n      }\n      if (url.getProtocol().equals(\"file\")) {\n        builder.add(toFile(url));\n      }\n    }\n  }\n  return builder.build();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "class",
            "path",
            "uris",
            "specified",
            "by",
            "the",
            "class",
            "path",
            "manifest",
            "attribute",
            "according",
            "to",
            "a",
            "href",
            "http",
            "docs"
        ]
    },
    {
        "id": 1743,
        "code": "static ImmutableList<URL> parseJavaClassPath() {\n  ImmutableList.Builder<URL> urls = ImmutableList.builder();\n  for (String entry : Splitter.on(PATH_SEPARATOR.value()).split(JAVA_CLASS_PATH.value())) {\n    try {\n      try {\n        urls.add(new File(entry).toURI().toURL());\n      } catch (SecurityException e) { \n        urls.add(new URL(\"file\", null, new File(entry).getAbsolutePath()));\n      }\n    } catch (MalformedURLException e) {\n      logger.log(WARNING, \"malformed classpath entry: \" + entry, e);\n    }\n  }\n  return urls.build();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "urls",
            "in",
            "the",
            "class",
            "path",
            "specified",
            "by",
            "the",
            "java"
        ]
    },
    {
        "id": 1744,
        "code": "static URL getClassPathEntry(File jarFile, String path) throws MalformedURLException {\n  return new URL(jarFile.toURI().toURL(), path);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "absolute",
            "uri",
            "of",
            "the",
            "class",
            "path",
            "entry",
            "value",
            "as",
            "specified",
            "in",
            "a",
            "href",
            "http",
            "docs"
        ]
    },
    {
        "id": 1745,
        "code": "public static <B> ImmutableTypeToInstanceMap<B> of() {\n  return new ImmutableTypeToInstanceMap<>(ImmutableMap.<TypeToken<? extends B>, B>of());\n}",
        "summary_tokens": [
            "returns",
            "an",
            "empty",
            "type",
            "to",
            "instance",
            "map"
        ]
    },
    {
        "id": 1746,
        "code": "public static <B> Builder<B> builder() {\n  return new Builder<>();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "builder"
        ]
    },
    {
        "id": 1747,
        "code": "public <T extends B> T putInstance(Class<T> type, T value) {\n  throw new UnsupportedOperationException();\n}",
        "summary_tokens": [
            "guaranteed",
            "to",
            "throw",
            "an",
            "exception",
            "and",
            "leave",
            "the",
            "map",
            "unmodified"
        ]
    },
    {
        "id": 1748,
        "code": "public B put(TypeToken<? extends B> key, B value) {\n  throw new UnsupportedOperationException();\n}",
        "summary_tokens": [
            "guaranteed",
            "to",
            "throw",
            "an",
            "exception",
            "and",
            "leave",
            "the",
            "map",
            "unmodified"
        ]
    },
    {
        "id": 1749,
        "code": "public void putAll(Map<? extends TypeToken<? extends B>, ? extends B> map) {\n  throw new UnsupportedOperationException();\n}",
        "summary_tokens": [
            "guaranteed",
            "to",
            "throw",
            "an",
            "exception",
            "and",
            "leave",
            "the",
            "map",
            "unmodified"
        ]
    },
    {
        "id": 1750,
        "code": "public static <T> Invokable<T, T> from(Constructor<T> constructor) {\n  return new ConstructorInvokable<T>(constructor);\n}",
        "summary_tokens": [
            "returns",
            "invokable",
            "of",
            "constructor"
        ]
    },
    {
        "id": 1751,
        "code": "public final boolean isPublic() {\n  return Modifier.isPublic(getModifiers());\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "the",
            "element",
            "is",
            "public"
        ]
    },
    {
        "id": 1752,
        "code": "public final boolean isProtected() {\n  return Modifier.isProtected(getModifiers());\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "the",
            "element",
            "is",
            "protected"
        ]
    },
    {
        "id": 1753,
        "code": "public final boolean isPackagePrivate() {\n  return !isPrivate() && !isPublic() && !isProtected();\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "the",
            "element",
            "is",
            "package",
            "private"
        ]
    },
    {
        "id": 1754,
        "code": "public final boolean isPrivate() {\n  return Modifier.isPrivate(getModifiers());\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "the",
            "element",
            "is",
            "private"
        ]
    },
    {
        "id": 1755,
        "code": "public final boolean isStatic() {\n  return Modifier.isStatic(getModifiers());\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "the",
            "element",
            "is",
            "static"
        ]
    },
    {
        "id": 1756,
        "code": "public final boolean isFinal() {\n  return Modifier.isFinal(getModifiers());\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "this",
            "method",
            "is",
            "final",
            "per",
            "modifier"
        ]
    },
    {
        "id": 1757,
        "code": "public final boolean isAbstract() {\n  return Modifier.isAbstract(getModifiers());\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "the",
            "method",
            "is",
            "abstract"
        ]
    },
    {
        "id": 1758,
        "code": "public final boolean isNative() {\n  return Modifier.isNative(getModifiers());\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "the",
            "element",
            "is",
            "native"
        ]
    },
    {
        "id": 1759,
        "code": "public final boolean isSynchronized() {\n  return Modifier.isSynchronized(getModifiers());\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "the",
            "method",
            "is",
            "synchronized"
        ]
    },
    {
        "id": 1760,
        "code": "final boolean isVolatile() {\n  return Modifier.isVolatile(getModifiers());\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "the",
            "field",
            "is",
            "volatile"
        ]
    },
    {
        "id": 1761,
        "code": "final boolean isTransient() {\n  return Modifier.isTransient(getModifiers());\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "the",
            "field",
            "is",
            "transient"
        ]
    },
    {
        "id": 1762,
        "code": "public final R invoke(@CheckForNull T receiver, @Nullable Object... args)\n    throws InvocationTargetException, IllegalAccessException {\n  return (R) invokeInternal(receiver, checkNotNull(args));\n}",
        "summary_tokens": [
            "invokes",
            "with",
            "receiver",
            "as",
            "this",
            "and",
            "args",
            "passed",
            "to",
            "the",
            "underlying",
            "method",
            "and",
            "returns",
            "the",
            "return",
            "value",
            "or",
            "calls",
            "the",
            "underlying",
            "constructor",
            "with",
            "args",
            "and",
            "returns",
            "the",
            "constructed",
            "instance"
        ]
    },
    {
        "id": 1763,
        "code": "public final TypeToken<? extends R> getReturnType() {\n  return (TypeToken<? extends R>) TypeToken.of(getGenericReturnType());\n}",
        "summary_tokens": [
            "returns",
            "the",
            "return",
            "type",
            "of",
            "this",
            "invokable"
        ]
    },
    {
        "id": 1764,
        "code": "public final ImmutableList<Parameter> getParameters() {\n  Type[] parameterTypes = getGenericParameterTypes();\n  Annotation[][] annotations = getParameterAnnotations();\n  AnnotatedType[] annotatedTypes = getAnnotatedParameterTypes();\n  ImmutableList.Builder<Parameter> builder = ImmutableList.builder();\n  for (int i = 0; i < parameterTypes.length; i++) {\n    builder.add(\n        new Parameter(\n            this, i, TypeToken.of(parameterTypes[i]), annotations[i], annotatedTypes[i]));\n  }\n  return builder.build();\n}",
        "summary_tokens": [
            "returns",
            "all",
            "declared",
            "parameters",
            "of",
            "this",
            "invokable"
        ]
    },
    {
        "id": 1765,
        "code": "public final ImmutableList<TypeToken<? extends Throwable>> getExceptionTypes() {\n  ImmutableList.Builder<TypeToken<? extends Throwable>> builder = ImmutableList.builder();\n  for (Type type : getGenericExceptionTypes()) {\n      \n    @SuppressWarnings(\"unchecked\")\n    TypeToken<? extends Throwable> exceptionType =\n        (TypeToken<? extends Throwable>) TypeToken.of(type);\n    builder.add(exceptionType);\n  }\n  return builder.build();\n}",
        "summary_tokens": [
            "returns",
            "all",
            "declared",
            "exception",
            "types",
            "of",
            "this",
            "invokable"
        ]
    },
    {
        "id": 1766,
        "code": "public final <R1 extends R> Invokable<T, R1> returning(TypeToken<R1> returnType) {\n  if (!returnType.isSupertypeOf(getReturnType())) {\n    throw new IllegalArgumentException(\n        \"Invokable is known to return \" + getReturnType() + \", not \" + returnType);\n  }\n  @SuppressWarnings(\"unchecked\") \n  Invokable<T, R1> specialized = (Invokable<T, R1>) this;\n  return specialized;\n}",
        "summary_tokens": [
            "explicitly",
            "specifies",
            "the",
            "return",
            "type",
            "of",
            "this",
            "invokable"
        ]
    },
    {
        "id": 1767,
        "code": "public TypeToken<T> getOwnerType() {\n  return (TypeToken<T>) TypeToken.of(getDeclaringClass());\n}",
        "summary_tokens": [
            "returns",
            "the",
            "type",
            "of",
            "t"
        ]
    },
    {
        "id": 1768,
        "code": "public TypeToken<?> getType() {\n  return type;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "type",
            "of",
            "the",
            "parameter"
        ]
    },
    {
        "id": 1769,
        "code": "public Invokable<?, ?> getDeclaringInvokable() {\n  return declaration;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "invokable",
            "that",
            "declares",
            "this",
            "parameter"
        ]
    },
    {
        "id": 1770,
        "code": "public static String getPackageName(String classFullName) {\n  int lastDot = classFullName.lastIndexOf('.');\n  return (lastDot < 0) ? \"\" : classFullName.substring(0, lastDot);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "package",
            "name",
            "of",
            "class",
            "full",
            "name",
            "according",
            "to",
            "the",
            "java",
            "language",
            "specification",
            "section",
            "0"
        ]
    },
    {
        "id": 1771,
        "code": "public static void initialize(Class<?>... classes) {\n  for (Class<?> clazz : classes) {\n    try {\n      Class.forName(clazz.getName(), true, clazz.getClassLoader());\n    } catch (ClassNotFoundException e) {\n      throw new AssertionError(e);\n    }\n  }\n}",
        "summary_tokens": [
            "ensures",
            "that",
            "the",
            "given",
            "classes",
            "are",
            "initialized",
            "as",
            "described",
            "in",
            "a",
            "href",
            "http",
            "java"
        ]
    },
    {
        "id": 1772,
        "code": "public static <T> T newProxy(Class<T> interfaceType, InvocationHandler handler) {\n  checkNotNull(handler);\n  checkArgument(interfaceType.isInterface(), \"%s is not an interface\", interfaceType);\n  Object object =\n      Proxy.newProxyInstance(\n          interfaceType.getClassLoader(), new Class<?>[] {interfaceType}, handler);\n  return interfaceType.cast(object);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "proxy",
            "instance",
            "that",
            "implements",
            "interface",
            "type",
            "by",
            "dispatching",
            "method",
            "invocations",
            "to",
            "handler"
        ]
    },
    {
        "id": 1773,
        "code": "final Type capture() {\n  Type superclass = getClass().getGenericSuperclass();\n  checkArgument(superclass instanceof ParameterizedType, \"%s isn't parameterized\", superclass);\n  return ((ParameterizedType) superclass).getActualTypeArguments()[0];\n}",
        "summary_tokens": [
            "returns",
            "the",
            "captured",
            "type"
        ]
    },
    {
        "id": 1774,
        "code": "static TypeResolver covariantly(Type contextType) {\n  return new TypeResolver().where(TypeMappingIntrospector.getTypeMappings(contextType));\n}",
        "summary_tokens": [
            "returns",
            "a",
            "resolver",
            "that",
            "resolves",
            "types",
            "covariantly"
        ]
    },
    {
        "id": 1775,
        "code": "static TypeResolver invariantly(Type contextType) {\n  Type invariantContext = WildcardCapturer.INSTANCE.capture(contextType);\n  return new TypeResolver().where(TypeMappingIntrospector.getTypeMappings(invariantContext));\n}",
        "summary_tokens": [
            "returns",
            "a",
            "resolver",
            "that",
            "resolves",
            "types",
            "invariantly"
        ]
    },
    {
        "id": 1776,
        "code": "TypeResolver where(Map<TypeVariableKey, ? extends Type> mappings) {\n  return new TypeResolver(typeTable.where(mappings));\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "type",
            "resolver",
            "with",
            "variable",
            "mapping",
            "to",
            "type"
        ]
    },
    {
        "id": 1777,
        "code": "public Type resolveType(Type type) {\n  checkNotNull(type);\n  if (type instanceof TypeVariable) {\n    return typeTable.resolve((TypeVariable<?>) type);\n  } else if (type instanceof ParameterizedType) {\n    return resolveParameterizedType((ParameterizedType) type);\n  } else if (type instanceof GenericArrayType) {\n    return resolveGenericArrayType((GenericArrayType) type);\n  } else if (type instanceof WildcardType) {\n    return resolveWildcardType((WildcardType) type);\n  } else {\n      \n    return type;\n  }\n}",
        "summary_tokens": [
            "resolves",
            "all",
            "type",
            "variables",
            "in",
            "type",
            "and",
            "all",
            "downstream",
            "types",
            "and",
            "returns",
            "a",
            "corresponding",
            "type",
            "with",
            "type",
            "variables",
            "resolved"
        ]
    },
    {
        "id": 1778,
        "code": "public static TypeToken<?> of(Type type) {\n  return new SimpleTypeToken<>(type);\n}",
        "summary_tokens": [
            "returns",
            "an",
            "instance",
            "of",
            "type",
            "token",
            "that",
            "wraps",
            "type"
        ]
    },
    {
        "id": 1779,
        "code": "public final Class<? super T> getRawType() {\n    \n  Class<?> rawType = getRawTypes().iterator().next();\n  @SuppressWarnings(\"unchecked\") \n  Class<? super T> result = (Class<? super T>) rawType;\n  return result;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "raw",
            "type",
            "of",
            "t"
        ]
    },
    {
        "id": 1780,
        "code": "public final Type getType() {\n  return runtimeType;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "represented",
            "type"
        ]
    },
    {
        "id": 1781,
        "code": "public final <X> TypeToken<T> where(TypeParameter<X> typeParam, Class<X> typeArg) {\n  return where(typeParam, of(typeArg));\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "type",
            "token",
            "where",
            "type",
            "variables",
            "represented",
            "by",
            "type",
            "param",
            "are",
            "substituted",
            "by",
            "type",
            "arg"
        ]
    },
    {
        "id": 1782,
        "code": "public final TypeToken<?> resolveType(Type type) {\n  checkNotNull(type);\n    \n    \n  return of(getInvariantTypeResolver().resolveType(type));\n}",
        "summary_tokens": [
            "resolves",
            "the",
            "given",
            "type",
            "against",
            "the",
            "type",
            "context",
            "represented",
            "by",
            "this",
            "type"
        ]
    },
    {
        "id": 1783,
        "code": "final TypeToken<? super T> getGenericSuperclass() {\n  if (runtimeType instanceof TypeVariable) {\n      \n    return boundAsSuperclass(((TypeVariable<?>) runtimeType).getBounds()[0]);\n  }\n  if (runtimeType instanceof WildcardType) {\n      \n    return boundAsSuperclass(((WildcardType) runtimeType).getUpperBounds()[0]);\n  }\n  Type superclass = getRawType().getGenericSuperclass();\n  if (superclass == null) {\n    return null;\n  }\n  @SuppressWarnings(\"unchecked\") \n  TypeToken<? super T> superToken = (TypeToken<? super T>) resolveSupertype(superclass);\n  return superToken;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "generic",
            "superclass",
            "of",
            "this",
            "type",
            "or",
            "null",
            "if",
            "the",
            "type",
            "represents",
            "object",
            "or",
            "an",
            "interface"
        ]
    },
    {
        "id": 1784,
        "code": "final ImmutableList<TypeToken<? super T>> getGenericInterfaces() {\n  if (runtimeType instanceof TypeVariable) {\n    return boundsAsInterfaces(((TypeVariable<?>) runtimeType).getBounds());\n  }\n  if (runtimeType instanceof WildcardType) {\n    return boundsAsInterfaces(((WildcardType) runtimeType).getUpperBounds());\n  }\n  ImmutableList.Builder<TypeToken<? super T>> builder = ImmutableList.builder();\n  for (Type interfaceType : getRawType().getGenericInterfaces()) {\n    @SuppressWarnings(\"unchecked\") \n    TypeToken<? super T> resolvedInterface =\n        (TypeToken<? super T>) resolveSupertype(interfaceType);\n    builder.add(resolvedInterface);\n  }\n  return builder.build();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "generic",
            "interfaces",
            "that",
            "this",
            "type",
            "directly",
            "implements"
        ]
    },
    {
        "id": 1785,
        "code": "public final TypeSet getTypes() {\n  return new TypeSet();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "set",
            "of",
            "interfaces",
            "and",
            "classes",
            "that",
            "this",
            "type",
            "is",
            "or",
            "is",
            "a",
            "subtype",
            "of"
        ]
    },
    {
        "id": 1786,
        "code": "public final TypeToken<? super T> getSupertype(Class<? super T> superclass) {\n  checkArgument(\n      this.someRawTypeIsSubclassOf(superclass),\n      \"%s is not a super class of %s\",\n      superclass,\n      this);\n  if (runtimeType instanceof TypeVariable) {\n    return getSupertypeFromUpperBounds(superclass, ((TypeVariable<?>) runtimeType).getBounds());\n  }\n  if (runtimeType instanceof WildcardType) {\n    return getSupertypeFromUpperBounds(superclass, ((WildcardType) runtimeType).getUpperBounds());\n  }\n  if (superclass.isArray()) {\n    return getArraySupertype(superclass);\n  }\n  @SuppressWarnings(\"unchecked\") \n  TypeToken<? super T> supertype =\n      (TypeToken<? super T>) resolveSupertype(toGenericType(superclass).runtimeType);\n  return supertype;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "generic",
            "form",
            "of",
            "superclass"
        ]
    },
    {
        "id": 1787,
        "code": "public final TypeToken<? extends T> getSubtype(Class<?> subclass) {\n  checkArgument(\n      !(runtimeType instanceof TypeVariable), \"Cannot get subtype of type variable <%s>\", this);\n  if (runtimeType instanceof WildcardType) {\n    return getSubtypeFromLowerBounds(subclass, ((WildcardType) runtimeType).getLowerBounds());\n  }\n    \n  if (isArray()) {\n    return getArraySubtype(subclass);\n  }\n    \n  checkArgument(\n      getRawType().isAssignableFrom(subclass), \"%s isn't a subclass of %s\", subclass, this);\n  Type resolvedTypeArgs = resolveTypeArgsForSubclass(subclass);\n  @SuppressWarnings(\"unchecked\") \n  TypeToken<? extends T> subtype = (TypeToken<? extends T>) of(resolvedTypeArgs);\n  checkArgument(\n      subtype.isSubtypeOf(this), \"%s does not appear to be a subtype of %s\", subtype, this);\n  return subtype;\n}",
        "summary_tokens": [
            "returns",
            "subtype",
            "of",
            "this",
            "with",
            "subclass",
            "as",
            "the",
            "raw",
            "class"
        ]
    },
    {
        "id": 1788,
        "code": "public final boolean isSupertypeOf(Type type) {\n  return of(type).isSubtypeOf(getType());\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "this",
            "type",
            "is",
            "a",
            "supertype",
            "of",
            "the",
            "given",
            "type"
        ]
    },
    {
        "id": 1789,
        "code": "public final boolean isSubtypeOf(Type supertype) {\n  checkNotNull(supertype);\n  if (supertype instanceof WildcardType) {\n      \n      \n      \n    return any(((WildcardType) supertype).getLowerBounds()).isSupertypeOf(runtimeType);\n  }\n    \n    \n  if (runtimeType instanceof WildcardType) {\n      \n    return any(((WildcardType) runtimeType).getUpperBounds()).isSubtypeOf(supertype);\n  }\n    \n    \n  if (runtimeType instanceof TypeVariable) {\n    return runtimeType.equals(supertype)\n        || any(((TypeVariable<?>) runtimeType).getBounds()).isSubtypeOf(supertype);\n  }\n  if (runtimeType instanceof GenericArrayType) {\n    return of(supertype).isSupertypeOfArray((GenericArrayType) runtimeType);\n  }\n    \n  if (supertype instanceof Class) {\n    return this.someRawTypeIsSubclassOf((Class<?>) supertype);\n  } else if (supertype instanceof ParameterizedType) {\n    return this.isSubtypeOfParameterizedType((ParameterizedType) supertype);\n  } else if (supertype instanceof GenericArrayType) {\n    return this.isSubtypeOfArrayType((GenericArrayType) supertype);\n  } else { \n    return false;\n  }\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "this",
            "type",
            "is",
            "a",
            "subtype",
            "of",
            "the",
            "given",
            "type"
        ]
    },
    {
        "id": 1790,
        "code": "public final boolean isArray() {\n  return getComponentType() != null;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "this",
            "type",
            "is",
            "known",
            "to",
            "be",
            "an",
            "array",
            "type",
            "such",
            "as",
            "int",
            "t",
            "extends",
            "map",
            "string",
            "integer",
            "etc"
        ]
    },
    {
        "id": 1791,
        "code": "public final boolean isPrimitive() {\n  return (runtimeType instanceof Class) && ((Class<?>) runtimeType).isPrimitive();\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "this",
            "type",
            "is",
            "one",
            "of",
            "the",
            "nine",
            "primitive",
            "types",
            "including",
            "void"
        ]
    },
    {
        "id": 1792,
        "code": "public final TypeToken<T> wrap() {\n  if (isPrimitive()) {\n    @SuppressWarnings(\"unchecked\") \n    Class<T> type = (Class<T>) runtimeType;\n    return of(Primitives.wrap(type));\n  }\n  return this;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "corresponding",
            "wrapper",
            "type",
            "if",
            "this",
            "is",
            "a",
            "primitive",
            "type",
            "otherwise",
            "returns",
            "this",
            "itself"
        ]
    },
    {
        "id": 1793,
        "code": "public final TypeToken<T> unwrap() {\n  if (isWrapper()) {\n    @SuppressWarnings(\"unchecked\") \n    Class<T> type = (Class<T>) runtimeType;\n    return of(Primitives.unwrap(type));\n  }\n  return this;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "corresponding",
            "primitive",
            "type",
            "if",
            "this",
            "is",
            "a",
            "wrapper",
            "type",
            "otherwise",
            "returns",
            "this",
            "itself"
        ]
    },
    {
        "id": 1794,
        "code": "public final TypeToken<?> getComponentType() {\n  Type componentType = Types.getComponentType(runtimeType);\n  if (componentType == null) {\n    return null;\n  }\n  return of(componentType);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "array",
            "component",
            "type",
            "if",
            "this",
            "type",
            "represents",
            "an",
            "array",
            "int",
            "t",
            "extends",
            "map",
            "string",
            "integer",
            "etc"
        ]
    },
    {
        "id": 1795,
        "code": "public final Invokable<T, Object> method(Method method) {\n  checkArgument(\n      this.someRawTypeIsSubclassOf(method.getDeclaringClass()),\n      \"%s not declared by %s\",\n      method,\n      this);\n  return new Invokable.MethodInvokable<T>(method) {\n    @Override\n    Type getGenericReturnType() {\n      return getCovariantTypeResolver().resolveType(super.getGenericReturnType());\n    }\n\n    @Override\n    Type[] getGenericParameterTypes() {\n      return getInvariantTypeResolver().resolveTypesInPlace(super.getGenericParameterTypes());\n    }\n\n    @Override\n    Type[] getGenericExceptionTypes() {\n      return getCovariantTypeResolver().resolveTypesInPlace(super.getGenericExceptionTypes());\n    }\n\n    @Override\n    public TypeToken<T> getOwnerType() {\n      return TypeToken.this;\n    }\n\n    @Override\n    public String toString() {\n      return getOwnerType() + \".\" + super.toString();\n    }\n  };\n}",
        "summary_tokens": [
            "returns",
            "the",
            "invokable",
            "for",
            "method",
            "which",
            "must",
            "be",
            "a",
            "member",
            "of",
            "t"
        ]
    },
    {
        "id": 1796,
        "code": "public final Invokable<T, T> constructor(Constructor<?> constructor) {\n  checkArgument(\n      constructor.getDeclaringClass() == getRawType(),\n      \"%s not declared by %s\",\n      constructor,\n      getRawType());\n  return new Invokable.ConstructorInvokable<T>(constructor) {\n    @Override\n    Type getGenericReturnType() {\n      return getCovariantTypeResolver().resolveType(super.getGenericReturnType());\n    }\n\n    @Override\n    Type[] getGenericParameterTypes() {\n      return getInvariantTypeResolver().resolveTypesInPlace(super.getGenericParameterTypes());\n    }\n\n    @Override\n    Type[] getGenericExceptionTypes() {\n      return getCovariantTypeResolver().resolveTypesInPlace(super.getGenericExceptionTypes());\n    }\n\n    @Override\n    public TypeToken<T> getOwnerType() {\n      return TypeToken.this;\n    }\n\n    @Override\n    public String toString() {\n      return getOwnerType() + \"(\" + Joiner.on(\", \").join(getGenericParameterTypes()) + \")\";\n    }\n  };\n}",
        "summary_tokens": [
            "returns",
            "the",
            "invokable",
            "for",
            "constructor",
            "which",
            "must",
            "be",
            "a",
            "member",
            "of",
            "t"
        ]
    },
    {
        "id": 1797,
        "code": "public boolean equals(@CheckForNull Object o) {\n  if (o instanceof TypeToken) {\n    TypeToken<?> that = (TypeToken<?>) o;\n    return runtimeType.equals(that.runtimeType);\n  }\n  return false;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "o",
            "is",
            "another",
            "type",
            "token",
            "that",
            "represents",
            "the",
            "same",
            "type"
        ]
    },
    {
        "id": 1798,
        "code": "protected Object writeReplace() {\n    \n    \n  return of(new TypeResolver().resolveType(runtimeType));\n}",
        "summary_tokens": [
            "implemented",
            "to",
            "support",
            "serialization",
            "of",
            "subclasses"
        ]
    },
    {
        "id": 1799,
        "code": "final TypeToken<T> rejectTypeVariables() {\n  new TypeVisitor() {\n    @Override\n    void visitTypeVariable(TypeVariable<?> type) {\n      throw new IllegalArgumentException(\n          runtimeType + \"contains a type variable and is not safe for the operation\");\n    }\n\n    @Override\n    void visitWildcardType(WildcardType type) {\n      visit(type.getLowerBounds());\n      visit(type.getUpperBounds());\n    }\n\n    @Override\n    void visitParameterizedType(ParameterizedType type) {\n      visit(type.getActualTypeArguments());\n      visit(type.getOwnerType());\n    }\n\n    @Override\n    void visitGenericArrayType(GenericArrayType type) {\n      visit(type.getGenericComponentType());\n    }\n  }.visit(runtimeType);\n  return this;\n}",
        "summary_tokens": [
            "ensures",
            "that",
            "this",
            "type",
            "token",
            "doesn",
            "t",
            "contain",
            "type",
            "variables",
            "which",
            "can",
            "cause",
            "unchecked",
            "type",
            "errors",
            "for",
            "callers",
            "like",
            "type",
            "to",
            "instance",
            "map"
        ]
    },
    {
        "id": 1800,
        "code": "private Type getOwnerTypeIfPresent() {\n  if (runtimeType instanceof ParameterizedType) {\n    return ((ParameterizedType) runtimeType).getOwnerType();\n  } else if (runtimeType instanceof Class<?>) {\n    return ((Class<?>) runtimeType).getEnclosingClass();\n  } else {\n    return null;\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "owner",
            "type",
            "of",
            "a",
            "parameterized",
            "type",
            "or",
            "enclosing",
            "class",
            "of",
            "a",
            "class",
            "or",
            "null",
            "otherwise"
        ]
    },
    {
        "id": 1801,
        "code": "static <T> TypeToken<? extends T> toGenericType(Class<T> cls) {\n  if (cls.isArray()) {\n    Type arrayOfGenericType =\n        Types.newArrayType(\n              \n            toGenericType(cls.getComponentType()).runtimeType);\n    @SuppressWarnings(\"unchecked\") \n    TypeToken<? extends T> result = (TypeToken<? extends T>) of(arrayOfGenericType);\n    return result;\n  }\n  TypeVariable<Class<T>>[] typeParams = cls.getTypeParameters();\n  Type ownerType =\n      cls.isMemberClass() && !Modifier.isStatic(cls.getModifiers())\n          ? toGenericType(cls.getEnclosingClass()).runtimeType\n          : null;\n\n  if ((typeParams.length > 0) || ((ownerType != null) && ownerType != cls.getEnclosingClass())) {\n    @SuppressWarnings(\"unchecked\") \n    TypeToken<? extends T> type =\n        (TypeToken<? extends T>)\n            of(Types.newParameterizedTypeWithOwner(ownerType, cls, typeParams));\n    return type;\n  } else {\n    return of(cls);\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "type",
            "token",
            "representing",
            "the",
            "generic",
            "type",
            "declaration",
            "of",
            "cls"
        ]
    },
    {
        "id": 1802,
        "code": "private static Type newArrayClassOrGenericArrayType(Type componentType) {\n  return Types.JavaVersion.JAVA7.newArrayType(componentType);\n}",
        "summary_tokens": [
            "creates",
            "an",
            "array",
            "class",
            "if",
            "component",
            "type",
            "is",
            "a",
            "class",
            "or",
            "else",
            "a",
            "generic",
            "array",
            "type"
        ]
    },
    {
        "id": 1803,
        "code": "public final void visit(@Nullable Type... types) {\n  for (Type type : types) {\n    if (type == null || !visited.add(type)) {\n        \n      continue;\n    }\n    boolean succeeded = false;\n    try {\n      if (type instanceof TypeVariable) {\n        visitTypeVariable((TypeVariable<?>) type);\n      } else if (type instanceof WildcardType) {\n        visitWildcardType((WildcardType) type);\n      } else if (type instanceof ParameterizedType) {\n        visitParameterizedType((ParameterizedType) type);\n      } else if (type instanceof Class) {\n        visitClass((Class<?>) type);\n      } else if (type instanceof GenericArrayType) {\n        visitGenericArrayType((GenericArrayType) type);\n      } else {\n        throw new AssertionError(\"Unknown type: \" + type);\n      }\n      succeeded = true;\n    } finally {\n      if (!succeeded) { \n        visited.remove(type);\n      }\n    }\n  }\n}",
        "summary_tokens": [
            "visits",
            "the",
            "given",
            "types"
        ]
    },
    {
        "id": 1804,
        "code": "",
        "summary_tokens": [
            "invoked",
            "to",
            "request",
            "the",
            "service",
            "to",
            "stop"
        ]
    },
    {
        "id": 1805,
        "code": "protected Executor executor() {\n  return new Executor() {\n    @Override\n    public void execute(Runnable command) {\n      MoreExecutors.newThread(serviceName(), command).start();\n    }\n  };\n}",
        "summary_tokens": [
            "returns",
            "the",
            "executor",
            "that",
            "will",
            "be",
            "used",
            "to",
            "run",
            "this",
            "service"
        ]
    },
    {
        "id": 1806,
        "code": "protected String serviceName() {\n  return getClass().getSimpleName();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "name",
            "of",
            "this",
            "service"
        ]
    },
    {
        "id": 1807,
        "code": "protected Executor executor() {\n  return new Executor() {\n    @Override\n    public void execute(Runnable command) {\n      MoreExecutors.newThread(threadNameSupplier.get(), command).start();\n    }\n  };\n}",
        "summary_tokens": [
            "returns",
            "the",
            "executor",
            "that",
            "will",
            "be",
            "used",
            "to",
            "run",
            "this",
            "service"
        ]
    },
    {
        "id": 1808,
        "code": "protected String serviceName() {\n  return getClass().getSimpleName();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "name",
            "of",
            "this",
            "service"
        ]
    },
    {
        "id": 1809,
        "code": "",
        "summary_tokens": [
            "this",
            "method",
            "is",
            "called",
            "by",
            "stop",
            "async",
            "when",
            "the",
            "service",
            "is",
            "still",
            "starting",
            "i"
        ]
    },
    {
        "id": 1810,
        "code": "private void checkCurrentState(State expected) {\n  State actual = state();\n  if (actual != expected) {\n    if (actual == FAILED) {\n        \n      throw new IllegalStateException(\n          \"Expected the service \" + this + \" to be \" + expected + \", but the service has FAILED\",\n          failureCause());\n    }\n    throw new IllegalStateException(\n        \"Expected the service \" + this + \" to be \" + expected + \", but was \" + actual);\n  }\n}",
        "summary_tokens": [
            "checks",
            "that",
            "the",
            "current",
            "state",
            "is",
            "equal",
            "to",
            "the",
            "expected",
            "state"
        ]
    },
    {
        "id": 1811,
        "code": "protected final void notifyStarted() {\n  monitor.enter();\n  try {\n      \n      \n    if (snapshot.state != STARTING) {\n      IllegalStateException failure =\n          new IllegalStateException(\n              \"Cannot notifyStarted() when the service is \" + snapshot.state);\n      notifyFailed(failure);\n      throw failure;\n    }\n\n    if (snapshot.shutdownWhenStartupFinishes) {\n      snapshot = new StateSnapshot(STOPPING);\n        \n        \n      doStop();\n    } else {\n      snapshot = new StateSnapshot(RUNNING);\n      enqueueRunningEvent();\n    }\n  } finally {\n    monitor.leave();\n    dispatchListenerEvents();\n  }\n}",
        "summary_tokens": [
            "implementing",
            "classes",
            "should",
            "invoke",
            "this",
            "method",
            "once",
            "their",
            "service",
            "has",
            "started"
        ]
    },
    {
        "id": 1812,
        "code": "protected final void notifyStopped() {\n  monitor.enter();\n  try {\n    State previous = state();\n    switch (previous) {\n      case NEW:\n      case TERMINATED:\n      case FAILED:\n        throw new IllegalStateException(\"Cannot notifyStopped() when the service is \" + previous);\n      case RUNNING:\n      case STARTING:\n      case STOPPING:\n        snapshot = new StateSnapshot(TERMINATED);\n        enqueueTerminatedEvent(previous);\n        break;\n    }\n  } finally {\n    monitor.leave();\n    dispatchListenerEvents();\n  }\n}",
        "summary_tokens": [
            "implementing",
            "classes",
            "should",
            "invoke",
            "this",
            "method",
            "once",
            "their",
            "service",
            "has",
            "stopped"
        ]
    },
    {
        "id": 1813,
        "code": "protected final void notifyFailed(Throwable cause) {\n  checkNotNull(cause);\n\n  monitor.enter();\n  try {\n    State previous = state();\n    switch (previous) {\n      case NEW:\n      case TERMINATED:\n        throw new IllegalStateException(\"Failed while in state:\" + previous, cause);\n      case RUNNING:\n      case STARTING:\n      case STOPPING:\n        snapshot = new StateSnapshot(FAILED, false, cause);\n        enqueueFailedEvent(previous, cause);\n        break;\n      case FAILED:\n          \n        break;\n    }\n  } finally {\n    monitor.leave();\n    dispatchListenerEvents();\n  }\n}",
        "summary_tokens": [
            "invoke",
            "this",
            "method",
            "to",
            "transition",
            "the",
            "service",
            "to",
            "the",
            "state",
            "failed"
        ]
    },
    {
        "id": 1814,
        "code": "private void dispatchListenerEvents() {\n  if (!monitor.isOccupiedByCurrentThread()) {\n    listeners.dispatch();\n  }\n}",
        "summary_tokens": [
            "attempts",
            "to",
            "execute",
            "all",
            "the",
            "listeners",
            "in",
            "listeners",
            "while",
            "not",
            "holding",
            "the",
            "monitor"
        ]
    },
    {
        "id": 1815,
        "code": "public final double get() {\n  return longBitsToDouble(value);\n}",
        "summary_tokens": [
            "gets",
            "the",
            "current",
            "value"
        ]
    },
    {
        "id": 1816,
        "code": "public final void set(double newValue) {\n  long next = doubleToRawLongBits(newValue);\n  value = next;\n}",
        "summary_tokens": [
            "sets",
            "to",
            "the",
            "given",
            "value"
        ]
    },
    {
        "id": 1817,
        "code": "public final void lazySet(double newValue) {\n  long next = doubleToRawLongBits(newValue);\n  updater.lazySet(this, next);\n}",
        "summary_tokens": [
            "eventually",
            "sets",
            "to",
            "the",
            "given",
            "value"
        ]
    },
    {
        "id": 1818,
        "code": "public final double getAndSet(double newValue) {\n  long next = doubleToRawLongBits(newValue);\n  return longBitsToDouble(updater.getAndSet(this, next));\n}",
        "summary_tokens": [
            "atomically",
            "sets",
            "to",
            "the",
            "given",
            "value",
            "and",
            "returns",
            "the",
            "old",
            "value"
        ]
    },
    {
        "id": 1819,
        "code": "public final boolean compareAndSet(double expect, double update) {\n  return updater.compareAndSet(this, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}",
        "summary_tokens": [
            "atomically",
            "sets",
            "the",
            "value",
            "to",
            "the",
            "given",
            "updated",
            "value",
            "if",
            "the",
            "current",
            "value",
            "is",
            "a",
            "href",
            "bit",
            "equals",
            "bitwise",
            "equal",
            "a",
            "to",
            "the",
            "expected",
            "value"
        ]
    },
    {
        "id": 1820,
        "code": "public final boolean weakCompareAndSet(double expect, double update) {\n  return updater.weakCompareAndSet(\n      this, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}",
        "summary_tokens": [
            "atomically",
            "sets",
            "the",
            "value",
            "to",
            "the",
            "given",
            "updated",
            "value",
            "if",
            "the",
            "current",
            "value",
            "is",
            "a",
            "href",
            "bit",
            "equals",
            "bitwise",
            "equal",
            "a",
            "to",
            "the",
            "expected",
            "value"
        ]
    },
    {
        "id": 1821,
        "code": "public final double getAndAdd(double delta) {\n  return getAndAccumulate(delta, Double::sum);\n}",
        "summary_tokens": [
            "atomically",
            "adds",
            "the",
            "given",
            "value",
            "to",
            "the",
            "current",
            "value"
        ]
    },
    {
        "id": 1822,
        "code": "public final double addAndGet(double delta) {\n  return accumulateAndGet(delta, Double::sum);\n}",
        "summary_tokens": [
            "atomically",
            "adds",
            "the",
            "given",
            "value",
            "to",
            "the",
            "current",
            "value"
        ]
    },
    {
        "id": 1823,
        "code": "public String toString() {\n  return Double.toString(get());\n}",
        "summary_tokens": [
            "returns",
            "the",
            "string",
            "representation",
            "of",
            "the",
            "current",
            "value"
        ]
    },
    {
        "id": 1824,
        "code": "public int intValue() {\n  return (int) get();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "value",
            "of",
            "this",
            "atomic",
            "double",
            "as",
            "an",
            "int",
            "after",
            "a",
            "narrowing",
            "primitive",
            "conversion"
        ]
    },
    {
        "id": 1825,
        "code": "public long longValue() {\n  return (long) get();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "value",
            "of",
            "this",
            "atomic",
            "double",
            "as",
            "a",
            "long",
            "after",
            "a",
            "narrowing",
            "primitive",
            "conversion"
        ]
    },
    {
        "id": 1826,
        "code": "public float floatValue() {\n  return (float) get();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "value",
            "of",
            "this",
            "atomic",
            "double",
            "as",
            "a",
            "float",
            "after",
            "a",
            "narrowing",
            "primitive",
            "conversion"
        ]
    },
    {
        "id": 1827,
        "code": "public double doubleValue() {\n  return get();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "value",
            "of",
            "this",
            "atomic",
            "double",
            "as",
            "a",
            "double"
        ]
    },
    {
        "id": 1828,
        "code": "private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException {\n  s.defaultWriteObject();\n\n  s.writeDouble(get());\n}",
        "summary_tokens": [
            "saves",
            "the",
            "state",
            "to",
            "a",
            "stream",
            "that",
            "is",
            "serializes",
            "it"
        ]
    },
    {
        "id": 1829,
        "code": "private void readObject(java.io.ObjectInputStream s)\n    throws java.io.IOException, ClassNotFoundException {\n  s.defaultReadObject();\n\n  set(s.readDouble());\n}",
        "summary_tokens": [
            "reconstitutes",
            "the",
            "instance",
            "from",
            "a",
            "stream",
            "that",
            "is",
            "deserializes",
            "it"
        ]
    },
    {
        "id": 1830,
        "code": "public final int length() {\n  return longs.length();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "length",
            "of",
            "the",
            "array"
        ]
    },
    {
        "id": 1831,
        "code": "public final double get(int i) {\n  return longBitsToDouble(longs.get(i));\n}",
        "summary_tokens": [
            "gets",
            "the",
            "current",
            "value",
            "at",
            "position",
            "i"
        ]
    },
    {
        "id": 1832,
        "code": "public final void set(int i, double newValue) {\n  long next = doubleToRawLongBits(newValue);\n  longs.set(i, next);\n}",
        "summary_tokens": [
            "atomically",
            "sets",
            "the",
            "element",
            "at",
            "position",
            "i",
            "to",
            "the",
            "given",
            "value"
        ]
    },
    {
        "id": 1833,
        "code": "public final void lazySet(int i, double newValue) {\n  long next = doubleToRawLongBits(newValue);\n  longs.lazySet(i, next);\n}",
        "summary_tokens": [
            "eventually",
            "sets",
            "the",
            "element",
            "at",
            "position",
            "i",
            "to",
            "the",
            "given",
            "value"
        ]
    },
    {
        "id": 1834,
        "code": "public final double getAndSet(int i, double newValue) {\n  long next = doubleToRawLongBits(newValue);\n  return longBitsToDouble(longs.getAndSet(i, next));\n}",
        "summary_tokens": [
            "atomically",
            "sets",
            "the",
            "element",
            "at",
            "position",
            "i",
            "to",
            "the",
            "given",
            "value",
            "and",
            "returns",
            "the",
            "old",
            "value"
        ]
    },
    {
        "id": 1835,
        "code": "public final boolean compareAndSet(int i, double expect, double update) {\n  return longs.compareAndSet(i, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}",
        "summary_tokens": [
            "atomically",
            "sets",
            "the",
            "element",
            "at",
            "position",
            "i",
            "to",
            "the",
            "given",
            "updated",
            "value",
            "if",
            "the",
            "current",
            "value",
            "is",
            "a",
            "href",
            "bit",
            "equals",
            "bitwise",
            "equal",
            "a",
            "to",
            "the",
            "expected",
            "value"
        ]
    },
    {
        "id": 1836,
        "code": "public final boolean weakCompareAndSet(int i, double expect, double update) {\n  return longs.weakCompareAndSet(i, doubleToRawLongBits(expect), doubleToRawLongBits(update));\n}",
        "summary_tokens": [
            "atomically",
            "sets",
            "the",
            "element",
            "at",
            "position",
            "i",
            "to",
            "the",
            "given",
            "updated",
            "value",
            "if",
            "the",
            "current",
            "value",
            "is",
            "a",
            "href",
            "bit",
            "equals",
            "bitwise",
            "equal",
            "a",
            "to",
            "the",
            "expected",
            "value"
        ]
    },
    {
        "id": 1837,
        "code": "public final double getAndAdd(int i, double delta) {\n  return getAndAccumulate(i, delta, Double::sum);\n}",
        "summary_tokens": [
            "atomically",
            "adds",
            "the",
            "given",
            "value",
            "to",
            "the",
            "element",
            "at",
            "index",
            "i"
        ]
    },
    {
        "id": 1838,
        "code": "public double addAndGet(int i, double delta) {\n  return accumulateAndGet(i, delta, Double::sum);\n}",
        "summary_tokens": [
            "atomically",
            "adds",
            "the",
            "given",
            "value",
            "to",
            "the",
            "element",
            "at",
            "index",
            "i"
        ]
    },
    {
        "id": 1839,
        "code": "public String toString() {\n  int iMax = length() - 1;\n  if (iMax == -1) {\n    return \"[]\";\n  }\n\n    \n  StringBuilder b = new StringBuilder((17 + 2) * (iMax + 1));\n  b.append('[');\n  for (int i = 0; ; i++) {\n    b.append(longBitsToDouble(longs.get(i)));\n    if (i == iMax) {\n      return b.append(']').toString();\n    }\n    b.append(',').append(' ');\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "string",
            "representation",
            "of",
            "the",
            "current",
            "values",
            "of",
            "array"
        ]
    },
    {
        "id": 1840,
        "code": "private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException {\n  s.defaultWriteObject();\n\n    \n  int length = length();\n  s.writeInt(length);\n\n    \n  for (int i = 0; i < length; i++) {\n    s.writeDouble(get(i));\n  }\n}",
        "summary_tokens": [
            "saves",
            "the",
            "state",
            "to",
            "a",
            "stream",
            "that",
            "is",
            "serializes",
            "it"
        ]
    },
    {
        "id": 1841,
        "code": "private void readObject(java.io.ObjectInputStream s)\n    throws java.io.IOException, ClassNotFoundException {\n  s.defaultReadObject();\n\n  int length = s.readInt();\n  ImmutableLongArray.Builder builder = ImmutableLongArray.builder();\n  for (int i = 0; i < length; i++) {\n    builder.add(doubleToRawLongBits(s.readDouble()));\n  }\n  this.longs = new AtomicLongArray(builder.build().toArray());\n}",
        "summary_tokens": [
            "reconstitutes",
            "the",
            "instance",
            "from",
            "a",
            "stream",
            "that",
            "is",
            "deserializes",
            "it"
        ]
    },
    {
        "id": 1842,
        "code": "public static <K> AtomicLongMap<K> create(Map<? extends K, ? extends Long> m) {\n  AtomicLongMap<K> result = create();\n  result.putAll(m);\n  return result;\n}",
        "summary_tokens": [
            "creates",
            "an",
            "atomic",
            "long",
            "map",
            "with",
            "the",
            "same",
            "mappings",
            "as",
            "the",
            "specified",
            "map"
        ]
    },
    {
        "id": 1843,
        "code": "public long get(K key) {\n  return map.getOrDefault(key, 0L);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "value",
            "associated",
            "with",
            "key",
            "or",
            "zero",
            "if",
            "there",
            "is",
            "no",
            "value",
            "associated",
            "with",
            "key"
        ]
    },
    {
        "id": 1844,
        "code": "public long incrementAndGet(K key) {\n  return addAndGet(key, 1);\n}",
        "summary_tokens": [
            "increments",
            "by",
            "one",
            "the",
            "value",
            "currently",
            "associated",
            "with",
            "key",
            "and",
            "returns",
            "the",
            "new",
            "value"
        ]
    },
    {
        "id": 1845,
        "code": "public long decrementAndGet(K key) {\n  return addAndGet(key, -1);\n}",
        "summary_tokens": [
            "decrements",
            "by",
            "one",
            "the",
            "value",
            "currently",
            "associated",
            "with",
            "key",
            "and",
            "returns",
            "the",
            "new",
            "value"
        ]
    },
    {
        "id": 1846,
        "code": "public long addAndGet(K key, long delta) {\n  return accumulateAndGet(key, delta, Long::sum);\n}",
        "summary_tokens": [
            "adds",
            "delta",
            "to",
            "the",
            "value",
            "currently",
            "associated",
            "with",
            "key",
            "and",
            "returns",
            "the",
            "new",
            "value"
        ]
    },
    {
        "id": 1847,
        "code": "public long getAndIncrement(K key) {\n  return getAndAdd(key, 1);\n}",
        "summary_tokens": [
            "increments",
            "by",
            "one",
            "the",
            "value",
            "currently",
            "associated",
            "with",
            "key",
            "and",
            "returns",
            "the",
            "old",
            "value"
        ]
    },
    {
        "id": 1848,
        "code": "public long getAndDecrement(K key) {\n  return getAndAdd(key, -1);\n}",
        "summary_tokens": [
            "decrements",
            "by",
            "one",
            "the",
            "value",
            "currently",
            "associated",
            "with",
            "key",
            "and",
            "returns",
            "the",
            "old",
            "value"
        ]
    },
    {
        "id": 1849,
        "code": "public long getAndAdd(K key, long delta) {\n  return getAndAccumulate(key, delta, Long::sum);\n}",
        "summary_tokens": [
            "adds",
            "delta",
            "to",
            "the",
            "value",
            "currently",
            "associated",
            "with",
            "key",
            "and",
            "returns",
            "the",
            "old",
            "value"
        ]
    },
    {
        "id": 1850,
        "code": "public long put(K key, long newValue) {\n  return getAndUpdate(key, x -> newValue);\n}",
        "summary_tokens": [
            "associates",
            "new",
            "value",
            "with",
            "key",
            "in",
            "this",
            "map",
            "and",
            "returns",
            "the",
            "value",
            "previously",
            "associated",
            "with",
            "key",
            "or",
            "zero",
            "if",
            "there",
            "was",
            "no",
            "such",
            "value"
        ]
    },
    {
        "id": 1851,
        "code": "public void putAll(Map<? extends K, ? extends Long> m) {\n  m.forEach(this::put);\n}",
        "summary_tokens": [
            "copies",
            "all",
            "of",
            "the",
            "mappings",
            "from",
            "the",
            "specified",
            "map",
            "to",
            "this",
            "map"
        ]
    },
    {
        "id": 1852,
        "code": "boolean remove(K key, long value) {\n  return map.remove(key, value);\n}",
        "summary_tokens": [
            "if",
            "key",
            "value",
            "is",
            "currently",
            "in",
            "the",
            "map",
            "this",
            "method",
            "removes",
            "it",
            "and",
            "returns",
            "true",
            "otherwise",
            "this",
            "method",
            "returns",
            "false"
        ]
    },
    {
        "id": 1853,
        "code": "public boolean removeIfZero(K key) {\n  return remove(key, 0);\n}",
        "summary_tokens": [
            "atomically",
            "remove",
            "key",
            "from",
            "the",
            "map",
            "iff",
            "its",
            "associated",
            "value",
            "is",
            "0"
        ]
    },
    {
        "id": 1854,
        "code": "public void removeAllZeros() {\n  map.values().removeIf(x -> x == 0);\n}",
        "summary_tokens": [
            "removes",
            "all",
            "mappings",
            "from",
            "this",
            "map",
            "whose",
            "values",
            "are",
            "zero"
        ]
    },
    {
        "id": 1855,
        "code": "public long sum() {\n  return map.values().stream().mapToLong(Long::longValue).sum();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "sum",
            "of",
            "all",
            "values",
            "in",
            "this",
            "map"
        ]
    },
    {
        "id": 1856,
        "code": "public Map<K, Long> asMap() {\n  Map<K, Long> result = asMap;\n  return (result == null) ? asMap = createAsMap() : result;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "live",
            "read",
            "only",
            "view",
            "of",
            "the",
            "map",
            "backing",
            "this",
            "atomic",
            "long",
            "map"
        ]
    },
    {
        "id": 1857,
        "code": "public boolean containsKey(Object key) {\n  return map.containsKey(key);\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "this",
            "map",
            "contains",
            "a",
            "mapping",
            "for",
            "the",
            "specified",
            "key"
        ]
    },
    {
        "id": 1858,
        "code": "public int size() {\n  return map.size();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "key",
            "value",
            "mappings",
            "in",
            "this",
            "map"
        ]
    },
    {
        "id": 1859,
        "code": "public boolean isEmpty() {\n  return map.isEmpty();\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "this",
            "map",
            "contains",
            "no",
            "key",
            "value",
            "mappings"
        ]
    },
    {
        "id": 1860,
        "code": "public void clear() {\n  map.clear();\n}",
        "summary_tokens": [
            "removes",
            "all",
            "of",
            "the",
            "mappings",
            "from",
            "this",
            "map"
        ]
    },
    {
        "id": 1861,
        "code": "long putIfAbsent(K key, long newValue) {\n  AtomicBoolean noValue = new AtomicBoolean(false);\n  Long result =\n      map.compute(\n          key,\n          (k, oldValue) -> {\n            if (oldValue == null || oldValue == 0) {\n              noValue.set(true);\n              return newValue;\n            } else {\n              return oldValue;\n            }\n          });\n  return noValue.get() ? 0L : result.longValue();\n}",
        "summary_tokens": [
            "if",
            "key",
            "is",
            "not",
            "already",
            "associated",
            "with",
            "a",
            "value",
            "or",
            "if",
            "key",
            "is",
            "associated",
            "with",
            "zero",
            "associate",
            "it",
            "with",
            "new",
            "value"
        ]
    },
    {
        "id": 1862,
        "code": "boolean replace(K key, long expectedOldValue, long newValue) {\n  if (expectedOldValue == 0L) {\n    return putIfAbsent(key, newValue) == 0L;\n  } else {\n    return map.replace(key, expectedOldValue, newValue);\n  }\n}",
        "summary_tokens": [
            "if",
            "key",
            "expected",
            "old",
            "value",
            "is",
            "currently",
            "in",
            "the",
            "map",
            "this",
            "method",
            "replaces",
            "expected",
            "old",
            "value",
            "with",
            "new",
            "value",
            "and",
            "returns",
            "true",
            "otherwise",
            "this",
            "method",
            "returns",
            "false"
        ]
    },
    {
        "id": 1863,
        "code": "public static CycleDetectingLockFactory newInstance(Policy policy) {\n  return new CycleDetectingLockFactory(policy);\n}",
        "summary_tokens": [
            "creates",
            "a",
            "new",
            "factory",
            "with",
            "the",
            "specified",
            "policy"
        ]
    },
    {
        "id": 1864,
        "code": "public ReentrantLock newReentrantLock(String lockName, boolean fair) {\n  return policy == Policies.DISABLED\n      ? new ReentrantLock(fair)\n      : new CycleDetectingReentrantLock(new LockGraphNode(lockName), fair);\n}",
        "summary_tokens": [
            "creates",
            "a",
            "reentrant",
            "lock",
            "with",
            "the",
            "given",
            "fairness",
            "policy"
        ]
    },
    {
        "id": 1865,
        "code": "public ReentrantReadWriteLock newReentrantReadWriteLock(String lockName, boolean fair) {\n  return policy == Policies.DISABLED\n      ? new ReentrantReadWriteLock(fair)\n      : new CycleDetectingReentrantReadWriteLock(new LockGraphNode(lockName), fair);\n}",
        "summary_tokens": [
            "creates",
            "a",
            "reentrant",
            "read",
            "write",
            "lock",
            "with",
            "the",
            "given",
            "fairness",
            "policy"
        ]
    },
    {
        "id": 1866,
        "code": "public static <E extends Enum<E>> WithExplicitOrdering<E> newInstanceWithExplicitOrdering(\n    Class<E> enumClass, Policy policy) {\n    \n    \n  checkNotNull(enumClass);\n  checkNotNull(policy);\n  @SuppressWarnings(\"unchecked\")\n  Map<E, LockGraphNode> lockGraphNodes = (Map<E, LockGraphNode>) getOrCreateNodes(enumClass);\n  return new WithExplicitOrdering<>(policy, lockGraphNodes);\n}",
        "summary_tokens": [
            "creates",
            "a",
            "cycle",
            "detecting",
            "lock",
            "factory"
        ]
    },
    {
        "id": 1867,
        "code": "static <E extends Enum<E>> Map<E, LockGraphNode> createNodes(Class<E> clazz) {\n  EnumMap<E, LockGraphNode> map = Maps.newEnumMap(clazz);\n  E[] keys = clazz.getEnumConstants();\n  int numKeys = keys.length;\n  ArrayList<LockGraphNode> nodes = Lists.newArrayListWithCapacity(numKeys);\n    \n  for (E key : keys) {\n    LockGraphNode node = new LockGraphNode(getLockName(key));\n    nodes.add(node);\n    map.put(key, node);\n  }\n    \n  for (int i = 1; i < numKeys; i++) {\n    nodes.get(i).checkAcquiredLocks(Policies.THROW, nodes.subList(0, i));\n  }\n    \n  for (int i = 0; i < numKeys - 1; i++) {\n    nodes.get(i).checkAcquiredLocks(Policies.DISABLED, nodes.subList(i + 1, numKeys));\n  }\n  return Collections.unmodifiableMap(map);\n}",
        "summary_tokens": [
            "for",
            "a",
            "given",
            "enum",
            "type",
            "creates",
            "an",
            "immutable",
            "map",
            "from",
            "each",
            "of",
            "the",
            "enum",
            "s",
            "values",
            "to",
            "a",
            "corresponding",
            "lock",
            "graph",
            "node",
            "with",
            "the",
            "allowed",
            "prior",
            "locks",
            "and",
            "disallowed",
            "prior",
            "locks",
            "prepopulated",
            "with",
            "nodes",
            "according",
            "to",
            "the",
            "natural",
            "ordering",
            "of",
            "the",
            "associated",
            "enum",
            "values"
        ]
    },
    {
        "id": 1868,
        "code": "private static String getLockName(Enum<?> rank) {\n  return rank.getDeclaringClass().getSimpleName() + \".\" + rank.name();\n}",
        "summary_tokens": [
            "for",
            "the",
            "given",
            "enum",
            "value",
            "rank",
            "returns",
            "the",
            "value",
            "s",
            "enum",
            "class"
        ]
    },
    {
        "id": 1869,
        "code": "private void aboutToAcquire(CycleDetectingLock lock) {\n  if (!lock.isAcquiredByCurrentThread()) {\n    ArrayList<LockGraphNode> acquiredLockList = acquiredLocks.get();\n    LockGraphNode node = lock.getLockGraphNode();\n    node.checkAcquiredLocks(policy, acquiredLockList);\n    acquiredLockList.add(node);\n  }\n}",
        "summary_tokens": [
            "cycle",
            "detecting",
            "lock",
            "implementations",
            "must",
            "call",
            "this",
            "method",
            "before",
            "attempting",
            "to",
            "acquire",
            "the",
            "lock"
        ]
    },
    {
        "id": 1870,
        "code": "private static void lockStateChanged(CycleDetectingLock lock) {\n  if (!lock.isAcquiredByCurrentThread()) {\n    ArrayList<LockGraphNode> acquiredLockList = acquiredLocks.get();\n    LockGraphNode node = lock.getLockGraphNode();\n      \n      \n    for (int i = acquiredLockList.size() - 1; i >= 0; i--) {\n      if (acquiredLockList.get(i) == node) {\n        acquiredLockList.remove(i);\n        break;\n      }\n    }\n  }\n}",
        "summary_tokens": [
            "cycle",
            "detecting",
            "lock",
            "implementations",
            "must",
            "call",
            "this",
            "method",
            "in",
            "a",
            "finally",
            "clause",
            "after",
            "any",
            "attempt",
            "to",
            "change",
            "the",
            "lock",
            "state",
            "including",
            "both",
            "lock",
            "and",
            "unlock",
            "attempts"
        ]
    },
    {
        "id": 1871,
        "code": "public void add(Runnable runnable, Executor executor) {\n    \n    \n  checkNotNull(runnable, \"Runnable was null.\");\n  checkNotNull(executor, \"Executor was null.\");\n\n    \n    \n    \n  synchronized (this) {\n    if (!executed) {\n      runnables = new RunnableExecutorPair(runnable, executor, runnables);\n      return;\n    }\n  }\n    \n    \n    \n    \n  executeListener(runnable, executor);\n}",
        "summary_tokens": [
            "adds",
            "the",
            "runnable",
            "and",
            "accompanying",
            "executor",
            "to",
            "the",
            "list",
            "of",
            "listeners",
            "to",
            "execute"
        ]
    },
    {
        "id": 1872,
        "code": "public void execute() {\n    \n    \n  RunnableExecutorPair list;\n  synchronized (this) {\n    if (executed) {\n      return;\n    }\n    executed = true;\n    list = runnables;\n    runnables = null; \n  }\n    \n    \n    \n    \n    \n    \n\n    \n    \n  RunnableExecutorPair reversedList = null;\n  while (list != null) {\n    RunnableExecutorPair tmp = list;\n    list = list.next;\n    tmp.next = reversedList;\n    reversedList = tmp;\n  }\n  while (reversedList != null) {\n    executeListener(reversedList.runnable, reversedList.executor);\n    reversedList = reversedList.next;\n  }\n}",
        "summary_tokens": [
            "runs",
            "this",
            "execution",
            "list",
            "executing",
            "all",
            "existing",
            "pairs",
            "in",
            "the",
            "order",
            "they",
            "were",
            "added"
        ]
    },
    {
        "id": 1873,
        "code": "private static void executeListener(Runnable runnable, Executor executor) {\n  try {\n    executor.execute(runnable);\n  } catch (RuntimeException e) {\n      \n      \n      \n    log.log(\n        Level.SEVERE,\n        \"RuntimeException while executing runnable \" + runnable + \" with executor \" + executor,\n        e);\n  }\n}",
        "summary_tokens": [
            "submits",
            "the",
            "given",
            "runnable",
            "to",
            "the",
            "given",
            "executor",
            "catching",
            "and",
            "logging",
            "all",
            "runtime",
            "exception",
            "runtime",
            "exceptions",
            "thrown",
            "by",
            "the",
            "executor"
        ]
    },
    {
        "id": 1874,
        "code": "public void addListener(L listener, Executor executor) {\n  checkNotNull(listener, \"listener\");\n  checkNotNull(executor, \"executor\");\n  listeners.add(new PerListenerQueue<>(listener, executor));\n}",
        "summary_tokens": [
            "adds",
            "a",
            "listener",
            "that",
            "will",
            "be",
            "called",
            "using",
            "the",
            "given",
            "executor",
            "when",
            "events",
            "are",
            "later",
            "enqueue",
            "enqueued",
            "and",
            "dispatch",
            "dispatched"
        ]
    },
    {
        "id": 1875,
        "code": "public void enqueue(Event<L> event, String label) {\n  enqueueHelper(event, label);\n}",
        "summary_tokens": [
            "enqueues",
            "an",
            "event",
            "to",
            "be",
            "run",
            "on",
            "currently",
            "known",
            "listeners",
            "with",
            "a",
            "label"
        ]
    },
    {
        "id": 1876,
        "code": "public void dispatch() {\n    \n  for (int i = 0; i < listeners.size(); i++) {\n    listeners.get(i).dispatch();\n  }\n}",
        "summary_tokens": [
            "dispatches",
            "all",
            "events",
            "enqueued",
            "prior",
            "to",
            "this",
            "call",
            "serially",
            "and",
            "in",
            "order",
            "for",
            "every",
            "listener"
        ]
    },
    {
        "id": 1877,
        "code": "public boolean tryEnter() {\n  return lock.tryLock();\n}",
        "summary_tokens": [
            "enters",
            "this",
            "monitor",
            "if",
            "it",
            "is",
            "possible",
            "to",
            "do",
            "so",
            "immediately"
        ]
    },
    {
        "id": 1878,
        "code": "public boolean enterWhen(Guard guard, long time, TimeUnit unit) throws InterruptedException {\n  final long timeoutNanos = toSafeNanos(time, unit);\n  if (guard.monitor != this) {\n    throw new IllegalMonitorStateException();\n  }\n  final ReentrantLock lock = this.lock;\n  boolean reentrant = lock.isHeldByCurrentThread();\n  long startTime = 0L;\n\n  locked:\n  {\n    if (!fair) {\n        \n      if (Thread.interrupted()) {\n        throw new InterruptedException();\n      }\n      if (lock.tryLock()) {\n        break locked;\n      }\n    }\n    startTime = initNanoTime(timeoutNanos);\n    if (!lock.tryLock(time, unit)) {\n      return false;\n    }\n  }\n\n  boolean satisfied = false;\n  boolean threw = true;\n  try {\n    satisfied =\n        guard.isSatisfied()\n            || awaitNanos(\n                guard,\n                (startTime == 0L) ? timeoutNanos : remainingNanos(startTime, timeoutNanos),\n                reentrant);\n    threw = false;\n    return satisfied;\n  } finally {\n    if (!satisfied) {\n      try {\n          \n        if (threw && !reentrant) {\n          signalNextWaiter();\n        }\n      } finally {\n        lock.unlock();\n      }\n    }\n  }\n}",
        "summary_tokens": [
            "enters",
            "this",
            "monitor",
            "when",
            "the",
            "guard",
            "is",
            "satisfied"
        ]
    },
    {
        "id": 1879,
        "code": "public boolean enterWhenUninterruptibly(Guard guard, long time, TimeUnit unit) {\n  final long timeoutNanos = toSafeNanos(time, unit);\n  if (guard.monitor != this) {\n    throw new IllegalMonitorStateException();\n  }\n  final ReentrantLock lock = this.lock;\n  long startTime = 0L;\n  boolean signalBeforeWaiting = lock.isHeldByCurrentThread();\n  boolean interrupted = Thread.interrupted();\n  try {\n    if (fair || !lock.tryLock()) {\n      startTime = initNanoTime(timeoutNanos);\n      for (long remainingNanos = timeoutNanos; ; ) {\n        try {\n          if (lock.tryLock(remainingNanos, TimeUnit.NANOSECONDS)) {\n            break;\n          } else {\n            return false;\n          }\n        } catch (InterruptedException interrupt) {\n          interrupted = true;\n          remainingNanos = remainingNanos(startTime, timeoutNanos);\n        }\n      }\n    }\n\n    boolean satisfied = false;\n    try {\n      while (true) {\n        try {\n          if (guard.isSatisfied()) {\n            satisfied = true;\n          } else {\n            final long remainingNanos;\n            if (startTime == 0L) {\n              startTime = initNanoTime(timeoutNanos);\n              remainingNanos = timeoutNanos;\n            } else {\n              remainingNanos = remainingNanos(startTime, timeoutNanos);\n            }\n            satisfied = awaitNanos(guard, remainingNanos, signalBeforeWaiting);\n          }\n          return satisfied;\n        } catch (InterruptedException interrupt) {\n          interrupted = true;\n          signalBeforeWaiting = false;\n        }\n      }\n    } finally {\n      if (!satisfied) {\n        lock.unlock(); \n      }\n    }\n  } finally {\n    if (interrupted) {\n      Thread.currentThread().interrupt();\n    }\n  }\n}",
        "summary_tokens": [
            "enters",
            "this",
            "monitor",
            "when",
            "the",
            "guard",
            "is",
            "satisfied"
        ]
    },
    {
        "id": 1880,
        "code": "public boolean enterIf(Guard guard, long time, TimeUnit unit) {\n  if (guard.monitor != this) {\n    throw new IllegalMonitorStateException();\n  }\n  if (!enter(time, unit)) {\n    return false;\n  }\n\n  boolean satisfied = false;\n  try {\n    return satisfied = guard.isSatisfied();\n  } finally {\n    if (!satisfied) {\n      lock.unlock();\n    }\n  }\n}",
        "summary_tokens": [
            "enters",
            "this",
            "monitor",
            "if",
            "the",
            "guard",
            "is",
            "satisfied"
        ]
    },
    {
        "id": 1881,
        "code": "public boolean enterIfInterruptibly(Guard guard, long time, TimeUnit unit)\n    throws InterruptedException {\n  if (guard.monitor != this) {\n    throw new IllegalMonitorStateException();\n  }\n  final ReentrantLock lock = this.lock;\n  if (!lock.tryLock(time, unit)) {\n    return false;\n  }\n\n  boolean satisfied = false;\n  try {\n    return satisfied = guard.isSatisfied();\n  } finally {\n    if (!satisfied) {\n      lock.unlock();\n    }\n  }\n}",
        "summary_tokens": [
            "enters",
            "this",
            "monitor",
            "if",
            "the",
            "guard",
            "is",
            "satisfied"
        ]
    },
    {
        "id": 1882,
        "code": "public boolean tryEnterIf(Guard guard) {\n  if (guard.monitor != this) {\n    throw new IllegalMonitorStateException();\n  }\n  final ReentrantLock lock = this.lock;\n  if (!lock.tryLock()) {\n    return false;\n  }\n\n  boolean satisfied = false;\n  try {\n    return satisfied = guard.isSatisfied();\n  } finally {\n    if (!satisfied) {\n      lock.unlock();\n    }\n  }\n}",
        "summary_tokens": [
            "enters",
            "this",
            "monitor",
            "if",
            "it",
            "is",
            "possible",
            "to",
            "do",
            "so",
            "immediately",
            "and",
            "the",
            "guard",
            "is",
            "satisfied"
        ]
    },
    {
        "id": 1883,
        "code": "public boolean waitFor(Guard guard, long time, TimeUnit unit) throws InterruptedException {\n  final long timeoutNanos = toSafeNanos(time, unit);\n  if (!((guard.monitor == this) && lock.isHeldByCurrentThread())) {\n    throw new IllegalMonitorStateException();\n  }\n  if (guard.isSatisfied()) {\n    return true;\n  }\n  if (Thread.interrupted()) {\n    throw new InterruptedException();\n  }\n  return awaitNanos(guard, timeoutNanos, true);\n}",
        "summary_tokens": [
            "waits",
            "for",
            "the",
            "guard",
            "to",
            "be",
            "satisfied"
        ]
    },
    {
        "id": 1884,
        "code": "public boolean waitForUninterruptibly(Guard guard, long time, TimeUnit unit) {\n  final long timeoutNanos = toSafeNanos(time, unit);\n  if (!((guard.monitor == this) && lock.isHeldByCurrentThread())) {\n    throw new IllegalMonitorStateException();\n  }\n  if (guard.isSatisfied()) {\n    return true;\n  }\n  boolean signalBeforeWaiting = true;\n  final long startTime = initNanoTime(timeoutNanos);\n  boolean interrupted = Thread.interrupted();\n  try {\n    for (long remainingNanos = timeoutNanos; ; ) {\n      try {\n        return awaitNanos(guard, remainingNanos, signalBeforeWaiting);\n      } catch (InterruptedException interrupt) {\n        interrupted = true;\n        if (guard.isSatisfied()) {\n          return true;\n        }\n        signalBeforeWaiting = false;\n        remainingNanos = remainingNanos(startTime, timeoutNanos);\n      }\n    }\n  } finally {\n    if (interrupted) {\n      Thread.currentThread().interrupt();\n    }\n  }\n}",
        "summary_tokens": [
            "waits",
            "for",
            "the",
            "guard",
            "to",
            "be",
            "satisfied"
        ]
    },
    {
        "id": 1885,
        "code": "public boolean isFair() {\n  return fair;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "this",
            "monitor",
            "is",
            "using",
            "a",
            "fair",
            "ordering",
            "policy"
        ]
    },
    {
        "id": 1886,
        "code": "public boolean isOccupied() {\n  return lock.isLocked();\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "this",
            "monitor",
            "is",
            "occupied",
            "by",
            "any",
            "thread"
        ]
    },
    {
        "id": 1887,
        "code": "public boolean isOccupiedByCurrentThread() {\n  return lock.isHeldByCurrentThread();\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "current",
            "thread",
            "is",
            "occupying",
            "this",
            "monitor",
            "has",
            "entered",
            "more",
            "times",
            "than",
            "it",
            "has",
            "left"
        ]
    },
    {
        "id": 1888,
        "code": "public int getOccupiedDepth() {\n  return lock.getHoldCount();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "times",
            "the",
            "current",
            "thread",
            "has",
            "entered",
            "this",
            "monitor",
            "in",
            "excess",
            "of",
            "the",
            "number",
            "of",
            "times",
            "it",
            "has",
            "left"
        ]
    },
    {
        "id": 1889,
        "code": "public int getQueueLength() {\n  return lock.getQueueLength();\n}",
        "summary_tokens": [
            "returns",
            "an",
            "estimate",
            "of",
            "the",
            "number",
            "of",
            "threads",
            "waiting",
            "to",
            "enter",
            "this",
            "monitor"
        ]
    },
    {
        "id": 1890,
        "code": "public boolean hasQueuedThreads() {\n  return lock.hasQueuedThreads();\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "any",
            "threads",
            "are",
            "waiting",
            "to",
            "enter",
            "this",
            "monitor"
        ]
    },
    {
        "id": 1891,
        "code": "public boolean hasQueuedThread(Thread thread) {\n  return lock.hasQueuedThread(thread);\n}",
        "summary_tokens": [
            "queries",
            "whether",
            "the",
            "given",
            "thread",
            "is",
            "waiting",
            "to",
            "enter",
            "this",
            "monitor"
        ]
    },
    {
        "id": 1892,
        "code": "public boolean hasWaiters(Guard guard) {\n  return getWaitQueueLength(guard) > 0;\n}",
        "summary_tokens": [
            "queries",
            "whether",
            "any",
            "threads",
            "are",
            "waiting",
            "for",
            "the",
            "given",
            "guard",
            "to",
            "become",
            "satisfied"
        ]
    },
    {
        "id": 1893,
        "code": "public int getWaitQueueLength(Guard guard) {\n  if (guard.monitor != this) {\n    throw new IllegalMonitorStateException();\n  }\n  lock.lock();\n  try {\n    return guard.waiterCount;\n  } finally {\n    lock.unlock();\n  }\n}",
        "summary_tokens": [
            "returns",
            "an",
            "estimate",
            "of",
            "the",
            "number",
            "of",
            "threads",
            "waiting",
            "for",
            "the",
            "given",
            "guard",
            "to",
            "become",
            "satisfied"
        ]
    },
    {
        "id": 1894,
        "code": "private static long remainingNanos(long startTime, long timeoutNanos) {\n    \n\n    \n    \n    \n    \n\n  return (timeoutNanos <= 0L) ? 0L : timeoutNanos - (System.nanoTime() - startTime);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "remaining",
            "nanos",
            "until",
            "the",
            "given",
            "timeout",
            "or",
            "0",
            "l",
            "if",
            "the",
            "timeout",
            "has",
            "already",
            "elapsed"
        ]
    },
    {
        "id": 1895,
        "code": "private void signalNextWaiter() {\n  for (Guard guard = activeGuards; guard != null; guard = guard.next) {\n    if (isSatisfied(guard)) {\n      guard.condition.signal();\n      break;\n    }\n  }\n}",
        "summary_tokens": [
            "signals",
            "some",
            "other",
            "thread",
            "waiting",
            "on",
            "a",
            "satisfied",
            "guard",
            "if",
            "one",
            "exists"
        ]
    },
    {
        "id": 1896,
        "code": "private void signalAllWaiters() {\n  for (Guard guard = activeGuards; guard != null; guard = guard.next) {\n    guard.condition.signalAll();\n  }\n}",
        "summary_tokens": [
            "signals",
            "all",
            "threads",
            "waiting",
            "on",
            "guards"
        ]
    },
    {
        "id": 1897,
        "code": "private void beginWaitingFor(Guard guard) {\n  int waiters = guard.waiterCount++;\n  if (waiters == 0) {\n      \n    guard.next = activeGuards;\n    activeGuards = guard;\n  }\n}",
        "summary_tokens": [
            "records",
            "that",
            "the",
            "current",
            "thread",
            "is",
            "about",
            "to",
            "wait",
            "on",
            "the",
            "specified",
            "guard"
        ]
    },
    {
        "id": 1898,
        "code": "private void endWaitingFor(Guard guard) {\n  int waiters = --guard.waiterCount;\n  if (waiters == 0) {\n      \n    for (Guard p = activeGuards, pred = null; ; pred = p, p = p.next) {\n      if (p == guard) {\n        if (pred == null) {\n          activeGuards = p.next;\n        } else {\n          pred.next = p.next;\n        }\n        p.next = null; \n        break;\n      }\n    }\n  }\n}",
        "summary_tokens": [
            "records",
            "that",
            "the",
            "current",
            "thread",
            "is",
            "no",
            "longer",
            "waiting",
            "on",
            "the",
            "specified",
            "guard"
        ]
    },
    {
        "id": 1899,
        "code": "private boolean awaitNanos(Guard guard, long nanos, boolean signalBeforeWaiting)\n    throws InterruptedException {\n  boolean firstTime = true;\n  try {\n    do {\n      if (nanos <= 0L) {\n        return false;\n      }\n      if (firstTime) {\n        if (signalBeforeWaiting) {\n          signalNextWaiter();\n        }\n        beginWaitingFor(guard);\n        firstTime = false;\n      }\n      nanos = guard.condition.awaitNanos(nanos);\n    } while (!guard.isSatisfied());\n    return true;\n  } finally {\n    if (!firstTime) {\n      endWaitingFor(guard);\n    }\n  }\n}",
        "summary_tokens": [
            "caller",
            "should",
            "check",
            "before",
            "calling",
            "that",
            "guard",
            "is",
            "not",
            "satisfied"
        ]
    },
    {
        "id": 1900,
        "code": "public static RateLimiter create(double permitsPerSecond, long warmupPeriod, TimeUnit unit) {\n  checkArgument(warmupPeriod >= 0, \"warmupPeriod must not be negative: %s\", warmupPeriod);\n  return create(\n      permitsPerSecond, warmupPeriod, unit, 3.0, SleepingStopwatch.createFromSystemTimer());\n}",
        "summary_tokens": [
            "creates",
            "a",
            "rate",
            "limiter",
            "with",
            "the",
            "specified",
            "stable",
            "throughput",
            "given",
            "as",
            "permits",
            "per",
            "second",
            "commonly",
            "referred",
            "to",
            "as",
            "i",
            "qps",
            "i",
            "queries",
            "per",
            "second",
            "and",
            "a",
            "i",
            "warmup",
            "period",
            "i",
            "during",
            "which",
            "the",
            "rate",
            "limiter",
            "smoothly",
            "ramps",
            "up",
            "its",
            "rate",
            "until",
            "it",
            "reaches",
            "its",
            "maximum",
            "rate",
            "at",
            "the",
            "end",
            "of",
            "the",
            "period",
            "as",
            "long",
            "as",
            "there",
            "are",
            "enough",
            "requests",
            "to",
            "saturate",
            "it"
        ]
    },
    {
        "id": 1901,
        "code": "public final void setRate(double permitsPerSecond) {\n  checkArgument(\n      permitsPerSecond > 0.0 && !Double.isNaN(permitsPerSecond), \"rate must be positive\");\n  synchronized (mutex()) {\n    doSetRate(permitsPerSecond, stopwatch.readMicros());\n  }\n}",
        "summary_tokens": [
            "updates",
            "the",
            "stable",
            "rate",
            "of",
            "this",
            "rate",
            "limiter",
            "that",
            "is",
            "the",
            "permits",
            "per",
            "second",
            "argument",
            "provided",
            "in",
            "the",
            "factory",
            "method",
            "that",
            "constructed",
            "the",
            "rate",
            "limiter"
        ]
    },
    {
        "id": 1902,
        "code": "public final double getRate() {\n  synchronized (mutex()) {\n    return doGetRate();\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "stable",
            "rate",
            "as",
            "permits",
            "per",
            "seconds",
            "with",
            "which",
            "this",
            "rate",
            "limiter",
            "is",
            "configured",
            "with"
        ]
    },
    {
        "id": 1903,
        "code": "public double acquire(int permits) {\n  long microsToWait = reserve(permits);\n  stopwatch.sleepMicrosUninterruptibly(microsToWait);\n  return 1.0 * microsToWait / SECONDS.toMicros(1L);\n}",
        "summary_tokens": [
            "acquires",
            "the",
            "given",
            "number",
            "of",
            "permits",
            "from",
            "this",
            "rate",
            "limiter",
            "blocking",
            "until",
            "the",
            "request",
            "can",
            "be",
            "granted"
        ]
    },
    {
        "id": 1904,
        "code": "final long reserve(int permits) {\n  checkPermits(permits);\n  synchronized (mutex()) {\n    return reserveAndGetWaitLength(permits, stopwatch.readMicros());\n  }\n}",
        "summary_tokens": [
            "reserves",
            "the",
            "given",
            "number",
            "of",
            "permits",
            "from",
            "this",
            "rate",
            "limiter",
            "for",
            "future",
            "use",
            "returning",
            "the",
            "number",
            "of",
            "microseconds",
            "until",
            "the",
            "reservation",
            "can",
            "be",
            "consumed"
        ]
    },
    {
        "id": 1905,
        "code": "public boolean tryAcquire(int permits, long timeout, TimeUnit unit) {\n  long timeoutMicros = max(unit.toMicros(timeout), 0);\n  checkPermits(permits);\n  long microsToWait;\n  synchronized (mutex()) {\n    long nowMicros = stopwatch.readMicros();\n    if (!canAcquire(nowMicros, timeoutMicros)) {\n      return false;\n    } else {\n      microsToWait = reserveAndGetWaitLength(permits, nowMicros);\n    }\n  }\n  stopwatch.sleepMicrosUninterruptibly(microsToWait);\n  return true;\n}",
        "summary_tokens": [
            "acquires",
            "the",
            "given",
            "number",
            "of",
            "permits",
            "from",
            "this",
            "rate",
            "limiter",
            "if",
            "it",
            "can",
            "be",
            "obtained",
            "without",
            "exceeding",
            "the",
            "specified",
            "timeout",
            "or",
            "returns",
            "false",
            "immediately",
            "without",
            "waiting",
            "if",
            "the",
            "permits",
            "would",
            "not",
            "have",
            "been",
            "granted",
            "before",
            "the",
            "timeout",
            "expired"
        ]
    },
    {
        "id": 1906,
        "code": "final long reserveAndGetWaitLength(int permits, long nowMicros) {\n  long momentAvailable = reserveEarliestAvailable(permits, nowMicros);\n  return max(momentAvailable - nowMicros, 0);\n}",
        "summary_tokens": [
            "reserves",
            "next",
            "ticket",
            "and",
            "returns",
            "the",
            "wait",
            "time",
            "that",
            "the",
            "caller",
            "must",
            "wait",
            "for"
        ]
    },
    {
        "id": 1907,
        "code": "public static Runnable doNothing() {\n  return EMPTY_RUNNABLE;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "runnable",
            "instance",
            "that",
            "does",
            "nothing",
            "when",
            "run"
        ]
    },
    {
        "id": 1908,
        "code": "public void execute(Runnable task) {\n  checkNotNull(task);\n  Runnable submittedTask;\n  long oldRunCount;\n  synchronized (queue) {\n      \n      \n    if (workerRunningState == RUNNING || workerRunningState == QUEUED) {\n      queue.add(task);\n      return;\n    }\n\n    oldRunCount = workerRunCount;\n\n      \n      \n      \n      \n      \n      \n    submittedTask =\n        new Runnable() {\n          @Override\n          public void run() {\n            task.run();\n          }\n\n          @Override\n          public String toString() {\n            return task.toString();\n          }\n        };\n    queue.add(submittedTask);\n    workerRunningState = QUEUING;\n  }\n\n  try {\n    executor.execute(worker);\n  } catch (RuntimeException | Error t) {\n    synchronized (queue) {\n      boolean removed =\n          (workerRunningState == IDLE || workerRunningState == QUEUING)\n              && queue.removeLastOccurrence(submittedTask);\n        \n        \n      if (!(t instanceof RejectedExecutionException) || removed) {\n        throw t;\n      }\n    }\n    return;\n  }\n\n    \n  @SuppressWarnings(\"GuardedBy\")\n  boolean alreadyMarkedQueued = workerRunningState != QUEUING;\n  if (alreadyMarkedQueued) {\n    return;\n  }\n  synchronized (queue) {\n    if (workerRunCount == oldRunCount && workerRunningState == QUEUING) {\n      workerRunningState = QUEUED;\n    }\n  }\n}",
        "summary_tokens": [
            "adds",
            "a",
            "task",
            "to",
            "the",
            "queue",
            "and",
            "makes",
            "sure",
            "a",
            "worker",
            "thread",
            "is",
            "running"
        ]
    },
    {
        "id": 1909,
        "code": "public void addListener(Listener listener, Executor executor) {\n  state.addListener(listener, executor);\n}",
        "summary_tokens": [
            "registers",
            "a",
            "listener",
            "to",
            "be",
            "executor",
            "execute",
            "executed",
            "on",
            "the",
            "given",
            "executor"
        ]
    },
    {
        "id": 1910,
        "code": "public ServiceManager startAsync() {\n  for (Service service : services) {\n    checkState(service.state() == NEW, \"Not all services are NEW, cannot start %s\", this);\n  }\n  for (Service service : services) {\n    try {\n      state.tryStartTiming(service);\n      service.startAsync();\n    } catch (IllegalStateException e) {\n        \n        \n        \n        \n      logger.log(Level.WARNING, \"Unable to start Service \" + service, e);\n    }\n  }\n  return this;\n}",
        "summary_tokens": [
            "initiates",
            "service",
            "service",
            "start",
            "async",
            "startup",
            "on",
            "all",
            "the",
            "services",
            "being",
            "managed"
        ]
    },
    {
        "id": 1911,
        "code": "public void awaitHealthy(long timeout, TimeUnit unit) throws TimeoutException {\n  state.awaitHealthy(timeout, unit);\n}",
        "summary_tokens": [
            "waits",
            "for",
            "the",
            "service",
            "manager",
            "to",
            "become",
            "is",
            "healthy",
            "healthy",
            "for",
            "no",
            "more",
            "than",
            "the",
            "given",
            "time"
        ]
    },
    {
        "id": 1912,
        "code": "public ServiceManager stopAsync() {\n  for (Service service : services) {\n    service.stopAsync();\n  }\n  return this;\n}",
        "summary_tokens": [
            "initiates",
            "service",
            "service",
            "stop",
            "async",
            "shutdown",
            "if",
            "necessary",
            "on",
            "all",
            "the",
            "services",
            "being",
            "managed"
        ]
    },
    {
        "id": 1913,
        "code": "public void awaitStopped(long timeout, TimeUnit unit) throws TimeoutException {\n  state.awaitStopped(timeout, unit);\n}",
        "summary_tokens": [
            "waits",
            "for",
            "the",
            "all",
            "the",
            "services",
            "to",
            "reach",
            "a",
            "terminal",
            "state",
            "for",
            "no",
            "more",
            "than",
            "the",
            "given",
            "time"
        ]
    },
    {
        "id": 1914,
        "code": "public boolean isHealthy() {\n  for (Service service : services) {\n    if (!service.isRunning()) {\n      return false;\n    }\n  }\n  return true;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "all",
            "services",
            "are",
            "currently",
            "in",
            "the",
            "state",
            "running",
            "running",
            "state"
        ]
    },
    {
        "id": 1915,
        "code": "public ImmutableSetMultimap<State, Service> servicesByState() {\n  return state.servicesByState();\n}",
        "summary_tokens": [
            "provides",
            "a",
            "snapshot",
            "of",
            "the",
            "current",
            "state",
            "of",
            "all",
            "the",
            "services",
            "under",
            "management"
        ]
    },
    {
        "id": 1916,
        "code": "public ImmutableMap<Service, Long> startupTimes() {\n  return state.startupTimes();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "service",
            "load",
            "times"
        ]
    },
    {
        "id": 1917,
        "code": "void resync(long nowMicros) {\n    \n  if (nowMicros > nextFreeTicketMicros) {\n    double newPermits = (nowMicros - nextFreeTicketMicros) / coolDownIntervalMicros();\n    storedPermits = min(maxPermits, storedPermits + newPermits);\n    nextFreeTicketMicros = nowMicros;\n  }\n}",
        "summary_tokens": [
            "updates",
            "stored",
            "permits",
            "and",
            "next",
            "free",
            "ticket",
            "micros",
            "based",
            "on",
            "the",
            "current",
            "time"
        ]
    },
    {
        "id": 1918,
        "code": "public ThreadFactoryBuilder setNameFormat(String nameFormat) {\n  String unused = format(nameFormat, 0); \n  this.nameFormat = nameFormat;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "naming",
            "format",
            "to",
            "use",
            "when",
            "naming",
            "threads",
            "thread",
            "set",
            "name",
            "which",
            "are",
            "created",
            "with",
            "this",
            "thread",
            "factory"
        ]
    },
    {
        "id": 1919,
        "code": "public ThreadFactoryBuilder setDaemon(boolean daemon) {\n  this.daemon = daemon;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "daemon",
            "or",
            "not",
            "for",
            "new",
            "threads",
            "created",
            "with",
            "this",
            "thread",
            "factory"
        ]
    },
    {
        "id": 1920,
        "code": "public ThreadFactoryBuilder setPriority(int priority) {\n    \n    \n  checkArgument(\n      priority >= Thread.MIN_PRIORITY,\n      \"Thread priority (%s) must be >= %s\",\n      priority,\n      Thread.MIN_PRIORITY);\n  checkArgument(\n      priority <= Thread.MAX_PRIORITY,\n      \"Thread priority (%s) must be <= %s\",\n      priority,\n      Thread.MAX_PRIORITY);\n  this.priority = priority;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "priority",
            "for",
            "new",
            "threads",
            "created",
            "with",
            "this",
            "thread",
            "factory"
        ]
    },
    {
        "id": 1921,
        "code": "public ThreadFactoryBuilder setUncaughtExceptionHandler(\n    UncaughtExceptionHandler uncaughtExceptionHandler) {\n  this.uncaughtExceptionHandler = checkNotNull(uncaughtExceptionHandler);\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "uncaught",
            "exception",
            "handler",
            "for",
            "new",
            "threads",
            "created",
            "with",
            "this",
            "thread",
            "factory"
        ]
    },
    {
        "id": 1922,
        "code": "public ThreadFactoryBuilder setThreadFactory(ThreadFactory backingThreadFactory) {\n  this.backingThreadFactory = checkNotNull(backingThreadFactory);\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "backing",
            "thread",
            "factory",
            "for",
            "new",
            "threads",
            "created",
            "with",
            "this",
            "thread",
            "factory"
        ]
    },
    {
        "id": 1923,
        "code": "public ThreadFactory build() {\n  return doBuild(this);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "thread",
            "factory",
            "using",
            "the",
            "options",
            "supplied",
            "during",
            "the",
            "building",
            "process"
        ]
    },
    {
        "id": 1924,
        "code": "public static UncaughtExceptionHandler systemExit() {\n  return new Exiter(Runtime.getRuntime());\n}",
        "summary_tokens": [
            "returns",
            "an",
            "exception",
            "handler",
            "that",
            "exits",
            "the",
            "system"
        ]
    },
    {
        "id": 1925,
        "code": "public static Escaper xmlContentEscaper() {\n  return XML_CONTENT_ESCAPER;\n}",
        "summary_tokens": [
            "returns",
            "an",
            "escaper",
            "instance",
            "that",
            "escapes",
            "special",
            "characters",
            "in",
            "a",
            "string",
            "so",
            "it",
            "can",
            "safely",
            "be",
            "included",
            "in",
            "an",
            "xml",
            "document",
            "as",
            "element",
            "content"
        ]
    },
    {
        "id": 1926,
        "code": "public static Escaper xmlAttributeEscaper() {\n  return XML_ATTRIBUTE_ESCAPER;\n}",
        "summary_tokens": [
            "returns",
            "an",
            "escaper",
            "instance",
            "that",
            "escapes",
            "special",
            "characters",
            "in",
            "a",
            "string",
            "so",
            "it",
            "can",
            "safely",
            "be",
            "included",
            "in",
            "xml",
            "document",
            "as",
            "an",
            "attribute",
            "value"
        ]
    },
    {
        "id": 1927,
        "code": "static ImmutableMap<String, PublicSuffixType> parseTrie(CharSequence encoded) {\n  ImmutableMap.Builder<String, PublicSuffixType> builder = ImmutableMap.builder();\n  int encodedLen = encoded.length();\n  int idx = 0;\n  while (idx < encodedLen) {\n    idx += doParseTrieToBuilder(Queues.<CharSequence>newArrayDeque(), encoded, idx, builder);\n  }\n  return builder.build();\n}",
        "summary_tokens": [
            "parses",
            "a",
            "serialized",
            "trie",
            "representation",
            "of",
            "a",
            "map",
            "of",
            "reversed",
            "public",
            "suffixes",
            "into",
            "an",
            "immutable",
            "map",
            "of",
            "public",
            "suffixes"
        ]
    },
    {
        "id": 1928,
        "code": "private static int doParseTrieToBuilder(\n    Deque<CharSequence> stack,\n    CharSequence encoded,\n    int start,\n    ImmutableMap.Builder<String, PublicSuffixType> builder) {\n\n  int encodedLen = encoded.length();\n  int idx = start;\n  char c = '\\0';\n\n    \n  for (; idx < encodedLen; idx++) {\n    c = encoded.charAt(idx);\n    if (c == '&' || c == '?' || c == '!' || c == ':' || c == ',') {\n      break;\n    }\n  }\n\n  stack.push(reverse(encoded.subSequence(start, idx)));\n\n  if (c == '!' || c == '?' || c == ':' || c == ',') {\n      \n      \n      \n      \n    String domain = PREFIX_JOINER.join(stack);\n    if (domain.length() > 0) {\n      builder.put(domain, PublicSuffixType.fromCode(c));\n    }\n  }\n  idx++;\n\n  if (c != '?' && c != ',') {\n    while (idx < encodedLen) {\n        \n      idx += doParseTrieToBuilder(stack, encoded, idx, builder);\n      if (encoded.charAt(idx) == '?' || encoded.charAt(idx) == ',') {\n          \n        idx++;\n        break;\n      }\n    }\n  }\n  stack.pop();\n  return idx - start;\n}",
        "summary_tokens": [
            "parses",
            "a",
            "trie",
            "node",
            "and",
            "returns",
            "the",
            "number",
            "of",
            "characters",
            "consumed"
        ]
    },
    {
        "id": 1929,
        "code": "public static Throwable tryInternalFastPathGetFailure(InternalFutureFailureAccess future) {\n  return future.tryInternalFastPathGetFailure();\n}",
        "summary_tokens": [
            "usually",
            "returns",
            "null",
            "but",
            "if",
            "the",
            "given",
            "future",
            "has",
            "failed",
            "may",
            "i",
            "optionally",
            "i",
            "return",
            "the",
            "cause",
            "of",
            "the",
            "failure"
        ]
    },
    {
        "id": 1930,
        "code": "protected Entry<E> standardFirstEntry() {\n  Iterator<Entry<E>> entryIterator = entrySet().iterator();\n  if (!entryIterator.hasNext()) {\n    return null;\n  }\n  Entry<E> entry = entryIterator.next();\n  return Multisets.immutableEntry(entry.getElement(), entry.getCount());\n}",
        "summary_tokens": [
            "a",
            "sensible",
            "definition",
            "of",
            "first",
            "entry",
            "in",
            "terms",
            "of",
            "entry",
            "set"
        ]
    },
    {
        "id": 1931,
        "code": "protected Entry<E> standardLastEntry() {\n  Iterator<Entry<E>> entryIterator = descendingMultiset().entrySet().iterator();\n  if (!entryIterator.hasNext()) {\n    return null;\n  }\n  Entry<E> entry = entryIterator.next();\n  return Multisets.immutableEntry(entry.getElement(), entry.getCount());\n}",
        "summary_tokens": [
            "a",
            "sensible",
            "definition",
            "of",
            "last",
            "entry",
            "in",
            "terms",
            "of",
            "descending",
            "multiset"
        ]
    },
    {
        "id": 1932,
        "code": "protected Entry<E> standardPollFirstEntry() {\n  Iterator<Entry<E>> entryIterator = entrySet().iterator();\n  if (!entryIterator.hasNext()) {\n    return null;\n  }\n  Entry<E> entry = entryIterator.next();\n  entry = Multisets.immutableEntry(entry.getElement(), entry.getCount());\n  entryIterator.remove();\n  return entry;\n}",
        "summary_tokens": [
            "a",
            "sensible",
            "definition",
            "of",
            "poll",
            "first",
            "entry",
            "in",
            "terms",
            "of",
            "entry",
            "set"
        ]
    },
    {
        "id": 1933,
        "code": "protected Entry<E> standardPollLastEntry() {\n  Iterator<Entry<E>> entryIterator = descendingMultiset().entrySet().iterator();\n  if (!entryIterator.hasNext()) {\n    return null;\n  }\n  Entry<E> entry = entryIterator.next();\n  entry = Multisets.immutableEntry(entry.getElement(), entry.getCount());\n  entryIterator.remove();\n  return entry;\n}",
        "summary_tokens": [
            "a",
            "sensible",
            "definition",
            "of",
            "poll",
            "last",
            "entry",
            "in",
            "terms",
            "of",
            "descending",
            "multiset"
        ]
    },
    {
        "id": 1934,
        "code": "protected SortedMultiset<E> standardSubMultiset(\n    E lowerBound, BoundType lowerBoundType, E upperBound, BoundType upperBoundType) {\n  return tailMultiset(lowerBound, lowerBoundType).headMultiset(upperBound, upperBoundType);\n}",
        "summary_tokens": [
            "a",
            "sensible",
            "definition",
            "of",
            "sub",
            "multiset",
            "object",
            "bound",
            "type",
            "object",
            "bound",
            "type",
            "in",
            "terms",
            "of",
            "head",
            "multiset",
            "object",
            "bound",
            "type",
            "head",
            "multiset",
            "and",
            "tail",
            "multiset",
            "object",
            "bound",
            "type",
            "tail",
            "multiset"
        ]
    },
    {
        "id": 1935,
        "code": "static <K, V> Map<K, V> preservesInsertionOrderOnPutsMap() {\n  return Maps.newLinkedHashMap();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "platform",
            "preferred",
            "map",
            "implementation",
            "that",
            "preserves",
            "insertion",
            "order",
            "when",
            "used",
            "only",
            "for",
            "insertions"
        ]
    },
    {
        "id": 1936,
        "code": "static <E> Set<E> preservesInsertionOrderOnAddsSet() {\n  return Sets.newLinkedHashSet();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "platform",
            "preferred",
            "set",
            "implementation",
            "that",
            "preserves",
            "insertion",
            "order",
            "when",
            "used",
            "only",
            "for",
            "insertions"
        ]
    },
    {
        "id": 1937,
        "code": "String pendingToString() {\n  if (state == State.DELEGATED) {\n    return \"setFuture=[\" + delegate + \"]\";\n  }\n  return null;\n}",
        "summary_tokens": [
            "provide",
            "a",
            "human",
            "readable",
            "explanation",
            "of",
            "why",
            "this",
            "future",
            "has",
            "not",
            "yet",
            "completed"
        ]
    },
    {
        "id": 1938,
        "code": "default <R> IThenable<R> then(\n    @JsOptional ThenOnFulfilledCallbackFn<? super V, ? extends R> onFulfilled,\n    @JsOptional ThenOnRejectedCallbackFn<? extends R> onRejected) {\n  return new Promise<V>(\n          (resolve, reject) -> {\n            Futures.addCallback(\n                this,\n                new FutureCallback<V>() {\n                  @Override\n                  public void onSuccess(V value) {\n                    resolve.onInvoke(value);\n                  }\n\n                  @Override\n                  public void onFailure(Throwable throwable) {\n                    reject.onInvoke(throwable.getBackingJsObject());\n                  }\n                },\n                MoreExecutors.directExecutor());\n          })\n      .then(\n          (IThenable.ThenOnFulfilledCallbackFn) onFulfilled,\n          (IThenable.ThenOnRejectedCallbackFn) onRejected);\n}",
        "summary_tokens": [
            "note",
            "that",
            "this",
            "method",
            "is",
            "not",
            "expected",
            "to",
            "be",
            "overridden"
        ]
    },
    {
        "id": 1939,
        "code": "public Test testsForSynchronizedNavigableMap() {\n  return NavigableMapTestSuiteBuilder.using(\n          new TestStringSortedMapGenerator() {\n            @Override\n            protected SortedMap<String, String> create(Entry<String, String>[] entries) {\n              NavigableMap<String, String> delegate = populate(new TreeMap<>(), entries);\n              return Collections.synchronizedNavigableMap(delegate);\n            }\n          })\n      .named(\"synchronizedNavigableMap/TreeMap, natural\")\n      .withFeatures(\n          MapFeature.GENERAL_PURPOSE,\n          MapFeature.ALLOWS_NULL_VALUES,\n          MapFeature.FAILS_FAST_ON_CONCURRENT_MODIFICATION,\n          CollectionFeature.SUPPORTS_ITERATOR_REMOVE,\n          CollectionFeature.KNOWN_ORDER,\n          CollectionFeature.SERIALIZABLE,\n          CollectionSize.ANY)\n      .suppressing(suppressForSynchronizedNavigableMap())\n      .createTestSuite();\n}",
        "summary_tokens": [
            "tests",
            "regular",
            "navigable",
            "map",
            "behavior",
            "of",
            "synchronized",
            "navigable",
            "map",
            "tree",
            "map",
            "does",
            "not",
            "test",
            "the",
            "fact",
            "that",
            "it",
            "s",
            "synchronized"
        ]
    },
    {
        "id": 1940,
        "code": "public Test testsForSynchronizedNavigableSet() {\n  return NavigableSetTestSuiteBuilder.using(\n          new TestStringSortedSetGenerator() {\n            @Override\n            public SortedSet<String> create(String[] elements) {\n              NavigableSet<String> delegate = new TreeSet<>(MinimalCollection.of(elements));\n              return Collections.synchronizedNavigableSet(delegate);\n            }\n          })\n      .named(\"synchronizedNavigableSet/TreeSet, natural\")\n      .withFeatures(\n          SetFeature.GENERAL_PURPOSE,\n          CollectionFeature.SERIALIZABLE,\n          CollectionFeature.KNOWN_ORDER,\n          CollectionFeature.FAILS_FAST_ON_CONCURRENT_MODIFICATION,\n          CollectionSize.ANY)\n      .suppressing(suppressForSynchronizedNavigableSet())\n      .createTestSuite();\n}",
        "summary_tokens": [
            "tests",
            "regular",
            "navigable",
            "set",
            "behavior",
            "of",
            "synchronized",
            "navigable",
            "set",
            "tree",
            "set",
            "does",
            "not",
            "test",
            "the",
            "fact",
            "that",
            "it",
            "s",
            "synchronized"
        ]
    },
    {
        "id": 1941,
        "code": "public static List<Method> getForEachEntryDuplicateInitializingMethods() {\n  return Arrays.asList(\n      Helpers.getMethod(MultisetForEachEntryTester.class, \"testForEachEntryDuplicates\"));\n}",
        "summary_tokens": [
            "returns",
            "method",
            "instances",
            "for",
            "the",
            "remove",
            "tests",
            "that",
            "assume",
            "multisets",
            "support",
            "duplicates",
            "so",
            "that",
            "the",
            "test",
            "of",
            "multisets"
        ]
    },
    {
        "id": 1942,
        "code": "public static Method getMergeNullValueMethod() {\n  return Helpers.getMethod(MapMergeTester.class, \"testMergeNullValue\");\n}",
        "summary_tokens": [
            "returns",
            "the",
            "method",
            "instance",
            "for",
            "test",
            "merge",
            "null",
            "value",
            "so",
            "that",
            "tests",
            "of",
            "hashtable",
            "can",
            "suppress",
            "it",
            "with",
            "feature",
            "specific",
            "test",
            "suite",
            "builder"
        ]
    },
    {
        "id": 1943,
        "code": "public static <T, A, R> CollectorTester<T, A, R> of(\n    Collector<T, A, R> collector, BiPredicate<? super R, ? super R> equivalence) {\n  return new CollectorTester<>(collector, equivalence);\n}",
        "summary_tokens": [
            "creates",
            "a",
            "collector",
            "tester",
            "for",
            "the",
            "specified",
            "collector"
        ]
    },
    {
        "id": 1944,
        "code": "public final CollectorTester<T, A, R> expectCollects(@Nullable R expectedResult, T... inputs) {\n  List<T> list = Arrays.asList(inputs);\n  doExpectCollects(expectedResult, list);\n  if (collector.characteristics().contains(Collector.Characteristics.UNORDERED)) {\n    Collections.reverse(list);\n    doExpectCollects(expectedResult, list);\n  }\n  return this;\n}",
        "summary_tokens": [
            "verifies",
            "that",
            "the",
            "specified",
            "expected",
            "result",
            "is",
            "always",
            "produced",
            "by",
            "collecting",
            "the",
            "specified",
            "inputs",
            "regardless",
            "of",
            "how",
            "the",
            "elements",
            "are",
            "divided"
        ]
    },
    {
        "id": 1945,
        "code": "static List<CountsHashCodeAndEquals> createAdversarialInput(int power, CallsCounter counter) {\n  String str1 = \"Aa\";\n  String str2 = \"BB\";\n  assertEquals(str1.hashCode(), str2.hashCode());\n  List<String> haveSameHashes2 = Arrays.asList(str1, str2);\n  List<CountsHashCodeAndEquals> result =\n      Lists.newArrayList(\n          Lists.transform(\n              Lists.cartesianProduct(Collections.nCopies(power, haveSameHashes2)),\n              strs ->\n                  new CountsHashCodeAndEquals(\n                      String.join(\"\", strs),\n                      () -> counter.hashCode++,\n                      () -> counter.equals++,\n                      () -> counter.compareTo++)));\n  assertEquals(\n      result.get(0).delegateString.hashCode(),\n      result.get(result.size() - 1).delegateString.hashCode());\n  return result;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "list",
            "of",
            "objects",
            "with",
            "the",
            "same",
            "hash",
            "code",
            "of",
            "size",
            "0",
            "power",
            "counting",
            "calls",
            "to",
            "equals",
            "hash",
            "code",
            "and",
            "compare",
            "to",
            "in",
            "counter"
        ]
    },
    {
        "id": 1946,
        "code": "static FileSystem newTestFileSystem(Feature... supportedFeatures) throws IOException {\n  FileSystem fs =\n      Jimfs.newFileSystem(\n          Configuration.unix()\n              .toBuilder()\n              .setSupportedFeatures(ObjectArrays.concat(SYMBOLIC_LINKS, supportedFeatures))\n              .build());\n  Files.createDirectories(fs.getPath(\"dir/b/i/j/l\"));\n  Files.createFile(fs.getPath(\"dir/a\"));\n  Files.createFile(fs.getPath(\"dir/c\"));\n  Files.createSymbolicLink(fs.getPath(\"dir/d\"), fs.getPath(\"b/i\"));\n  Files.createDirectory(fs.getPath(\"dir/e\"));\n  Files.createSymbolicLink(fs.getPath(\"dir/f\"), fs.getPath(\"/dontdelete\"));\n  Files.createFile(fs.getPath(\"dir/b/g\"));\n  Files.createSymbolicLink(fs.getPath(\"dir/b/h\"), fs.getPath(\"../a\"));\n  Files.createFile(fs.getPath(\"dir/b/i/j/k\"));\n  Files.createDirectory(fs.getPath(\"/dontdelete\"));\n  Files.createFile(fs.getPath(\"/dontdelete/a\"));\n  Files.createDirectory(fs.getPath(\"/dontdelete/b\"));\n  Files.createFile(fs.getPath(\"/dontdelete/c\"));\n  Files.createSymbolicLink(fs.getPath(\"/symlinktodir\"), fs.getPath(\"work/dir\"));\n  return fs;\n}",
        "summary_tokens": [
            "creates",
            "a",
            "new",
            "file",
            "system",
            "for",
            "testing",
            "that",
            "supports",
            "the",
            "given",
            "features",
            "in",
            "addition",
            "to",
            "supporting",
            "symbolic",
            "links"
        ]
    },
    {
        "id": 1947,
        "code": "public void testDirectoryDeletion_directorySymlinkRace() throws IOException {\n  for (DirectoryDeleteMethod method : EnumSet.allOf(DirectoryDeleteMethod.class)) {\n    try (FileSystem fs = newTestFileSystem(SECURE_DIRECTORY_STREAM)) {\n      Path dirToDelete = fs.getPath(\"dir/b/i\");\n      Path changingFile = dirToDelete.resolve(\"j/l\");\n      Path symlinkTarget = fs.getPath(\"/dontdelete\");\n\n      ExecutorService executor = Executors.newSingleThreadExecutor();\n      startDirectorySymlinkSwitching(changingFile, symlinkTarget, executor);\n\n      try {\n        for (int i = 0; i < 5000; i++) {\n          try {\n            Files.createDirectories(changingFile);\n            Files.createFile(dirToDelete.resolve(\"j/k\"));\n          } catch (FileAlreadyExistsException expected) {\n              \n          }\n\n          try {\n            method.delete(dirToDelete);\n          } catch (FileSystemException expected) {\n              \n              \n          }\n\n            \n            \n          assertEquals(3, MoreFiles.listFiles(symlinkTarget).size());\n\n          Thread.yield();\n        }\n      } finally {\n        executor.shutdownNow();\n      }\n    }\n  }\n}",
        "summary_tokens": [
            "this",
            "test",
            "attempts",
            "to",
            "create",
            "a",
            "situation",
            "in",
            "which",
            "one",
            "thread",
            "is",
            "constantly",
            "changing",
            "a",
            "file",
            "from",
            "being",
            "a",
            "real",
            "directory",
            "to",
            "being",
            "a",
            "symlink",
            "to",
            "another",
            "directory"
        ]
    },
    {
        "id": 1948,
        "code": "private static void startDirectorySymlinkSwitching(\n    final Path file, final Path target, ExecutorService executor) {\n  @SuppressWarnings(\"unused\") \n  Future<?> possiblyIgnoredError =\n      executor.submit(\n          new Runnable() {\n            @Override\n            public void run() {\n              boolean createSymlink = false;\n              while (!Thread.interrupted()) {\n                try {\n                    \n                  if (Files.deleteIfExists(file)) {\n                    if (createSymlink) {\n                      Files.createSymbolicLink(file, target);\n                    } else {\n                      Files.createDirectory(file);\n                    }\n                    createSymlink = !createSymlink;\n                  }\n                } catch (IOException tolerated) {\n                    \n                }\n\n                Thread.yield();\n              }\n            }\n          });\n}",
        "summary_tokens": [
            "starts",
            "a",
            "new",
            "task",
            "on",
            "the",
            "given",
            "executor",
            "that",
            "switches",
            "deletes",
            "and",
            "replaces",
            "a",
            "file",
            "between",
            "being",
            "a",
            "directory",
            "and",
            "being",
            "a",
            "symlink"
        ]
    },
    {
        "id": 1949,
        "code": "static DoubleStream megaPrimitiveDoubleStream() {\n  return DoubleStream.iterate(0.0, x -> x + 1.0).limit(MEGA_STREAM_COUNT).parallel();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "stream",
            "of",
            "a",
            "million",
            "primitive",
            "doubles"
        ]
    },
    {
        "id": 1950,
        "code": "static DoubleStream megaPrimitiveDoubleStreamPart1() {\n  return DoubleStream.iterate(0.0, x -> x + 2.0).limit(MEGA_STREAM_COUNT / 2).parallel();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "stream",
            "containing",
            "half",
            "the",
            "values",
            "from",
            "mega",
            "primitive",
            "double",
            "stream"
        ]
    },
    {
        "id": 1951,
        "code": "static DoubleStream megaPrimitiveDoubleStreamPart2() {\n  return DoubleStream.iterate(999_999.0, x -> x - 2.0).limit(MEGA_STREAM_COUNT / 2).parallel();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "stream",
            "containing",
            "the",
            "values",
            "from",
            "mega",
            "primitive",
            "double",
            "stream",
            "not",
            "in",
            "mega",
            "primitive",
            "double",
            "stream",
            "part",
            "0"
        ]
    },
    {
        "id": 1952,
        "code": "public void testGetAndAccumulateWithSum() {\n  AtomicDoubleArray aa = new AtomicDoubleArray(SIZE);\n  for (int i : new int[] {0, SIZE - 1}) {\n    for (double x : VALUES) {\n      for (double y : VALUES) {\n        aa.set(i, x);\n        double z = aa.getAndAccumulate(i, y, Double::sum);\n        assertBitEquals(x, z);\n        assertBitEquals(x + y, aa.get(i));\n      }\n    }\n  }\n}",
        "summary_tokens": [
            "get",
            "and",
            "accumulate",
            "with",
            "sum",
            "adds",
            "given",
            "value",
            "to",
            "current",
            "and",
            "returns",
            "previous",
            "value"
        ]
    },
    {
        "id": 1953,
        "code": "public void testGetAndAccumulateWithMax() {\n  AtomicDoubleArray aa = new AtomicDoubleArray(SIZE);\n  for (int i : new int[] {0, SIZE - 1}) {\n    for (double x : VALUES) {\n      for (double y : VALUES) {\n        aa.set(i, x);\n        double z = aa.getAndAccumulate(i, y, Double::max);\n        double expectedMax = max(x, y);\n        assertBitEquals(x, z);\n        assertBitEquals(expectedMax, aa.get(i));\n      }\n    }\n  }\n}",
        "summary_tokens": [
            "get",
            "and",
            "accumulate",
            "with",
            "max",
            "stores",
            "max",
            "of",
            "given",
            "value",
            "to",
            "current",
            "and",
            "returns",
            "previous",
            "value"
        ]
    },
    {
        "id": 1954,
        "code": "public void testAccumulateAndGetWithSum() {\n  AtomicDoubleArray aa = new AtomicDoubleArray(SIZE);\n  for (int i : new int[] {0, SIZE - 1}) {\n    for (double x : VALUES) {\n      for (double y : VALUES) {\n        aa.set(i, x);\n        double z = aa.accumulateAndGet(i, y, Double::sum);\n        assertBitEquals(x + y, z);\n        assertBitEquals(x + y, aa.get(i));\n      }\n    }\n  }\n}",
        "summary_tokens": [
            "accumulate",
            "and",
            "get",
            "with",
            "sum",
            "adds",
            "given",
            "value",
            "to",
            "current",
            "and",
            "returns",
            "current",
            "value"
        ]
    },
    {
        "id": 1955,
        "code": "public void testAccumulateAndGetWithMax() {\n  AtomicDoubleArray aa = new AtomicDoubleArray(SIZE);\n  for (int i : new int[] {0, SIZE - 1}) {\n    for (double x : VALUES) {\n      for (double y : VALUES) {\n        aa.set(i, x);\n        double z = aa.accumulateAndGet(i, y, Double::max);\n        double expectedMax = max(x, y);\n        assertBitEquals(expectedMax, z);\n        assertBitEquals(expectedMax, aa.get(i));\n      }\n    }\n  }\n}",
        "summary_tokens": [
            "accumulate",
            "and",
            "get",
            "with",
            "max",
            "stores",
            "max",
            "of",
            "given",
            "value",
            "to",
            "current",
            "and",
            "returns",
            "current",
            "value"
        ]
    },
    {
        "id": 1956,
        "code": "public void testGetAndUpdateWithSum() {\n  AtomicDoubleArray aa = new AtomicDoubleArray(SIZE);\n  for (int i : new int[] {0, SIZE - 1}) {\n    for (double x : VALUES) {\n      for (double y : VALUES) {\n        aa.set(i, x);\n        double z = aa.getAndUpdate(i, value -> value + y);\n        assertBitEquals(x, z);\n        assertBitEquals(x + y, aa.get(i));\n      }\n    }\n  }\n}",
        "summary_tokens": [
            "get",
            "and",
            "update",
            "adds",
            "given",
            "value",
            "to",
            "current",
            "and",
            "returns",
            "previous",
            "value"
        ]
    },
    {
        "id": 1957,
        "code": "public void testGetAndUpdateWithSubtract() {\n  AtomicDoubleArray aa = new AtomicDoubleArray(SIZE);\n  for (int i : new int[] {0, SIZE - 1}) {\n    for (double x : VALUES) {\n      for (double y : VALUES) {\n        aa.set(i, x);\n        double z = aa.getAndUpdate(i, value -> value - y);\n        assertBitEquals(x, z);\n        assertBitEquals(x - y, aa.get(i));\n      }\n    }\n  }\n}",
        "summary_tokens": [
            "get",
            "and",
            "update",
            "subtracts",
            "given",
            "value",
            "to",
            "current",
            "and",
            "returns",
            "previous",
            "value"
        ]
    },
    {
        "id": 1958,
        "code": "public void testUpdateAndGetWithSum() {\n  AtomicDoubleArray aa = new AtomicDoubleArray(SIZE);\n  for (int i : new int[] {0, SIZE - 1}) {\n    for (double x : VALUES) {\n      for (double y : VALUES) {\n        aa.set(i, x);\n        double z = aa.updateAndGet(i, value -> value + y);\n        assertBitEquals(x + y, z);\n        assertBitEquals(x + y, aa.get(i));\n      }\n    }\n  }\n}",
        "summary_tokens": [
            "update",
            "and",
            "get",
            "adds",
            "given",
            "value",
            "to",
            "current",
            "and",
            "returns",
            "current",
            "value"
        ]
    },
    {
        "id": 1959,
        "code": "public void testUpdateAndGetWithSubtract() {\n  AtomicDoubleArray aa = new AtomicDoubleArray(SIZE);\n  for (int i : new int[] {0, SIZE - 1}) {\n    for (double x : VALUES) {\n      for (double y : VALUES) {\n        aa.set(i, x);\n        double z = aa.updateAndGet(i, value -> value - y);\n        assertBitEquals(x - y, z);\n        assertBitEquals(x - y, aa.get(i));\n      }\n    }\n  }\n}",
        "summary_tokens": [
            "update",
            "and",
            "get",
            "subtracts",
            "given",
            "value",
            "to",
            "current",
            "and",
            "returns",
            "current",
            "value"
        ]
    },
    {
        "id": 1960,
        "code": "public void testGetAndAccumulateWithSum() {\n  for (double x : VALUES) {\n    for (double y : VALUES) {\n      AtomicDouble a = new AtomicDouble(x);\n      double z = a.getAndAccumulate(y, Double::sum);\n      assertBitEquals(x, z);\n      assertBitEquals(x + y, a.get());\n    }\n  }\n}",
        "summary_tokens": [
            "get",
            "and",
            "accumulate",
            "with",
            "sum",
            "adds",
            "given",
            "value",
            "to",
            "current",
            "and",
            "returns",
            "previous",
            "value"
        ]
    },
    {
        "id": 1961,
        "code": "public void testGetAndAccumulateWithMax() {\n  for (double x : VALUES) {\n    for (double y : VALUES) {\n      AtomicDouble a = new AtomicDouble(x);\n      double z = a.getAndAccumulate(y, Double::max);\n      double expectedMax = max(x, y);\n      assertBitEquals(x, z);\n      assertBitEquals(expectedMax, a.get());\n    }\n  }\n}",
        "summary_tokens": [
            "get",
            "and",
            "accumulate",
            "with",
            "max",
            "stores",
            "max",
            "of",
            "given",
            "value",
            "to",
            "current",
            "and",
            "returns",
            "previous",
            "value"
        ]
    },
    {
        "id": 1962,
        "code": "public void testAccumulateAndGetWithSum() {\n  for (double x : VALUES) {\n    for (double y : VALUES) {\n      AtomicDouble a = new AtomicDouble(x);\n      double z = a.accumulateAndGet(y, Double::sum);\n      assertBitEquals(x + y, z);\n      assertBitEquals(x + y, a.get());\n    }\n  }\n}",
        "summary_tokens": [
            "accumulate",
            "and",
            "get",
            "with",
            "sum",
            "adds",
            "given",
            "value",
            "to",
            "current",
            "and",
            "returns",
            "current",
            "value"
        ]
    },
    {
        "id": 1963,
        "code": "public void testAccumulateAndGetWithMax() {\n  for (double x : VALUES) {\n    for (double y : VALUES) {\n      AtomicDouble a = new AtomicDouble(x);\n      double z = a.accumulateAndGet(y, Double::max);\n      double expectedMax = max(x, y);\n      assertBitEquals(expectedMax, z);\n      assertBitEquals(expectedMax, a.get());\n    }\n  }\n}",
        "summary_tokens": [
            "accumulate",
            "and",
            "get",
            "with",
            "max",
            "stores",
            "max",
            "of",
            "given",
            "value",
            "to",
            "current",
            "and",
            "returns",
            "current",
            "value"
        ]
    },
    {
        "id": 1964,
        "code": "public void testGetAndUpdateWithSum() {\n  for (double x : VALUES) {\n    for (double y : VALUES) {\n      AtomicDouble a = new AtomicDouble(x);\n      double z = a.getAndUpdate(value -> value + y);\n      assertBitEquals(x, z);\n      assertBitEquals(x + y, a.get());\n    }\n  }\n}",
        "summary_tokens": [
            "get",
            "and",
            "update",
            "with",
            "sum",
            "stores",
            "sum",
            "of",
            "given",
            "value",
            "to",
            "current",
            "and",
            "returns",
            "previous",
            "value"
        ]
    },
    {
        "id": 1965,
        "code": "public void testGetAndUpdateWithSubtract() {\n  for (double x : VALUES) {\n    for (double y : VALUES) {\n      AtomicDouble a = new AtomicDouble(x);\n      double z = a.getAndUpdate(value -> value - y);\n      assertBitEquals(x, z);\n      assertBitEquals(x - y, a.get());\n    }\n  }\n}",
        "summary_tokens": [
            "get",
            "and",
            "update",
            "with",
            "subtract",
            "stores",
            "subtraction",
            "of",
            "value",
            "from",
            "current",
            "and",
            "returns",
            "previous",
            "value"
        ]
    },
    {
        "id": 1966,
        "code": "public void testUpdateAndGetWithSum() {\n  for (double x : VALUES) {\n    for (double y : VALUES) {\n      AtomicDouble a = new AtomicDouble(x);\n      double z = a.updateAndGet(value -> value + y);\n      assertBitEquals(x + y, z);\n      assertBitEquals(x + y, a.get());\n    }\n  }\n}",
        "summary_tokens": [
            "update",
            "and",
            "get",
            "with",
            "sum",
            "stores",
            "sum",
            "of",
            "given",
            "value",
            "to",
            "current",
            "and",
            "returns",
            "current",
            "value"
        ]
    },
    {
        "id": 1967,
        "code": "public void testUpdateAndGetWithSubtract() {\n  for (double x : VALUES) {\n    for (double y : VALUES) {\n      AtomicDouble a = new AtomicDouble(x);\n      double z = a.updateAndGet(value -> value - y);\n      assertBitEquals(x - y, z);\n      assertBitEquals(x - y, a.get());\n    }\n  }\n}",
        "summary_tokens": [
            "update",
            "and",
            "get",
            "with",
            "subtract",
            "stores",
            "subtraction",
            "of",
            "value",
            "from",
            "current",
            "and",
            "returns",
            "current",
            "value"
        ]
    },
    {
        "id": 1968,
        "code": "private static boolean isLongTimeUnitBased(Method method) {\n  Class<?>[] parameterTypes = method.getParameterTypes();\n  return parameterTypes.length >= 2\n      && parameterTypes[parameterTypes.length - 2] == long.class\n      && parameterTypes[parameterTypes.length - 1] == TimeUnit.class;\n}",
        "summary_tokens": [
            "determines",
            "whether",
            "the",
            "given",
            "method",
            "takes",
            "a",
            "time",
            "and",
            "unit",
            "as",
            "its",
            "last",
            "two",
            "parameters"
        ]
    },
    {
        "id": 1969,
        "code": "private static boolean isDurationBased(Method method) {\n  Class<?>[] parameterTypes = method.getParameterTypes();\n  return parameterTypes.length >= 1\n      && parameterTypes[parameterTypes.length - 1] == Duration.class;\n}",
        "summary_tokens": [
            "determines",
            "whether",
            "the",
            "given",
            "method",
            "takes",
            "a",
            "duration",
            "as",
            "its",
            "last",
            "parameter"
        ]
    },
    {
        "id": 1970,
        "code": "public static <T> Optional<T> fromJavaUtil(@CheckForNull java.util.Optional<T> javaUtilOptional) {\n  return (javaUtilOptional == null) ? null : fromNullable(javaUtilOptional.orElse(null));\n}",
        "summary_tokens": [
            "returns",
            "the",
            "equivalent",
            "com"
        ]
    },
    {
        "id": 1971,
        "code": "public java.util.Optional<T> toJavaUtil() {\n  return java.util.Optional.ofNullable(orNull());\n}",
        "summary_tokens": [
            "returns",
            "the",
            "equivalent",
            "java"
        ]
    },
    {
        "id": 1972,
        "code": "public Stream<String> splitToStream(CharSequence sequence) {\n    \n  return StreamSupport.stream(split(sequence).spliterator(), false);\n}",
        "summary_tokens": [
            "splits",
            "sequence",
            "into",
            "string",
            "components",
            "and",
            "makes",
            "them",
            "available",
            "through",
            "an",
            "stream",
            "which",
            "may",
            "be",
            "lazily",
            "evaluated"
        ]
    },
    {
        "id": 1973,
        "code": "private static long toNanosSaturated(java.time.Duration duration) {\n    \n    \n  try {\n    return duration.toNanos();\n  } catch (ArithmeticException tooBig) {\n    return duration.isNegative() ? Long.MIN_VALUE : Long.MAX_VALUE;\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "nanoseconds",
            "of",
            "the",
            "given",
            "duration",
            "without",
            "throwing",
            "or",
            "overflowing"
        ]
    },
    {
        "id": 1974,
        "code": "static <K, V> ImmutableMapEntry<K, V>[] createEntryArray(int size) {\n  return new ImmutableMapEntry[size];\n}",
        "summary_tokens": [
            "creates",
            "an",
            "immutable",
            "map",
            "entry",
            "array",
            "to",
            "hold",
            "parameterized",
            "entries"
        ]
    },
    {
        "id": 1975,
        "code": "boolean isReusable() {\n  return true;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "this",
            "entry",
            "has",
            "no",
            "bucket",
            "links",
            "and",
            "can",
            "safely",
            "be",
            "reused",
            "as",
            "a",
            "terminal",
            "entry",
            "in",
            "a",
            "bucket",
            "in",
            "another",
            "map"
        ]
    },
    {
        "id": 1976,
        "code": "public static <E extends Comparable<? super E>>\n    Collector<Range<E>, ?, ImmutableRangeSet<E>> toImmutableRangeSet() {\n  return CollectCollectors.toImmutableRangeSet();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "collector",
            "that",
            "accumulates",
            "the",
            "input",
            "elements",
            "into",
            "a",
            "new",
            "immutable",
            "range",
            "set"
        ]
    },
    {
        "id": 1977,
        "code": "default boolean enclosesAll(Iterable<Range<C>> other) {\n  for (Range<C> range : other) {\n    if (!encloses(range)) {\n      return false;\n    }\n  }\n  return true;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "for",
            "each",
            "range",
            "in",
            "other",
            "there",
            "exists",
            "a",
            "member",
            "range",
            "in",
            "this",
            "range",
            "set",
            "which",
            "range",
            "encloses",
            "encloses",
            "it"
        ]
    },
    {
        "id": 1978,
        "code": "default void addAll(Iterable<Range<C>> ranges) {\n  for (Range<C> range : ranges) {\n    add(range);\n  }\n}",
        "summary_tokens": [
            "adds",
            "all",
            "of",
            "the",
            "specified",
            "ranges",
            "to",
            "this",
            "range",
            "set",
            "optional",
            "operation"
        ]
    },
    {
        "id": 1979,
        "code": "default void removeAll(Iterable<Range<C>> ranges) {\n  for (Range<C> range : ranges) {\n    remove(range);\n  }\n}",
        "summary_tokens": [
            "removes",
            "all",
            "of",
            "the",
            "specified",
            "ranges",
            "from",
            "this",
            "range",
            "set",
            "optional",
            "operation"
        ]
    },
    {
        "id": 1980,
        "code": "private static void checkNoConflictInValueBucket(\n    Object value, Entry<?, ?> entry, @CheckForNull ImmutableMapEntry<?, ?> valueBucketHead)\n    throws BucketOverflowException {\n  int bucketSize = 0;\n  for (; valueBucketHead != null; valueBucketHead = valueBucketHead.getNextInValueBucket()) {\n    checkNoConflict(!value.equals(valueBucketHead.getValue()), \"value\", entry, valueBucketHead);\n    if (++bucketSize > MAX_HASH_BUCKET_LENGTH) {\n      throw new BucketOverflowException();\n    }\n  }\n}",
        "summary_tokens": [
            "illegal",
            "argument",
            "exception",
            "if",
            "another",
            "entry",
            "in",
            "the",
            "bucket",
            "has",
            "the",
            "same",
            "key",
            "bucket",
            "overflow",
            "exception",
            "if",
            "this",
            "bucket",
            "has",
            "too",
            "many",
            "entries",
            "which",
            "may",
            "indicate",
            "a",
            "hash",
            "flooding",
            "attack"
        ]
    },
    {
        "id": 1981,
        "code": "public static ByteSource asByteSource(Path path, OpenOption... options) {\n  return new PathByteSource(path, options);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "view",
            "of",
            "the",
            "given",
            "path",
            "as",
            "a",
            "byte",
            "source"
        ]
    },
    {
        "id": 1982,
        "code": "public static ByteSink asByteSink(Path path, OpenOption... options) {\n  return new PathByteSink(path, options);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "view",
            "of",
            "the",
            "given",
            "path",
            "as",
            "a",
            "byte",
            "sink"
        ]
    },
    {
        "id": 1983,
        "code": "public static CharSource asCharSource(Path path, Charset charset, OpenOption... options) {\n  return asByteSource(path, options).asCharSource(charset);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "view",
            "of",
            "the",
            "given",
            "path",
            "as",
            "a",
            "char",
            "source",
            "using",
            "the",
            "given",
            "charset"
        ]
    },
    {
        "id": 1984,
        "code": "public static CharSink asCharSink(Path path, Charset charset, OpenOption... options) {\n  return asByteSink(path, options).asCharSink(charset);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "view",
            "of",
            "the",
            "given",
            "path",
            "as",
            "a",
            "char",
            "sink",
            "using",
            "the",
            "given",
            "charset"
        ]
    },
    {
        "id": 1985,
        "code": "public static ImmutableList<Path> listFiles(Path dir) throws IOException {\n  try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir)) {\n    return ImmutableList.copyOf(stream);\n  } catch (DirectoryIteratorException e) {\n    throw e.getCause();\n  }\n}",
        "summary_tokens": [
            "returns",
            "an",
            "immutable",
            "list",
            "of",
            "paths",
            "to",
            "the",
            "files",
            "contained",
            "in",
            "the",
            "given",
            "directory"
        ]
    },
    {
        "id": 1986,
        "code": "public static Traverser<Path> fileTraverser() {\n  return Traverser.forTree(FILE_TREE);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "traverser",
            "instance",
            "for",
            "the",
            "file",
            "and",
            "directory",
            "tree"
        ]
    },
    {
        "id": 1987,
        "code": "private static boolean isDirectory(\n    SecureDirectoryStream<Path> dir, Path name, LinkOption... options) throws IOException {\n  return dir.getFileAttributeView(name, BasicFileAttributeView.class, options)\n      .readAttributes()\n      .isDirectory();\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "or",
            "not",
            "the",
            "file",
            "with",
            "the",
            "given",
            "name",
            "in",
            "the",
            "given",
            "dir",
            "is",
            "a",
            "directory"
        ]
    },
    {
        "id": 1988,
        "code": "public static Predicate<Path> isRegularFile(LinkOption... options) {\n  final LinkOption[] optionsCopy = options.clone();\n  return new Predicate<Path>() {\n    @Override\n    public boolean apply(Path input) {\n      return Files.isRegularFile(input, optionsCopy);\n    }\n\n    @Override\n    public String toString() {\n      return \"MoreFiles.isRegularFile(\" + Arrays.toString(optionsCopy) + \")\";\n    }\n  };\n}",
        "summary_tokens": [
            "returns",
            "a",
            "predicate",
            "that",
            "returns",
            "the",
            "result",
            "of",
            "java"
        ]
    },
    {
        "id": 1989,
        "code": "public static boolean equal(Path path1, Path path2) throws IOException {\n  checkNotNull(path1);\n  checkNotNull(path2);\n  if (Files.isSameFile(path1, path2)) {\n    return true;\n  }\n\n    \n  ByteSource source1 = asByteSource(path1);\n  ByteSource source2 = asByteSource(path2);\n  long len1 = source1.sizeIfKnown().or(0L);\n  long len2 = source2.sizeIfKnown().or(0L);\n  if (len1 != 0 && len2 != 0 && len1 != len2) {\n    return false;\n  }\n  return source1.contentEquals(source2);\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "the",
            "files",
            "located",
            "by",
            "the",
            "given",
            "paths",
            "exist",
            "are",
            "not",
            "directories",
            "and",
            "contain",
            "the",
            "same",
            "bytes"
        ]
    },
    {
        "id": 1990,
        "code": "public static void touch(Path path) throws IOException {\n  checkNotNull(path);\n\n  try {\n    Files.setLastModifiedTime(path, FileTime.fromMillis(System.currentTimeMillis()));\n  } catch (NoSuchFileException e) {\n    try {\n      Files.createFile(path);\n    } catch (FileAlreadyExistsException ignore) {\n        \n        \n        \n        \n        \n        \n    }\n  }\n}",
        "summary_tokens": [
            "like",
            "the",
            "unix",
            "command",
            "of",
            "the",
            "same",
            "name",
            "creates",
            "an",
            "empty",
            "file",
            "or",
            "updates",
            "the",
            "last",
            "modified",
            "timestamp",
            "of",
            "the",
            "existing",
            "file",
            "at",
            "the",
            "given",
            "path",
            "to",
            "the",
            "current",
            "system",
            "time"
        ]
    },
    {
        "id": 1991,
        "code": "public static void createParentDirectories(Path path, FileAttribute<?>... attrs)\n    throws IOException {\n    \n    \n    \n    \n  Path normalizedAbsolutePath = path.toAbsolutePath().normalize();\n  Path parent = normalizedAbsolutePath.getParent();\n  if (parent == null) {\n      \n      \n      \n      \n    return;\n  }\n\n    \n    \n    \n    \n  if (!Files.isDirectory(parent)) {\n    Files.createDirectories(parent, attrs);\n    if (!Files.isDirectory(parent)) {\n      throw new IOException(\"Unable to create parent directories of \" + path);\n    }\n  }\n}",
        "summary_tokens": [
            "creates",
            "any",
            "necessary",
            "but",
            "nonexistent",
            "parent",
            "directories",
            "of",
            "the",
            "specified",
            "path"
        ]
    },
    {
        "id": 1992,
        "code": "public static String getFileExtension(Path path) {\n  Path name = path.getFileName();\n\n    \n  if (name == null) {\n    return \"\";\n  }\n\n  String fileName = name.toString();\n  int dotIndex = fileName.lastIndexOf('.');\n  return dotIndex == -1 ? \"\" : fileName.substring(dotIndex + 1);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "a",
            "href",
            "http",
            "en"
        ]
    },
    {
        "id": 1993,
        "code": "public static String getNameWithoutExtension(Path path) {\n  Path name = path.getFileName();\n\n    \n  if (name == null) {\n    return \"\";\n  }\n\n  String fileName = name.toString();\n  int dotIndex = fileName.lastIndexOf('.');\n  return dotIndex == -1 ? fileName : fileName.substring(0, dotIndex);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "file",
            "name",
            "without",
            "its",
            "a",
            "href",
            "http",
            "en"
        ]
    },
    {
        "id": 1994,
        "code": "public static void deleteRecursively(Path path, RecursiveDeleteOption... options)\n    throws IOException {\n  Path parentPath = getParentPath(path);\n  if (parentPath == null) {\n    throw new FileSystemException(path.toString(), null, \"can't delete recursively\");\n  }\n\n  Collection<IOException> exceptions = null; \n  try {\n    boolean sdsSupported = false;\n    try (DirectoryStream<Path> parent = Files.newDirectoryStream(parentPath)) {\n      if (parent instanceof SecureDirectoryStream) {\n        sdsSupported = true;\n        exceptions =\n            deleteRecursivelySecure(\n                (SecureDirectoryStream<Path>) parent,\n                  \n                requireNonNull(path.getFileName()));\n      }\n    }\n\n    if (!sdsSupported) {\n      checkAllowsInsecure(path, options);\n      exceptions = deleteRecursivelyInsecure(path);\n    }\n  } catch (IOException e) {\n    if (exceptions == null) {\n      throw e;\n    } else {\n      exceptions.add(e);\n    }\n  }\n\n  if (exceptions != null) {\n    throwDeleteFailed(path, exceptions);\n  }\n}",
        "summary_tokens": [
            "deletes",
            "the",
            "file",
            "or",
            "directory",
            "at",
            "the",
            "given",
            "path",
            "recursively"
        ]
    },
    {
        "id": 1995,
        "code": "public static void deleteDirectoryContents(Path path, RecursiveDeleteOption... options)\n    throws IOException {\n  Collection<IOException> exceptions = null; \n  try (DirectoryStream<Path> stream = Files.newDirectoryStream(path)) {\n    if (stream instanceof SecureDirectoryStream) {\n      SecureDirectoryStream<Path> sds = (SecureDirectoryStream<Path>) stream;\n      exceptions = deleteDirectoryContentsSecure(sds);\n    } else {\n      checkAllowsInsecure(path, options);\n      exceptions = deleteDirectoryContentsInsecure(stream);\n    }\n  } catch (IOException e) {\n    if (exceptions == null) {\n      throw e;\n    } else {\n      exceptions.add(e);\n    }\n  }\n\n  if (exceptions != null) {\n    throwDeleteFailed(path, exceptions);\n  }\n}",
        "summary_tokens": [
            "deletes",
            "all",
            "files",
            "within",
            "the",
            "directory",
            "at",
            "the",
            "given",
            "path",
            "delete",
            "recursively",
            "recursively"
        ]
    },
    {
        "id": 1996,
        "code": "private static Collection<IOException> deleteRecursivelySecure(\n    SecureDirectoryStream<Path> dir, Path path) {\n  Collection<IOException> exceptions = null;\n  try {\n    if (isDirectory(dir, path, NOFOLLOW_LINKS)) {\n      try (SecureDirectoryStream<Path> childDir = dir.newDirectoryStream(path, NOFOLLOW_LINKS)) {\n        exceptions = deleteDirectoryContentsSecure(childDir);\n      }\n\n        \n        \n      if (exceptions == null) {\n        dir.deleteDirectory(path);\n      }\n    } else {\n      dir.deleteFile(path);\n    }\n\n    return exceptions;\n  } catch (IOException e) {\n    return addException(exceptions, e);\n  }\n}",
        "summary_tokens": [
            "secure",
            "recursive",
            "delete",
            "using",
            "secure",
            "directory",
            "stream"
        ]
    },
    {
        "id": 1997,
        "code": "private static Collection<IOException> deleteDirectoryContentsSecure(\n    SecureDirectoryStream<Path> dir) {\n  Collection<IOException> exceptions = null;\n  try {\n    for (Path path : dir) {\n      exceptions = concat(exceptions, deleteRecursivelySecure(dir, path.getFileName()));\n    }\n\n    return exceptions;\n  } catch (DirectoryIteratorException e) {\n    return addException(exceptions, e.getCause());\n  }\n}",
        "summary_tokens": [
            "secure",
            "method",
            "for",
            "deleting",
            "the",
            "contents",
            "of",
            "a",
            "directory",
            "using",
            "secure",
            "directory",
            "stream"
        ]
    },
    {
        "id": 1998,
        "code": "private static Collection<IOException> deleteRecursivelyInsecure(Path path) {\n  Collection<IOException> exceptions = null;\n  try {\n    if (Files.isDirectory(path, NOFOLLOW_LINKS)) {\n      try (DirectoryStream<Path> stream = Files.newDirectoryStream(path)) {\n        exceptions = deleteDirectoryContentsInsecure(stream);\n      }\n    }\n\n      \n      \n    if (exceptions == null) {\n      Files.delete(path);\n    }\n\n    return exceptions;\n  } catch (IOException e) {\n    return addException(exceptions, e);\n  }\n}",
        "summary_tokens": [
            "insecure",
            "recursive",
            "delete",
            "for",
            "file",
            "systems",
            "that",
            "don",
            "t",
            "support",
            "secure",
            "directory",
            "stream"
        ]
    },
    {
        "id": 1999,
        "code": "private static Collection<IOException> deleteDirectoryContentsInsecure(\n    DirectoryStream<Path> dir) {\n  Collection<IOException> exceptions = null;\n  try {\n    for (Path entry : dir) {\n      exceptions = concat(exceptions, deleteRecursivelyInsecure(entry));\n    }\n\n    return exceptions;\n  } catch (DirectoryIteratorException e) {\n    return addException(exceptions, e.getCause());\n  }\n}",
        "summary_tokens": [
            "simple",
            "insecure",
            "method",
            "for",
            "deleting",
            "the",
            "contents",
            "of",
            "a",
            "directory",
            "for",
            "file",
            "systems",
            "that",
            "don",
            "t",
            "support",
            "secure",
            "directory",
            "stream"
        ]
    },
    {
        "id": 2000,
        "code": "private static Path getParentPath(Path path) {\n  Path parent = path.getParent();\n\n    \n  if (parent != null) {\n      \n      \n      \n      \n      \n    return parent;\n  }\n\n    \n  if (path.getNameCount() == 0) {\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    return null;\n  } else {\n      \n    return path.getFileSystem().getPath(\".\");\n  }\n}",
        "summary_tokens": [
            "returns",
            "a",
            "path",
            "to",
            "the",
            "parent",
            "directory",
            "of",
            "the",
            "given",
            "path"
        ]
    },
    {
        "id": 2001,
        "code": "private static void checkAllowsInsecure(Path path, RecursiveDeleteOption[] options)\n    throws InsecureRecursiveDeleteException {\n  if (!Arrays.asList(options).contains(RecursiveDeleteOption.ALLOW_INSECURE)) {\n    throw new InsecureRecursiveDeleteException(path.toString());\n  }\n}",
        "summary_tokens": [
            "checks",
            "that",
            "the",
            "given",
            "options",
            "allow",
            "an",
            "insecure",
            "delete",
            "throwing",
            "an",
            "exception",
            "if",
            "not"
        ]
    },
    {
        "id": 2002,
        "code": "private static Collection<IOException> addException(\n    @CheckForNull Collection<IOException> exceptions, IOException e) {\n  if (exceptions == null) {\n    exceptions = new ArrayList<>(); \n  }\n  exceptions.add(e);\n  return exceptions;\n}",
        "summary_tokens": [
            "adds",
            "the",
            "given",
            "exception",
            "to",
            "the",
            "given",
            "collection",
            "creating",
            "the",
            "collection",
            "if",
            "it",
            "s",
            "null"
        ]
    },
    {
        "id": 2003,
        "code": "private static Collection<IOException> concat(\n    @CheckForNull Collection<IOException> exceptions,\n    @CheckForNull Collection<IOException> other) {\n  if (exceptions == null) {\n    return other;\n  } else if (other != null) {\n    exceptions.addAll(other);\n  }\n  return exceptions;\n}",
        "summary_tokens": [
            "concatenates",
            "the",
            "contents",
            "of",
            "the",
            "two",
            "given",
            "collections",
            "of",
            "exceptions"
        ]
    },
    {
        "id": 2004,
        "code": "private static void throwDeleteFailed(Path path, Collection<IOException> exceptions)\n    throws FileSystemException {\n  NoSuchFileException pathNotFound = pathNotFound(path, exceptions);\n  if (pathNotFound != null) {\n    throw pathNotFound;\n  }\n    \n    \n    \n  FileSystemException deleteFailed =\n      new FileSystemException(\n          path.toString(),\n          null,\n          \"failed to delete one or more files; see suppressed exceptions for details\");\n  for (IOException e : exceptions) {\n    deleteFailed.addSuppressed(e);\n  }\n  throw deleteFailed;\n}",
        "summary_tokens": [
            "throws",
            "an",
            "exception",
            "indicating",
            "that",
            "one",
            "or",
            "more",
            "files",
            "couldn",
            "t",
            "be",
            "deleted",
            "when",
            "deleting",
            "path",
            "or",
            "its",
            "contents"
        ]
    },
    {
        "id": 2005,
        "code": "public static Collector<Number, StatsAccumulator, Stats> toStats() {\n  return Collector.of(\n      StatsAccumulator::new,\n      (a, x) -> a.add(x.doubleValue()),\n      (l, r) -> {\n        l.addAll(r);\n        return l;\n      },\n      StatsAccumulator::snapshot,\n      Collector.Characteristics.UNORDERED);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "collector",
            "which",
            "accumulates",
            "statistics",
            "from",
            "a",
            "java"
        ]
    },
    {
        "id": 2006,
        "code": "public void forEach(DoubleConsumer consumer) {\n  checkNotNull(consumer);\n  for (int i = start; i < end; i++) {\n    consumer.accept(array[i]);\n  }\n}",
        "summary_tokens": [
            "invokes",
            "consumer",
            "for",
            "each",
            "value",
            "contained",
            "in",
            "this",
            "array",
            "in",
            "order"
        ]
    },
    {
        "id": 2007,
        "code": "public DoubleStream stream() {\n  return Arrays.stream(array, start, end);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "stream",
            "over",
            "the",
            "values",
            "in",
            "this",
            "array",
            "in",
            "order"
        ]
    },
    {
        "id": 2008,
        "code": "public void forEach(IntConsumer consumer) {\n  checkNotNull(consumer);\n  for (int i = start; i < end; i++) {\n    consumer.accept(array[i]);\n  }\n}",
        "summary_tokens": [
            "invokes",
            "consumer",
            "for",
            "each",
            "value",
            "contained",
            "in",
            "this",
            "array",
            "in",
            "order"
        ]
    },
    {
        "id": 2009,
        "code": "public IntStream stream() {\n  return Arrays.stream(array, start, end);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "stream",
            "over",
            "the",
            "values",
            "in",
            "this",
            "array",
            "in",
            "order"
        ]
    },
    {
        "id": 2010,
        "code": "public void forEach(LongConsumer consumer) {\n  checkNotNull(consumer);\n  for (int i = start; i < end; i++) {\n    consumer.accept(array[i]);\n  }\n}",
        "summary_tokens": [
            "invokes",
            "consumer",
            "for",
            "each",
            "value",
            "contained",
            "in",
            "this",
            "array",
            "in",
            "order"
        ]
    },
    {
        "id": 2011,
        "code": "public LongStream stream() {\n  return Arrays.stream(array, start, end);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "stream",
            "over",
            "the",
            "values",
            "in",
            "this",
            "array",
            "in",
            "order"
        ]
    },
    {
        "id": 2012,
        "code": "public final double getAndAccumulate(double x, DoubleBinaryOperator accumulatorFunction) {\n  checkNotNull(accumulatorFunction);\n  return getAndUpdate(oldValue -> accumulatorFunction.applyAsDouble(oldValue, x));\n}",
        "summary_tokens": [
            "atomically",
            "updates",
            "the",
            "current",
            "value",
            "with",
            "the",
            "results",
            "of",
            "applying",
            "the",
            "given",
            "function",
            "to",
            "the",
            "current",
            "and",
            "given",
            "values"
        ]
    },
    {
        "id": 2013,
        "code": "public final double accumulateAndGet(double x, DoubleBinaryOperator accumulatorFunction) {\n  checkNotNull(accumulatorFunction);\n  return updateAndGet(oldValue -> accumulatorFunction.applyAsDouble(oldValue, x));\n}",
        "summary_tokens": [
            "atomically",
            "updates",
            "the",
            "current",
            "value",
            "with",
            "the",
            "results",
            "of",
            "applying",
            "the",
            "given",
            "function",
            "to",
            "the",
            "current",
            "and",
            "given",
            "values"
        ]
    },
    {
        "id": 2014,
        "code": "public final double getAndUpdate(DoubleUnaryOperator updateFunction) {\n  while (true) {\n    long current = value;\n    double currentVal = longBitsToDouble(current);\n    double nextVal = updateFunction.applyAsDouble(currentVal);\n    long next = doubleToRawLongBits(nextVal);\n    if (updater.compareAndSet(this, current, next)) {\n      return currentVal;\n    }\n  }\n}",
        "summary_tokens": [
            "atomically",
            "updates",
            "the",
            "current",
            "value",
            "with",
            "the",
            "results",
            "of",
            "applying",
            "the",
            "given",
            "function"
        ]
    },
    {
        "id": 2015,
        "code": "public final double updateAndGet(DoubleUnaryOperator updateFunction) {\n  while (true) {\n    long current = value;\n    double currentVal = longBitsToDouble(current);\n    double nextVal = updateFunction.applyAsDouble(currentVal);\n    long next = doubleToRawLongBits(nextVal);\n    if (updater.compareAndSet(this, current, next)) {\n      return nextVal;\n    }\n  }\n}",
        "summary_tokens": [
            "atomically",
            "updates",
            "the",
            "current",
            "value",
            "with",
            "the",
            "results",
            "of",
            "applying",
            "the",
            "given",
            "function"
        ]
    },
    {
        "id": 2016,
        "code": "public final double getAndAccumulate(int i, double x, DoubleBinaryOperator accumulatorFunction) {\n  checkNotNull(accumulatorFunction);\n  return getAndUpdate(i, oldValue -> accumulatorFunction.applyAsDouble(oldValue, x));\n}",
        "summary_tokens": [
            "atomically",
            "updates",
            "the",
            "element",
            "at",
            "index",
            "i",
            "with",
            "the",
            "results",
            "of",
            "applying",
            "the",
            "given",
            "function",
            "to",
            "the",
            "curernt",
            "and",
            "given",
            "values"
        ]
    },
    {
        "id": 2017,
        "code": "public final double accumulateAndGet(int i, double x, DoubleBinaryOperator accumulatorFunction) {\n  checkNotNull(accumulatorFunction);\n  return updateAndGet(i, oldValue -> accumulatorFunction.applyAsDouble(oldValue, x));\n}",
        "summary_tokens": [
            "atomically",
            "updates",
            "the",
            "element",
            "at",
            "index",
            "i",
            "with",
            "the",
            "results",
            "of",
            "applying",
            "the",
            "given",
            "function",
            "to",
            "the",
            "curernt",
            "and",
            "given",
            "values"
        ]
    },
    {
        "id": 2018,
        "code": "public final double getAndUpdate(int i, DoubleUnaryOperator updaterFunction) {\n  while (true) {\n    long current = longs.get(i);\n    double currentVal = longBitsToDouble(current);\n    double nextVal = updaterFunction.applyAsDouble(currentVal);\n    long next = doubleToRawLongBits(nextVal);\n    if (longs.compareAndSet(i, current, next)) {\n      return currentVal;\n    }\n  }\n}",
        "summary_tokens": [
            "atomically",
            "updates",
            "the",
            "element",
            "at",
            "index",
            "i",
            "with",
            "the",
            "results",
            "of",
            "applying",
            "the",
            "given",
            "function",
            "to",
            "the",
            "curernt",
            "value"
        ]
    },
    {
        "id": 2019,
        "code": "public final double updateAndGet(int i, DoubleUnaryOperator updaterFunction) {\n  while (true) {\n    long current = longs.get(i);\n    double currentVal = longBitsToDouble(current);\n    double nextVal = updaterFunction.applyAsDouble(currentVal);\n    long next = doubleToRawLongBits(nextVal);\n    if (longs.compareAndSet(i, current, next)) {\n      return nextVal;\n    }\n  }\n}",
        "summary_tokens": [
            "atomically",
            "updates",
            "the",
            "element",
            "at",
            "index",
            "i",
            "with",
            "the",
            "results",
            "of",
            "applying",
            "the",
            "given",
            "function",
            "to",
            "the",
            "curernt",
            "value"
        ]
    },
    {
        "id": 2020,
        "code": "public long updateAndGet(K key, LongUnaryOperator updaterFunction) {\n  checkNotNull(updaterFunction);\n  return map.compute(\n      key, (k, value) -> updaterFunction.applyAsLong((value == null) ? 0L : value.longValue()));\n}",
        "summary_tokens": [
            "updates",
            "the",
            "value",
            "currently",
            "associated",
            "with",
            "key",
            "with",
            "the",
            "specified",
            "function",
            "and",
            "returns",
            "the",
            "new",
            "value"
        ]
    },
    {
        "id": 2021,
        "code": "public long getAndUpdate(K key, LongUnaryOperator updaterFunction) {\n  checkNotNull(updaterFunction);\n  AtomicLong holder = new AtomicLong();\n  map.compute(\n      key,\n      (k, value) -> {\n        long oldValue = (value == null) ? 0L : value.longValue();\n        holder.set(oldValue);\n        return updaterFunction.applyAsLong(oldValue);\n      });\n  return holder.get();\n}",
        "summary_tokens": [
            "updates",
            "the",
            "value",
            "currently",
            "associated",
            "with",
            "key",
            "with",
            "the",
            "specified",
            "function",
            "and",
            "returns",
            "the",
            "old",
            "value"
        ]
    },
    {
        "id": 2022,
        "code": "public long accumulateAndGet(K key, long x, LongBinaryOperator accumulatorFunction) {\n  checkNotNull(accumulatorFunction);\n  return updateAndGet(key, oldValue -> accumulatorFunction.applyAsLong(oldValue, x));\n}",
        "summary_tokens": [
            "updates",
            "the",
            "value",
            "currently",
            "associated",
            "with",
            "key",
            "by",
            "combining",
            "it",
            "with",
            "x",
            "via",
            "the",
            "specified",
            "accumulator",
            "function",
            "returning",
            "the",
            "new",
            "value"
        ]
    },
    {
        "id": 2023,
        "code": "public long getAndAccumulate(K key, long x, LongBinaryOperator accumulatorFunction) {\n  checkNotNull(accumulatorFunction);\n  return getAndUpdate(key, oldValue -> accumulatorFunction.applyAsLong(oldValue, x));\n}",
        "summary_tokens": [
            "updates",
            "the",
            "value",
            "currently",
            "associated",
            "with",
            "key",
            "by",
            "combining",
            "it",
            "with",
            "x",
            "via",
            "the",
            "specified",
            "accumulator",
            "function",
            "returning",
            "the",
            "old",
            "value"
        ]
    },
    {
        "id": 2024,
        "code": "static long toNanosSaturated(Duration duration) {\n    \n    \n  try {\n    return duration.toNanos();\n  } catch (ArithmeticException tooBig) {\n    return duration.isNegative() ? Long.MIN_VALUE : Long.MAX_VALUE;\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "nanoseconds",
            "of",
            "the",
            "given",
            "duration",
            "without",
            "throwing",
            "or",
            "overflowing"
        ]
    },
    {
        "id": 2025,
        "code": "public Guard newGuard(final BooleanSupplier isSatisfied) {\n  checkNotNull(isSatisfied, \"isSatisfied\");\n  return new Guard(this) {\n    @Override\n    public boolean isSatisfied() {\n      return isSatisfied.getAsBoolean();\n    }\n  };\n}",
        "summary_tokens": [
            "creates",
            "a",
            "new",
            "guard",
            "guard",
            "for",
            "this",
            "monitor"
        ]
    },
    {
        "id": 2026,
        "code": "default void awaitRunning(Duration timeout) throws TimeoutException {\n  awaitRunning(toNanosSaturated(timeout), TimeUnit.NANOSECONDS);\n}",
        "summary_tokens": [
            "waits",
            "for",
            "the",
            "service",
            "to",
            "reach",
            "the",
            "state",
            "running",
            "running",
            "state",
            "for",
            "no",
            "more",
            "than",
            "the",
            "given",
            "time"
        ]
    },
    {
        "id": 2027,
        "code": "default void awaitTerminated(Duration timeout) throws TimeoutException {\n  awaitTerminated(toNanosSaturated(timeout), TimeUnit.NANOSECONDS);\n}",
        "summary_tokens": [
            "waits",
            "for",
            "the",
            "service",
            "to",
            "reach",
            "a",
            "terminal",
            "state",
            "either",
            "service"
        ]
    },
    {
        "id": 2028,
        "code": "public ImmutableMap<Service, Duration> startupDurations() {\n  return ImmutableMap.copyOf(\n      Maps.<Service, Long, Duration>transformValues(startupTimes(), Duration::ofMillis));\n}",
        "summary_tokens": [
            "returns",
            "the",
            "service",
            "load",
            "times"
        ]
    }
]