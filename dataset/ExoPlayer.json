[
    {
        "id": 1,
        "code": "public void selectQueueItem(int itemIndex) {\n  setCurrentItem(itemIndex);\n}",
        "summary_tokens": [
            "plays",
            "a",
            "specified",
            "queue",
            "item",
            "in",
            "the",
            "current",
            "player"
        ]
    },
    {
        "id": 2,
        "code": "public int getCurrentItemIndex() {\n  return currentItemIndex;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "index",
            "of",
            "the",
            "currently",
            "played",
            "item"
        ]
    },
    {
        "id": 3,
        "code": "public void addItem(MediaItem item) {\n  mediaQueue.add(item);\n  currentPlayer.addMediaItem(item);\n}",
        "summary_tokens": [
            "appends",
            "item",
            "to",
            "the",
            "media",
            "queue"
        ]
    },
    {
        "id": 4,
        "code": "public int getMediaQueueSize() {\n  return mediaQueue.size();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "size",
            "of",
            "the",
            "media",
            "queue"
        ]
    },
    {
        "id": 5,
        "code": "public MediaItem getItem(int position) {\n  return mediaQueue.get(position);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "item",
            "at",
            "the",
            "given",
            "index",
            "in",
            "the",
            "media",
            "queue"
        ]
    },
    {
        "id": 6,
        "code": "public boolean removeItem(MediaItem item) {\n  int itemIndex = mediaQueue.indexOf(item);\n  if (itemIndex == -1) {\n    return false;\n  }\n  currentPlayer.removeMediaItem(itemIndex);\n  mediaQueue.remove(itemIndex);\n  if (itemIndex == currentItemIndex && itemIndex == mediaQueue.size()) {\n    maybeSetCurrentItemAndNotify(C.INDEX_UNSET);\n  } else if (itemIndex < currentItemIndex) {\n    maybeSetCurrentItemAndNotify(currentItemIndex - 1);\n  }\n  return true;\n}",
        "summary_tokens": [
            "removes",
            "the",
            "item",
            "at",
            "the",
            "given",
            "index",
            "from",
            "the",
            "media",
            "queue"
        ]
    },
    {
        "id": 7,
        "code": "public boolean moveItem(MediaItem item, int newIndex) {\n  int fromIndex = mediaQueue.indexOf(item);\n  if (fromIndex == -1) {\n    return false;\n  }\n\n    \n  currentPlayer.moveMediaItem(fromIndex, newIndex);\n  mediaQueue.add(newIndex, mediaQueue.remove(fromIndex));\n\n    \n  if (fromIndex == currentItemIndex) {\n    maybeSetCurrentItemAndNotify(newIndex);\n  } else if (fromIndex < currentItemIndex && newIndex >= currentItemIndex) {\n    maybeSetCurrentItemAndNotify(currentItemIndex - 1);\n  } else if (fromIndex > currentItemIndex && newIndex <= currentItemIndex) {\n    maybeSetCurrentItemAndNotify(currentItemIndex + 1);\n  }\n\n  return true;\n}",
        "summary_tokens": [
            "moves",
            "an",
            "item",
            "within",
            "the",
            "queue"
        ]
    },
    {
        "id": 8,
        "code": "public boolean dispatchKeyEvent(KeyEvent event) {\n  return playerView.dispatchKeyEvent(event);\n}",
        "summary_tokens": [
            "dispatches",
            "a",
            "given",
            "key",
            "event",
            "to",
            "the",
            "corresponding",
            "view",
            "of",
            "the",
            "current",
            "player"
        ]
    },
    {
        "id": 9,
        "code": "public void release() {\n  currentItemIndex = C.INDEX_UNSET;\n  mediaQueue.clear();\n  castPlayer.setSessionAvailabilityListener(null);\n  castPlayer.release();\n  playerView.setPlayer(null);\n  localPlayer.release();\n}",
        "summary_tokens": [
            "releases",
            "the",
            "manager",
            "and",
            "the",
            "players",
            "that",
            "it",
            "holds"
        ]
    },
    {
        "id": 10,
        "code": "private void setCurrentItem(int itemIndex) {\n  maybeSetCurrentItemAndNotify(itemIndex);\n  if (currentPlayer.getCurrentTimeline().getWindowCount() != mediaQueue.size()) {\n      \n      \n    currentPlayer.setMediaItems(mediaQueue, itemIndex, C.TIME_UNSET);\n  } else {\n    currentPlayer.seekTo(itemIndex, C.TIME_UNSET);\n  }\n  currentPlayer.setPlayWhenReady(true);\n}",
        "summary_tokens": [
            "starts",
            "playback",
            "of",
            "the",
            "item",
            "at",
            "the",
            "given",
            "index"
        ]
    },
    {
        "id": 11,
        "code": "public void setPlayer(@Nullable ExoPlayer player) {\n  if (player == this.player) {\n    return;\n  }\n  if (this.player != null) {\n    if (surface != null) {\n      this.player.clearVideoSurface(surface);\n    }\n    this.player.clearVideoFrameMetadataListener(renderer);\n  }\n  this.player = player;\n  if (this.player != null) {\n    this.player.setVideoFrameMetadataListener(renderer);\n    this.player.setVideoSurface(surface);\n  }\n}",
        "summary_tokens": [
            "attaches",
            "or",
            "detaches",
            "if",
            "player",
            "is",
            "null",
            "this",
            "view",
            "from",
            "the",
            "player"
        ]
    },
    {
        "id": 12,
        "code": "private void startDownloadService() {\n    \n    \n    \n  try {\n    DownloadService.start(this, DemoDownloadService.class);\n  } catch (IllegalStateException e) {\n    DownloadService.startForeground(this, DemoDownloadService.class);\n  }\n}",
        "summary_tokens": [
            "start",
            "the",
            "download",
            "service",
            "if",
            "it",
            "should",
            "be",
            "running",
            "but",
            "it",
            "s",
            "not",
            "currently"
        ]
    },
    {
        "id": 13,
        "code": "public static boolean willHaveContent(Tracks tracks) {\n  for (Tracks.Group trackGroup : tracks.getGroups()) {\n    if (SUPPORTED_TRACK_TYPES.contains(trackGroup.getType())) {\n      return true;\n    }\n  }\n  return false;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "a",
            "track",
            "selection",
            "dialog",
            "will",
            "have",
            "content",
            "to",
            "display",
            "if",
            "initialized",
            "with",
            "the",
            "specified",
            "tracks"
        ]
    },
    {
        "id": 14,
        "code": "public static TrackSelectionDialog createForPlayer(\n    Player player, DialogInterface.OnDismissListener onDismissListener) {\n  return createForTracksAndParameters(\n      R.string.track_selection_title,\n      player.getCurrentTracks(),\n      player.getTrackSelectionParameters(),\n       true,\n       false,\n      player::setTrackSelectionParameters,\n      onDismissListener);\n}",
        "summary_tokens": [
            "creates",
            "a",
            "dialog",
            "for",
            "a",
            "given",
            "player",
            "whose",
            "parameters",
            "will",
            "be",
            "automatically",
            "updated",
            "when",
            "tracks",
            "are",
            "selected"
        ]
    },
    {
        "id": 15,
        "code": "public static TrackSelectionDialog createForTracksAndParameters(\n    int titleId,\n    Tracks tracks,\n    TrackSelectionParameters trackSelectionParameters,\n    boolean allowAdaptiveSelections,\n    boolean allowMultipleOverrides,\n    TrackSelectionListener trackSelectionListener,\n    DialogInterface.OnDismissListener onDismissListener) {\n  TrackSelectionDialog trackSelectionDialog = new TrackSelectionDialog();\n  trackSelectionDialog.init(\n      tracks,\n      trackSelectionParameters,\n      titleId,\n      allowAdaptiveSelections,\n      allowMultipleOverrides,\n       (dialog, which) -> {\n        TrackSelectionParameters.Builder builder = trackSelectionParameters.buildUpon();\n        for (int i = 0; i < SUPPORTED_TRACK_TYPES.size(); i++) {\n          int trackType = SUPPORTED_TRACK_TYPES.get(i);\n          builder.setTrackTypeDisabled(trackType, trackSelectionDialog.getIsDisabled(trackType));\n          builder.clearOverridesOfType(trackType);\n          Map<TrackGroup, TrackSelectionOverride> overrides =\n              trackSelectionDialog.getOverrides(trackType);\n          for (TrackSelectionOverride override : overrides.values()) {\n            builder.addOverride(override);\n          }\n        }\n        trackSelectionListener.onTracksSelected(builder.build());\n      },\n      onDismissListener);\n  return trackSelectionDialog;\n}",
        "summary_tokens": [
            "creates",
            "a",
            "dialog",
            "for",
            "given",
            "tracks",
            "and",
            "track",
            "selection",
            "parameters"
        ]
    },
    {
        "id": 16,
        "code": "public boolean getIsDisabled(int trackType) {\n  TrackSelectionViewFragment trackView = tabFragments.get(trackType);\n  return trackView != null && trackView.isDisabled;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "disabled",
            "option",
            "is",
            "selected",
            "for",
            "the",
            "specified",
            "track",
            "type"
        ]
    },
    {
        "id": 17,
        "code": "public Map<TrackGroup, TrackSelectionOverride> getOverrides(int trackType) {\n  TrackSelectionViewFragment trackView = tabFragments.get(trackType);\n  return trackView == null ? Collections.emptyMap() : trackView.overrides;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "selected",
            "track",
            "overrides",
            "for",
            "the",
            "specified",
            "track",
            "type"
        ]
    },
    {
        "id": 18,
        "code": "public static MatrixTransformation createZoomInTransition() {\n  return MatrixTransformationFactory::calculateZoomInTransitionMatrix;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "matrix",
            "transformation",
            "that",
            "rescales",
            "the",
            "frames",
            "over",
            "the",
            "first",
            "zoom",
            "duration",
            "seconds",
            "seconds",
            "such",
            "that",
            "the",
            "rectangle",
            "filled",
            "with",
            "the",
            "input",
            "frame",
            "increases",
            "linearly",
            "in",
            "size",
            "from",
            "a",
            "single",
            "point",
            "to",
            "filling",
            "the",
            "full",
            "output",
            "frame"
        ]
    },
    {
        "id": 19,
        "code": "public static MatrixTransformation createDizzyCropEffect() {\n  return MatrixTransformationFactory::calculateDizzyCropMatrix;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "matrix",
            "transformation",
            "that",
            "crops",
            "frames",
            "to",
            "a",
            "rectangle",
            "that",
            "moves",
            "on",
            "an",
            "ellipse"
        ]
    },
    {
        "id": 20,
        "code": "public static GlMatrixTransformation createSpin3dEffect() {\n  return MatrixTransformationFactory::calculate3dSpinMatrix;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "gl",
            "matrix",
            "transformation",
            "that",
            "rotates",
            "a",
            "frame",
            "in",
            "0",
            "d",
            "around",
            "the",
            "y",
            "axis",
            "and",
            "applies",
            "perspective",
            "projection",
            "to",
            "0",
            "d"
        ]
    },
    {
        "id": 21,
        "code": "public void setOutputMode(@C.VideoOutputMode int outputMode) {\n  this.outputMode = outputMode;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "output",
            "mode",
            "for",
            "frames",
            "rendered",
            "by",
            "the",
            "decoder"
        ]
    },
    {
        "id": 22,
        "code": "public void renderToSurface(VideoDecoderOutputBuffer outputBuffer, Surface surface)\n    throws Gav1DecoderException {\n  if (outputBuffer.mode != C.VIDEO_OUTPUT_MODE_SURFACE_YUV) {\n    throw new Gav1DecoderException(\"Invalid output mode.\");\n  }\n  if (gav1RenderFrame(gav1DecoderContext, surface, outputBuffer) == GAV1_ERROR) {\n    throw new Gav1DecoderException(\n        \"Buffer render error: \" + gav1GetErrorMessage(gav1DecoderContext));\n  }\n}",
        "summary_tokens": [
            "renders",
            "output",
            "buffer",
            "to",
            "the",
            "given",
            "surface"
        ]
    },
    {
        "id": 23,
        "code": "public static boolean isAvailable() {\n  return LOADER.isAvailable();\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "underlying",
            "library",
            "is",
            "available",
            "loading",
            "it",
            "if",
            "necessary"
        ]
    },
    {
        "id": 24,
        "code": "public MediaQueueItem getItem(int periodId) {\n  MediaStatus mediaStatus = getMediaStatus();\n  return mediaStatus != null && currentTimeline.getIndexOfPeriod(periodId) != C.INDEX_UNSET\n      ? mediaStatus.getItemById(periodId)\n      : null;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "item",
            "that",
            "corresponds",
            "to",
            "the",
            "period",
            "with",
            "the",
            "given",
            "id",
            "or",
            "null",
            "if",
            "no",
            "media",
            "queue",
            "or",
            "period",
            "with",
            "id",
            "period",
            "id",
            "exist"
        ]
    },
    {
        "id": 25,
        "code": "public boolean isCastSessionAvailable() {\n  return remoteMediaClient != null;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "a",
            "cast",
            "session",
            "is",
            "available"
        ]
    },
    {
        "id": 26,
        "code": "public void setSessionAvailabilityListener(@Nullable SessionAvailabilityListener listener) {\n  sessionAvailabilityListener = listener;\n}",
        "summary_tokens": [
            "sets",
            "a",
            "listener",
            "for",
            "updates",
            "on",
            "the",
            "cast",
            "session",
            "availability"
        ]
    },
    {
        "id": 27,
        "code": "public void stop(boolean reset) {\n  playbackState = STATE_IDLE;\n  if (remoteMediaClient != null) {\n      \n    remoteMediaClient.stop();\n  }\n}",
        "summary_tokens": [
            "use",
            "stop",
            "and",
            "clear",
            "media",
            "items",
            "if",
            "reset",
            "is",
            "true",
            "or",
            "just",
            "stop",
            "if",
            "reset",
            "is",
            "false"
        ]
    },
    {
        "id": 28,
        "code": "public void setPlaylistMetadata(MediaMetadata mediaMetadata) {\n    \n}",
        "summary_tokens": [
            "this",
            "method",
            "is",
            "not",
            "supported",
            "and",
            "does",
            "nothing"
        ]
    },
    {
        "id": 29,
        "code": "public AudioAttributes getAudioAttributes() {\n  return AudioAttributes.DEFAULT;\n}",
        "summary_tokens": [
            "this",
            "method",
            "is",
            "not",
            "supported",
            "and",
            "returns",
            "audio",
            "attributes",
            "default"
        ]
    },
    {
        "id": 30,
        "code": "public void setVolume(float volume) {}",
        "summary_tokens": [
            "this",
            "method",
            "is",
            "not",
            "supported",
            "and",
            "does",
            "nothing"
        ]
    },
    {
        "id": 31,
        "code": "public float getVolume() {\n  return 1;\n}",
        "summary_tokens": [
            "this",
            "method",
            "is",
            "not",
            "supported",
            "and",
            "returns",
            "0"
        ]
    },
    {
        "id": 32,
        "code": "public void clearVideoSurface(@Nullable Surface surface) {}",
        "summary_tokens": [
            "this",
            "method",
            "is",
            "not",
            "supported",
            "and",
            "does",
            "nothing"
        ]
    },
    {
        "id": 33,
        "code": "public void setVideoSurface(@Nullable Surface surface) {}",
        "summary_tokens": [
            "this",
            "method",
            "is",
            "not",
            "supported",
            "and",
            "does",
            "nothing"
        ]
    },
    {
        "id": 34,
        "code": "public void setVideoSurfaceHolder(@Nullable SurfaceHolder surfaceHolder) {}",
        "summary_tokens": [
            "this",
            "method",
            "is",
            "not",
            "supported",
            "and",
            "does",
            "nothing"
        ]
    },
    {
        "id": 35,
        "code": "public void clearVideoSurfaceHolder(@Nullable SurfaceHolder surfaceHolder) {}",
        "summary_tokens": [
            "this",
            "method",
            "is",
            "not",
            "supported",
            "and",
            "does",
            "nothing"
        ]
    },
    {
        "id": 36,
        "code": "public void setVideoSurfaceView(@Nullable SurfaceView surfaceView) {}",
        "summary_tokens": [
            "this",
            "method",
            "is",
            "not",
            "supported",
            "and",
            "does",
            "nothing"
        ]
    },
    {
        "id": 37,
        "code": "public void clearVideoSurfaceView(@Nullable SurfaceView surfaceView) {}",
        "summary_tokens": [
            "this",
            "method",
            "is",
            "not",
            "supported",
            "and",
            "does",
            "nothing"
        ]
    },
    {
        "id": 38,
        "code": "public void setVideoTextureView(@Nullable TextureView textureView) {}",
        "summary_tokens": [
            "this",
            "method",
            "is",
            "not",
            "supported",
            "and",
            "does",
            "nothing"
        ]
    },
    {
        "id": 39,
        "code": "public void clearVideoTextureView(@Nullable TextureView textureView) {}",
        "summary_tokens": [
            "this",
            "method",
            "is",
            "not",
            "supported",
            "and",
            "does",
            "nothing"
        ]
    },
    {
        "id": 40,
        "code": "public VideoSize getVideoSize() {\n  return VideoSize.UNKNOWN;\n}",
        "summary_tokens": [
            "this",
            "method",
            "is",
            "not",
            "supported",
            "and",
            "returns",
            "video",
            "size",
            "unknown"
        ]
    },
    {
        "id": 41,
        "code": "public CueGroup getCurrentCues() {\n  return CueGroup.EMPTY;\n}",
        "summary_tokens": [
            "this",
            "method",
            "is",
            "not",
            "supported",
            "and",
            "returns",
            "an",
            "empty",
            "cue",
            "group"
        ]
    },
    {
        "id": 42,
        "code": "public DeviceInfo getDeviceInfo() {\n  return DeviceInfo.UNKNOWN;\n}",
        "summary_tokens": [
            "this",
            "method",
            "is",
            "not",
            "supported",
            "and",
            "always",
            "returns",
            "device",
            "info",
            "unknown"
        ]
    },
    {
        "id": 43,
        "code": "public int getDeviceVolume() {\n  return 0;\n}",
        "summary_tokens": [
            "this",
            "method",
            "is",
            "not",
            "supported",
            "and",
            "always",
            "returns",
            "0"
        ]
    },
    {
        "id": 44,
        "code": "public boolean isDeviceMuted() {\n  return false;\n}",
        "summary_tokens": [
            "this",
            "method",
            "is",
            "not",
            "supported",
            "and",
            "always",
            "returns",
            "false"
        ]
    },
    {
        "id": 45,
        "code": "public void setDeviceVolume(int volume) {}",
        "summary_tokens": [
            "this",
            "method",
            "is",
            "not",
            "supported",
            "and",
            "does",
            "nothing"
        ]
    },
    {
        "id": 46,
        "code": "",
        "summary_tokens": [
            "this",
            "method",
            "is",
            "not",
            "supported",
            "and",
            "does",
            "nothing"
        ]
    },
    {
        "id": 47,
        "code": "",
        "summary_tokens": [
            "this",
            "method",
            "is",
            "not",
            "supported",
            "and",
            "does",
            "nothing"
        ]
    },
    {
        "id": 48,
        "code": "public void setDeviceMuted(boolean muted) {}",
        "summary_tokens": [
            "this",
            "method",
            "is",
            "not",
            "supported",
            "and",
            "does",
            "nothing"
        ]
    },
    {
        "id": 49,
        "code": "private void updatePlayerStateAndNotifyIfChanged(@Nullable ResultCallback<?> resultCallback) {\n  boolean newPlayWhenReadyValue = playWhenReady.value;\n  if (playWhenReady.acceptsUpdate(resultCallback)) {\n    newPlayWhenReadyValue = !remoteMediaClient.isPaused();\n    playWhenReady.clearPendingResultCallback();\n  }\n  @PlayWhenReadyChangeReason\n  int playWhenReadyChangeReason =\n      newPlayWhenReadyValue != playWhenReady.value\n          ? PLAY_WHEN_READY_CHANGE_REASON_REMOTE\n          : PLAY_WHEN_READY_CHANGE_REASON_USER_REQUEST;\n    \n  setPlayerStateAndNotifyIfChanged(\n      newPlayWhenReadyValue, playWhenReadyChangeReason, fetchPlaybackState(remoteMediaClient));\n}",
        "summary_tokens": [
            "updates",
            "play",
            "when",
            "ready",
            "and",
            "playback",
            "state",
            "to",
            "match",
            "the",
            "cast",
            "remote",
            "media",
            "client",
            "state",
            "and",
            "notifies",
            "listeners",
            "of",
            "any",
            "state",
            "changes"
        ]
    },
    {
        "id": 50,
        "code": "private boolean updateTimelineAndNotifyIfChanged() {\n  Timeline oldTimeline = currentTimeline;\n  int oldWindowIndex = currentWindowIndex;\n  boolean playingPeriodChanged = false;\n  if (updateTimeline()) {\n      \n      \n    Timeline timeline = currentTimeline;\n      \n    listeners.queueEvent(\n        Player.EVENT_TIMELINE_CHANGED,\n        listener ->\n            listener.onTimelineChanged(timeline, Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE));\n\n      \n    Timeline currentTimeline = getCurrentTimeline();\n    boolean playingPeriodRemoved = false;\n    if (!oldTimeline.isEmpty()) {\n      Object oldPeriodUid =\n          castNonNull(oldTimeline.getPeriod(oldWindowIndex, period,  true).uid);\n      playingPeriodRemoved = currentTimeline.getIndexOfPeriod(oldPeriodUid) == C.INDEX_UNSET;\n    }\n    if (playingPeriodRemoved) {\n      PositionInfo oldPosition;\n      if (pendingMediaItemRemovalPosition != null) {\n        oldPosition = pendingMediaItemRemovalPosition;\n        pendingMediaItemRemovalPosition = null;\n      } else {\n          \n          \n        oldTimeline.getPeriod(oldWindowIndex, period,  true);\n        oldTimeline.getWindow(period.windowIndex, window);\n        oldPosition =\n            new PositionInfo(\n                window.uid,\n                period.windowIndex,\n                window.mediaItem,\n                period.uid,\n                period.windowIndex,\n                getCurrentPosition(),\n                getContentPosition(),\n                 C.INDEX_UNSET,\n                 C.INDEX_UNSET);\n      }\n      PositionInfo newPosition = getCurrentPositionInfo();\n      listeners.queueEvent(\n          Player.EVENT_POSITION_DISCONTINUITY,\n          listener -> {\n            listener.onPositionDiscontinuity(DISCONTINUITY_REASON_REMOVE);\n            listener.onPositionDiscontinuity(\n                oldPosition, newPosition, DISCONTINUITY_REASON_REMOVE);\n          });\n    }\n\n      \n    playingPeriodChanged =\n        currentTimeline.isEmpty() != oldTimeline.isEmpty() || playingPeriodRemoved;\n    if (playingPeriodChanged) {\n      listeners.queueEvent(\n          Player.EVENT_MEDIA_ITEM_TRANSITION,\n          listener ->\n              listener.onMediaItemTransition(\n                  getCurrentMediaItem(), MEDIA_ITEM_TRANSITION_REASON_PLAYLIST_CHANGED));\n    }\n    updateAvailableCommandsAndNotifyIfChanged();\n  }\n  return playingPeriodChanged;\n}",
        "summary_tokens": [
            "updates",
            "the",
            "timeline",
            "and",
            "notifies",
            "player"
        ]
    },
    {
        "id": 51,
        "code": "private boolean updateTimeline() {\n  CastTimeline oldTimeline = currentTimeline;\n  MediaStatus status = getMediaStatus();\n  currentTimeline =\n      status != null\n          ? timelineTracker.getCastTimeline(remoteMediaClient)\n          : CastTimeline.EMPTY_CAST_TIMELINE;\n  boolean timelineChanged = !oldTimeline.equals(currentTimeline);\n  if (timelineChanged) {\n    currentWindowIndex = fetchCurrentWindowIndex(remoteMediaClient, currentTimeline);\n  }\n  return timelineChanged;\n}",
        "summary_tokens": [
            "updates",
            "the",
            "current",
            "timeline"
        ]
    },
    {
        "id": 52,
        "code": "private boolean updateTracksAndSelectionsAndNotifyIfChanged() {\n  if (remoteMediaClient == null) {\n      \n    return false;\n  }\n\n  @Nullable MediaStatus mediaStatus = getMediaStatus();\n  @Nullable MediaInfo mediaInfo = mediaStatus != null ? mediaStatus.getMediaInfo() : null;\n  @Nullable\n  List<MediaTrack> castMediaTracks = mediaInfo != null ? mediaInfo.getMediaTracks() : null;\n  if (castMediaTracks == null || castMediaTracks.isEmpty()) {\n    boolean hasChanged = !Tracks.EMPTY.equals(currentTracks);\n    currentTracks = Tracks.EMPTY;\n    return hasChanged;\n  }\n  @Nullable long[] activeTrackIds = mediaStatus.getActiveTrackIds();\n  if (activeTrackIds == null) {\n    activeTrackIds = EMPTY_TRACK_ID_ARRAY;\n  }\n\n  Tracks.Group[] trackGroups = new Tracks.Group[castMediaTracks.size()];\n  for (int i = 0; i < castMediaTracks.size(); i++) {\n    MediaTrack mediaTrack = castMediaTracks.get(i);\n    TrackGroup trackGroup =\n        new TrackGroup( Integer.toString(i), CastUtils.mediaTrackToFormat(mediaTrack));\n    @C.FormatSupport int[] trackSupport = new int[] {C.FORMAT_HANDLED};\n    boolean[] trackSelected = new boolean[] {isTrackActive(mediaTrack.getId(), activeTrackIds)};\n    trackGroups[i] =\n        new Tracks.Group(trackGroup,  false, trackSupport, trackSelected);\n  }\n  Tracks newTracks = new Tracks(ImmutableList.copyOf(trackGroups));\n  if (!newTracks.equals(currentTracks)) {\n    currentTracks = newTracks;\n    return true;\n  }\n  return false;\n}",
        "summary_tokens": [
            "updates",
            "the",
            "internal",
            "tracks",
            "and",
            "selection",
            "and",
            "returns",
            "whether",
            "they",
            "have",
            "changed"
        ]
    },
    {
        "id": 53,
        "code": "private static int fetchPlaybackState(RemoteMediaClient remoteMediaClient) {\n  int receiverAppStatus = remoteMediaClient.getPlayerState();\n  switch (receiverAppStatus) {\n    case MediaStatus.PLAYER_STATE_BUFFERING:\n      return STATE_BUFFERING;\n    case MediaStatus.PLAYER_STATE_PLAYING:\n    case MediaStatus.PLAYER_STATE_PAUSED:\n      return STATE_READY;\n    case MediaStatus.PLAYER_STATE_IDLE:\n    case MediaStatus.PLAYER_STATE_UNKNOWN:\n    default:\n      return STATE_IDLE;\n  }\n}",
        "summary_tokens": [
            "retrieves",
            "the",
            "playback",
            "state",
            "from",
            "remote",
            "media",
            "client",
            "and",
            "maps",
            "it",
            "into",
            "a",
            "player",
            "state"
        ]
    },
    {
        "id": 54,
        "code": "private static @RepeatMode int fetchRepeatMode(RemoteMediaClient remoteMediaClient) {\n  MediaStatus mediaStatus = remoteMediaClient.getMediaStatus();\n  if (mediaStatus == null) {\n      \n    return REPEAT_MODE_OFF;\n  }\n  int castRepeatMode = mediaStatus.getQueueRepeatMode();\n  switch (castRepeatMode) {\n    case MediaStatus.REPEAT_MODE_REPEAT_SINGLE:\n      return REPEAT_MODE_ONE;\n    case MediaStatus.REPEAT_MODE_REPEAT_ALL:\n    case MediaStatus.REPEAT_MODE_REPEAT_ALL_AND_SHUFFLE:\n      return REPEAT_MODE_ALL;\n    case MediaStatus.REPEAT_MODE_REPEAT_OFF:\n      return REPEAT_MODE_OFF;\n    default:\n      throw new IllegalStateException();\n  }\n}",
        "summary_tokens": [
            "retrieves",
            "the",
            "repeat",
            "mode",
            "from",
            "remote",
            "media",
            "client",
            "and",
            "maps",
            "it",
            "into",
            "a",
            "player"
        ]
    },
    {
        "id": 55,
        "code": "public void onMediaItemsSet(List<MediaItem> mediaItems, MediaQueueItem[] mediaQueueItems) {\n  mediaItemsByContentId.clear();\n  onMediaItemsAdded(mediaItems, mediaQueueItems);\n}",
        "summary_tokens": [
            "called",
            "when",
            "media",
            "items",
            "player",
            "set",
            "media",
            "items",
            "have",
            "been",
            "set",
            "to",
            "the",
            "playlist",
            "and",
            "are",
            "sent",
            "to",
            "the",
            "cast",
            "playback",
            "queue"
        ]
    },
    {
        "id": 56,
        "code": "public void onMediaItemsAdded(List<MediaItem> mediaItems, MediaQueueItem[] mediaQueueItems) {\n  for (int i = 0; i < mediaItems.size(); i++) {\n    mediaItemsByContentId.put(\n        checkNotNull(mediaQueueItems[i].getMedia()).getContentId(), mediaItems.get(i));\n  }\n}",
        "summary_tokens": [
            "called",
            "when",
            "media",
            "items",
            "player",
            "add",
            "media",
            "items",
            "list",
            "have",
            "been",
            "added",
            "and",
            "are",
            "sent",
            "to",
            "the",
            "cast",
            "playback",
            "queue"
        ]
    },
    {
        "id": 57,
        "code": "public CastTimeline getCastTimeline(RemoteMediaClient remoteMediaClient) {\n  int[] itemIds = remoteMediaClient.getMediaQueue().getItemIds();\n  if (itemIds.length > 0) {\n      \n      \n    removeUnusedItemDataEntries(itemIds);\n  }\n\n    \n  MediaStatus mediaStatus = remoteMediaClient.getMediaStatus();\n  if (mediaStatus == null) {\n    return CastTimeline.EMPTY_CAST_TIMELINE;\n  }\n\n  int currentItemId = mediaStatus.getCurrentItemId();\n  String currentContentId = checkStateNotNull(mediaStatus.getMediaInfo()).getContentId();\n  MediaItem mediaItem = mediaItemsByContentId.get(currentContentId);\n  updateItemData(\n      currentItemId,\n      mediaItem != null ? mediaItem : MediaItem.EMPTY,\n      mediaStatus.getMediaInfo(),\n      currentContentId,\n       C.TIME_UNSET);\n\n  for (MediaQueueItem queueItem : mediaStatus.getQueueItems()) {\n    long defaultPositionUs = (long) (queueItem.getStartTime() * C.MICROS_PER_SECOND);\n    @Nullable MediaInfo mediaInfo = queueItem.getMedia();\n    String contentId = mediaInfo != null ? mediaInfo.getContentId() : UNKNOWN_CONTENT_ID;\n    mediaItem = mediaItemsByContentId.get(contentId);\n    updateItemData(\n        queueItem.getItemId(),\n        mediaItem != null ? mediaItem : mediaItemConverter.toMediaItem(queueItem),\n        mediaInfo,\n        contentId,\n        defaultPositionUs);\n  }\n  return new CastTimeline(itemIds, itemIdToData);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "cast",
            "timeline",
            "that",
            "represents",
            "the",
            "state",
            "of",
            "the",
            "given",
            "remote",
            "media",
            "client"
        ]
    },
    {
        "id": 58,
        "code": "public static long getStreamDurationUs(@Nullable MediaInfo mediaInfo) {\n  if (mediaInfo == null) {\n    return C.TIME_UNSET;\n  }\n  long durationMs = mediaInfo.getStreamDuration();\n  return durationMs != MediaInfo.UNKNOWN_DURATION && durationMs != LIVE_STREAM_DURATION\n      ? Util.msToUs(durationMs)\n      : C.TIME_UNSET;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "duration",
            "in",
            "microseconds",
            "advertised",
            "by",
            "a",
            "media",
            "info",
            "or",
            "c",
            "time",
            "unset",
            "if",
            "unknown",
            "or",
            "not",
            "applicable"
        ]
    },
    {
        "id": 59,
        "code": "public static String getLogString(int statusCode) {\n  switch (statusCode) {\n    case CastStatusCodes.APPLICATION_NOT_FOUND:\n      return \"A requested application could not be found.\";\n    case CastStatusCodes.APPLICATION_NOT_RUNNING:\n      return \"A requested application is not currently running.\";\n    case CastStatusCodes.AUTHENTICATION_FAILED:\n      return \"Authentication failure.\";\n    case CastStatusCodes.CANCELED:\n      return \"An in-progress request has been canceled, most likely because another action has \"\n          + \"preempted it.\";\n    case CastStatusCodes.ERROR_SERVICE_CREATION_FAILED:\n      return \"The Cast Remote Display service could not be created.\";\n    case CastStatusCodes.ERROR_SERVICE_DISCONNECTED:\n      return \"The Cast Remote Display service was disconnected.\";\n    case CastStatusCodes.FAILED:\n      return \"The in-progress request failed.\";\n    case CastStatusCodes.INTERNAL_ERROR:\n      return \"An internal error has occurred.\";\n    case CastStatusCodes.INTERRUPTED:\n      return \"A blocking call was interrupted while waiting and did not run to completion.\";\n    case CastStatusCodes.INVALID_REQUEST:\n      return \"An invalid request was made.\";\n    case CastStatusCodes.MESSAGE_SEND_BUFFER_TOO_FULL:\n      return \"A message could not be sent because there is not enough room in the send buffer at \"\n          + \"this time.\";\n    case CastStatusCodes.MESSAGE_TOO_LARGE:\n      return \"A message could not be sent because it is too large.\";\n    case CastStatusCodes.NETWORK_ERROR:\n      return \"Network I/O error.\";\n    case CastStatusCodes.NOT_ALLOWED:\n      return \"The request was disallowed and could not be completed.\";\n    case CastStatusCodes.REPLACED:\n      return \"The request's progress is no longer being tracked because another request of the \"\n          + \"same type has been made before the first request completed.\";\n    case CastStatusCodes.SUCCESS:\n      return \"Success.\";\n    case CastStatusCodes.TIMEOUT:\n      return \"An operation has timed out.\";\n    case CastStatusCodes.UNKNOWN_ERROR:\n      return \"An unknown, unexpected error has occurred.\";\n    default:\n      return CastStatusCodes.getStatusCodeString(statusCode);\n  }\n}",
        "summary_tokens": [
            "returns",
            "a",
            "descriptive",
            "log",
            "string",
            "for",
            "the",
            "given",
            "status",
            "code",
            "or",
            "unknown"
        ]
    },
    {
        "id": 60,
        "code": "public static Format mediaTrackToFormat(MediaTrack mediaTrack) {\n  return new Format.Builder()\n      .setId(mediaTrack.getContentId())\n      .setContainerMimeType(mediaTrack.getContentType())\n      .setLanguage(mediaTrack.getLanguage())\n      .build();\n}",
        "summary_tokens": [
            "creates",
            "a",
            "format",
            "instance",
            "containing",
            "all",
            "information",
            "contained",
            "in",
            "the",
            "given",
            "media",
            "track",
            "object"
        ]
    },
    {
        "id": 61,
        "code": "public void getCastTimelinePersistsDuration() {\n  CastTimelineTracker tracker = new CastTimelineTracker(new DefaultMediaItemConverter());\n\n  RemoteMediaClient remoteMediaClient =\n      mockRemoteMediaClient(\n           new int[] {1, 2, 3, 4, 5},\n           2,\n           DURATION_2_MS);\n  TimelineAsserts.assertPeriodDurations(\n      tracker.getCastTimeline(remoteMediaClient),\n      C.TIME_UNSET,\n      Util.msToUs(DURATION_2_MS),\n      C.TIME_UNSET,\n      C.TIME_UNSET,\n      C.TIME_UNSET);\n\n  remoteMediaClient =\n      mockRemoteMediaClient(\n           new int[] {1, 2, 3},\n           3,\n           DURATION_3_MS);\n  TimelineAsserts.assertPeriodDurations(\n      tracker.getCastTimeline(remoteMediaClient),\n      C.TIME_UNSET,\n      Util.msToUs(DURATION_2_MS),\n      Util.msToUs(DURATION_3_MS));\n\n  remoteMediaClient =\n      mockRemoteMediaClient(\n           new int[] {1, 3},\n           3,\n           DURATION_3_MS);\n  TimelineAsserts.assertPeriodDurations(\n      tracker.getCastTimeline(remoteMediaClient), C.TIME_UNSET, Util.msToUs(DURATION_3_MS));\n\n  remoteMediaClient =\n      mockRemoteMediaClient(\n           new int[] {1, 2, 3, 4, 5},\n           4,\n           DURATION_4_MS);\n  TimelineAsserts.assertPeriodDurations(\n      tracker.getCastTimeline(remoteMediaClient),\n      C.TIME_UNSET,\n      C.TIME_UNSET,\n      Util.msToUs(DURATION_3_MS),\n      Util.msToUs(DURATION_4_MS),\n      C.TIME_UNSET);\n\n  remoteMediaClient =\n      mockRemoteMediaClient(\n           new int[] {1, 2, 3, 4, 5},\n           5,\n           DURATION_5_MS);\n  TimelineAsserts.assertPeriodDurations(\n      tracker.getCastTimeline(remoteMediaClient),\n      C.TIME_UNSET,\n      C.TIME_UNSET,\n      Util.msToUs(DURATION_3_MS),\n      Util.msToUs(DURATION_4_MS),\n      Util.msToUs(DURATION_5_MS));\n}",
        "summary_tokens": [
            "tests",
            "that",
            "duration",
            "of",
            "the",
            "current",
            "media",
            "info",
            "is",
            "correctly",
            "propagated",
            "to",
            "the",
            "timeline"
        ]
    },
    {
        "id": 62,
        "code": "public void setContentTypePredicate(@Nullable Predicate<String> contentTypePredicate) {\n  this.contentTypePredicate = contentTypePredicate;\n}",
        "summary_tokens": [
            "use",
            "cronet",
            "data",
            "source"
        ]
    },
    {
        "id": 63,
        "code": "public int read(ByteBuffer buffer) throws HttpDataSourceException {\n  Assertions.checkState(opened);\n\n  if (!buffer.isDirect()) {\n    throw new IllegalArgumentException(\"Passed buffer is not a direct ByteBuffer\");\n  }\n  if (!buffer.hasRemaining()) {\n    return 0;\n  } else if (bytesRemaining == 0) {\n    return C.RESULT_END_OF_INPUT;\n  }\n  int readLength = buffer.remaining();\n\n  if (readBuffer != null) {\n      \n    int copyBytes = copyByteBuffer( readBuffer,  buffer);\n    if (copyBytes != 0) {\n      if (bytesRemaining != C.LENGTH_UNSET) {\n        bytesRemaining -= copyBytes;\n      }\n      bytesTransferred(copyBytes);\n      return copyBytes;\n    }\n  }\n\n    \n  operation.close();\n  readInternal(buffer, castNonNull(currentDataSpec));\n\n  if (finished) {\n    bytesRemaining = 0;\n    return C.RESULT_END_OF_INPUT;\n  }\n\n    \n  Assertions.checkState(readLength > buffer.remaining());\n  int bytesRead = readLength - buffer.remaining();\n  if (bytesRemaining != C.LENGTH_UNSET) {\n    bytesRemaining -= bytesRead;\n  }\n  bytesTransferred(bytesRead);\n  return bytesRead;\n}",
        "summary_tokens": [
            "reads",
            "up",
            "to",
            "buffer"
        ]
    },
    {
        "id": 64,
        "code": "protected UrlRequest getCurrentUrlRequest() {\n  return currentUrlRequest;\n}",
        "summary_tokens": [
            "returns",
            "current",
            "url",
            "request"
        ]
    },
    {
        "id": 65,
        "code": "protected UrlResponseInfo getCurrentUrlResponseInfo() {\n  return responseInfo;\n}",
        "summary_tokens": [
            "returns",
            "current",
            "url",
            "response",
            "info"
        ]
    },
    {
        "id": 66,
        "code": "private void skipFully(long bytesToSkip, DataSpec dataSpec) throws HttpDataSourceException {\n  if (bytesToSkip == 0) {\n    return;\n  }\n  ByteBuffer readBuffer = getOrCreateReadBuffer();\n\n  try {\n    while (bytesToSkip > 0) {\n        \n      operation.close();\n      readBuffer.clear();\n      readInternal(readBuffer, dataSpec);\n      if (Thread.currentThread().isInterrupted()) {\n        throw new InterruptedIOException();\n      }\n      if (finished) {\n        throw new OpenException(\n            dataSpec,\n            PlaybackException.ERROR_CODE_IO_READ_POSITION_OUT_OF_RANGE,\n            Status.READING_RESPONSE);\n      } else {\n          \n        readBuffer.flip();\n        Assertions.checkState(readBuffer.hasRemaining());\n        int bytesSkipped = (int) Math.min(readBuffer.remaining(), bytesToSkip);\n        readBuffer.position(readBuffer.position() + bytesSkipped);\n        bytesToSkip -= bytesSkipped;\n      }\n    }\n  } catch (IOException e) {\n    if (e instanceof HttpDataSourceException) {\n      throw (HttpDataSourceException) e;\n    } else {\n      throw new OpenException(\n          e,\n          dataSpec,\n          e instanceof SocketTimeoutException\n              ? PlaybackException.ERROR_CODE_IO_NETWORK_CONNECTION_TIMEOUT\n              : PlaybackException.ERROR_CODE_IO_NETWORK_CONNECTION_FAILED,\n          Status.READING_RESPONSE);\n    }\n  }\n}",
        "summary_tokens": [
            "attempts",
            "to",
            "skip",
            "the",
            "specified",
            "number",
            "of",
            "bytes",
            "in",
            "full"
        ]
    },
    {
        "id": 67,
        "code": "private byte[] readResponseBody() throws IOException {\n  byte[] responseBody = Util.EMPTY_BYTE_ARRAY;\n  ByteBuffer readBuffer = getOrCreateReadBuffer();\n  while (!finished) {\n    operation.close();\n    readBuffer.clear();\n    readInternal(readBuffer, castNonNull(currentDataSpec));\n    readBuffer.flip();\n    if (readBuffer.remaining() > 0) {\n      int existingResponseBodyEnd = responseBody.length;\n      responseBody = Arrays.copyOf(responseBody, responseBody.length + readBuffer.remaining());\n      readBuffer.get(responseBody, existingResponseBodyEnd, readBuffer.remaining());\n    }\n  }\n  return responseBody;\n}",
        "summary_tokens": [
            "reads",
            "the",
            "whole",
            "response",
            "body"
        ]
    },
    {
        "id": 68,
        "code": "private void readInternal(ByteBuffer buffer, DataSpec dataSpec) throws HttpDataSourceException {\n  castNonNull(currentUrlRequest).read(buffer);\n  try {\n    if (!operation.block(readTimeoutMs)) {\n      throw new SocketTimeoutException();\n    }\n  } catch (InterruptedException e) {\n      \n      \n    if (buffer == readBuffer) {\n      readBuffer = null;\n    }\n    Thread.currentThread().interrupt();\n    exception = new InterruptedIOException();\n  } catch (SocketTimeoutException e) {\n      \n      \n    if (buffer == readBuffer) {\n      readBuffer = null;\n    }\n    exception =\n        new HttpDataSourceException(\n            e,\n            dataSpec,\n            PlaybackException.ERROR_CODE_IO_NETWORK_CONNECTION_TIMEOUT,\n            HttpDataSourceException.TYPE_READ);\n  }\n\n  if (exception != null) {\n    if (exception instanceof HttpDataSourceException) {\n      throw (HttpDataSourceException) exception;\n    } else {\n      throw HttpDataSourceException.createForIOException(\n          exception, dataSpec, HttpDataSourceException.TYPE_READ);\n    }\n  }\n}",
        "summary_tokens": [
            "reads",
            "up",
            "to",
            "buffer"
        ]
    },
    {
        "id": 69,
        "code": " CronetEngine getCronetEngine() {\n  return cronetEngine;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "wrapped",
            "cronet",
            "engine"
        ]
    },
    {
        "id": 70,
        "code": "public static CronetEngine buildCronetEngine(\n    Context context, @Nullable String userAgent, boolean preferGooglePlayServices) {\n  List<CronetProvider> cronetProviders = new ArrayList<>(CronetProvider.getAllProviders(context));\n    \n  for (int i = cronetProviders.size() - 1; i >= 0; i--) {\n    if (!cronetProviders.get(i).isEnabled()\n        || CronetProvider.PROVIDER_NAME_FALLBACK.equals(cronetProviders.get(i).getName())) {\n      cronetProviders.remove(i);\n    }\n  }\n    \n  CronetProviderComparator providerComparator =\n      new CronetProviderComparator(preferGooglePlayServices);\n  Collections.sort(cronetProviders, providerComparator);\n  for (int i = 0; i < cronetProviders.size(); i++) {\n    String providerName = cronetProviders.get(i).getName();\n    try {\n      CronetEngine.Builder cronetEngineBuilder = cronetProviders.get(i).createBuilder();\n      if (userAgent != null) {\n        cronetEngineBuilder.setUserAgent(userAgent);\n      }\n      CronetEngine cronetEngine = cronetEngineBuilder.build();\n      Log.d(TAG, \"CronetEngine built using \" + providerName);\n      return cronetEngine;\n    } catch (SecurityException e) {\n      Log.w(\n          TAG,\n          \"Failed to build CronetEngine. Please check that the process has \"\n              + \"android.permission.ACCESS_NETWORK_STATE.\");\n    } catch (UnsatisfiedLinkError e) {\n      Log.w(\n          TAG,\n          \"Failed to link Cronet binaries. Please check that native Cronet binaries are\"\n              + \"bundled into your app.\");\n    }\n  }\n  Log.w(TAG, \"CronetEngine could not be built.\");\n  return null;\n}",
        "summary_tokens": [
            "builds",
            "a",
            "cronet",
            "engine",
            "suitable",
            "for",
            "use",
            "with",
            "cronet",
            "data",
            "source"
        ]
    },
    {
        "id": 71,
        "code": "public int getChannelCount() {\n  return channelCount;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "channel",
            "count",
            "of",
            "output",
            "audio"
        ]
    },
    {
        "id": 72,
        "code": "public int getSampleRate() {\n  return sampleRate;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "sample",
            "rate",
            "of",
            "output",
            "audio"
        ]
    },
    {
        "id": 73,
        "code": "public @C.PcmEncoding int getEncoding() {\n  return encoding;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "encoding",
            "of",
            "output",
            "audio"
        ]
    },
    {
        "id": 74,
        "code": "private static byte[] getExtraData(String mimeType, List<byte[]> initializationData) {\n  switch (mimeType) {\n    case MimeTypes.AUDIO_AAC:\n    case MimeTypes.AUDIO_OPUS:\n      return initializationData.get(0);\n    case MimeTypes.AUDIO_ALAC:\n      return getAlacExtraData(initializationData);\n    case MimeTypes.AUDIO_VORBIS:\n      return getVorbisExtraData(initializationData);\n    default:\n        \n      return null;\n  }\n}",
        "summary_tokens": [
            "returns",
            "ffmpeg",
            "compatible",
            "codec",
            "specific",
            "initialization",
            "data",
            "extra",
            "data",
            "or",
            "null",
            "if",
            "not",
            "required"
        ]
    },
    {
        "id": 75,
        "code": "private boolean sinkSupportsFormat(Format inputFormat, @C.PcmEncoding int pcmEncoding) {\n  return sinkSupportsFormat(\n      Util.getPcmFormat(pcmEncoding, inputFormat.channelCount, inputFormat.sampleRate));\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "renderer",
            "s",
            "audio",
            "sink",
            "supports",
            "the",
            "pcm",
            "format",
            "that",
            "will",
            "be",
            "output",
            "from",
            "the",
            "decoder",
            "for",
            "the",
            "given",
            "input",
            "format",
            "and",
            "requested",
            "output",
            "encoding"
        ]
    },
    {
        "id": 76,
        "code": "public static void setLibraries(String... libraries) {\n  LOADER.setLibraries(libraries);\n}",
        "summary_tokens": [
            "override",
            "the",
            "names",
            "of",
            "the",
            "ffmpeg",
            "native",
            "libraries"
        ]
    },
    {
        "id": 77,
        "code": "public static boolean isAvailable() {\n  return LOADER.isAvailable();\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "underlying",
            "library",
            "is",
            "available",
            "loading",
            "it",
            "if",
            "necessary"
        ]
    },
    {
        "id": 78,
        "code": "public static String getVersion() {\n  if (!isAvailable()) {\n    return null;\n  }\n  if (version == null) {\n    version = ffmpegGetVersion();\n  }\n  return version;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "version",
            "of",
            "the",
            "underlying",
            "library",
            "if",
            "available",
            "or",
            "null",
            "otherwise"
        ]
    },
    {
        "id": 79,
        "code": "public static int getInputBufferPaddingSize() {\n  if (!isAvailable()) {\n    return C.LENGTH_UNSET;\n  }\n  if (inputBufferPaddingSize == C.LENGTH_UNSET) {\n    inputBufferPaddingSize = ffmpegGetInputBufferPaddingSize();\n  }\n  return inputBufferPaddingSize;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "required",
            "amount",
            "of",
            "padding",
            "for",
            "input",
            "buffers",
            "in",
            "bytes",
            "or",
            "c",
            "length",
            "unset",
            "if",
            "the",
            "underlying",
            "library",
            "is",
            "not",
            "available"
        ]
    },
    {
        "id": 80,
        "code": "public static boolean supportsFormat(String mimeType) {\n  if (!isAvailable()) {\n    return false;\n  }\n  @Nullable String codecName = getCodecName(mimeType);\n  if (codecName == null) {\n    return false;\n  }\n  if (!ffmpegHasDecoder(codecName)) {\n    Log.w(TAG, \"No \" + codecName + \" decoder available. Check the FFmpeg build configuration.\");\n    return false;\n  }\n  return true;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "underlying",
            "library",
            "supports",
            "the",
            "specified",
            "mime",
            "type"
        ]
    },
    {
        "id": 81,
        "code": " static String getCodecName(String mimeType) {\n  switch (mimeType) {\n    case MimeTypes.AUDIO_AAC:\n      return \"aac\";\n    case MimeTypes.AUDIO_MPEG:\n    case MimeTypes.AUDIO_MPEG_L1:\n    case MimeTypes.AUDIO_MPEG_L2:\n      return \"mp3\";\n    case MimeTypes.AUDIO_AC3:\n      return \"ac3\";\n    case MimeTypes.AUDIO_E_AC3:\n    case MimeTypes.AUDIO_E_AC3_JOC:\n      return \"eac3\";\n    case MimeTypes.AUDIO_TRUEHD:\n      return \"truehd\";\n    case MimeTypes.AUDIO_DTS:\n    case MimeTypes.AUDIO_DTS_HD:\n      return \"dca\";\n    case MimeTypes.AUDIO_VORBIS:\n      return \"vorbis\";\n    case MimeTypes.AUDIO_OPUS:\n      return \"opus\";\n    case MimeTypes.AUDIO_AMR_NB:\n      return \"amrnb\";\n    case MimeTypes.AUDIO_AMR_WB:\n      return \"amrwb\";\n    case MimeTypes.AUDIO_FLAC:\n      return \"flac\";\n    case MimeTypes.AUDIO_ALAC:\n      return \"alac\";\n    case MimeTypes.AUDIO_MLAW:\n      return \"pcm_mulaw\";\n    case MimeTypes.AUDIO_ALAW:\n      return \"pcm_alaw\";\n    default:\n      return null;\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "name",
            "of",
            "the",
            "ffmpeg",
            "decoder",
            "that",
            "could",
            "be",
            "used",
            "to",
            "decode",
            "the",
            "format",
            "or",
            "null",
            "if",
            "it",
            "s",
            "unsupported"
        ]
    },
    {
        "id": 82,
        "code": "public FlacStreamMetadata getStreamMetadata() {\n  return streamMetadata;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "flac",
            "stream",
            "metadata",
            "decoded",
            "from",
            "the",
            "initialization",
            "data"
        ]
    },
    {
        "id": 83,
        "code": "public void setData(ExtractorInput extractorInput) {\n  this.byteBufferData = null;\n  this.extractorInput = extractorInput;\n  endOfExtractorInput = false;\n  if (tempBuffer == null) {\n    tempBuffer = new byte[TEMP_BUFFER_SIZE];\n  }\n}",
        "summary_tokens": [
            "sets",
            "the",
            "data",
            "to",
            "be",
            "parsed"
        ]
    },
    {
        "id": 84,
        "code": "public boolean isEndOfData() {\n  if (byteBufferData != null) {\n    return byteBufferData.remaining() == 0;\n  } else if (extractorInput != null) {\n    return endOfExtractorInput;\n  } else {\n    return true;\n  }\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "end",
            "of",
            "the",
            "data",
            "to",
            "be",
            "parsed",
            "has",
            "been",
            "reached",
            "or",
            "true",
            "if",
            "no",
            "data",
            "was",
            "set"
        ]
    },
    {
        "id": 85,
        "code": "public void clearData() {\n  byteBufferData = null;\n  extractorInput = null;\n}",
        "summary_tokens": [
            "clears",
            "the",
            "data",
            "to",
            "be",
            "parsed"
        ]
    },
    {
        "id": 86,
        "code": "public int read(ByteBuffer target) throws IOException {\n  int byteCount = target.remaining();\n  if (byteBufferData != null) {\n    byteCount = min(byteCount, byteBufferData.remaining());\n    int originalLimit = byteBufferData.limit();\n    byteBufferData.limit(byteBufferData.position() + byteCount);\n    target.put(byteBufferData);\n    byteBufferData.limit(originalLimit);\n  } else if (extractorInput != null) {\n    ExtractorInput extractorInput = this.extractorInput;\n    byte[] tempBuffer = Util.castNonNull(this.tempBuffer);\n    byteCount = min(byteCount, TEMP_BUFFER_SIZE);\n    int read = readFromExtractorInput(extractorInput, tempBuffer,  0, byteCount);\n    if (read < 4) {\n        \n        \n        \n      read +=\n          readFromExtractorInput(\n              extractorInput, tempBuffer, read,  byteCount - read);\n    }\n    byteCount = read;\n    target.put(tempBuffer, 0, byteCount);\n  } else {\n    return -1;\n  }\n  return byteCount;\n}",
        "summary_tokens": [
            "reads",
            "up",
            "to",
            "length",
            "bytes",
            "from",
            "the",
            "data",
            "source"
        ]
    },
    {
        "id": 87,
        "code": "public FlacStreamMetadata decodeStreamMetadata() throws IOException {\n  FlacStreamMetadata streamMetadata = flacDecodeMetadata(nativeDecoderContext);\n  if (streamMetadata == null) {\n    throw ParserException.createForMalformedContainer(\n        \"Failed to decode stream metadata\",  null);\n  }\n  return streamMetadata;\n}",
        "summary_tokens": [
            "decodes",
            "and",
            "consumes",
            "the",
            "metadata",
            "from",
            "the",
            "flac",
            "stream"
        ]
    },
    {
        "id": 88,
        "code": "public void decodeSampleWithBacktrackPosition(ByteBuffer output, long retryPosition)\n    throws IOException, FlacFrameDecodeException {\n  try {\n    decodeSample(output);\n  } catch (IOException e) {\n    if (retryPosition >= 0) {\n      reset(retryPosition);\n      if (extractorInput != null) {\n        extractorInput.setRetryPosition(retryPosition, e);\n      }\n    }\n    throw e;\n  }\n}",
        "summary_tokens": [
            "decodes",
            "and",
            "consumes",
            "the",
            "next",
            "frame",
            "from",
            "the",
            "flac",
            "stream",
            "into",
            "the",
            "given",
            "byte",
            "buffer"
        ]
    },
    {
        "id": 89,
        "code": "public void decodeSample(ByteBuffer output) throws IOException, FlacFrameDecodeException {\n  output.clear();\n  int frameSize =\n      output.isDirect()\n          ? flacDecodeToBuffer(nativeDecoderContext, output)\n          : flacDecodeToArray(nativeDecoderContext, output.array());\n  if (frameSize < 0) {\n    if (!isDecoderAtEndOfInput()) {\n      throw new FlacFrameDecodeException(\"Cannot decode FLAC frame\", frameSize);\n    }\n      \n    output.limit(0);\n  } else {\n    output.limit(frameSize);\n  }\n}",
        "summary_tokens": [
            "decodes",
            "and",
            "consumes",
            "the",
            "next",
            "sample",
            "from",
            "the",
            "flac",
            "stream",
            "into",
            "the",
            "given",
            "byte",
            "buffer"
        ]
    },
    {
        "id": 90,
        "code": "public long getDecodePosition() {\n  return flacGetDecodePosition(nativeDecoderContext);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "position",
            "of",
            "the",
            "next",
            "data",
            "to",
            "be",
            "decoded",
            "or",
            "0",
            "in",
            "case",
            "of",
            "error"
        ]
    },
    {
        "id": 91,
        "code": "public long getLastFrameTimestamp() {\n  return flacGetLastFrameTimestamp(nativeDecoderContext);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "timestamp",
            "for",
            "the",
            "first",
            "sample",
            "in",
            "the",
            "last",
            "decoded",
            "frame"
        ]
    },
    {
        "id": 92,
        "code": "public long getLastFrameFirstSampleIndex() {\n  return flacGetLastFrameFirstSampleIndex(nativeDecoderContext);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "first",
            "sample",
            "index",
            "of",
            "the",
            "last",
            "extracted",
            "frame"
        ]
    },
    {
        "id": 93,
        "code": "public long getNextFrameFirstSampleIndex() {\n  return flacGetNextFrameFirstSampleIndex(nativeDecoderContext);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "first",
            "sample",
            "index",
            "of",
            "the",
            "frame",
            "to",
            "be",
            "extracted",
            "next"
        ]
    },
    {
        "id": 94,
        "code": "public SeekMap.SeekPoints getSeekPoints(long timeUs) {\n  long[] seekPoints = new long[4];\n  if (!flacGetSeekPoints(nativeDecoderContext, timeUs, seekPoints)) {\n    return null;\n  }\n  SeekPoint firstSeekPoint = new SeekPoint(seekPoints[0], seekPoints[1]);\n  SeekPoint secondSeekPoint =\n      seekPoints[2] == seekPoints[0]\n          ? firstSeekPoint\n          : new SeekPoint(seekPoints[2], seekPoints[3]);\n  return new SeekMap.SeekPoints(firstSeekPoint, secondSeekPoint);\n}",
        "summary_tokens": [
            "maps",
            "a",
            "seek",
            "position",
            "in",
            "microseconds",
            "to",
            "the",
            "corresponding",
            "seek",
            "map"
        ]
    },
    {
        "id": 95,
        "code": "public boolean isDecoderAtEndOfInput() {\n  return flacIsDecoderAtEndOfStream(nativeDecoderContext);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "decoder",
            "has",
            "read",
            "to",
            "the",
            "end",
            "of",
            "the",
            "input"
        ]
    },
    {
        "id": 96,
        "code": "public void reset(long newPosition) {\n  flacReset(nativeDecoderContext, newPosition);\n}",
        "summary_tokens": [
            "resets",
            "internal",
            "state",
            "of",
            "the",
            "decoder",
            "and",
            "sets",
            "the",
            "stream",
            "position"
        ]
    },
    {
        "id": 97,
        "code": "private static FlacBinarySearchSeeker outputSeekMap(\n    FlacDecoderJni decoderJni,\n    FlacStreamMetadata streamMetadata,\n    long streamLength,\n    ExtractorOutput output,\n    OutputFrameHolder outputFrameHolder) {\n  boolean haveSeekTable = decoderJni.getSeekPoints( 0) != null;\n  FlacBinarySearchSeeker binarySearchSeeker = null;\n  SeekMap seekMap;\n  if (haveSeekTable) {\n    seekMap = new FlacSeekMap(streamMetadata.getDurationUs(), decoderJni);\n  } else if (streamLength != C.LENGTH_UNSET && streamMetadata.totalSamples > 0) {\n    long firstFramePosition = decoderJni.getDecodePosition();\n    binarySearchSeeker =\n        new FlacBinarySearchSeeker(\n            streamMetadata, firstFramePosition, streamLength, decoderJni, outputFrameHolder);\n    seekMap = binarySearchSeeker.getSeekMap();\n  } else {\n    seekMap = new SeekMap.Unseekable(streamMetadata.getDurationUs());\n  }\n  output.seekMap(seekMap);\n  return binarySearchSeeker;\n}",
        "summary_tokens": [
            "outputs",
            "a",
            "seek",
            "map",
            "and",
            "returns",
            "a",
            "flac",
            "binary",
            "search",
            "seeker",
            "if",
            "one",
            "is",
            "required",
            "to",
            "handle",
            "seeks"
        ]
    },
    {
        "id": 98,
        "code": "public static void setLibraries(String... libraries) {\n  LOADER.setLibraries(libraries);\n}",
        "summary_tokens": [
            "override",
            "the",
            "names",
            "of",
            "the",
            "flac",
            "native",
            "libraries"
        ]
    },
    {
        "id": 99,
        "code": "public static boolean isAvailable() {\n  return LOADER.isAvailable();\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "underlying",
            "library",
            "is",
            "available",
            "loading",
            "it",
            "if",
            "necessary"
        ]
    },
    {
        "id": 100,
        "code": "public AdsLoader getAdsLoader() {\n  return adsLoader;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "underlying",
            "ima",
            "sdk",
            "ads",
            "loader"
        ]
    },
    {
        "id": 101,
        "code": "public AdDisplayContainer getAdDisplayContainer() {\n  return adDisplayContainer;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "ima",
            "sdk",
            "ad",
            "display",
            "container"
        ]
    },
    {
        "id": 102,
        "code": "public void skipAd() {\n  if (adsManager != null) {\n    adsManager.skip();\n  }\n}",
        "summary_tokens": [
            "skips",
            "the",
            "current",
            "skippable",
            "ad",
            "if",
            "there",
            "is",
            "one"
        ]
    },
    {
        "id": 103,
        "code": "public void focusSkipButton() {\n  if (adsManager != null) {\n    adsManager.focus();\n  }\n}",
        "summary_tokens": [
            "moves",
            "ui",
            "focus",
            "to",
            "the",
            "skip",
            "button",
            "or",
            "other",
            "interactive",
            "elements",
            "if",
            "currently",
            "shown"
        ]
    },
    {
        "id": 104,
        "code": "public void addListenerWithAdView(EventListener eventListener, AdViewProvider adViewProvider) {\n  boolean isStarted = !eventListeners.isEmpty();\n  eventListeners.add(eventListener);\n  if (isStarted) {\n    if (!AdPlaybackState.NONE.equals(adPlaybackState)) {\n        \n      eventListener.onAdPlaybackState(adPlaybackState);\n    }\n    return;\n  }\n  lastVolumePercent = 0;\n  lastAdProgress = VideoProgressUpdate.VIDEO_TIME_NOT_READY;\n  lastContentProgress = VideoProgressUpdate.VIDEO_TIME_NOT_READY;\n  maybeNotifyPendingAdLoadError();\n  if (!AdPlaybackState.NONE.equals(adPlaybackState)) {\n      \n    eventListener.onAdPlaybackState(adPlaybackState);\n  } else if (adsManager != null) {\n    adPlaybackState =\n        new AdPlaybackState(adsId, getAdGroupTimesUsForCuePoints(adsManager.getAdCuePoints()));\n    updateAdPlaybackState();\n  }\n  for (AdOverlayInfo overlayInfo : adViewProvider.getAdOverlayInfos()) {\n    adDisplayContainer.registerFriendlyObstruction(\n        imaFactory.createFriendlyObstruction(\n            overlayInfo.view,\n            ImaUtil.getFriendlyObstructionPurpose(overlayInfo.purpose),\n            overlayInfo.reasonDetail));\n  }\n}",
        "summary_tokens": [
            "starts",
            "passing",
            "events",
            "from",
            "this",
            "instance",
            "including",
            "any",
            "pending",
            "ad",
            "playback",
            "state",
            "and",
            "registers",
            "obstructions"
        ]
    },
    {
        "id": 105,
        "code": "public void maybePreloadAds(long contentPositionMs, long contentDurationMs) {\n  maybeInitializeAdsManager(contentPositionMs, contentDurationMs);\n}",
        "summary_tokens": [
            "populates",
            "the",
            "ad",
            "playback",
            "state",
            "with",
            "loaded",
            "cue",
            "points",
            "if",
            "available"
        ]
    },
    {
        "id": 106,
        "code": "public void removeListener(EventListener eventListener) {\n  eventListeners.remove(eventListener);\n  if (eventListeners.isEmpty()) {\n    adDisplayContainer.unregisterAllFriendlyObstructions();\n  }\n}",
        "summary_tokens": [
            "stops",
            "passing",
            "of",
            "events",
            "from",
            "this",
            "instance",
            "and",
            "unregisters",
            "obstructions"
        ]
    },
    {
        "id": 107,
        "code": "public void release() {\n  if (released) {\n    return;\n  }\n  released = true;\n  pendingAdRequestContext = null;\n  destroyAdsManager();\n  adsLoader.removeAdsLoadedListener(componentListener);\n  adsLoader.removeAdErrorListener(componentListener);\n  if (configuration.applicationAdErrorListener != null) {\n    adsLoader.removeAdErrorListener(configuration.applicationAdErrorListener);\n  }\n  adsLoader.release();\n  imaPausedContent = false;\n  imaAdState = IMA_AD_STATE_NONE;\n  imaAdMediaInfo = null;\n  stopUpdatingAdProgress();\n  imaAdInfo = null;\n  pendingAdLoadError = null;\n    \n  for (int i = 0; i < adPlaybackState.adGroupCount; i++) {\n    adPlaybackState = adPlaybackState.withSkippedAdGroup(i);\n  }\n  updateAdPlaybackState();\n}",
        "summary_tokens": [
            "releases",
            "all",
            "resources",
            "used",
            "by",
            "the",
            "ad",
            "tag",
            "loader"
        ]
    },
    {
        "id": 108,
        "code": "public void handlePrepareComplete(int adGroupIndex, int adIndexInAdGroup) {\n  AdInfo adInfo = new AdInfo(adGroupIndex, adIndexInAdGroup);\n  if (configuration.debugModeEnabled) {\n    Log.d(TAG, \"Prepared ad \" + adInfo);\n  }\n  @Nullable AdMediaInfo adMediaInfo = adInfoByAdMediaInfo.inverse().get(adInfo);\n  if (adMediaInfo != null) {\n    for (int i = 0; i < adCallbacks.size(); i++) {\n      adCallbacks.get(i).onLoaded(adMediaInfo);\n    }\n  } else {\n    Log.w(TAG, \"Unexpected prepared ad \" + adInfo);\n  }\n}",
        "summary_tokens": [
            "notifies",
            "the",
            "ima",
            "sdk",
            "that",
            "the",
            "specified",
            "ad",
            "has",
            "been",
            "prepared",
            "for",
            "playback"
        ]
    },
    {
        "id": 109,
        "code": "public void handlePrepareError(int adGroupIndex, int adIndexInAdGroup, IOException exception) {\n  if (player == null) {\n    return;\n  }\n  try {\n    handleAdPrepareError(adGroupIndex, adIndexInAdGroup, exception);\n  } catch (RuntimeException e) {\n    maybeNotifyInternalError(\"handlePrepareError\", e);\n  }\n}",
        "summary_tokens": [
            "notifies",
            "the",
            "ima",
            "sdk",
            "that",
            "the",
            "specified",
            "ad",
            "has",
            "failed",
            "to",
            "prepare",
            "for",
            "playback"
        ]
    },
    {
        "id": 110,
        "code": "private AdsRenderingSettings setupAdsRendering(long contentPositionMs, long contentDurationMs) {\n  AdsRenderingSettings adsRenderingSettings = imaFactory.createAdsRenderingSettings();\n  adsRenderingSettings.setEnablePreloading(true);\n  adsRenderingSettings.setMimeTypes(\n      configuration.adMediaMimeTypes != null\n          ? configuration.adMediaMimeTypes\n          : supportedMimeTypes);\n  if (configuration.mediaLoadTimeoutMs != TIMEOUT_UNSET) {\n    adsRenderingSettings.setLoadVideoTimeout(configuration.mediaLoadTimeoutMs);\n  }\n  if (configuration.mediaBitrate != BITRATE_UNSET) {\n    adsRenderingSettings.setBitrateKbps(configuration.mediaBitrate / 1000);\n  }\n  adsRenderingSettings.setFocusSkipButtonWhenAvailable(\n      configuration.focusSkipButtonWhenAvailable);\n  if (configuration.adUiElements != null) {\n    adsRenderingSettings.setUiElements(configuration.adUiElements);\n  }\n\n    \n  int adGroupForPositionIndex =\n      adPlaybackState.getAdGroupIndexForPositionUs(\n          Util.msToUs(contentPositionMs), Util.msToUs(contentDurationMs));\n  if (adGroupForPositionIndex != C.INDEX_UNSET) {\n    boolean playAdWhenStartingPlayback =\n        adPlaybackState.getAdGroup(adGroupForPositionIndex).timeUs\n                == Util.msToUs(contentPositionMs)\n            || configuration.playAdBeforeStartPosition;\n    if (!playAdWhenStartingPlayback) {\n      adGroupForPositionIndex++;\n    } else if (hasMidrollAdGroups(adPlaybackState)) {\n        \n        \n        \n      pendingContentPositionMs = contentPositionMs;\n    }\n    if (adGroupForPositionIndex > 0) {\n      for (int i = 0; i < adGroupForPositionIndex; i++) {\n        adPlaybackState = adPlaybackState.withSkippedAdGroup(i);\n      }\n      if (adGroupForPositionIndex == adPlaybackState.adGroupCount) {\n          \n          \n        return null;\n      }\n      long adGroupForPositionTimeUs = adPlaybackState.getAdGroup(adGroupForPositionIndex).timeUs;\n      long adGroupBeforePositionTimeUs =\n          adPlaybackState.getAdGroup(adGroupForPositionIndex - 1).timeUs;\n      if (adGroupForPositionTimeUs == C.TIME_END_OF_SOURCE) {\n          \n        adsRenderingSettings.setPlayAdsAfterTime(\n            (double) adGroupBeforePositionTimeUs / C.MICROS_PER_SECOND + 1d);\n      } else {\n          \n          \n        double midpointTimeUs = (adGroupForPositionTimeUs + adGroupBeforePositionTimeUs) / 2d;\n        adsRenderingSettings.setPlayAdsAfterTime(midpointTimeUs / C.MICROS_PER_SECOND);\n      }\n    }\n  }\n  return adsRenderingSettings;\n}",
        "summary_tokens": [
            "configures",
            "ads",
            "rendering",
            "for",
            "starting",
            "playback",
            "returning",
            "the",
            "settings",
            "for",
            "the",
            "ima",
            "sdk",
            "or",
            "null",
            "if",
            "no",
            "ads",
            "should",
            "play"
        ]
    },
    {
        "id": 111,
        "code": "private boolean isWaitingForAdToLoad() {\n  @Nullable Player player = this.player;\n  if (player == null) {\n    return false;\n  }\n  int adGroupIndex = getLoadingAdGroupIndex();\n  if (adGroupIndex == C.INDEX_UNSET) {\n    return false;\n  }\n  AdPlaybackState.AdGroup adGroup = adPlaybackState.getAdGroup(adGroupIndex);\n  if (adGroup.count != C.LENGTH_UNSET\n      && adGroup.count != 0\n      && adGroup.states[0] != AdPlaybackState.AD_STATE_UNAVAILABLE) {\n      \n    return false;\n  }\n  long adGroupTimeMs = Util.usToMs(adGroup.timeUs);\n  long contentPositionMs = getContentPeriodPositionMs(player, timeline, period);\n  long timeUntilAdMs = adGroupTimeMs - contentPositionMs;\n  return timeUntilAdMs < configuration.adPreloadTimeoutMs;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "this",
            "instance",
            "is",
            "expecting",
            "the",
            "first",
            "ad",
            "in",
            "an",
            "the",
            "upcoming",
            "ad",
            "group",
            "to",
            "load",
            "within",
            "the",
            "ima",
            "util"
        ]
    },
    {
        "id": 112,
        "code": "private int getLoadingAdGroupIndex() {\n  if (player == null) {\n    return C.INDEX_UNSET;\n  }\n  long playerPositionUs = Util.msToUs(getContentPeriodPositionMs(player, timeline, period));\n  int adGroupIndex =\n      adPlaybackState.getAdGroupIndexForPositionUs(\n          playerPositionUs, Util.msToUs(contentDurationMs));\n  if (adGroupIndex == C.INDEX_UNSET) {\n    adGroupIndex =\n        adPlaybackState.getAdGroupIndexAfterPositionUs(\n            playerPositionUs, Util.msToUs(contentDurationMs));\n  }\n  return adGroupIndex;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "index",
            "of",
            "the",
            "ad",
            "group",
            "that",
            "will",
            "preload",
            "next",
            "or",
            "c",
            "index",
            "unset",
            "if",
            "there",
            "is",
            "no",
            "such",
            "ad",
            "group"
        ]
    },
    {
        "id": 113,
        "code": "public com.google.ads.interactivemedia.v3.api.AdsLoader getAdsLoader() {\n  return currentAdTagLoader != null ? currentAdTagLoader.getAdsLoader() : null;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "underlying",
            "com"
        ]
    },
    {
        "id": 114,
        "code": "public AdDisplayContainer getAdDisplayContainer() {\n  return currentAdTagLoader != null ? currentAdTagLoader.getAdDisplayContainer() : null;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "ad",
            "display",
            "container",
            "used",
            "by",
            "this",
            "loader",
            "or",
            "null",
            "if",
            "ads",
            "have",
            "not",
            "been",
            "requested",
            "yet"
        ]
    },
    {
        "id": 115,
        "code": "public void requestAds(DataSpec adTagDataSpec, Object adsId, @Nullable ViewGroup adViewGroup) {\n  if (!adTagLoaderByAdsId.containsKey(adsId)) {\n    AdTagLoader adTagLoader =\n        new AdTagLoader(\n            context,\n            configuration,\n            imaFactory,\n            supportedMimeTypes,\n            adTagDataSpec,\n            adsId,\n            adViewGroup);\n    adTagLoaderByAdsId.put(adsId, adTagLoader);\n  }\n}",
        "summary_tokens": [
            "requests",
            "ads",
            "if",
            "they",
            "have",
            "not",
            "already",
            "been",
            "requested"
        ]
    },
    {
        "id": 116,
        "code": "public void skipAd() {\n  if (currentAdTagLoader != null) {\n    currentAdTagLoader.skipAd();\n  }\n}",
        "summary_tokens": [
            "skips",
            "the",
            "current",
            "ad"
        ]
    },
    {
        "id": 117,
        "code": "public void focusSkipButton() {\n  if (currentAdTagLoader != null) {\n    currentAdTagLoader.focusSkipButton();\n  }\n}",
        "summary_tokens": [
            "moves",
            "ui",
            "focus",
            "to",
            "the",
            "skip",
            "button",
            "or",
            "other",
            "interactive",
            "elements",
            "if",
            "currently",
            "shown"
        ]
    },
    {
        "id": 118,
        "code": "public ImaServerSideAdInsertionUriBuilder setAdsId(String adsId) {\n  this.adsId = adsId;\n  return this;\n}",
        "summary_tokens": [
            "an",
            "opaque",
            "identifier",
            "for",
            "associated",
            "ad",
            "playback",
            "state",
            "or",
            "null",
            "if",
            "the",
            "set",
            "asset",
            "key",
            "string",
            "asset",
            "key",
            "for",
            "live",
            "or",
            "set",
            "video",
            "id",
            "string",
            "video",
            "id",
            "for",
            "vod",
            "should",
            "be",
            "used",
            "as",
            "the",
            "ads",
            "identifier"
        ]
    },
    {
        "id": 119,
        "code": "public ImaServerSideAdInsertionUriBuilder setAssetKey(@Nullable String assetKey) {\n  this.assetKey = assetKey;\n  return this;\n}",
        "summary_tokens": [
            "the",
            "stream",
            "request",
            "asset",
            "key",
            "used",
            "for",
            "live",
            "streams"
        ]
    },
    {
        "id": 120,
        "code": "public ImaServerSideAdInsertionUriBuilder setAuthToken(@Nullable String authToken) {\n  this.authToken = authToken;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "stream",
            "request",
            "authorization",
            "token"
        ]
    },
    {
        "id": 121,
        "code": "public ImaServerSideAdInsertionUriBuilder setContentSourceId(@Nullable String contentSourceId) {\n  this.contentSourceId = contentSourceId;\n  return this;\n}",
        "summary_tokens": [
            "the",
            "stream",
            "request",
            "content",
            "source",
            "id",
            "used",
            "for",
            "on",
            "demand",
            "streams"
        ]
    },
    {
        "id": 122,
        "code": "public ImaServerSideAdInsertionUriBuilder setVideoId(@Nullable String videoId) {\n  this.videoId = videoId;\n  return this;\n}",
        "summary_tokens": [
            "the",
            "stream",
            "request",
            "video",
            "id",
            "used",
            "for",
            "on",
            "demand",
            "streams"
        ]
    },
    {
        "id": 123,
        "code": "public ImaServerSideAdInsertionUriBuilder setFormat(@ContentType int format) {\n  checkArgument(format == C.CONTENT_TYPE_DASH || format == C.CONTENT_TYPE_HLS);\n  this.format = format;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "format",
            "of",
            "the",
            "stream",
            "request"
        ]
    },
    {
        "id": 124,
        "code": "public ImaServerSideAdInsertionUriBuilder setApiKey(@Nullable String apiKey) {\n  this.apiKey = apiKey;\n  return this;\n}",
        "summary_tokens": [
            "the",
            "stream",
            "request",
            "api",
            "key"
        ]
    },
    {
        "id": 125,
        "code": "public ImaServerSideAdInsertionUriBuilder setStreamActivityMonitorId(\n    @Nullable String streamActivityMonitorId) {\n  this.streamActivityMonitorId = streamActivityMonitorId;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "id",
            "to",
            "be",
            "used",
            "to",
            "debug",
            "the",
            "stream",
            "with",
            "the",
            "stream",
            "activity",
            "monitor"
        ]
    },
    {
        "id": 126,
        "code": "public ImaServerSideAdInsertionUriBuilder setAdTagParameters(\n    Map<String, String> adTagParameters) {\n  this.adTagParameters = ImmutableMap.copyOf(adTagParameters);\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "overridable",
            "ad",
            "tag",
            "parameters",
            "on",
            "the",
            "stream",
            "request"
        ]
    },
    {
        "id": 127,
        "code": "public ImaServerSideAdInsertionUriBuilder setManifestSuffix(@Nullable String manifestSuffix) {\n  this.manifestSuffix = manifestSuffix;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "optional",
            "stream",
            "manifest",
            "s",
            "suffix",
            "which",
            "will",
            "be",
            "appended",
            "to",
            "the",
            "stream",
            "manifest",
            "s",
            "url"
        ]
    },
    {
        "id": 128,
        "code": "public ImaServerSideAdInsertionUriBuilder setContentUrl(@Nullable String contentUrl) {\n  this.contentUrl = contentUrl;\n  return this;\n}",
        "summary_tokens": [
            "specifies",
            "the",
            "deep",
            "link",
            "to",
            "the",
            "content",
            "s",
            "screen"
        ]
    },
    {
        "id": 129,
        "code": "public ImaServerSideAdInsertionUriBuilder setLoadVideoTimeoutMs(int loadVideoTimeoutMs) {\n  this.loadVideoTimeoutMs = loadVideoTimeoutMs;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "duration",
            "after",
            "which",
            "resolving",
            "the",
            "video",
            "uri",
            "should",
            "time",
            "out",
            "in",
            "milliseconds"
        ]
    },
    {
        "id": 130,
        "code": "public Uri build() {\n  checkState(\n      (TextUtils.isEmpty(assetKey)\n              && !TextUtils.isEmpty(contentSourceId)\n              && !TextUtils.isEmpty(videoId))\n          || (!TextUtils.isEmpty(assetKey)\n              && TextUtils.isEmpty(contentSourceId)\n              && TextUtils.isEmpty(videoId)));\n  checkState(format != C.CONTENT_TYPE_OTHER);\n  @Nullable String adsId = this.adsId;\n  if (adsId == null) {\n    adsId = assetKey != null ? assetKey : checkNotNull(videoId);\n  }\n  Uri.Builder dataUriBuilder = new Uri.Builder();\n  dataUriBuilder.scheme(C.SSAI_SCHEME);\n  dataUriBuilder.authority(IMA_AUTHORITY);\n  dataUriBuilder.appendQueryParameter(ADS_ID, adsId);\n  if (loadVideoTimeoutMs != DEFAULT_LOAD_VIDEO_TIMEOUT_MS) {\n    dataUriBuilder.appendQueryParameter(\n        LOAD_VIDEO_TIMEOUT_MS, String.valueOf(loadVideoTimeoutMs));\n  }\n  if (assetKey != null) {\n    dataUriBuilder.appendQueryParameter(ASSET_KEY, assetKey);\n  }\n  if (apiKey != null) {\n    dataUriBuilder.appendQueryParameter(API_KEY, apiKey);\n  }\n  if (contentSourceId != null) {\n    dataUriBuilder.appendQueryParameter(CONTENT_SOURCE_ID, contentSourceId);\n  }\n  if (videoId != null) {\n    dataUriBuilder.appendQueryParameter(VIDEO_ID, videoId);\n  }\n  if (manifestSuffix != null) {\n    dataUriBuilder.appendQueryParameter(MANIFEST_SUFFIX, manifestSuffix);\n  }\n  if (contentUrl != null) {\n    dataUriBuilder.appendQueryParameter(CONTENT_URL, contentUrl);\n  }\n  if (authToken != null) {\n    dataUriBuilder.appendQueryParameter(AUTH_TOKEN, authToken);\n  }\n  if (streamActivityMonitorId != null) {\n    dataUriBuilder.appendQueryParameter(STREAM_ACTIVITY_MONITOR_ID, streamActivityMonitorId);\n  }\n  if (!adTagParameters.isEmpty()) {\n    Uri.Builder adTagParametersUriBuilder = new Uri.Builder();\n    for (Map.Entry<String, String> entry : adTagParameters.entrySet()) {\n      adTagParametersUriBuilder.appendQueryParameter(entry.getKey(), entry.getValue());\n    }\n    dataUriBuilder.appendQueryParameter(\n        AD_TAG_PARAMETERS, adTagParametersUriBuilder.build().toString());\n  }\n  dataUriBuilder.appendQueryParameter(FORMAT, String.valueOf(format));\n  return dataUriBuilder.build();\n}",
        "summary_tokens": [
            "builds",
            "a",
            "uri",
            "with",
            "the",
            "builder",
            "s",
            "current",
            "values"
        ]
    },
    {
        "id": 131,
        "code": " static boolean isLiveStream(Uri uri) {\n  return !TextUtils.isEmpty(uri.getQueryParameter(ASSET_KEY));\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "provided",
            "request",
            "is",
            "for",
            "a",
            "live",
            "stream",
            "or",
            "false",
            "if",
            "it",
            "is",
            "a",
            "vod",
            "stream"
        ]
    },
    {
        "id": 132,
        "code": " static String getAdsId(Uri uri) {\n  return checkNotNull(uri.getQueryParameter(ADS_ID));\n}",
        "summary_tokens": [
            "returns",
            "the",
            "opaque",
            "ads",
            "id",
            "for",
            "this",
            "stream"
        ]
    },
    {
        "id": 133,
        "code": " static int getLoadVideoTimeoutMs(Uri uri) {\n  @Nullable String adsLoaderTimeoutUs = uri.getQueryParameter(LOAD_VIDEO_TIMEOUT_MS);\n  return TextUtils.isEmpty(adsLoaderTimeoutUs)\n      ? DEFAULT_LOAD_VIDEO_TIMEOUT_MS\n      : Integer.parseInt(adsLoaderTimeoutUs);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "video",
            "load",
            "timeout",
            "in",
            "milliseconds"
        ]
    },
    {
        "id": 134,
        "code": " static StreamRequest createStreamRequest(Uri uri) {\n  if (!C.SSAI_SCHEME.equals(uri.getScheme()) || !IMA_AUTHORITY.equals(uri.getAuthority())) {\n    throw new IllegalArgumentException(\"Invalid URI scheme or authority.\");\n  }\n  StreamRequest streamRequest;\n    \n  @Nullable String assetKey = uri.getQueryParameter(ASSET_KEY);\n  @Nullable String apiKey = uri.getQueryParameter(API_KEY);\n  @Nullable String contentSourceId = uri.getQueryParameter(CONTENT_SOURCE_ID);\n  @Nullable String videoId = uri.getQueryParameter(VIDEO_ID);\n  if (!TextUtils.isEmpty(assetKey)) {\n    streamRequest = ImaSdkFactory.getInstance().createLiveStreamRequest(assetKey, apiKey);\n  } else {\n    streamRequest =\n        ImaSdkFactory.getInstance()\n            .createVodStreamRequest(checkNotNull(contentSourceId), checkNotNull(videoId), apiKey);\n  }\n  int format = Integer.parseInt(uri.getQueryParameter(FORMAT));\n  if (format == C.CONTENT_TYPE_DASH) {\n    streamRequest.setFormat(StreamFormat.DASH);\n  } else if (format == C.CONTENT_TYPE_HLS) {\n    streamRequest.setFormat(StreamFormat.HLS);\n  } else {\n    throw new IllegalArgumentException(\"Unsupported stream format:\" + format);\n  }\n    \n  @Nullable String adTagParametersValue = uri.getQueryParameter(AD_TAG_PARAMETERS);\n  if (!TextUtils.isEmpty(adTagParametersValue)) {\n    Map<String, String> adTagParameters = new HashMap<>();\n    Uri adTagParametersUri = Uri.parse(adTagParametersValue);\n    for (String paramName : adTagParametersUri.getQueryParameterNames()) {\n      String singleAdTagParameterValue = adTagParametersUri.getQueryParameter(paramName);\n      if (!TextUtils.isEmpty(singleAdTagParameterValue)) {\n        adTagParameters.put(paramName, singleAdTagParameterValue);\n      }\n    }\n    streamRequest.setAdTagParameters(adTagParameters);\n  }\n  @Nullable String manifestSuffix = uri.getQueryParameter(MANIFEST_SUFFIX);\n  if (manifestSuffix != null) {\n    streamRequest.setManifestSuffix(manifestSuffix);\n  }\n  @Nullable String contentUrl = uri.getQueryParameter(CONTENT_URL);\n  if (contentUrl != null) {\n    streamRequest.setContentUrl(contentUrl);\n  }\n  @Nullable String authToken = uri.getQueryParameter(AUTH_TOKEN);\n  if (authToken != null) {\n    streamRequest.setAuthToken(authToken);\n  }\n  @Nullable String streamActivityMonitorId = uri.getQueryParameter(STREAM_ACTIVITY_MONITOR_ID);\n  if (streamActivityMonitorId != null) {\n    streamRequest.setStreamActivityMonitorId(streamActivityMonitorId);\n  }\n  checkState(\n      streamRequest.getFormat() != StreamFormat.DASH\n          || TextUtils.isEmpty(streamRequest.getAssetKey()),\n      \"DASH live streams are not supported yet.\");\n  return streamRequest;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "corresponding",
            "stream",
            "request"
        ]
    },
    {
        "id": 135,
        "code": "public static FriendlyObstructionPurpose getFriendlyObstructionPurpose(\n    @AdOverlayInfo.Purpose int purpose) {\n  switch (purpose) {\n    case AdOverlayInfo.PURPOSE_CONTROLS:\n      return FriendlyObstructionPurpose.VIDEO_CONTROLS;\n    case AdOverlayInfo.PURPOSE_CLOSE_AD:\n      return FriendlyObstructionPurpose.CLOSE_AD;\n    case AdOverlayInfo.PURPOSE_NOT_VISIBLE:\n      return FriendlyObstructionPurpose.NOT_VISIBLE;\n    case AdOverlayInfo.PURPOSE_OTHER:\n    default:\n      return FriendlyObstructionPurpose.OTHER;\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "ima",
            "friendly",
            "obstruction",
            "purpose",
            "corresponding",
            "to",
            "the",
            "given",
            "ad",
            "overlay",
            "info",
            "purpose"
        ]
    },
    {
        "id": 136,
        "code": "public static long[] getAdGroupTimesUsForCuePoints(List<Float> cuePoints) {\n  if (cuePoints.isEmpty()) {\n    return new long[] {0L};\n  }\n\n  int count = cuePoints.size();\n  long[] adGroupTimesUs = new long[count];\n  int adGroupIndex = 0;\n  for (int i = 0; i < count; i++) {\n    double cuePoint = cuePoints.get(i);\n    if (cuePoint == -1.0) {\n      adGroupTimesUs[count - 1] = C.TIME_END_OF_SOURCE;\n    } else {\n      adGroupTimesUs[adGroupIndex++] = Math.round(C.MICROS_PER_SECOND * cuePoint);\n    }\n  }\n    \n  Arrays.sort(adGroupTimesUs, 0, adGroupIndex);\n  return adGroupTimesUs;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "microsecond",
            "ad",
            "group",
            "timestamps",
            "corresponding",
            "to",
            "the",
            "specified",
            "cue",
            "points"
        ]
    },
    {
        "id": 137,
        "code": "public static AdsRequest getAdsRequestForAdTagDataSpec(\n    ImaFactory imaFactory, DataSpec adTagDataSpec) throws IOException {\n  AdsRequest request = imaFactory.createAdsRequest();\n  if (DataSchemeDataSource.SCHEME_DATA.equals(adTagDataSpec.uri.getScheme())) {\n    DataSchemeDataSource dataSchemeDataSource = new DataSchemeDataSource();\n    try {\n      dataSchemeDataSource.open(adTagDataSpec);\n      request.setAdsResponse(Util.fromUtf8Bytes(DataSourceUtil.readToEnd(dataSchemeDataSource)));\n    } finally {\n      dataSchemeDataSource.close();\n    }\n  } else {\n    request.setAdTagUrl(adTagDataSpec.uri.toString());\n  }\n  return request;\n}",
        "summary_tokens": [
            "returns",
            "an",
            "ads",
            "request",
            "based",
            "on",
            "the",
            "specified",
            "ad",
            "tag",
            "data",
            "spec"
        ]
    },
    {
        "id": 138,
        "code": "public static boolean isAdGroupLoadError(AdError adError) {\n    \n    \n  return adError.getErrorCode() == AdError.AdErrorCode.VAST_LINEAR_ASSET_MISMATCH\n      || adError.getErrorCode() == AdError.AdErrorCode.UNKNOWN_ERROR;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "ad",
            "error",
            "indicates",
            "that",
            "an",
            "entire",
            "ad",
            "group",
            "failed",
            "to",
            "load"
        ]
    },
    {
        "id": 139,
        "code": "public static Looper getImaLooper() {\n    \n    \n  return Looper.getMainLooper();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "looper",
            "on",
            "which",
            "all",
            "ima",
            "sdk",
            "interaction",
            "must",
            "occur"
        ]
    },
    {
        "id": 140,
        "code": "public static String getStringForVideoProgressUpdate(VideoProgressUpdate videoProgressUpdate) {\n  if (VideoProgressUpdate.VIDEO_TIME_NOT_READY.equals(videoProgressUpdate)) {\n    return \"not ready\";\n  } else {\n    return Util.formatInvariant(\n        \"%d ms of %d ms\",\n        videoProgressUpdate.getCurrentTimeMs(), videoProgressUpdate.getDurationMs());\n  }\n}",
        "summary_tokens": [
            "returns",
            "a",
            "human",
            "readable",
            "representation",
            "of",
            "a",
            "video",
            "progress",
            "update"
        ]
    },
    {
        "id": 141,
        "code": "public static AdPlaybackState expandAdGroupPlaceholder(\n    int adGroupIndex,\n    long adGroupDurationUs,\n    int adIndexInAdGroup,\n    long adDurationUs,\n    int adsInAdGroupCount,\n    AdPlaybackState adPlaybackState) {\n  checkArgument(adIndexInAdGroup < adsInAdGroupCount);\n  long[] adDurationsUs =\n      updateAdDurationAndPropagate(\n          new long[adsInAdGroupCount], adIndexInAdGroup, adDurationUs, adGroupDurationUs);\n  return adPlaybackState\n      .withAdCount(adGroupIndex, adDurationsUs.length)\n      .withAdDurationsUs(adGroupIndex, adDurationsUs);\n}",
        "summary_tokens": [
            "expands",
            "a",
            "placeholder",
            "ad",
            "group",
            "with",
            "a",
            "single",
            "ad",
            "to",
            "the",
            "requested",
            "number",
            "of",
            "ads",
            "and",
            "sets",
            "the",
            "duration",
            "of",
            "the",
            "inserted",
            "ad"
        ]
    },
    {
        "id": 142,
        "code": "public static AdPlaybackState updateAdDurationInAdGroup(\n    int adGroupIndex, int adIndexInAdGroup, long adDurationUs, AdPlaybackState adPlaybackState) {\n  AdPlaybackState.AdGroup adGroup = adPlaybackState.getAdGroup(adGroupIndex);\n  checkArgument(adIndexInAdGroup < adGroup.durationsUs.length);\n  long[] adDurationsUs =\n      updateAdDurationAndPropagate(\n          Arrays.copyOf(adGroup.durationsUs, adGroup.durationsUs.length),\n          adIndexInAdGroup,\n          adDurationUs,\n          adGroup.durationsUs[adIndexInAdGroup]);\n  return adPlaybackState.withAdDurationsUs(adGroupIndex, adDurationsUs);\n}",
        "summary_tokens": [
            "updates",
            "the",
            "duration",
            "of",
            "an",
            "ad",
            "in",
            "and",
            "ad",
            "group"
        ]
    },
    {
        "id": 143,
        "code": " static long[] updateAdDurationAndPropagate(\n    long[] adDurationsUs, int adIndex, long adDurationUs, long totalDurationUs) {\n  adDurationsUs[adIndex] = adDurationUs;\n  int nextAdIndex = (adIndex + 1) % adDurationsUs.length;\n  if (adDurationsUs[nextAdIndex] == 0) {\n      \n    adDurationsUs[nextAdIndex] = max(0, totalDurationUs - adDurationUs);\n  }\n  return adDurationsUs;\n}",
        "summary_tokens": [
            "updates",
            "the",
            "duration",
            "of",
            "the",
            "given",
            "ad",
            "in",
            "the",
            "array",
            "and",
            "propagates",
            "the",
            "difference",
            "to",
            "the",
            "total",
            "duration",
            "to",
            "the",
            "next",
            "ad"
        ]
    },
    {
        "id": 144,
        "code": "public static ImmutableMap<Object, AdPlaybackState> splitAdPlaybackStateForPeriods(\n    AdPlaybackState adPlaybackState, Timeline contentTimeline) {\n  Timeline.Period period = new Timeline.Period();\n  if (contentTimeline.getPeriodCount() == 1) {\n      \n    return ImmutableMap.of(\n        checkNotNull(\n            contentTimeline.getPeriod( 0, period,  true).uid),\n        adPlaybackState);\n  }\n\n  int periodIndex = 0;\n  long totalElapsedContentDurationUs = 0;\n  Object adsId = checkNotNull(adPlaybackState.adsId);\n  AdPlaybackState contentOnlyAdPlaybackState = new AdPlaybackState(adsId);\n  Map<Object, AdPlaybackState> adPlaybackStates = new HashMap<>();\n  for (int i = adPlaybackState.removedAdGroupCount; i < adPlaybackState.adGroupCount; i++) {\n    AdPlaybackState.AdGroup adGroup = adPlaybackState.getAdGroup( i);\n    if (adGroup.timeUs == C.TIME_END_OF_SOURCE) {\n      checkState(i == adPlaybackState.adGroupCount - 1);\n        \n      break;\n    }\n      \n      \n    long adGroupDurationUs = sum(adGroup.durationsUs);\n    long elapsedAdGroupAdDurationUs = 0;\n    for (int j = periodIndex; j < contentTimeline.getPeriodCount(); j++) {\n      contentTimeline.getPeriod(j, period,  true);\n      if (totalElapsedContentDurationUs < adGroup.timeUs) {\n          \n        adPlaybackStates.put(checkNotNull(period.uid), contentOnlyAdPlaybackState);\n        totalElapsedContentDurationUs += period.durationUs;\n      } else {\n        long periodStartUs = totalElapsedContentDurationUs + elapsedAdGroupAdDurationUs;\n        if (periodStartUs + period.durationUs <= adGroup.timeUs + adGroupDurationUs) {\n            \n            \n          adPlaybackStates.put(\n              checkNotNull(period.uid),\n              splitAdGroupForPeriod(adsId, adGroup, periodStartUs, period.durationUs));\n          elapsedAdGroupAdDurationUs += period.durationUs;\n        } else {\n            \n          break;\n        }\n      }\n        \n      periodIndex++;\n    }\n  }\n    \n  for (int i = periodIndex; i < contentTimeline.getPeriodCount(); i++) {\n    contentTimeline.getPeriod(i, period,  true);\n    adPlaybackStates.put(checkNotNull(period.uid), contentOnlyAdPlaybackState);\n  }\n  return ImmutableMap.copyOf(adPlaybackStates);\n}",
        "summary_tokens": [
            "splits",
            "an",
            "ad",
            "playback",
            "state",
            "into",
            "a",
            "separate",
            "ad",
            "playback",
            "state",
            "for",
            "each",
            "period",
            "of",
            "a",
            "content",
            "timeline"
        ]
    },
    {
        "id": 145,
        "code": "public static Pair<Integer, Integer> getAdGroupAndIndexInMultiPeriodWindow(\n    int adPeriodIndex, AdPlaybackState adPlaybackState, Timeline contentTimeline) {\n  Timeline.Period period = new Timeline.Period();\n  int periodIndex = 0;\n  long totalElapsedContentDurationUs = 0;\n  for (int i = adPlaybackState.removedAdGroupCount; i < adPlaybackState.adGroupCount; i++) {\n    int adIndexInAdGroup = 0;\n    AdPlaybackState.AdGroup adGroup = adPlaybackState.getAdGroup( i);\n    long adGroupDurationUs = sum(adGroup.durationsUs);\n    long elapsedAdGroupAdDurationUs = 0;\n    for (int j = periodIndex; j < contentTimeline.getPeriodCount(); j++) {\n      contentTimeline.getPeriod(j, period,  true);\n      if (totalElapsedContentDurationUs < adGroup.timeUs) {\n          \n        totalElapsedContentDurationUs += period.durationUs;\n      } else {\n        long periodStartUs = totalElapsedContentDurationUs + elapsedAdGroupAdDurationUs;\n        if (periodStartUs + period.durationUs <= adGroup.timeUs + adGroupDurationUs) {\n            \n          if (j == adPeriodIndex) {\n            return new Pair<>( i, adIndexInAdGroup);\n          }\n          elapsedAdGroupAdDurationUs += period.durationUs;\n          adIndexInAdGroup++;\n        } else {\n            \n          break;\n        }\n      }\n        \n      periodIndex++;\n    }\n  }\n  throw new IllegalStateException();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "ad",
            "group",
            "index",
            "and",
            "the",
            "ad",
            "index",
            "in",
            "ad",
            "group",
            "for",
            "the",
            "given",
            "period",
            "index",
            "of",
            "an",
            "ad",
            "period"
        ]
    },
    {
        "id": 146,
        "code": "public static long secToUsRounded(double timeSec) {\n  return DoubleMath.roundToLong(\n      BigDecimal.valueOf(timeSec).scaleByPowerOfTen(6).doubleValue(), RoundingMode.HALF_UP);\n}",
        "summary_tokens": [
            "converts",
            "a",
            "time",
            "in",
            "seconds",
            "to",
            "the",
            "corresponding",
            "time",
            "in",
            "microseconds"
        ]
    },
    {
        "id": 147,
        "code": "public static long secToMsRounded(double timeSec) {\n  return DoubleMath.roundToLong(\n      BigDecimal.valueOf(timeSec).scaleByPowerOfTen(3).doubleValue(), RoundingMode.HALF_UP);\n}",
        "summary_tokens": [
            "converts",
            "a",
            "time",
            "in",
            "seconds",
            "to",
            "the",
            "corresponding",
            "time",
            "in",
            "milliseconds"
        ]
    },
    {
        "id": 148,
        "code": "public void updateTimeline(Timeline timeline, @TimelineChangeReason int reason) {\n  this.timeline = timeline;\n  listeners.sendEvent(\n      Player.EVENT_TIMELINE_CHANGED, listener -> listener.onTimelineChanged(timeline, reason));\n}",
        "summary_tokens": [
            "sets",
            "the",
            "timeline",
            "on",
            "this",
            "fake",
            "player",
            "which",
            "notifies",
            "listeners",
            "with",
            "the",
            "changed",
            "timeline"
        ]
    },
    {
        "id": 149,
        "code": "public void setPlayingContentPosition(int periodIndex, long positionMs) {\n  boolean notify = isPlayingAd;\n  PositionInfo oldPosition =\n      new PositionInfo(\n          windowUid,\n           0,\n          mediaItem,\n          periodUid,\n           0,\n          this.positionMs,\n          this.contentPositionMs,\n          this.adGroupIndex,\n          this.adIndexInAdGroup);\n  isPlayingAd = false;\n  adGroupIndex = C.INDEX_UNSET;\n  adIndexInAdGroup = C.INDEX_UNSET;\n  this.periodIndex = periodIndex;\n  this.positionMs = positionMs;\n  contentPositionMs = positionMs;\n  if (notify) {\n    PositionInfo newPosition =\n        new PositionInfo(\n            windowUid,\n             0,\n            mediaItem,\n            periodUid,\n             0,\n            positionMs,\n            this.contentPositionMs,\n            this.adGroupIndex,\n            this.adIndexInAdGroup);\n    listeners.sendEvent(\n        Player.EVENT_POSITION_DISCONTINUITY,\n        listener ->\n            listener.onPositionDiscontinuity(\n                oldPosition, newPosition, DISCONTINUITY_REASON_AUTO_TRANSITION));\n  }\n}",
        "summary_tokens": [
            "sets",
            "the",
            "state",
            "of",
            "this",
            "player",
            "as",
            "if",
            "it",
            "were",
            "playing",
            "content",
            "at",
            "the",
            "given",
            "position"
        ]
    },
    {
        "id": 150,
        "code": "public void setPlayingAdPosition(\n    int periodIndex,\n    int adGroupIndex,\n    int adIndexInAdGroup,\n    long positionMs,\n    long contentPositionMs) {\n  boolean notify = !isPlayingAd || this.adIndexInAdGroup != adIndexInAdGroup;\n  PositionInfo oldPosition =\n      new PositionInfo(\n          windowUid,\n           0,\n          mediaItem,\n          periodUid,\n           0,\n          this.positionMs,\n          this.contentPositionMs,\n          this.adGroupIndex,\n          this.adIndexInAdGroup);\n  isPlayingAd = true;\n  this.periodIndex = periodIndex;\n  this.adGroupIndex = adGroupIndex;\n  this.adIndexInAdGroup = adIndexInAdGroup;\n  this.positionMs = positionMs;\n  this.contentPositionMs = contentPositionMs;\n  if (notify) {\n    PositionInfo newPosition =\n        new PositionInfo(\n            windowUid,\n             0,\n            mediaItem,\n            periodUid,\n             0,\n            positionMs,\n            contentPositionMs,\n            adGroupIndex,\n            adIndexInAdGroup);\n    listeners.sendEvent(\n        EVENT_POSITION_DISCONTINUITY,\n        listener ->\n            listener.onPositionDiscontinuity(\n                oldPosition, newPosition, DISCONTINUITY_REASON_AUTO_TRANSITION));\n  }\n}",
        "summary_tokens": [
            "sets",
            "the",
            "state",
            "of",
            "this",
            "player",
            "as",
            "if",
            "it",
            "were",
            "playing",
            "an",
            "ad",
            "with",
            "the",
            "given",
            "indices",
            "at",
            "the",
            "given",
            "position"
        ]
    },
    {
        "id": 151,
        "code": "public void setPlayerError(PlaybackException error) {\n  checkState(state == STATE_BUFFERING || state == STATE_READY);\n  this.state = Player.STATE_IDLE;\n  listeners.sendEvent(\n      Player.EVENT_PLAYBACK_STATE_CHANGED,\n      listener -> {\n        listener.onPlayerError(error);\n        listener.onPlayerErrorChanged(error);\n        listener.onPlayerStateChanged(playWhenReady, state);\n        listener.onPlaybackStateChanged(state);\n      });\n}",
        "summary_tokens": [
            "sets",
            "an",
            "error",
            "on",
            "this",
            "player"
        ]
    },
    {
        "id": 152,
        "code": "public void setErrorMessageProvider(\n    @Nullable ErrorMessageProvider<? super PlaybackException> errorMessageProvider) {\n  this.errorMessageProvider = errorMessageProvider;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "optional",
            "error",
            "message",
            "provider"
        ]
    },
    {
        "id": 153,
        "code": "public SessionCallbackBuilder setRatingCallback(@Nullable RatingCallback ratingCallback) {\n  this.ratingCallback = ratingCallback;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "rating",
            "callback",
            "to",
            "handle",
            "user",
            "ratings"
        ]
    },
    {
        "id": 154,
        "code": "public SessionCallbackBuilder setCustomCommandProvider(\n    @Nullable CustomCommandProvider customCommandProvider) {\n  this.customCommandProvider = customCommandProvider;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "custom",
            "command",
            "provider",
            "to",
            "handle",
            "incoming",
            "custom",
            "commands"
        ]
    },
    {
        "id": 155,
        "code": "public SessionCallbackBuilder setMediaItemProvider(\n    @Nullable MediaItemProvider mediaItemProvider) {\n  this.mediaItemProvider = mediaItemProvider;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "media",
            "item",
            "provider",
            "that",
            "will",
            "convert",
            "media",
            "ids",
            "to",
            "media",
            "item",
            "media",
            "items"
        ]
    },
    {
        "id": 156,
        "code": "public SessionCallbackBuilder setAllowedCommandProvider(\n    @Nullable AllowedCommandProvider allowedCommandProvider) {\n  this.allowedCommandProvider = allowedCommandProvider;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "allowed",
            "command",
            "provider",
            "to",
            "provide",
            "allowed",
            "commands",
            "for",
            "controllers"
        ]
    },
    {
        "id": 157,
        "code": "public SessionCallbackBuilder setSkipCallback(@Nullable SkipCallback skipCallback) {\n  this.skipCallback = skipCallback;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "skip",
            "callback",
            "to",
            "handle",
            "skip",
            "backward",
            "and",
            "skip",
            "forward"
        ]
    },
    {
        "id": 158,
        "code": "public SessionCallbackBuilder setPostConnectCallback(\n    @Nullable PostConnectCallback postConnectCallback) {\n  this.postConnectCallback = postConnectCallback;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "post",
            "connect",
            "callback",
            "to",
            "handle",
            "extra",
            "initialization",
            "after",
            "the",
            "connection"
        ]
    },
    {
        "id": 159,
        "code": "public SessionCallbackBuilder setDisconnectedCallback(\n    @Nullable DisconnectedCallback disconnectedCallback) {\n  this.disconnectedCallback = disconnectedCallback;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "disconnected",
            "callback",
            "to",
            "handle",
            "cleaning",
            "up",
            "controller"
        ]
    },
    {
        "id": 160,
        "code": "public SessionCallbackBuilder setRewindIncrementMs(int rewindMs) {\n  this.rewindMs = rewindMs;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "rewind",
            "increment",
            "in",
            "milliseconds"
        ]
    },
    {
        "id": 161,
        "code": "public SessionCallbackBuilder setFastForwardIncrementMs(int fastForwardMs) {\n  this.fastForwardMs = fastForwardMs;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "fast",
            "forward",
            "increment",
            "in",
            "milliseconds"
        ]
    },
    {
        "id": 162,
        "code": "public SessionCallbackBuilder setSeekTimeoutMs(int seekTimeoutMs) {\n  this.seekTimeoutMs = seekTimeoutMs;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "timeout",
            "in",
            "milliseconds",
            "for",
            "fast",
            "forward",
            "and",
            "rewind",
            "operations",
            "or",
            "0",
            "for",
            "no",
            "timeout"
        ]
    },
    {
        "id": 163,
        "code": "public static AudioAttributes getAudioAttributes(AudioAttributesCompat audioAttributesCompat) {\n  return new AudioAttributes.Builder()\n      .setContentType(audioAttributesCompat.getContentType())\n      .setFlags(audioAttributesCompat.getFlags())\n      .setUsage(audioAttributesCompat.getUsage())\n      .build();\n}",
        "summary_tokens": [
            "returns",
            "exo",
            "player",
            "audio",
            "attributes",
            "for",
            "the",
            "given",
            "audio",
            "attributes"
        ]
    },
    {
        "id": 164,
        "code": "public static AudioAttributesCompat getAudioAttributesCompat(AudioAttributes audioAttributes) {\n  return new AudioAttributesCompat.Builder()\n      .setContentType(audioAttributes.contentType)\n      .setFlags(audioAttributes.flags)\n      .setUsage(audioAttributes.usage)\n      .build();\n}",
        "summary_tokens": [
            "returns",
            "audio",
            "attributes",
            "for",
            "the",
            "given",
            "exo",
            "player",
            "audio",
            "attributes"
        ]
    },
    {
        "id": 165,
        "code": "public static boolean getExoPlayerShuffleMode(int shuffleMode) {\n  switch (shuffleMode) {\n    case SessionPlayer.SHUFFLE_MODE_ALL:\n    case SessionPlayer.SHUFFLE_MODE_GROUP:\n      return true;\n    case SessionPlayer.SHUFFLE_MODE_NONE:\n      return false;\n    default:\n      throw new IllegalArgumentException();\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "simple",
            "exo",
            "player",
            "s",
            "shuffle",
            "mode",
            "for",
            "the",
            "given",
            "shuffle",
            "mode"
        ]
    },
    {
        "id": 166,
        "code": "public static int getShuffleMode(boolean exoPlayerShuffleMode) {\n  return exoPlayerShuffleMode ? SessionPlayer.SHUFFLE_MODE_ALL : SessionPlayer.SHUFFLE_MODE_NONE;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "shuffle",
            "mode",
            "for",
            "the",
            "given",
            "exo",
            "player",
            "s",
            "shuffle",
            "mode"
        ]
    },
    {
        "id": 167,
        "code": "public static int getExoPlayerRepeatMode(int repeatMode) {\n  switch (repeatMode) {\n    case SessionPlayer.REPEAT_MODE_ALL:\n    case SessionPlayer.REPEAT_MODE_GROUP:\n      return Player.REPEAT_MODE_ALL;\n    case SessionPlayer.REPEAT_MODE_ONE:\n      return Player.REPEAT_MODE_ONE;\n    case SessionPlayer.REPEAT_MODE_NONE:\n      return Player.REPEAT_MODE_OFF;\n    default:\n      throw new IllegalArgumentException();\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "exo",
            "player",
            "s",
            "repeat",
            "mode",
            "for",
            "the",
            "given",
            "repeat",
            "mode"
        ]
    },
    {
        "id": 168,
        "code": "public static int getRepeatMode(@Player.RepeatMode int exoPlayerRepeatMode) {\n  switch (exoPlayerRepeatMode) {\n    case Player.REPEAT_MODE_ALL:\n      return SessionPlayer.REPEAT_MODE_ALL;\n    case Player.REPEAT_MODE_ONE:\n      return SessionPlayer.REPEAT_MODE_ONE;\n    case Player.REPEAT_MODE_OFF:\n      return SessionPlayer.REPEAT_MODE_NONE;\n    default:\n      throw new IllegalArgumentException();\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "repeat",
            "mode",
            "for",
            "the",
            "given",
            "simple",
            "exo",
            "player",
            "s",
            "repeat",
            "mode"
        ]
    },
    {
        "id": 169,
        "code": "public void setPlayer(@Nullable Player player) {\n  Assertions.checkArgument(player == null || player.getApplicationLooper() == looper);\n  if (this.player != null) {\n    this.player.removeListener(componentListener);\n  }\n  this.player = player;\n  if (player != null) {\n    player.addListener(componentListener);\n  }\n  invalidateMediaSessionPlaybackState();\n  invalidateMediaSessionMetadata();\n}",
        "summary_tokens": [
            "sets",
            "the",
            "player",
            "to",
            "be",
            "connected",
            "to",
            "the",
            "media",
            "session"
        ]
    },
    {
        "id": 170,
        "code": "public void setPlaybackPreparer(@Nullable PlaybackPreparer playbackPreparer) {\n  if (this.playbackPreparer != playbackPreparer) {\n    unregisterCommandReceiver(this.playbackPreparer);\n    this.playbackPreparer = playbackPreparer;\n    registerCommandReceiver(playbackPreparer);\n    invalidateMediaSessionPlaybackState();\n  }\n}",
        "summary_tokens": [
            "sets",
            "the",
            "playback",
            "preparer"
        ]
    },
    {
        "id": 171,
        "code": "public void setMediaButtonEventHandler(\n    @Nullable MediaButtonEventHandler mediaButtonEventHandler) {\n  this.mediaButtonEventHandler = mediaButtonEventHandler;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "media",
            "button",
            "event",
            "handler"
        ]
    },
    {
        "id": 172,
        "code": "public void setEnabledPlaybackActions(@PlaybackActions long enabledPlaybackActions) {\n  enabledPlaybackActions &= ALL_PLAYBACK_ACTIONS;\n  if (this.enabledPlaybackActions != enabledPlaybackActions) {\n    this.enabledPlaybackActions = enabledPlaybackActions;\n    invalidateMediaSessionPlaybackState();\n  }\n}",
        "summary_tokens": [
            "sets",
            "the",
            "enabled",
            "playback",
            "actions"
        ]
    },
    {
        "id": 173,
        "code": "public void setErrorMessageProvider(\n    @Nullable ErrorMessageProvider<? super PlaybackException> errorMessageProvider) {\n  if (this.errorMessageProvider != errorMessageProvider) {\n    this.errorMessageProvider = errorMessageProvider;\n    invalidateMediaSessionPlaybackState();\n  }\n}",
        "summary_tokens": [
            "sets",
            "the",
            "optional",
            "error",
            "message",
            "provider"
        ]
    },
    {
        "id": 174,
        "code": "public void setQueueNavigator(@Nullable QueueNavigator queueNavigator) {\n  if (this.queueNavigator != queueNavigator) {\n    unregisterCommandReceiver(this.queueNavigator);\n    this.queueNavigator = queueNavigator;\n    registerCommandReceiver(queueNavigator);\n  }\n}",
        "summary_tokens": [
            "sets",
            "the",
            "queue",
            "navigator",
            "to",
            "handle",
            "queue",
            "navigation",
            "actions",
            "action",
            "skip",
            "to",
            "next",
            "action",
            "skip",
            "to",
            "previous",
            "and",
            "action",
            "skip",
            "to",
            "queue",
            "item"
        ]
    },
    {
        "id": 175,
        "code": "public void setQueueEditor(@Nullable QueueEditor queueEditor) {\n  if (this.queueEditor != queueEditor) {\n    unregisterCommandReceiver(this.queueEditor);\n    this.queueEditor = queueEditor;\n    registerCommandReceiver(queueEditor);\n    mediaSession.setFlags(\n        queueEditor == null ? BASE_MEDIA_SESSION_FLAGS : EDITOR_MEDIA_SESSION_FLAGS);\n  }\n}",
        "summary_tokens": [
            "sets",
            "the",
            "queue",
            "editor",
            "to",
            "handle",
            "queue",
            "edits",
            "sent",
            "by",
            "the",
            "media",
            "controller"
        ]
    },
    {
        "id": 176,
        "code": "public void setRatingCallback(@Nullable RatingCallback ratingCallback) {\n  if (this.ratingCallback != ratingCallback) {\n    unregisterCommandReceiver(this.ratingCallback);\n    this.ratingCallback = ratingCallback;\n    registerCommandReceiver(this.ratingCallback);\n  }\n}",
        "summary_tokens": [
            "sets",
            "the",
            "rating",
            "callback",
            "to",
            "handle",
            "user",
            "ratings"
        ]
    },
    {
        "id": 177,
        "code": "public void setCaptionCallback(@Nullable CaptionCallback captionCallback) {\n  if (this.captionCallback != captionCallback) {\n    unregisterCommandReceiver(this.captionCallback);\n    this.captionCallback = captionCallback;\n    registerCommandReceiver(this.captionCallback);\n  }\n}",
        "summary_tokens": [
            "sets",
            "the",
            "caption",
            "callback",
            "to",
            "handle",
            "requests",
            "to",
            "enable",
            "or",
            "disable",
            "captions"
        ]
    },
    {
        "id": 178,
        "code": "public void setCustomErrorMessage(\n    @Nullable CharSequence message, int code, @Nullable Bundle extras) {\n  customError = (message == null) ? null : new Pair<>(code, message);\n  customErrorExtras = (message == null) ? null : extras;\n  invalidateMediaSessionPlaybackState();\n}",
        "summary_tokens": [
            "sets",
            "a",
            "custom",
            "error",
            "on",
            "the",
            "session"
        ]
    },
    {
        "id": 179,
        "code": "public void setCustomActionProviders(@Nullable CustomActionProvider... customActionProviders) {\n  this.customActionProviders =\n      customActionProviders == null ? new CustomActionProvider[0] : customActionProviders;\n  invalidateMediaSessionPlaybackState();\n}",
        "summary_tokens": [
            "sets",
            "custom",
            "action",
            "providers"
        ]
    },
    {
        "id": 180,
        "code": "public void setMediaMetadataProvider(@Nullable MediaMetadataProvider mediaMetadataProvider) {\n  if (this.mediaMetadataProvider != mediaMetadataProvider) {\n    this.mediaMetadataProvider = mediaMetadataProvider;\n    invalidateMediaSessionMetadata();\n  }\n}",
        "summary_tokens": [
            "sets",
            "a",
            "provider",
            "of",
            "metadata",
            "to",
            "be",
            "published",
            "to",
            "the",
            "media",
            "session"
        ]
    },
    {
        "id": 181,
        "code": "public void setDispatchUnsupportedActionsEnabled(boolean dispatchUnsupportedActionsEnabled) {\n  this.dispatchUnsupportedActionsEnabled = dispatchUnsupportedActionsEnabled;\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "actions",
            "that",
            "are",
            "not",
            "advertised",
            "to",
            "the",
            "media",
            "session",
            "compat",
            "will",
            "be",
            "dispatched",
            "either",
            "way"
        ]
    },
    {
        "id": 182,
        "code": "public void setClearMediaItemsOnStop(boolean clearMediaItemsOnStop) {\n  this.clearMediaItemsOnStop = clearMediaItemsOnStop;\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "media",
            "items",
            "are",
            "cleared",
            "from",
            "the",
            "playlist",
            "when",
            "a",
            "client",
            "sends",
            "a",
            "media",
            "controller",
            "compat"
        ]
    },
    {
        "id": 183,
        "code": "public void setMapStateIdleToSessionStateStopped(boolean mapIdleToStopped) {\n  this.mapIdleToStopped = mapIdleToStopped;\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "player",
            "state",
            "idle",
            "should",
            "be",
            "mapped",
            "to",
            "playback",
            "state",
            "compat",
            "state",
            "stopped"
        ]
    },
    {
        "id": 184,
        "code": "public void setMetadataDeduplicationEnabled(boolean metadataDeduplicationEnabled) {\n  this.metadataDeduplicationEnabled = metadataDeduplicationEnabled;\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "media",
            "metadata",
            "provider",
            "same",
            "as",
            "media",
            "metadata",
            "compat",
            "media",
            "metadata",
            "compat",
            "should",
            "be",
            "consulted",
            "before",
            "calling",
            "media",
            "session",
            "compat",
            "set",
            "metadata",
            "media",
            "metadata",
            "compat"
        ]
    },
    {
        "id": 185,
        "code": "public final void invalidateMediaSessionMetadata() {\n  MediaMetadataCompat metadata =\n      mediaMetadataProvider != null && player != null\n          ? mediaMetadataProvider.getMetadata(player)\n          : METADATA_EMPTY;\n  @Nullable MediaMetadataProvider mediaMetadataProvider = this.mediaMetadataProvider;\n  if (metadataDeduplicationEnabled && mediaMetadataProvider != null) {\n    @Nullable MediaMetadataCompat oldMetadata = mediaSession.getController().getMetadata();\n    if (oldMetadata != null && mediaMetadataProvider.sameAs(oldMetadata, metadata)) {\n        \n      return;\n    }\n  }\n  mediaSession.setMetadata(metadata);\n}",
        "summary_tokens": [
            "updates",
            "the",
            "metadata",
            "of",
            "the",
            "media",
            "session"
        ]
    },
    {
        "id": 186,
        "code": "public final void invalidateMediaSessionPlaybackState() {\n  PlaybackStateCompat.Builder builder = new PlaybackStateCompat.Builder();\n  @Nullable Player player = this.player;\n  if (player == null) {\n    builder\n        .setActions(buildPrepareActions())\n        .setState(\n            PlaybackStateCompat.STATE_NONE,\n             0,\n             0,\n             SystemClock.elapsedRealtime());\n\n    mediaSession.setRepeatMode(PlaybackStateCompat.REPEAT_MODE_NONE);\n    mediaSession.setShuffleMode(PlaybackStateCompat.SHUFFLE_MODE_NONE);\n    mediaSession.setPlaybackState(builder.build());\n    return;\n  }\n\n  Map<String, CustomActionProvider> currentActions = new HashMap<>();\n  for (CustomActionProvider customActionProvider : customActionProviders) {\n    @Nullable\n    PlaybackStateCompat.CustomAction customAction = customActionProvider.getCustomAction(player);\n    if (customAction != null) {\n      currentActions.put(customAction.getAction(), customActionProvider);\n      builder.addCustomAction(customAction);\n    }\n  }\n  customActionMap = Collections.unmodifiableMap(currentActions);\n\n  Bundle extras = new Bundle();\n  @Nullable PlaybackException playbackError = player.getPlayerError();\n  boolean reportError = playbackError != null || customError != null;\n  int sessionPlaybackState =\n      reportError\n          ? PlaybackStateCompat.STATE_ERROR\n          : getMediaSessionPlaybackState(player.getPlaybackState(), player.getPlayWhenReady());\n  if (customError != null) {\n    builder.setErrorMessage(customError.first, customError.second);\n    if (customErrorExtras != null) {\n      extras.putAll(customErrorExtras);\n    }\n  } else if (playbackError != null && errorMessageProvider != null) {\n    Pair<Integer, String> message = errorMessageProvider.getErrorMessage(playbackError);\n    builder.setErrorMessage(message.first, message.second);\n  }\n  long activeQueueItemId =\n      queueNavigator != null\n          ? queueNavigator.getActiveQueueItemId(player)\n          : MediaSessionCompat.QueueItem.UNKNOWN_ID;\n  float playbackSpeed = player.getPlaybackParameters().speed;\n  extras.putFloat(EXTRAS_SPEED, playbackSpeed);\n  float sessionPlaybackSpeed = player.isPlaying() ? playbackSpeed : 0f;\n  @Nullable MediaItem currentMediaItem = player.getCurrentMediaItem();\n  if (currentMediaItem != null && !MediaItem.DEFAULT_MEDIA_ID.equals(currentMediaItem.mediaId)) {\n    extras.putString(PLAYBACK_STATE_EXTRAS_KEY_MEDIA_ID, currentMediaItem.mediaId);\n  }\n  builder\n      .setActions(buildPrepareActions() | buildPlaybackActions(player))\n      .setActiveQueueItemId(activeQueueItemId)\n      .setBufferedPosition(player.getBufferedPosition())\n      .setState(\n          sessionPlaybackState,\n          player.getCurrentPosition(),\n          sessionPlaybackSpeed,\n           SystemClock.elapsedRealtime())\n      .setExtras(extras);\n\n  @Player.RepeatMode int repeatMode = player.getRepeatMode();\n  mediaSession.setRepeatMode(\n      repeatMode == Player.REPEAT_MODE_ONE\n          ? PlaybackStateCompat.REPEAT_MODE_ONE\n          : repeatMode == Player.REPEAT_MODE_ALL\n              ? PlaybackStateCompat.REPEAT_MODE_ALL\n              : PlaybackStateCompat.REPEAT_MODE_NONE);\n  mediaSession.setShuffleMode(\n      player.getShuffleModeEnabled()\n          ? PlaybackStateCompat.SHUFFLE_MODE_ALL\n          : PlaybackStateCompat.SHUFFLE_MODE_NONE);\n  mediaSession.setPlaybackState(builder.build());\n}",
        "summary_tokens": [
            "updates",
            "the",
            "playback",
            "state",
            "of",
            "the",
            "media",
            "session"
        ]
    },
    {
        "id": 187,
        "code": "public final void invalidateMediaSessionQueue() {\n  if (queueNavigator != null && player != null) {\n    queueNavigator.onTimelineChanged(player);\n  }\n}",
        "summary_tokens": [
            "updates",
            "the",
            "queue",
            "of",
            "the",
            "media",
            "session",
            "by",
            "calling",
            "queue",
            "navigator",
            "on",
            "timeline",
            "changed",
            "player"
        ]
    },
    {
        "id": 188,
        "code": "public void registerCustomCommandReceiver(@Nullable CommandReceiver commandReceiver) {\n  if (commandReceiver != null && !customCommandReceivers.contains(commandReceiver)) {\n    customCommandReceivers.add(commandReceiver);\n  }\n}",
        "summary_tokens": [
            "registers",
            "a",
            "custom",
            "command",
            "receiver",
            "for",
            "responding",
            "to",
            "commands",
            "delivered",
            "via",
            "media",
            "session",
            "compat"
        ]
    },
    {
        "id": 189,
        "code": "public void unregisterCustomCommandReceiver(@Nullable CommandReceiver commandReceiver) {\n  if (commandReceiver != null) {\n    customCommandReceivers.remove(commandReceiver);\n  }\n}",
        "summary_tokens": [
            "unregisters",
            "a",
            "previously",
            "registered",
            "custom",
            "command",
            "receiver"
        ]
    },
    {
        "id": 190,
        "code": "public void setContentTypePredicate(@Nullable Predicate<String> contentTypePredicate) {\n  this.contentTypePredicate = contentTypePredicate;\n}",
        "summary_tokens": [
            "use",
            "ok",
            "http",
            "data",
            "source"
        ]
    },
    {
        "id": 191,
        "code": "private Response executeCall(Call call) throws IOException {\n  SettableFuture<Response> future = SettableFuture.create();\n  call.enqueue(\n      new Callback() {\n        @Override\n        public void onFailure(Call call, IOException e) {\n          future.setException(e);\n        }\n\n        @Override\n        public void onResponse(Call call, Response response) {\n          future.set(response);\n        }\n      });\n\n  try {\n    return future.get();\n  } catch (InterruptedException e) {\n    call.cancel();\n    throw new InterruptedIOException();\n  } catch (ExecutionException ee) {\n    throw new IOException(ee);\n  }\n}",
        "summary_tokens": [
            "this",
            "method",
            "is",
            "an",
            "interrupt",
            "safe",
            "replacement",
            "of",
            "ok",
            "http",
            "call"
        ]
    },
    {
        "id": 192,
        "code": "private void skipFully(long bytesToSkip, DataSpec dataSpec) throws HttpDataSourceException {\n  if (bytesToSkip == 0) {\n    return;\n  }\n  byte[] skipBuffer = new byte[4096];\n  try {\n    while (bytesToSkip > 0) {\n      int readLength = (int) min(bytesToSkip, skipBuffer.length);\n      int read = castNonNull(responseByteStream).read(skipBuffer, 0, readLength);\n      if (Thread.currentThread().isInterrupted()) {\n        throw new InterruptedIOException();\n      }\n      if (read == -1) {\n        throw new HttpDataSourceException(\n            dataSpec,\n            PlaybackException.ERROR_CODE_IO_READ_POSITION_OUT_OF_RANGE,\n            HttpDataSourceException.TYPE_OPEN);\n      }\n      bytesToSkip -= read;\n      bytesTransferred(read);\n    }\n    return;\n  } catch (IOException e) {\n    if (e instanceof HttpDataSourceException) {\n      throw (HttpDataSourceException) e;\n    } else {\n      throw new HttpDataSourceException(\n          dataSpec,\n          PlaybackException.ERROR_CODE_IO_UNSPECIFIED,\n          HttpDataSourceException.TYPE_OPEN);\n    }\n  }\n}",
        "summary_tokens": [
            "attempts",
            "to",
            "skip",
            "the",
            "specified",
            "number",
            "of",
            "bytes",
            "in",
            "full"
        ]
    },
    {
        "id": 193,
        "code": "private int readInternal(byte[] buffer, int offset, int readLength) throws IOException {\n  if (readLength == 0) {\n    return 0;\n  }\n  if (bytesToRead != C.LENGTH_UNSET) {\n    long bytesRemaining = bytesToRead - bytesRead;\n    if (bytesRemaining == 0) {\n      return C.RESULT_END_OF_INPUT;\n    }\n    readLength = (int) min(readLength, bytesRemaining);\n  }\n\n  int read = castNonNull(responseByteStream).read(buffer, offset, readLength);\n  if (read == -1) {\n    return C.RESULT_END_OF_INPUT;\n  }\n\n  bytesRead += read;\n  bytesTransferred(read);\n  return read;\n}",
        "summary_tokens": [
            "reads",
            "up",
            "to",
            "length",
            "bytes",
            "of",
            "data",
            "and",
            "stores",
            "them",
            "into",
            "buffer",
            "starting",
            "at",
            "index",
            "offset"
        ]
    },
    {
        "id": 194,
        "code": "private void closeConnectionQuietly() {\n  if (response != null) {\n    Assertions.checkNotNull(response.body()).close();\n    response = null;\n  }\n  responseByteStream = null;\n}",
        "summary_tokens": [
            "closes",
            "the",
            "current",
            "connection",
            "quietly",
            "if",
            "there",
            "is",
            "one"
        ]
    },
    {
        "id": 195,
        "code": "public void open_setsCorrectHeaders() throws Exception {\n  MockWebServer mockWebServer = new MockWebServer();\n  mockWebServer.enqueue(new MockResponse());\n\n  String propertyFromFactory = \"fromFactory\";\n  Map<String, String> defaultRequestProperties = new HashMap<>();\n  defaultRequestProperties.put(\"0\", propertyFromFactory);\n  defaultRequestProperties.put(\"1\", propertyFromFactory);\n  defaultRequestProperties.put(\"2\", propertyFromFactory);\n  defaultRequestProperties.put(\"4\", propertyFromFactory);\n  HttpDataSource dataSource =\n      new OkHttpDataSource.Factory(new OkHttpClient())\n          .setDefaultRequestProperties(defaultRequestProperties)\n          .createDataSource();\n\n  String propertyFromSetter = \"fromSetter\";\n  dataSource.setRequestProperty(\"1\", propertyFromSetter);\n  dataSource.setRequestProperty(\"2\", propertyFromSetter);\n  dataSource.setRequestProperty(\"3\", propertyFromSetter);\n  dataSource.setRequestProperty(\"5\", propertyFromSetter);\n\n  String propertyFromDataSpec = \"fromDataSpec\";\n  Map<String, String> dataSpecRequestProperties = new HashMap<>();\n  dataSpecRequestProperties.put(\"2\", propertyFromDataSpec);\n  dataSpecRequestProperties.put(\"3\", propertyFromDataSpec);\n  dataSpecRequestProperties.put(\"4\", propertyFromDataSpec);\n  dataSpecRequestProperties.put(\"6\", propertyFromDataSpec);\n\n  DataSpec dataSpec =\n      new DataSpec.Builder()\n          .setUri(mockWebServer.url(\"/test-path\").toString())\n          .setHttpRequestHeaders(dataSpecRequestProperties)\n          .build();\n\n  dataSource.open(dataSpec);\n\n  Headers headers = mockWebServer.takeRequest(10, SECONDS).getHeaders();\n  assertThat(headers.get(\"0\")).isEqualTo(propertyFromFactory);\n  assertThat(headers.get(\"1\")).isEqualTo(propertyFromSetter);\n  assertThat(headers.get(\"2\")).isEqualTo(propertyFromDataSpec);\n  assertThat(headers.get(\"3\")).isEqualTo(propertyFromDataSpec);\n  assertThat(headers.get(\"4\")).isEqualTo(propertyFromDataSpec);\n  assertThat(headers.get(\"5\")).isEqualTo(propertyFromSetter);\n  assertThat(headers.get(\"6\")).isEqualTo(propertyFromDataSpec);\n}",
        "summary_tokens": [
            "this",
            "test",
            "will",
            "set",
            "http",
            "default",
            "request",
            "parameters",
            "0",
            "in",
            "the",
            "ok",
            "http",
            "data",
            "source",
            "0",
            "via",
            "ok",
            "http",
            "data",
            "source"
        ]
    },
    {
        "id": 196,
        "code": "protected boolean experimentalGetDiscardPaddingEnabled() {\n  return false;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "support",
            "for",
            "padding",
            "removal",
            "from",
            "the",
            "end",
            "of",
            "decoder",
            "output",
            "buffer",
            "should",
            "be",
            "enabled"
        ]
    },
    {
        "id": 197,
        "code": "public void experimentalSetDiscardPaddingEnabled(boolean enabled) {\n  this.experimentalDiscardPaddingEnabled = enabled;\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "discard",
            "padding",
            "is",
            "enabled"
        ]
    },
    {
        "id": 198,
        "code": " static int getChannelCount(byte[] header) {\n  return header[9] & 0xFF;\n}",
        "summary_tokens": [
            "parses",
            "the",
            "channel",
            "count",
            "from",
            "an",
            "opus",
            "identification",
            "header"
        ]
    },
    {
        "id": 199,
        "code": " static int getPreSkipSamples(List<byte[]> initializationData) {\n  if (initializationData.size() == FULL_CODEC_INITIALIZATION_DATA_BUFFER_COUNT) {\n    long codecDelayNs =\n        ByteBuffer.wrap(initializationData.get(1)).order(ByteOrder.nativeOrder()).getLong();\n    return (int) ((codecDelayNs * SAMPLE_RATE) / C.NANOS_PER_SECOND);\n  }\n    \n  byte[] headerData = initializationData.get(0);\n  return ((headerData[11] & 0xFF) << 8) | (headerData[10] & 0xFF);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "pre",
            "skip",
            "samples",
            "specified",
            "by",
            "the",
            "given",
            "opus",
            "codec",
            "initialization",
            "data"
        ]
    },
    {
        "id": 200,
        "code": " static int getSeekPreRollSamples(List<byte[]> initializationData) {\n  if (initializationData.size() == FULL_CODEC_INITIALIZATION_DATA_BUFFER_COUNT) {\n    long seekPreRollNs =\n        ByteBuffer.wrap(initializationData.get(2)).order(ByteOrder.nativeOrder()).getLong();\n    return (int) ((seekPreRollNs * SAMPLE_RATE) / C.NANOS_PER_SECOND);\n  }\n    \n  return DEFAULT_SEEK_PRE_ROLL_SAMPLES;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "seek",
            "per",
            "roll",
            "samples",
            "specified",
            "by",
            "the",
            "given",
            "opus",
            "codec",
            "initialization",
            "data"
        ]
    },
    {
        "id": 201,
        "code": " static int getDiscardPaddingSamples(@Nullable ByteBuffer supplementalData) {\n  if (supplementalData == null || supplementalData.remaining() != 8) {\n    return 0;\n  }\n  long discardPaddingNs = supplementalData.order(ByteOrder.LITTLE_ENDIAN).getLong();\n  if (discardPaddingNs < 0) {\n    return 0;\n  }\n  return (int) ((discardPaddingNs * SAMPLE_RATE) / C.NANOS_PER_SECOND);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "discard",
            "padding",
            "samples",
            "specified",
            "by",
            "the",
            "supplemental",
            "data",
            "attached",
            "to",
            "an",
            "input",
            "buffer"
        ]
    },
    {
        "id": 202,
        "code": "private static int samplesToBytes(int samples, int channelCount, boolean outputFloat) {\n  int bytesPerChannel = outputFloat ? 4 : 2;\n  return samples * channelCount * bytesPerChannel;\n}",
        "summary_tokens": [
            "returns",
            "number",
            "of",
            "bytes",
            "to",
            "represent",
            "samples"
        ]
    },
    {
        "id": 203,
        "code": "public static void setLibraries(@C.CryptoType int cryptoType, String... libraries) {\n  OpusLibrary.cryptoType = cryptoType;\n  LOADER.setLibraries(libraries);\n}",
        "summary_tokens": [
            "override",
            "the",
            "names",
            "of",
            "the",
            "opus",
            "native",
            "libraries"
        ]
    },
    {
        "id": 204,
        "code": "public static boolean isAvailable() {\n  return LOADER.isAvailable();\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "underlying",
            "library",
            "is",
            "available",
            "loading",
            "it",
            "if",
            "necessary"
        ]
    },
    {
        "id": 205,
        "code": "public static String getVersion() {\n  return isAvailable() ? opusGetVersion() : null;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "version",
            "of",
            "the",
            "underlying",
            "library",
            "if",
            "available",
            "or",
            "null",
            "otherwise"
        ]
    },
    {
        "id": 206,
        "code": "public static boolean supportsCryptoType(@C.CryptoType int cryptoType) {\n  return cryptoType == C.CRYPTO_TYPE_NONE\n      || (cryptoType != C.CRYPTO_TYPE_UNSUPPORTED && cryptoType == OpusLibrary.cryptoType);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "library",
            "supports",
            "the",
            "given",
            "c"
        ]
    },
    {
        "id": 207,
        "code": "public void setOutputMode(@C.VideoOutputMode int outputMode) {\n  this.outputMode = outputMode;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "output",
            "mode",
            "for",
            "frames",
            "rendered",
            "by",
            "the",
            "decoder"
        ]
    },
    {
        "id": 208,
        "code": "public void renderToSurface(VideoDecoderOutputBuffer outputBuffer, Surface surface)\n    throws VpxDecoderException {\n  int getFrameResult = vpxRenderFrame(vpxDecContext, surface, outputBuffer);\n  if (getFrameResult == -1) {\n    throw new VpxDecoderException(\"Buffer render failed.\");\n  }\n}",
        "summary_tokens": [
            "renders",
            "the",
            "output",
            "buffer",
            "to",
            "the",
            "surface"
        ]
    },
    {
        "id": 209,
        "code": "public static void setLibraries(@C.CryptoType int cryptoType, String... libraries) {\n  VpxLibrary.cryptoType = cryptoType;\n  LOADER.setLibraries(libraries);\n}",
        "summary_tokens": [
            "override",
            "the",
            "names",
            "of",
            "the",
            "vpx",
            "native",
            "libraries"
        ]
    },
    {
        "id": 210,
        "code": "public static boolean isAvailable() {\n  return LOADER.isAvailable();\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "underlying",
            "library",
            "is",
            "available",
            "loading",
            "it",
            "if",
            "necessary"
        ]
    },
    {
        "id": 211,
        "code": "public static String getVersion() {\n  return isAvailable() ? vpxGetVersion() : null;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "version",
            "of",
            "the",
            "underlying",
            "library",
            "if",
            "available",
            "or",
            "null",
            "otherwise"
        ]
    },
    {
        "id": 212,
        "code": "public static String getBuildConfig() {\n  return isAvailable() ? vpxGetBuildConfig() : null;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "configuration",
            "string",
            "with",
            "which",
            "the",
            "underlying",
            "library",
            "was",
            "built",
            "if",
            "available",
            "or",
            "null",
            "otherwise"
        ]
    },
    {
        "id": 213,
        "code": "public static boolean isHighBitDepthSupported() {\n  String config = getBuildConfig();\n  int indexHbd = config != null ? config.indexOf(\"--enable-vp9-highbitdepth\") : -1;\n  return indexHbd >= 0;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "the",
            "underlying",
            "libvpx",
            "library",
            "supports",
            "high",
            "bit",
            "depth"
        ]
    },
    {
        "id": 214,
        "code": "public static boolean supportsCryptoType(@C.CryptoType int cryptoType) {\n  return cryptoType == C.CRYPTO_TYPE_NONE\n      || (cryptoType != C.CRYPTO_TYPE_UNSUPPORTED && cryptoType == VpxLibrary.cryptoType);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "library",
            "supports",
            "the",
            "given",
            "c"
        ]
    },
    {
        "id": 215,
        "code": "public final boolean hasPrevious() {\n  return hasPreviousMediaItem();\n}",
        "summary_tokens": [
            "use",
            "has",
            "previous",
            "media",
            "item",
            "instead"
        ]
    },
    {
        "id": 216,
        "code": "public final boolean hasPreviousWindow() {\n  return hasPreviousMediaItem();\n}",
        "summary_tokens": [
            "use",
            "has",
            "previous",
            "media",
            "item",
            "instead"
        ]
    },
    {
        "id": 217,
        "code": "public final void previous() {\n  seekToPreviousMediaItem();\n}",
        "summary_tokens": [
            "use",
            "seek",
            "to",
            "previous",
            "media",
            "item",
            "instead"
        ]
    },
    {
        "id": 218,
        "code": "public final void seekToPreviousWindow() {\n  seekToPreviousMediaItem();\n}",
        "summary_tokens": [
            "use",
            "seek",
            "to",
            "previous",
            "media",
            "item",
            "instead"
        ]
    },
    {
        "id": 219,
        "code": "public final boolean hasNext() {\n  return hasNextMediaItem();\n}",
        "summary_tokens": [
            "use",
            "has",
            "next",
            "media",
            "item",
            "instead"
        ]
    },
    {
        "id": 220,
        "code": "public final boolean hasNextWindow() {\n  return hasNextMediaItem();\n}",
        "summary_tokens": [
            "use",
            "has",
            "next",
            "media",
            "item",
            "instead"
        ]
    },
    {
        "id": 221,
        "code": "public final void next() {\n  seekToNextMediaItem();\n}",
        "summary_tokens": [
            "use",
            "seek",
            "to",
            "next",
            "media",
            "item",
            "instead"
        ]
    },
    {
        "id": 222,
        "code": "public final void seekToNextWindow() {\n  seekToNextMediaItem();\n}",
        "summary_tokens": [
            "use",
            "seek",
            "to",
            "next",
            "media",
            "item",
            "instead"
        ]
    },
    {
        "id": 223,
        "code": "public final int getCurrentWindowIndex() {\n  return getCurrentMediaItemIndex();\n}",
        "summary_tokens": [
            "use",
            "get",
            "current",
            "media",
            "item",
            "index",
            "instead"
        ]
    },
    {
        "id": 224,
        "code": "public final int getNextWindowIndex() {\n  return getNextMediaItemIndex();\n}",
        "summary_tokens": [
            "use",
            "get",
            "next",
            "media",
            "item",
            "index",
            "instead"
        ]
    },
    {
        "id": 225,
        "code": "public final int getPreviousWindowIndex() {\n  return getPreviousMediaItemIndex();\n}",
        "summary_tokens": [
            "use",
            "get",
            "previous",
            "media",
            "item",
            "index",
            "instead"
        ]
    },
    {
        "id": 226,
        "code": "public final boolean isCurrentWindowDynamic() {\n  return isCurrentMediaItemDynamic();\n}",
        "summary_tokens": [
            "use",
            "is",
            "current",
            "media",
            "item",
            "dynamic",
            "instead"
        ]
    },
    {
        "id": 227,
        "code": "public final boolean isCurrentWindowLive() {\n  return isCurrentMediaItemLive();\n}",
        "summary_tokens": [
            "use",
            "is",
            "current",
            "media",
            "item",
            "live",
            "instead"
        ]
    },
    {
        "id": 228,
        "code": "public final boolean isCurrentWindowSeekable() {\n  return isCurrentMediaItemSeekable();\n}",
        "summary_tokens": [
            "use",
            "is",
            "current",
            "media",
            "item",
            "seekable",
            "instead"
        ]
    },
    {
        "id": 229,
        "code": "public static ImmutableList<Bundle> getList(IBinder binder) {\n  ImmutableList.Builder<Bundle> builder = ImmutableList.builder();\n\n  int index = 0;\n  int replyCode = REPLY_CONTINUE;\n\n  while (replyCode != REPLY_END_OF_LIST) {\n    Parcel data = Parcel.obtain();\n    Parcel reply = Parcel.obtain();\n    try {\n      data.writeInt(index);\n      try {\n        binder.transact(FIRST_CALL_TRANSACTION, data, reply,  0);\n      } catch (RemoteException e) {\n        throw new RuntimeException(e);\n      }\n      while ((replyCode = reply.readInt()) == REPLY_CONTINUE) {\n        builder.add(checkNotNull(reply.readBundle()));\n        index++;\n      }\n    } finally {\n      reply.recycle();\n      data.recycle();\n    }\n  }\n\n  return builder.build();\n}",
        "summary_tokens": [
            "gets",
            "a",
            "list",
            "of",
            "bundle",
            "bundles",
            "from",
            "a",
            "bundle",
            "list",
            "retriever"
        ]
    },
    {
        "id": 230,
        "code": "public static long usToMs(long timeUs) {\n  return Util.usToMs(timeUs);\n}",
        "summary_tokens": [
            "use",
            "util",
            "us",
            "to",
            "ms",
            "long"
        ]
    },
    {
        "id": 231,
        "code": "public static long msToUs(long timeMs) {\n  return Util.msToUs(timeMs);\n}",
        "summary_tokens": [
            "use",
            "util",
            "ms",
            "to",
            "us",
            "long"
        ]
    },
    {
        "id": 232,
        "code": "public static int generateAudioSessionIdV21(Context context) {\n  return Util.generateAudioSessionIdV21(context);\n}",
        "summary_tokens": [
            "use",
            "util",
            "generate",
            "audio",
            "session",
            "id",
            "v",
            "0",
            "context"
        ]
    },
    {
        "id": 233,
        "code": "public static String getFormatSupportString(@FormatSupport int formatSupport) {\n  return Util.getFormatSupportString(formatSupport);\n}",
        "summary_tokens": [
            "use",
            "util",
            "get",
            "format",
            "support",
            "string",
            "int"
        ]
    },
    {
        "id": 234,
        "code": "public static @PlaybackException.ErrorCode int getErrorCodeForMediaDrmErrorCode(\n    int mediaDrmErrorCode) {\n  return Util.getErrorCodeForMediaDrmErrorCode(mediaDrmErrorCode);\n}",
        "summary_tokens": [
            "use",
            "util",
            "get",
            "error",
            "code",
            "for",
            "media",
            "drm",
            "error",
            "code",
            "int"
        ]
    },
    {
        "id": 235,
        "code": "public static synchronized String registeredModules() {\n  return registeredModulesString;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "string",
            "consisting",
            "of",
            "registered",
            "module",
            "names",
            "separated",
            "by"
        ]
    },
    {
        "id": 236,
        "code": "public static synchronized void registerModule(String name) {\n  if (registeredModules.add(name)) {\n    registeredModulesString = registeredModulesString + \", \" + name;\n  }\n}",
        "summary_tokens": [
            "registers",
            "a",
            "module",
            "to",
            "be",
            "returned",
            "in",
            "the",
            "registered",
            "modules",
            "string"
        ]
    },
    {
        "id": 237,
        "code": "public Format copyWithMaxInputSize(int maxInputSize) {\n  return buildUpon().setMaxInputSize(maxInputSize).build();\n}",
        "summary_tokens": [
            "use",
            "build",
            "upon",
            "and",
            "builder",
            "set",
            "max",
            "input",
            "size",
            "int"
        ]
    },
    {
        "id": 238,
        "code": "public Format copyWithSubsampleOffsetUs(long subsampleOffsetUs) {\n  return buildUpon().setSubsampleOffsetUs(subsampleOffsetUs).build();\n}",
        "summary_tokens": [
            "use",
            "build",
            "upon",
            "and",
            "builder",
            "set",
            "subsample",
            "offset",
            "us",
            "long"
        ]
    },
    {
        "id": 239,
        "code": "public Format copyWithLabel(@Nullable String label) {\n  return buildUpon().setLabel(label).build();\n}",
        "summary_tokens": [
            "use",
            "build",
            "upon",
            "and",
            "builder",
            "set",
            "label",
            "string"
        ]
    },
    {
        "id": 240,
        "code": "public Format copyWithManifestFormatInfo(Format manifestFormat) {\n  return withManifestFormatInfo(manifestFormat);\n}",
        "summary_tokens": [
            "use",
            "with",
            "manifest",
            "format",
            "info",
            "format"
        ]
    },
    {
        "id": 241,
        "code": "public Format copyWithGaplessInfo(int encoderDelay, int encoderPadding) {\n  return buildUpon().setEncoderDelay(encoderDelay).setEncoderPadding(encoderPadding).build();\n}",
        "summary_tokens": [
            "use",
            "build",
            "upon",
            "builder",
            "set",
            "encoder",
            "delay",
            "int",
            "and",
            "builder",
            "set",
            "encoder",
            "padding",
            "int"
        ]
    },
    {
        "id": 242,
        "code": "public Format copyWithFrameRate(float frameRate) {\n  return buildUpon().setFrameRate(frameRate).build();\n}",
        "summary_tokens": [
            "use",
            "build",
            "upon",
            "and",
            "builder",
            "set",
            "frame",
            "rate",
            "float"
        ]
    },
    {
        "id": 243,
        "code": "public Format copyWithDrmInitData(@Nullable DrmInitData drmInitData) {\n  return buildUpon().setDrmInitData(drmInitData).build();\n}",
        "summary_tokens": [
            "use",
            "build",
            "upon",
            "and",
            "builder",
            "set",
            "drm",
            "init",
            "data",
            "drm",
            "init",
            "data"
        ]
    },
    {
        "id": 244,
        "code": "public Format copyWithMetadata(@Nullable Metadata metadata) {\n  return buildUpon().setMetadata(metadata).build();\n}",
        "summary_tokens": [
            "use",
            "build",
            "upon",
            "and",
            "builder",
            "set",
            "metadata",
            "metadata"
        ]
    },
    {
        "id": 245,
        "code": "public Format copyWithBitrate(int bitrate) {\n  return buildUpon().setAverageBitrate(bitrate).setPeakBitrate(bitrate).build();\n}",
        "summary_tokens": [
            "use",
            "build",
            "upon",
            "and",
            "builder",
            "set",
            "average",
            "bitrate",
            "int",
            "and",
            "builder",
            "set",
            "peak",
            "bitrate",
            "int"
        ]
    },
    {
        "id": 246,
        "code": "public Format copyWithVideoSize(int width, int height) {\n  return buildUpon().setWidth(width).setHeight(height).build();\n}",
        "summary_tokens": [
            "use",
            "build",
            "upon",
            "builder",
            "set",
            "width",
            "int",
            "and",
            "builder",
            "set",
            "height",
            "int"
        ]
    },
    {
        "id": 247,
        "code": "public Format copyWithCryptoType(@C.CryptoType int cryptoType) {\n  return buildUpon().setCryptoType(cryptoType).build();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "copy",
            "of",
            "this",
            "format",
            "with",
            "the",
            "specified",
            "crypto",
            "type"
        ]
    },
    {
        "id": 248,
        "code": "public int getPixelCount() {\n  return width == NO_VALUE || height == NO_VALUE ? NO_VALUE : (width * height);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "pixels",
            "if",
            "this",
            "is",
            "a",
            "video",
            "format",
            "whose",
            "width",
            "and",
            "height",
            "are",
            "known",
            "or",
            "no",
            "value",
            "otherwise"
        ]
    },
    {
        "id": 249,
        "code": "public boolean initializationDataEquals(Format other) {\n  if (initializationData.size() != other.initializationData.size()) {\n    return false;\n  }\n  for (int i = 0; i < initializationData.size(); i++) {\n    if (!Arrays.equals(initializationData.get(i), other.initializationData.get(i))) {\n      return false;\n    }\n  }\n  return true;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "initialization",
            "data",
            "s",
            "belonging",
            "to",
            "this",
            "format",
            "and",
            "other",
            "are",
            "equal"
        ]
    },
    {
        "id": 250,
        "code": "public static String toLogString(@Nullable Format format) {\n  if (format == null) {\n    return \"null\";\n  }\n  StringBuilder builder = new StringBuilder();\n  builder.append(\"id=\").append(format.id).append(\", mimeType=\").append(format.sampleMimeType);\n  if (format.bitrate != NO_VALUE) {\n    builder.append(\", bitrate=\").append(format.bitrate);\n  }\n  if (format.codecs != null) {\n    builder.append(\", codecs=\").append(format.codecs);\n  }\n  if (format.drmInitData != null) {\n    Set<String> schemes = new LinkedHashSet<>();\n    for (int i = 0; i < format.drmInitData.schemeDataCount; i++) {\n      UUID schemeUuid = format.drmInitData.get(i).uuid;\n      if (schemeUuid.equals(C.COMMON_PSSH_UUID)) {\n        schemes.add(\"cenc\");\n      } else if (schemeUuid.equals(C.CLEARKEY_UUID)) {\n        schemes.add(\"clearkey\");\n      } else if (schemeUuid.equals(C.PLAYREADY_UUID)) {\n        schemes.add(\"playready\");\n      } else if (schemeUuid.equals(C.WIDEVINE_UUID)) {\n        schemes.add(\"widevine\");\n      } else if (schemeUuid.equals(C.UUID_NIL)) {\n        schemes.add(\"universal\");\n      } else {\n        schemes.add(\"unknown (\" + schemeUuid + \")\");\n      }\n    }\n    builder.append(\", drm=[\");\n    Joiner.on(',').appendTo(builder, schemes);\n    builder.append(']');\n  }\n  if (format.width != NO_VALUE && format.height != NO_VALUE) {\n    builder.append(\", res=\").append(format.width).append(\"x\").append(format.height);\n  }\n  if (format.frameRate != NO_VALUE) {\n    builder.append(\", fps=\").append(format.frameRate);\n  }\n  if (format.channelCount != NO_VALUE) {\n    builder.append(\", channels=\").append(format.channelCount);\n  }\n  if (format.sampleRate != NO_VALUE) {\n    builder.append(\", sample_rate=\").append(format.sampleRate);\n  }\n  if (format.language != null) {\n    builder.append(\", language=\").append(format.language);\n  }\n  if (format.label != null) {\n    builder.append(\", label=\").append(format.label);\n  }\n  if (format.selectionFlags != 0) {\n    List<String> selectionFlags = new ArrayList<>();\n      \n    if ((format.selectionFlags & C.SELECTION_FLAG_AUTOSELECT) != 0) {\n      selectionFlags.add(\"auto\");\n    }\n    if ((format.selectionFlags & C.SELECTION_FLAG_DEFAULT) != 0) {\n      selectionFlags.add(\"default\");\n    }\n    if ((format.selectionFlags & C.SELECTION_FLAG_FORCED) != 0) {\n      selectionFlags.add(\"forced\");\n    }\n    builder.append(\", selectionFlags=[\");\n    Joiner.on(',').appendTo(builder, selectionFlags);\n    builder.append(\"]\");\n  }\n  if (format.roleFlags != 0) {\n      \n    List<String> roleFlags = new ArrayList<>();\n    if ((format.roleFlags & C.ROLE_FLAG_MAIN) != 0) {\n      roleFlags.add(\"main\");\n    }\n    if ((format.roleFlags & C.ROLE_FLAG_ALTERNATE) != 0) {\n      roleFlags.add(\"alt\");\n    }\n    if ((format.roleFlags & C.ROLE_FLAG_SUPPLEMENTARY) != 0) {\n      roleFlags.add(\"supplementary\");\n    }\n    if ((format.roleFlags & C.ROLE_FLAG_COMMENTARY) != 0) {\n      roleFlags.add(\"commentary\");\n    }\n    if ((format.roleFlags & C.ROLE_FLAG_DUB) != 0) {\n      roleFlags.add(\"dub\");\n    }\n    if ((format.roleFlags & C.ROLE_FLAG_EMERGENCY) != 0) {\n      roleFlags.add(\"emergency\");\n    }\n    if ((format.roleFlags & C.ROLE_FLAG_CAPTION) != 0) {\n      roleFlags.add(\"caption\");\n    }\n    if ((format.roleFlags & C.ROLE_FLAG_SUBTITLE) != 0) {\n      roleFlags.add(\"subtitle\");\n    }\n    if ((format.roleFlags & C.ROLE_FLAG_SIGN) != 0) {\n      roleFlags.add(\"sign\");\n    }\n    if ((format.roleFlags & C.ROLE_FLAG_DESCRIBES_VIDEO) != 0) {\n      roleFlags.add(\"describes-video\");\n    }\n    if ((format.roleFlags & C.ROLE_FLAG_DESCRIBES_MUSIC_AND_SOUND) != 0) {\n      roleFlags.add(\"describes-music\");\n    }\n    if ((format.roleFlags & C.ROLE_FLAG_ENHANCED_DIALOG_INTELLIGIBILITY) != 0) {\n      roleFlags.add(\"enhanced-intelligibility\");\n    }\n    if ((format.roleFlags & C.ROLE_FLAG_TRANSCRIBES_DIALOG) != 0) {\n      roleFlags.add(\"transcribes-dialog\");\n    }\n    if ((format.roleFlags & C.ROLE_FLAG_EASY_TO_READ) != 0) {\n      roleFlags.add(\"easy-read\");\n    }\n    if ((format.roleFlags & C.ROLE_FLAG_TRICK_PLAY) != 0) {\n      roleFlags.add(\"trick-play\");\n    }\n    builder.append(\", roleFlags=[\");\n    Joiner.on(',').appendTo(builder, roleFlags);\n    builder.append(\"]\");\n  }\n  return builder.toString();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "prettier",
            "string",
            "than",
            "to",
            "string",
            "intended",
            "for",
            "logging"
        ]
    },
    {
        "id": 251,
        "code": "public Looper getApplicationLooper() {\n  return player.getApplicationLooper();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "get",
            "application",
            "looper",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 252,
        "code": "public void addListener(Listener listener) {\n  player.addListener(new ForwardingListener(this, listener));\n}",
        "summary_tokens": [
            "calls",
            "player",
            "add",
            "listener",
            "listener",
            "on",
            "the",
            "delegate"
        ]
    },
    {
        "id": 253,
        "code": "public void removeListener(Listener listener) {\n  player.removeListener(new ForwardingListener(this, listener));\n}",
        "summary_tokens": [
            "calls",
            "player",
            "remove",
            "listener",
            "listener",
            "on",
            "the",
            "delegate"
        ]
    },
    {
        "id": 254,
        "code": "public void setMediaItems(List<MediaItem> mediaItems, int startIndex, long startPositionMs) {\n  player.setMediaItems(mediaItems, startIndex, startPositionMs);\n}",
        "summary_tokens": [
            "calls",
            "player",
            "set",
            "media",
            "items",
            "list",
            "int",
            "long",
            "on",
            "the",
            "delegate"
        ]
    },
    {
        "id": 255,
        "code": "public void setMediaItem(MediaItem mediaItem, boolean resetPosition) {\n  player.setMediaItem(mediaItem, resetPosition);\n}",
        "summary_tokens": [
            "calls",
            "player",
            "set",
            "media",
            "item",
            "media",
            "item",
            "boolean",
            "on",
            "the",
            "delegate"
        ]
    },
    {
        "id": 256,
        "code": "public void addMediaItem(int index, MediaItem mediaItem) {\n  player.addMediaItem(index, mediaItem);\n}",
        "summary_tokens": [
            "calls",
            "player",
            "add",
            "media",
            "item",
            "int",
            "media",
            "item",
            "on",
            "the",
            "delegate"
        ]
    },
    {
        "id": 257,
        "code": "public void addMediaItems(int index, List<MediaItem> mediaItems) {\n  player.addMediaItems(index, mediaItems);\n}",
        "summary_tokens": [
            "calls",
            "player",
            "add",
            "media",
            "items",
            "int",
            "list",
            "on",
            "the",
            "delegate"
        ]
    },
    {
        "id": 258,
        "code": "public void moveMediaItem(int currentIndex, int newIndex) {\n  player.moveMediaItem(currentIndex, newIndex);\n}",
        "summary_tokens": [
            "calls",
            "player",
            "move",
            "media",
            "item",
            "int",
            "int",
            "on",
            "the",
            "delegate"
        ]
    },
    {
        "id": 259,
        "code": "public void moveMediaItems(int fromIndex, int toIndex, int newIndex) {\n  player.moveMediaItems(fromIndex, toIndex, newIndex);\n}",
        "summary_tokens": [
            "calls",
            "player",
            "move",
            "media",
            "items",
            "int",
            "int",
            "int",
            "on",
            "the",
            "delegate"
        ]
    },
    {
        "id": 260,
        "code": "public void removeMediaItem(int index) {\n  player.removeMediaItem(index);\n}",
        "summary_tokens": [
            "calls",
            "player",
            "remove",
            "media",
            "item",
            "int",
            "on",
            "the",
            "delegate"
        ]
    },
    {
        "id": 261,
        "code": "public void removeMediaItems(int fromIndex, int toIndex) {\n  player.removeMediaItems(fromIndex, toIndex);\n}",
        "summary_tokens": [
            "calls",
            "player",
            "remove",
            "media",
            "items",
            "int",
            "int",
            "on",
            "the",
            "delegate"
        ]
    },
    {
        "id": 262,
        "code": "public void clearMediaItems() {\n  player.clearMediaItems();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "clear",
            "media",
            "items",
            "on",
            "the",
            "delegate"
        ]
    },
    {
        "id": 263,
        "code": "public boolean isCommandAvailable(@Command int command) {\n  return player.isCommandAvailable(command);\n}",
        "summary_tokens": [
            "calls",
            "player",
            "is",
            "command",
            "available",
            "int",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 264,
        "code": "public boolean canAdvertiseSession() {\n  return player.canAdvertiseSession();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "can",
            "advertise",
            "session",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 265,
        "code": "public Commands getAvailableCommands() {\n  return player.getAvailableCommands();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "get",
            "available",
            "commands",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 266,
        "code": "public void prepare() {\n  player.prepare();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "prepare",
            "on",
            "the",
            "delegate"
        ]
    },
    {
        "id": 267,
        "code": "public int getPlaybackState() {\n  return player.getPlaybackState();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "get",
            "playback",
            "state",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 268,
        "code": "public int getPlaybackSuppressionReason() {\n  return player.getPlaybackSuppressionReason();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "get",
            "playback",
            "suppression",
            "reason",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 269,
        "code": "public boolean isPlaying() {\n  return player.isPlaying();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "is",
            "playing",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 270,
        "code": "public PlaybackException getPlayerError() {\n  return player.getPlayerError();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "get",
            "player",
            "error",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 271,
        "code": "public void play() {\n  player.play();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "play",
            "on",
            "the",
            "delegate"
        ]
    },
    {
        "id": 272,
        "code": "public void pause() {\n  player.pause();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "pause",
            "on",
            "the",
            "delegate"
        ]
    },
    {
        "id": 273,
        "code": "public void setPlayWhenReady(boolean playWhenReady) {\n  player.setPlayWhenReady(playWhenReady);\n}",
        "summary_tokens": [
            "calls",
            "player",
            "set",
            "play",
            "when",
            "ready",
            "boolean",
            "on",
            "the",
            "delegate"
        ]
    },
    {
        "id": 274,
        "code": "public boolean getPlayWhenReady() {\n  return player.getPlayWhenReady();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "get",
            "play",
            "when",
            "ready",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 275,
        "code": "public void setRepeatMode(@RepeatMode int repeatMode) {\n  player.setRepeatMode(repeatMode);\n}",
        "summary_tokens": [
            "calls",
            "player",
            "set",
            "repeat",
            "mode",
            "int",
            "on",
            "the",
            "delegate"
        ]
    },
    {
        "id": 276,
        "code": "public int getRepeatMode() {\n  return player.getRepeatMode();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "get",
            "repeat",
            "mode",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 277,
        "code": "public void setShuffleModeEnabled(boolean shuffleModeEnabled) {\n  player.setShuffleModeEnabled(shuffleModeEnabled);\n}",
        "summary_tokens": [
            "calls",
            "player",
            "set",
            "shuffle",
            "mode",
            "enabled",
            "boolean",
            "on",
            "the",
            "delegate"
        ]
    },
    {
        "id": 278,
        "code": "public boolean getShuffleModeEnabled() {\n  return player.getShuffleModeEnabled();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "get",
            "shuffle",
            "mode",
            "enabled",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 279,
        "code": "public boolean isLoading() {\n  return player.isLoading();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "is",
            "loading",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 280,
        "code": "public void seekToDefaultPosition(int mediaItemIndex) {\n  player.seekToDefaultPosition(mediaItemIndex);\n}",
        "summary_tokens": [
            "calls",
            "player",
            "seek",
            "to",
            "default",
            "position",
            "int",
            "on",
            "the",
            "delegate"
        ]
    },
    {
        "id": 281,
        "code": "public void seekTo(int mediaItemIndex, long positionMs) {\n  player.seekTo(mediaItemIndex, positionMs);\n}",
        "summary_tokens": [
            "calls",
            "player",
            "seek",
            "to",
            "int",
            "long",
            "on",
            "the",
            "delegate"
        ]
    },
    {
        "id": 282,
        "code": "public long getSeekBackIncrement() {\n  return player.getSeekBackIncrement();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "get",
            "seek",
            "back",
            "increment",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 283,
        "code": "public void seekBack() {\n  player.seekBack();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "seek",
            "back",
            "on",
            "the",
            "delegate"
        ]
    },
    {
        "id": 284,
        "code": "public long getSeekForwardIncrement() {\n  return player.getSeekForwardIncrement();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "get",
            "seek",
            "forward",
            "increment",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 285,
        "code": "public void seekForward() {\n  player.seekForward();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "seek",
            "forward",
            "on",
            "the",
            "delegate"
        ]
    },
    {
        "id": 286,
        "code": "public boolean hasPrevious() {\n  return player.hasPrevious();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "has",
            "previous",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 287,
        "code": "public boolean hasPreviousWindow() {\n  return player.hasPreviousWindow();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "has",
            "previous",
            "window",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 288,
        "code": "public boolean hasPreviousMediaItem() {\n  return player.hasPreviousMediaItem();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "has",
            "previous",
            "media",
            "item",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 289,
        "code": "public void previous() {\n  player.previous();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "previous",
            "on",
            "the",
            "delegate"
        ]
    },
    {
        "id": 290,
        "code": "public void seekToPreviousWindow() {\n  player.seekToPreviousWindow();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "seek",
            "to",
            "previous",
            "window",
            "on",
            "the",
            "delegate"
        ]
    },
    {
        "id": 291,
        "code": "public void seekToPreviousMediaItem() {\n  player.seekToPreviousMediaItem();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "seek",
            "to",
            "previous",
            "media",
            "item",
            "on",
            "the",
            "delegate"
        ]
    },
    {
        "id": 292,
        "code": "public void seekToPrevious() {\n  player.seekToPrevious();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "seek",
            "to",
            "previous",
            "on",
            "the",
            "delegate"
        ]
    },
    {
        "id": 293,
        "code": "public long getMaxSeekToPreviousPosition() {\n  return player.getMaxSeekToPreviousPosition();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "get",
            "max",
            "seek",
            "to",
            "previous",
            "position",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 294,
        "code": "public boolean hasNext() {\n  return player.hasNext();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "has",
            "next",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 295,
        "code": "public boolean hasNextWindow() {\n  return player.hasNextWindow();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "has",
            "next",
            "window",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 296,
        "code": "public boolean hasNextMediaItem() {\n  return player.hasNextMediaItem();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "has",
            "next",
            "media",
            "item",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 297,
        "code": "public void next() {\n  player.next();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "next",
            "on",
            "the",
            "delegate"
        ]
    },
    {
        "id": 298,
        "code": "public void seekToNextWindow() {\n  player.seekToNextWindow();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "seek",
            "to",
            "next",
            "window",
            "on",
            "the",
            "delegate"
        ]
    },
    {
        "id": 299,
        "code": "public void seekToNextMediaItem() {\n  player.seekToNextMediaItem();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "seek",
            "to",
            "next",
            "media",
            "item",
            "on",
            "the",
            "delegate"
        ]
    },
    {
        "id": 300,
        "code": "public void seekToNext() {\n  player.seekToNext();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "seek",
            "to",
            "next",
            "on",
            "the",
            "delegate"
        ]
    },
    {
        "id": 301,
        "code": "public void setPlaybackParameters(PlaybackParameters playbackParameters) {\n  player.setPlaybackParameters(playbackParameters);\n}",
        "summary_tokens": [
            "calls",
            "player",
            "set",
            "playback",
            "parameters",
            "playback",
            "parameters",
            "on",
            "the",
            "delegate"
        ]
    },
    {
        "id": 302,
        "code": "public void setPlaybackSpeed(float speed) {\n  player.setPlaybackSpeed(speed);\n}",
        "summary_tokens": [
            "calls",
            "player",
            "set",
            "playback",
            "speed",
            "float",
            "on",
            "the",
            "delegate"
        ]
    },
    {
        "id": 303,
        "code": "public PlaybackParameters getPlaybackParameters() {\n  return player.getPlaybackParameters();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "get",
            "playback",
            "parameters",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 304,
        "code": "public void stop(boolean reset) {\n  player.stop(reset);\n}",
        "summary_tokens": [
            "calls",
            "player",
            "stop",
            "boolean",
            "on",
            "the",
            "delegate"
        ]
    },
    {
        "id": 305,
        "code": "public void release() {\n  player.release();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "release",
            "on",
            "the",
            "delegate"
        ]
    },
    {
        "id": 306,
        "code": "public Tracks getCurrentTracks() {\n  return player.getCurrentTracks();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "get",
            "current",
            "tracks",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 307,
        "code": "public TrackSelectionParameters getTrackSelectionParameters() {\n  return player.getTrackSelectionParameters();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "get",
            "track",
            "selection",
            "parameters",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 308,
        "code": "public void setTrackSelectionParameters(TrackSelectionParameters parameters) {\n  player.setTrackSelectionParameters(parameters);\n}",
        "summary_tokens": [
            "calls",
            "player",
            "set",
            "track",
            "selection",
            "parameters",
            "track",
            "selection",
            "parameters",
            "on",
            "the",
            "delegate"
        ]
    },
    {
        "id": 309,
        "code": "public MediaMetadata getMediaMetadata() {\n  return player.getMediaMetadata();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "get",
            "media",
            "metadata",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 310,
        "code": "public MediaMetadata getPlaylistMetadata() {\n  return player.getPlaylistMetadata();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "get",
            "playlist",
            "metadata",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 311,
        "code": "public void setPlaylistMetadata(MediaMetadata mediaMetadata) {\n  player.setPlaylistMetadata(mediaMetadata);\n}",
        "summary_tokens": [
            "calls",
            "player",
            "set",
            "playlist",
            "metadata",
            "media",
            "metadata",
            "on",
            "the",
            "delegate"
        ]
    },
    {
        "id": 312,
        "code": "public Object getCurrentManifest() {\n  return player.getCurrentManifest();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "get",
            "current",
            "manifest",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 313,
        "code": "public Timeline getCurrentTimeline() {\n  return player.getCurrentTimeline();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "get",
            "current",
            "timeline",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 314,
        "code": "public int getCurrentPeriodIndex() {\n  return player.getCurrentPeriodIndex();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "get",
            "current",
            "period",
            "index",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 315,
        "code": "public int getCurrentWindowIndex() {\n  return player.getCurrentWindowIndex();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "get",
            "current",
            "window",
            "index",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 316,
        "code": "public int getCurrentMediaItemIndex() {\n  return player.getCurrentMediaItemIndex();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "get",
            "current",
            "media",
            "item",
            "index",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 317,
        "code": "public int getNextWindowIndex() {\n  return player.getNextWindowIndex();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "get",
            "next",
            "window",
            "index",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 318,
        "code": "public int getNextMediaItemIndex() {\n  return player.getNextMediaItemIndex();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "get",
            "next",
            "media",
            "item",
            "index",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 319,
        "code": "public int getPreviousWindowIndex() {\n  return player.getPreviousWindowIndex();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "get",
            "previous",
            "window",
            "index",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 320,
        "code": "public int getPreviousMediaItemIndex() {\n  return player.getPreviousMediaItemIndex();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "get",
            "previous",
            "media",
            "item",
            "index",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 321,
        "code": "public MediaItem getCurrentMediaItem() {\n  return player.getCurrentMediaItem();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "get",
            "current",
            "media",
            "item",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 322,
        "code": "public int getMediaItemCount() {\n  return player.getMediaItemCount();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "get",
            "media",
            "item",
            "count",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 323,
        "code": "public MediaItem getMediaItemAt(int index) {\n  return player.getMediaItemAt(index);\n}",
        "summary_tokens": [
            "calls",
            "player",
            "get",
            "media",
            "item",
            "at",
            "int",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 324,
        "code": "public long getDuration() {\n  return player.getDuration();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "get",
            "duration",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 325,
        "code": "public long getCurrentPosition() {\n  return player.getCurrentPosition();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "get",
            "current",
            "position",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 326,
        "code": "public long getBufferedPosition() {\n  return player.getBufferedPosition();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "get",
            "buffered",
            "position",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 327,
        "code": "public int getBufferedPercentage() {\n  return player.getBufferedPercentage();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "get",
            "buffered",
            "percentage",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 328,
        "code": "public long getTotalBufferedDuration() {\n  return player.getTotalBufferedDuration();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "get",
            "total",
            "buffered",
            "duration",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 329,
        "code": "public boolean isCurrentWindowDynamic() {\n  return player.isCurrentWindowDynamic();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "is",
            "current",
            "window",
            "dynamic",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 330,
        "code": "public boolean isCurrentMediaItemDynamic() {\n  return player.isCurrentMediaItemDynamic();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "is",
            "current",
            "media",
            "item",
            "dynamic",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 331,
        "code": "public boolean isCurrentWindowLive() {\n  return player.isCurrentWindowLive();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "is",
            "current",
            "window",
            "live",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 332,
        "code": "public boolean isCurrentMediaItemLive() {\n  return player.isCurrentMediaItemLive();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "is",
            "current",
            "media",
            "item",
            "live",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 333,
        "code": "public long getCurrentLiveOffset() {\n  return player.getCurrentLiveOffset();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "get",
            "current",
            "live",
            "offset",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 334,
        "code": "public boolean isCurrentWindowSeekable() {\n  return player.isCurrentWindowSeekable();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "is",
            "current",
            "window",
            "seekable",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 335,
        "code": "public boolean isCurrentMediaItemSeekable() {\n  return player.isCurrentMediaItemSeekable();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "is",
            "current",
            "media",
            "item",
            "seekable",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 336,
        "code": "public boolean isPlayingAd() {\n  return player.isPlayingAd();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "is",
            "playing",
            "ad",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 337,
        "code": "public int getCurrentAdGroupIndex() {\n  return player.getCurrentAdGroupIndex();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "get",
            "current",
            "ad",
            "group",
            "index",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 338,
        "code": "public int getCurrentAdIndexInAdGroup() {\n  return player.getCurrentAdIndexInAdGroup();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "get",
            "current",
            "ad",
            "index",
            "in",
            "ad",
            "group",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 339,
        "code": "public long getContentDuration() {\n  return player.getContentDuration();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "get",
            "content",
            "duration",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 340,
        "code": "public long getContentPosition() {\n  return player.getContentPosition();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "get",
            "content",
            "position",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 341,
        "code": "public long getContentBufferedPosition() {\n  return player.getContentBufferedPosition();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "get",
            "content",
            "buffered",
            "position",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 342,
        "code": "public AudioAttributes getAudioAttributes() {\n  return player.getAudioAttributes();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "get",
            "audio",
            "attributes",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 343,
        "code": "public void setVolume(float volume) {\n  player.setVolume(volume);\n}",
        "summary_tokens": [
            "calls",
            "player",
            "set",
            "volume",
            "float",
            "on",
            "the",
            "delegate"
        ]
    },
    {
        "id": 344,
        "code": "public float getVolume() {\n  return player.getVolume();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "get",
            "volume",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 345,
        "code": "public VideoSize getVideoSize() {\n  return player.getVideoSize();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "get",
            "video",
            "size",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 346,
        "code": "public void clearVideoSurface(@Nullable Surface surface) {\n  player.clearVideoSurface(surface);\n}",
        "summary_tokens": [
            "calls",
            "player",
            "clear",
            "video",
            "surface",
            "surface",
            "on",
            "the",
            "delegate"
        ]
    },
    {
        "id": 347,
        "code": "public void setVideoSurface(@Nullable Surface surface) {\n  player.setVideoSurface(surface);\n}",
        "summary_tokens": [
            "calls",
            "player",
            "set",
            "video",
            "surface",
            "surface",
            "on",
            "the",
            "delegate"
        ]
    },
    {
        "id": 348,
        "code": "public void setVideoSurfaceHolder(@Nullable SurfaceHolder surfaceHolder) {\n  player.setVideoSurfaceHolder(surfaceHolder);\n}",
        "summary_tokens": [
            "calls",
            "player",
            "set",
            "video",
            "surface",
            "holder",
            "surface",
            "holder",
            "on",
            "the",
            "delegate"
        ]
    },
    {
        "id": 349,
        "code": "public void clearVideoSurfaceHolder(@Nullable SurfaceHolder surfaceHolder) {\n  player.clearVideoSurfaceHolder(surfaceHolder);\n}",
        "summary_tokens": [
            "calls",
            "player",
            "clear",
            "video",
            "surface",
            "holder",
            "surface",
            "holder",
            "on",
            "the",
            "delegate"
        ]
    },
    {
        "id": 350,
        "code": "public void setVideoSurfaceView(@Nullable SurfaceView surfaceView) {\n  player.setVideoSurfaceView(surfaceView);\n}",
        "summary_tokens": [
            "calls",
            "player",
            "set",
            "video",
            "surface",
            "view",
            "surface",
            "view",
            "on",
            "the",
            "delegate"
        ]
    },
    {
        "id": 351,
        "code": "public void clearVideoSurfaceView(@Nullable SurfaceView surfaceView) {\n  player.clearVideoSurfaceView(surfaceView);\n}",
        "summary_tokens": [
            "calls",
            "player",
            "clear",
            "video",
            "surface",
            "view",
            "surface",
            "view",
            "on",
            "the",
            "delegate"
        ]
    },
    {
        "id": 352,
        "code": "public void setVideoTextureView(@Nullable TextureView textureView) {\n  player.setVideoTextureView(textureView);\n}",
        "summary_tokens": [
            "calls",
            "player",
            "set",
            "video",
            "texture",
            "view",
            "texture",
            "view",
            "on",
            "the",
            "delegate"
        ]
    },
    {
        "id": 353,
        "code": "public void clearVideoTextureView(@Nullable TextureView textureView) {\n  player.clearVideoTextureView(textureView);\n}",
        "summary_tokens": [
            "calls",
            "player",
            "clear",
            "video",
            "texture",
            "view",
            "texture",
            "view",
            "on",
            "the",
            "delegate"
        ]
    },
    {
        "id": 354,
        "code": "public CueGroup getCurrentCues() {\n  return player.getCurrentCues();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "get",
            "current",
            "cues",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 355,
        "code": "public DeviceInfo getDeviceInfo() {\n  return player.getDeviceInfo();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "get",
            "device",
            "info",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 356,
        "code": "public int getDeviceVolume() {\n  return player.getDeviceVolume();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "get",
            "device",
            "volume",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 357,
        "code": "public boolean isDeviceMuted() {\n  return player.isDeviceMuted();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "is",
            "device",
            "muted",
            "on",
            "the",
            "delegate",
            "and",
            "returns",
            "the",
            "result"
        ]
    },
    {
        "id": 358,
        "code": "public void setDeviceVolume(int volume) {\n  player.setDeviceVolume(volume);\n}",
        "summary_tokens": [
            "calls",
            "player",
            "set",
            "device",
            "volume",
            "int",
            "on",
            "the",
            "delegate"
        ]
    },
    {
        "id": 359,
        "code": "public void increaseDeviceVolume() {\n  player.increaseDeviceVolume();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "increase",
            "device",
            "volume",
            "on",
            "the",
            "delegate"
        ]
    },
    {
        "id": 360,
        "code": "public void decreaseDeviceVolume() {\n  player.decreaseDeviceVolume();\n}",
        "summary_tokens": [
            "calls",
            "player",
            "decrease",
            "device",
            "volume",
            "on",
            "the",
            "delegate"
        ]
    },
    {
        "id": 361,
        "code": "public void setDeviceMuted(boolean muted) {\n  player.setDeviceMuted(muted);\n}",
        "summary_tokens": [
            "calls",
            "player",
            "set",
            "device",
            "muted",
            "boolean",
            "on",
            "the",
            "delegate"
        ]
    },
    {
        "id": 362,
        "code": "public Player getWrappedPlayer() {\n  return player;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "player",
            "to",
            "which",
            "operations",
            "are",
            "forwarded"
        ]
    },
    {
        "id": 363,
        "code": "public boolean isHeart() {\n  return isHeart;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "rating",
            "is",
            "heart"
        ]
    },
    {
        "id": 364,
        "code": "public Builder buildUpon() {\n  return new Builder( this);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "builder",
            "instance",
            "with",
            "the",
            "current",
            "media",
            "metadata",
            "fields"
        ]
    },
    {
        "id": 365,
        "code": "public static ParserException createForMalformedDataOfUnknownType(\n    @Nullable String message, @Nullable Throwable cause) {\n  return new ParserException(message, cause,  true, C.DATA_TYPE_UNKNOWN);\n}",
        "summary_tokens": [
            "creates",
            "a",
            "new",
            "instance",
            "for",
            "which",
            "content",
            "is",
            "malformed",
            "is",
            "true",
            "and",
            "data",
            "type",
            "is",
            "c",
            "data",
            "type",
            "unknown"
        ]
    },
    {
        "id": 366,
        "code": "public static ParserException createForMalformedContainer(\n    @Nullable String message, @Nullable Throwable cause) {\n  return new ParserException(message, cause,  true, C.DATA_TYPE_MEDIA);\n}",
        "summary_tokens": [
            "creates",
            "a",
            "new",
            "instance",
            "for",
            "which",
            "content",
            "is",
            "malformed",
            "is",
            "true",
            "and",
            "data",
            "type",
            "is",
            "c",
            "data",
            "type",
            "media"
        ]
    },
    {
        "id": 367,
        "code": "public static ParserException createForMalformedManifest(\n    @Nullable String message, @Nullable Throwable cause) {\n  return new ParserException(\n      message, cause,  true, C.DATA_TYPE_MANIFEST);\n}",
        "summary_tokens": [
            "creates",
            "a",
            "new",
            "instance",
            "for",
            "which",
            "content",
            "is",
            "malformed",
            "is",
            "true",
            "and",
            "data",
            "type",
            "is",
            "c",
            "data",
            "type",
            "manifest"
        ]
    },
    {
        "id": 368,
        "code": "public static ParserException createForManifestWithUnsupportedFeature(\n    @Nullable String message, @Nullable Throwable cause) {\n  return new ParserException(\n      message, cause,  false, C.DATA_TYPE_MANIFEST);\n}",
        "summary_tokens": [
            "creates",
            "a",
            "new",
            "instance",
            "for",
            "which",
            "content",
            "is",
            "malformed",
            "is",
            "false",
            "and",
            "data",
            "type",
            "is",
            "c",
            "data",
            "type",
            "manifest"
        ]
    },
    {
        "id": 369,
        "code": "public static ParserException createForUnsupportedContainerFeature(@Nullable String message) {\n  return new ParserException(\n      message,  null,  false, C.DATA_TYPE_MEDIA);\n}",
        "summary_tokens": [
            "creates",
            "a",
            "new",
            "instance",
            "for",
            "which",
            "content",
            "is",
            "malformed",
            "is",
            "false",
            "and",
            "data",
            "type",
            "is",
            "c",
            "data",
            "type",
            "media"
        ]
    },
    {
        "id": 370,
        "code": "public float getPercent() {\n  return percent;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "percent",
            "value",
            "of",
            "this",
            "rating"
        ]
    },
    {
        "id": 371,
        "code": "public final String getErrorCodeName() {\n  return getErrorCodeName(errorCode);\n}",
        "summary_tokens": [
            "equivalent",
            "to",
            "playback",
            "exception",
            "get",
            "error",
            "code",
            "name",
            "int",
            "playback",
            "exception"
        ]
    },
    {
        "id": 372,
        "code": "public boolean errorInfoEquals(@Nullable PlaybackException other) {\n  if (this == other) {\n    return true;\n  }\n  if (other == null || getClass() != other.getClass()) {\n    return false;\n  }\n\n  @Nullable Throwable thisCause = getCause();\n  @Nullable Throwable thatCause = other.getCause();\n  if (thisCause != null && thatCause != null) {\n    if (!Util.areEqual(thisCause.getMessage(), thatCause.getMessage())) {\n      return false;\n    }\n    if (!Util.areEqual(thisCause.getClass(), thatCause.getClass())) {\n      return false;\n    }\n  } else if (thisCause != null || thatCause != null) {\n    return false;\n  }\n  return errorCode == other.errorCode\n      && Util.areEqual(getMessage(), other.getMessage())\n      && timestampMs == other.timestampMs;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "error",
            "data",
            "associated",
            "to",
            "this",
            "exception",
            "equals",
            "the",
            "error",
            "data",
            "associated",
            "to",
            "other"
        ]
    },
    {
        "id": 373,
        "code": "protected static String keyForField(int field) {\n  return Integer.toString(field, Character.MAX_RADIX);\n}",
        "summary_tokens": [
            "converts",
            "the",
            "given",
            "field",
            "number",
            "to",
            "a",
            "string",
            "which",
            "can",
            "be",
            "used",
            "as",
            "a",
            "field",
            "key",
            "when",
            "implementing",
            "to",
            "bundle",
            "and",
            "bundleable"
        ]
    },
    {
        "id": 374,
        "code": "public long getMediaTimeUsForPlayoutTimeMs(long timeMs) {\n  return timeMs * scaledUsPerMs;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "media",
            "time",
            "in",
            "microseconds",
            "that",
            "will",
            "elapse",
            "in",
            "time",
            "ms",
            "milliseconds",
            "of",
            "wallclock",
            "time"
        ]
    },
    {
        "id": 375,
        "code": "public PlaybackParameters withSpeed(@FloatRange(from = 0, fromInclusive = false) float speed) {\n  return new PlaybackParameters(speed, pitch);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "copy",
            "with",
            "the",
            "given",
            "speed"
        ]
    },
    {
        "id": 376,
        "code": "public int getMaxStars() {\n  return maxStars;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "maximum",
            "number",
            "of",
            "stars"
        ]
    },
    {
        "id": 377,
        "code": "public float getStarRating() {\n  return starRating;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "fractional",
            "number",
            "of",
            "stars",
            "of",
            "this",
            "rating"
        ]
    },
    {
        "id": 378,
        "code": "public boolean isThumbsUp() {\n  return isThumbsUp;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "rating",
            "is",
            "thumbs",
            "up"
        ]
    },
    {
        "id": 379,
        "code": "public final boolean isEmpty() {\n  return getWindowCount() == 0;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "timeline",
            "is",
            "empty"
        ]
    },
    {
        "id": 380,
        "code": "public int getNextWindowIndex(\n    int windowIndex, @Player.RepeatMode int repeatMode, boolean shuffleModeEnabled) {\n  switch (repeatMode) {\n    case Player.REPEAT_MODE_OFF:\n      return windowIndex == getLastWindowIndex(shuffleModeEnabled)\n          ? C.INDEX_UNSET\n          : windowIndex + 1;\n    case Player.REPEAT_MODE_ONE:\n      return windowIndex;\n    case Player.REPEAT_MODE_ALL:\n      return windowIndex == getLastWindowIndex(shuffleModeEnabled)\n          ? getFirstWindowIndex(shuffleModeEnabled)\n          : windowIndex + 1;\n    default:\n      throw new IllegalStateException();\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "index",
            "of",
            "the",
            "window",
            "after",
            "the",
            "window",
            "at",
            "index",
            "window",
            "index",
            "depending",
            "on",
            "the",
            "repeat",
            "mode",
            "and",
            "whether",
            "shuffling",
            "is",
            "enabled"
        ]
    },
    {
        "id": 381,
        "code": "public int getPreviousWindowIndex(\n    int windowIndex, @Player.RepeatMode int repeatMode, boolean shuffleModeEnabled) {\n  switch (repeatMode) {\n    case Player.REPEAT_MODE_OFF:\n      return windowIndex == getFirstWindowIndex(shuffleModeEnabled)\n          ? C.INDEX_UNSET\n          : windowIndex - 1;\n    case Player.REPEAT_MODE_ONE:\n      return windowIndex;\n    case Player.REPEAT_MODE_ALL:\n      return windowIndex == getFirstWindowIndex(shuffleModeEnabled)\n          ? getLastWindowIndex(shuffleModeEnabled)\n          : windowIndex - 1;\n    default:\n      throw new IllegalStateException();\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "index",
            "of",
            "the",
            "window",
            "before",
            "the",
            "window",
            "at",
            "index",
            "window",
            "index",
            "depending",
            "on",
            "the",
            "repeat",
            "mode",
            "and",
            "whether",
            "shuffling",
            "is",
            "enabled"
        ]
    },
    {
        "id": 382,
        "code": "public int getLastWindowIndex(boolean shuffleModeEnabled) {\n  return isEmpty() ? C.INDEX_UNSET : getWindowCount() - 1;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "index",
            "of",
            "the",
            "last",
            "window",
            "in",
            "the",
            "playback",
            "order",
            "depending",
            "on",
            "whether",
            "shuffling",
            "is",
            "enabled"
        ]
    },
    {
        "id": 383,
        "code": "public int getFirstWindowIndex(boolean shuffleModeEnabled) {\n  return isEmpty() ? C.INDEX_UNSET : 0;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "index",
            "of",
            "the",
            "first",
            "window",
            "in",
            "the",
            "playback",
            "order",
            "depending",
            "on",
            "whether",
            "shuffling",
            "is",
            "enabled"
        ]
    },
    {
        "id": 384,
        "code": "public final Window getWindow(int windowIndex, Window window) {\n  return getWindow(windowIndex, window,  0);\n}",
        "summary_tokens": [
            "populates",
            "a",
            "window",
            "with",
            "data",
            "for",
            "the",
            "window",
            "at",
            "the",
            "specified",
            "index"
        ]
    },
    {
        "id": 385,
        "code": "public final int getNextPeriodIndex(\n    int periodIndex,\n    Period period,\n    Window window,\n    @Player.RepeatMode int repeatMode,\n    boolean shuffleModeEnabled) {\n  int windowIndex = getPeriod(periodIndex, period).windowIndex;\n  if (getWindow(windowIndex, window).lastPeriodIndex == periodIndex) {\n    int nextWindowIndex = getNextWindowIndex(windowIndex, repeatMode, shuffleModeEnabled);\n    if (nextWindowIndex == C.INDEX_UNSET) {\n      return C.INDEX_UNSET;\n    }\n    return getWindow(nextWindowIndex, window).firstPeriodIndex;\n  }\n  return periodIndex + 1;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "index",
            "of",
            "the",
            "period",
            "after",
            "the",
            "period",
            "at",
            "index",
            "period",
            "index",
            "depending",
            "on",
            "the",
            "repeat",
            "mode",
            "and",
            "whether",
            "shuffling",
            "is",
            "enabled"
        ]
    },
    {
        "id": 386,
        "code": "public final boolean isLastPeriod(\n    int periodIndex,\n    Period period,\n    Window window,\n    @Player.RepeatMode int repeatMode,\n    boolean shuffleModeEnabled) {\n  return getNextPeriodIndex(periodIndex, period, window, repeatMode, shuffleModeEnabled)\n      == C.INDEX_UNSET;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "given",
            "period",
            "is",
            "the",
            "last",
            "period",
            "of",
            "the",
            "timeline",
            "depending",
            "on",
            "the",
            "repeat",
            "mode",
            "and",
            "whether",
            "shuffling",
            "is",
            "enabled"
        ]
    },
    {
        "id": 387,
        "code": "public final Pair<Object, Long> getPeriodPosition(\n    Window window,\n    Period period,\n    int windowIndex,\n    long windowPositionUs,\n    long defaultPositionProjectionUs) {\n  return getPeriodPositionUs(\n      window, period, windowIndex, windowPositionUs, defaultPositionProjectionUs);\n}",
        "summary_tokens": [
            "use",
            "get",
            "period",
            "position",
            "us",
            "window",
            "period",
            "int",
            "long",
            "long",
            "instead"
        ]
    },
    {
        "id": 388,
        "code": "public final Pair<Object, Long> getPeriodPositionUs(\n    Window window,\n    Period period,\n    int windowIndex,\n    long windowPositionUs,\n    long defaultPositionProjectionUs) {\n  Assertions.checkIndex(windowIndex, 0, getWindowCount());\n  getWindow(windowIndex, window, defaultPositionProjectionUs);\n  if (windowPositionUs == C.TIME_UNSET) {\n    windowPositionUs = window.getDefaultPositionUs();\n    if (windowPositionUs == C.TIME_UNSET) {\n      return null;\n    }\n  }\n  int periodIndex = window.firstPeriodIndex;\n  getPeriod(periodIndex, period);\n  while (periodIndex < window.lastPeriodIndex\n      && period.positionInWindowUs != windowPositionUs\n      && getPeriod(periodIndex + 1, period).positionInWindowUs <= windowPositionUs) {\n    periodIndex++;\n  }\n  getPeriod(periodIndex, period,  true);\n  long periodPositionUs = windowPositionUs - period.positionInWindowUs;\n    \n  if (period.durationUs != C.TIME_UNSET) {\n    periodPositionUs = min(periodPositionUs, period.durationUs - 1);\n  }\n    \n  periodPositionUs = max(0, periodPositionUs);\n  return Pair.create(Assertions.checkNotNull(period.uid), periodPositionUs);\n}",
        "summary_tokens": [
            "converts",
            "window",
            "index",
            "window",
            "position",
            "us",
            "to",
            "the",
            "corresponding",
            "period",
            "uid",
            "period",
            "position",
            "us"
        ]
    },
    {
        "id": 389,
        "code": "public Period getPeriodByUid(Object periodUid, Period period) {\n  return getPeriod(getIndexOfPeriod(periodUid), period,  true);\n}",
        "summary_tokens": [
            "populates",
            "a",
            "period",
            "with",
            "data",
            "for",
            "the",
            "period",
            "with",
            "the",
            "specified",
            "unique",
            "identifier"
        ]
    },
    {
        "id": 390,
        "code": "public final Period getPeriod(int periodIndex, Period period) {\n  return getPeriod(periodIndex, period, false);\n}",
        "summary_tokens": [
            "populates",
            "a",
            "period",
            "with",
            "data",
            "for",
            "the",
            "period",
            "at",
            "the",
            "specified",
            "index"
        ]
    },
    {
        "id": 391,
        "code": "public ImmutableList<Group> getGroups() {\n  return groups;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "group",
            "groups",
            "of",
            "tracks"
        ]
    },
    {
        "id": 392,
        "code": "public boolean isEmpty() {\n  return groups.isEmpty();\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "there",
            "are",
            "no",
            "tracks",
            "and",
            "false",
            "otherwise"
        ]
    },
    {
        "id": 393,
        "code": "public boolean containsType(@C.TrackType int trackType) {\n  for (int i = 0; i < groups.size(); i++) {\n    if (groups.get(i).getType() == trackType) {\n      return true;\n    }\n  }\n  return false;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "there",
            "are",
            "tracks",
            "of",
            "type",
            "track",
            "type",
            "and",
            "false",
            "otherwise"
        ]
    },
    {
        "id": 394,
        "code": "public boolean isTypeSupported(@C.TrackType int trackType, boolean allowExceedsCapabilities) {\n  for (int i = 0; i < groups.size(); i++) {\n    if (groups.get(i).getType() == trackType) {\n      if (groups.get(i).isSupported(allowExceedsCapabilities)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "at",
            "least",
            "one",
            "track",
            "of",
            "type",
            "track",
            "type",
            "is",
            "group",
            "is",
            "track",
            "supported",
            "int",
            "boolean",
            "supported"
        ]
    },
    {
        "id": 395,
        "code": "public boolean isTypeSupportedOrEmpty(\n    @C.TrackType int trackType, boolean allowExceedsCapabilities) {\n  return !containsType(trackType) || isTypeSupported(trackType, allowExceedsCapabilities);\n}",
        "summary_tokens": [
            "use",
            "contains",
            "type",
            "int",
            "and",
            "is",
            "type",
            "supported",
            "int",
            "boolean"
        ]
    },
    {
        "id": 396,
        "code": "public boolean isTypeSelected(@C.TrackType int trackType) {\n  for (int i = 0; i < groups.size(); i++) {\n    Group group = groups.get(i);\n    if (group.isSelected() && group.getType() == trackType) {\n      return true;\n    }\n  }\n  return false;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "at",
            "least",
            "one",
            "track",
            "of",
            "the",
            "type",
            "track",
            "type",
            "is",
            "selected",
            "for",
            "playback"
        ]
    },
    {
        "id": 397,
        "code": "public AudioAttributesV21 getAudioAttributesV21() {\n  if (audioAttributesV21 == null) {\n    audioAttributesV21 = new AudioAttributesV21(this);\n  }\n  return audioAttributesV21;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "audio",
            "attributes",
            "v",
            "0",
            "from",
            "this",
            "instance"
        ]
    },
    {
        "id": 398,
        "code": "public static DrmInitData createSessionCreationData(\n    @Nullable DrmInitData manifestData, @Nullable DrmInitData mediaData) {\n  ArrayList<SchemeData> result = new ArrayList<>();\n  String schemeType = null;\n  if (manifestData != null) {\n    schemeType = manifestData.schemeType;\n    for (SchemeData data : manifestData.schemeDatas) {\n      if (data.hasData()) {\n        result.add(data);\n      }\n    }\n  }\n\n  if (mediaData != null) {\n    if (schemeType == null) {\n      schemeType = mediaData.schemeType;\n    }\n    int manifestDatasCount = result.size();\n    for (SchemeData data : mediaData.schemeDatas) {\n      if (data.hasData() && !containsSchemeDataWithUuid(result, manifestDatasCount, data.uuid)) {\n        result.add(data);\n      }\n    }\n  }\n\n  return result.isEmpty() ? null : new DrmInitData(schemeType, result);\n}",
        "summary_tokens": [
            "merges",
            "drm",
            "init",
            "data",
            "obtained",
            "from",
            "a",
            "media",
            "manifest",
            "and",
            "a",
            "media",
            "stream"
        ]
    },
    {
        "id": 399,
        "code": "public SchemeData get(int index) {\n  return schemeDatas[index];\n}",
        "summary_tokens": [
            "retrieves",
            "the",
            "scheme",
            "data",
            "at",
            "a",
            "given",
            "index"
        ]
    },
    {
        "id": 400,
        "code": "public DrmInitData copyWithSchemeType(@Nullable String schemeType) {\n  if (Util.areEqual(this.schemeType, schemeType)) {\n    return this;\n  }\n  return new DrmInitData(schemeType, false, schemeDatas);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "copy",
            "with",
            "the",
            "specified",
            "protection",
            "scheme",
            "type"
        ]
    },
    {
        "id": 401,
        "code": "public DrmInitData merge(DrmInitData drmInitData) {\n  Assertions.checkState(\n      schemeType == null\n          || drmInitData.schemeType == null\n          || TextUtils.equals(schemeType, drmInitData.schemeType));\n  String mergedSchemeType = schemeType != null ? this.schemeType : drmInitData.schemeType;\n  SchemeData[] mergedSchemeDatas =\n      Util.nullSafeArrayConcatenation(schemeDatas, drmInitData.schemeDatas);\n  return new DrmInitData(mergedSchemeType, mergedSchemeDatas);\n}",
        "summary_tokens": [
            "returns",
            "an",
            "instance",
            "containing",
            "the",
            "scheme",
            "datas",
            "from",
            "both",
            "this",
            "and",
            "other"
        ]
    },
    {
        "id": 402,
        "code": "public int length() {\n  return entries.length;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "metadata",
            "entries"
        ]
    },
    {
        "id": 403,
        "code": "public Metadata.Entry get(int index) {\n  return entries[index];\n}",
        "summary_tokens": [
            "returns",
            "the",
            "entry",
            "at",
            "the",
            "specified",
            "index"
        ]
    },
    {
        "id": 404,
        "code": "public Metadata copyWithAppendedEntriesFrom(@Nullable Metadata other) {\n  if (other == null) {\n    return this;\n  }\n  return copyWithAppendedEntries(other.entries);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "copy",
            "of",
            "this",
            "metadata",
            "with",
            "the",
            "entries",
            "of",
            "the",
            "specified",
            "metadata",
            "appended"
        ]
    },
    {
        "id": 405,
        "code": "public Metadata copyWithAppendedEntries(Entry... entriesToAppend) {\n  if (entriesToAppend.length == 0) {\n    return this;\n  }\n  return new Metadata(Util.nullSafeArrayConcatenation(entries, entriesToAppend));\n}",
        "summary_tokens": [
            "returns",
            "a",
            "copy",
            "of",
            "this",
            "metadata",
            "with",
            "the",
            "specified",
            "entries",
            "appended"
        ]
    },
    {
        "id": 406,
        "code": "public MediaPeriodId copyWithPeriodUid(Object newPeriodUid) {\n  return periodUid.equals(newPeriodUid)\n      ? this\n      : new MediaPeriodId(\n          newPeriodUid, adGroupIndex, adIndexInAdGroup, windowSequenceNumber, nextAdGroupIndex);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "copy",
            "of",
            "this",
            "period",
            "identifier",
            "but",
            "with",
            "new",
            "period",
            "uid",
            "as",
            "its",
            "period",
            "uid"
        ]
    },
    {
        "id": 407,
        "code": "public MediaPeriodId copyWithWindowSequenceNumber(long windowSequenceNumber) {\n  return this.windowSequenceNumber == windowSequenceNumber\n      ? this\n      : new MediaPeriodId(\n          periodUid, adGroupIndex, adIndexInAdGroup, windowSequenceNumber, nextAdGroupIndex);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "copy",
            "of",
            "this",
            "period",
            "identifier",
            "with",
            "a",
            "new",
            "window",
            "sequence",
            "number"
        ]
    },
    {
        "id": 408,
        "code": "public boolean isAd() {\n  return adGroupIndex != C.INDEX_UNSET;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "this",
            "period",
            "identifier",
            "identifies",
            "an",
            "ad",
            "in",
            "an",
            "ad",
            "group",
            "in",
            "a",
            "period"
        ]
    },
    {
        "id": 409,
        "code": "public TrackGroup copyWithId(String id) {\n  return new TrackGroup(id, formats);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "copy",
            "of",
            "this",
            "track",
            "group",
            "with",
            "the",
            "specified",
            "id"
        ]
    },
    {
        "id": 410,
        "code": "public Format getFormat(int index) {\n  return formats[index];\n}",
        "summary_tokens": [
            "returns",
            "the",
            "format",
            "of",
            "the",
            "track",
            "at",
            "a",
            "given",
            "index"
        ]
    },
    {
        "id": 411,
        "code": "public int indexOf(Format format) {\n  for (int i = 0; i < formats.length; i++) {\n    if (format == formats[i]) {\n      return i;\n    }\n  }\n  return C.INDEX_UNSET;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "index",
            "of",
            "the",
            "track",
            "with",
            "the",
            "given",
            "format",
            "in",
            "the",
            "group"
        ]
    },
    {
        "id": 412,
        "code": "public Builder buildUpon() {\n  return new Cue.Builder(this);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "cue"
        ]
    },
    {
        "id": 413,
        "code": "private static ImmutableList<Cue> filterOutBitmapCues(List<Cue> cues) {\n  ImmutableList.Builder<Cue> builder = ImmutableList.builder();\n  for (int i = 0; i < cues.size(); i++) {\n    if (cues.get(i).bitmap != null) {\n      continue;\n    }\n    builder.add(cues.get(i));\n  }\n  return builder.build();\n}",
        "summary_tokens": [
            "filters",
            "out",
            "cue",
            "objects",
            "containing",
            "bitmap"
        ]
    },
    {
        "id": 414,
        "code": "public static void addOrReplaceSpan(\n    Spannable spannable, Object span, int start, int end, int spanFlags) {\n  Object[] existingSpans = spannable.getSpans(start, end, span.getClass());\n  for (Object existingSpan : existingSpans) {\n    if (spannable.getSpanStart(existingSpan) == start\n        && spannable.getSpanEnd(existingSpan) == end\n        && spannable.getSpanFlags(existingSpan) == spanFlags) {\n      spannable.removeSpan(existingSpan);\n    }\n  }\n  spannable.setSpan(span, start, end, spanFlags);\n}",
        "summary_tokens": [
            "adds",
            "span",
            "to",
            "spannable",
            "between",
            "start",
            "and",
            "end",
            "removing",
            "any",
            "existing",
            "spans",
            "of",
            "the",
            "same",
            "type",
            "and",
            "with",
            "the",
            "same",
            "indices",
            "and",
            "flags"
        ]
    },
    {
        "id": 415,
        "code": "default List<AdOverlayInfo> getAdOverlayInfos() {\n  return ImmutableList.of();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "list",
            "of",
            "ad",
            "overlay",
            "info",
            "instances",
            "describing",
            "views",
            "that",
            "are",
            "on",
            "top",
            "of",
            "the",
            "ad",
            "view",
            "group",
            "but",
            "that",
            "are",
            "essential",
            "for",
            "controlling",
            "playback",
            "and",
            "should",
            "be",
            "excluded",
            "from",
            "ad",
            "viewability",
            "measurements"
        ]
    },
    {
        "id": 416,
        "code": "public static void checkArgument(boolean expression, Object errorMessage) {\n  if (ExoPlayerLibraryInfo.ASSERTIONS_ENABLED && !expression) {\n    throw new IllegalArgumentException(String.valueOf(errorMessage));\n  }\n}",
        "summary_tokens": [
            "throws",
            "illegal",
            "argument",
            "exception",
            "if",
            "expression",
            "evaluates",
            "to",
            "false"
        ]
    },
    {
        "id": 417,
        "code": "public static int checkIndex(int index, int start, int limit) {\n  if (index < start || index >= limit) {\n    throw new IndexOutOfBoundsException();\n  }\n  return index;\n}",
        "summary_tokens": [
            "throws",
            "index",
            "out",
            "of",
            "bounds",
            "exception",
            "if",
            "index",
            "falls",
            "outside",
            "the",
            "specified",
            "bounds"
        ]
    },
    {
        "id": 418,
        "code": "public static void checkState(boolean expression, Object errorMessage) {\n  if (ExoPlayerLibraryInfo.ASSERTIONS_ENABLED && !expression) {\n    throw new IllegalStateException(String.valueOf(errorMessage));\n  }\n}",
        "summary_tokens": [
            "throws",
            "illegal",
            "state",
            "exception",
            "if",
            "expression",
            "evaluates",
            "to",
            "false"
        ]
    },
    {
        "id": 419,
        "code": "public static <T> T checkStateNotNull(@Nullable T reference, Object errorMessage) {\n  if (ExoPlayerLibraryInfo.ASSERTIONS_ENABLED && reference == null) {\n    throw new IllegalStateException(String.valueOf(errorMessage));\n  }\n  return reference;\n}",
        "summary_tokens": [
            "throws",
            "illegal",
            "state",
            "exception",
            "if",
            "reference",
            "is",
            "null"
        ]
    },
    {
        "id": 420,
        "code": "public static <T> T checkNotNull(@Nullable T reference, Object errorMessage) {\n  if (ExoPlayerLibraryInfo.ASSERTIONS_ENABLED && reference == null) {\n    throw new NullPointerException(String.valueOf(errorMessage));\n  }\n  return reference;\n}",
        "summary_tokens": [
            "throws",
            "null",
            "pointer",
            "exception",
            "if",
            "reference",
            "is",
            "null"
        ]
    },
    {
        "id": 421,
        "code": "public static String checkNotEmpty(@Nullable String string, Object errorMessage) {\n  if (ExoPlayerLibraryInfo.ASSERTIONS_ENABLED && TextUtils.isEmpty(string)) {\n    throw new IllegalArgumentException(String.valueOf(errorMessage));\n  }\n  return string;\n}",
        "summary_tokens": [
            "throws",
            "illegal",
            "argument",
            "exception",
            "if",
            "string",
            "is",
            "null",
            "or",
            "zero",
            "length"
        ]
    },
    {
        "id": 422,
        "code": "public static void checkMainThread() {\n  if (ExoPlayerLibraryInfo.ASSERTIONS_ENABLED && Looper.myLooper() != Looper.getMainLooper()) {\n    throw new IllegalStateException(\"Not in applications main thread\");\n  }\n}",
        "summary_tokens": [
            "throws",
            "illegal",
            "state",
            "exception",
            "if",
            "the",
            "calling",
            "thread",
            "is",
            "not",
            "the",
            "application",
            "s",
            "main",
            "thread"
        ]
    },
    {
        "id": 423,
        "code": "public boolean exists() {\n  return baseName.exists() || backupName.exists();\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "file",
            "or",
            "its",
            "backup",
            "exists"
        ]
    },
    {
        "id": 424,
        "code": "public void delete() {\n  baseName.delete();\n  backupName.delete();\n}",
        "summary_tokens": [
            "delete",
            "the",
            "atomic",
            "file"
        ]
    },
    {
        "id": 425,
        "code": "public OutputStream startWrite() throws IOException {\n    \n  if (baseName.exists()) {\n    if (!backupName.exists()) {\n      if (!baseName.renameTo(backupName)) {\n        Log.w(TAG, \"Couldn't rename file \" + baseName + \" to backup file \" + backupName);\n      }\n    } else {\n      baseName.delete();\n    }\n  }\n  OutputStream str;\n  try {\n    str = new AtomicFileOutputStream(baseName);\n  } catch (FileNotFoundException e) {\n    File parent = baseName.getParentFile();\n    if (parent == null || !parent.mkdirs()) {\n      throw new IOException(\"Couldn't create \" + baseName, e);\n    }\n      \n    try {\n      str = new AtomicFileOutputStream(baseName);\n    } catch (FileNotFoundException e2) {\n      throw new IOException(\"Couldn't create \" + baseName, e2);\n    }\n  }\n  return str;\n}",
        "summary_tokens": [
            "start",
            "a",
            "new",
            "write",
            "operation",
            "on",
            "the",
            "file"
        ]
    },
    {
        "id": 426,
        "code": "public void endWrite(OutputStream str) throws IOException {\n  str.close();\n    \n  backupName.delete();\n}",
        "summary_tokens": [
            "call",
            "when",
            "you",
            "have",
            "successfully",
            "finished",
            "writing",
            "to",
            "the",
            "stream",
            "returned",
            "by",
            "start",
            "write"
        ]
    },
    {
        "id": 427,
        "code": "public InputStream openRead() throws FileNotFoundException {\n  restoreBackup();\n  return new FileInputStream(baseName);\n}",
        "summary_tokens": [
            "open",
            "the",
            "atomic",
            "file",
            "for",
            "reading"
        ]
    },
    {
        "id": 428,
        "code": "public static IBinder getBinder(Bundle bundle, @Nullable String key) {\n  if (Util.SDK_INT >= 18) {\n    return bundle.getBinder(key);\n  } else {\n    return getBinderByReflection(bundle, key);\n  }\n}",
        "summary_tokens": [
            "gets",
            "an",
            "ibinder",
            "inside",
            "a",
            "bundle",
            "for",
            "all",
            "android",
            "versions"
        ]
    },
    {
        "id": 429,
        "code": "public static void putBinder(Bundle bundle, @Nullable String key, @Nullable IBinder binder) {\n  if (Util.SDK_INT >= 18) {\n    bundle.putBinder(key, binder);\n  } else {\n    putBinderByReflection(bundle, key, binder);\n  }\n}",
        "summary_tokens": [
            "puts",
            "an",
            "ibinder",
            "inside",
            "a",
            "bundle",
            "for",
            "all",
            "android",
            "versions"
        ]
    },
    {
        "id": 430,
        "code": "public static <T extends Bundleable> ImmutableList<Bundle> toBundleList(List<T> bundleableList) {\n  ImmutableList.Builder<Bundle> builder = ImmutableList.builder();\n  for (int i = 0; i < bundleableList.size(); i++) {\n    Bundleable bundleable = bundleableList.get(i);\n    builder.add(bundleable.toBundle());\n  }\n  return builder.build();\n}",
        "summary_tokens": [
            "converts",
            "a",
            "list",
            "of",
            "bundleable",
            "to",
            "a",
            "list",
            "bundle"
        ]
    },
    {
        "id": 431,
        "code": "public static <T extends Bundleable> ImmutableList<T> fromBundleList(\n    Bundleable.Creator<T> creator, List<Bundle> bundleList) {\n  ImmutableList.Builder<T> builder = ImmutableList.builder();\n  for (int i = 0; i < bundleList.size(); i++) {\n    Bundle bundle = checkNotNull(bundleList.get(i)); \n    T bundleable = creator.fromBundle(bundle);\n    builder.add(bundleable);\n  }\n  return builder.build();\n}",
        "summary_tokens": [
            "converts",
            "a",
            "list",
            "of",
            "bundle",
            "to",
            "a",
            "list",
            "of",
            "bundleable"
        ]
    },
    {
        "id": 432,
        "code": "public static <T extends Bundleable> ArrayList<Bundle> toBundleArrayList(\n    Collection<T> bundleables) {\n  ArrayList<Bundle> arrayList = new ArrayList<>(bundleables.size());\n  for (T element : bundleables) {\n    arrayList.add(element.toBundle());\n  }\n  return arrayList;\n}",
        "summary_tokens": [
            "converts",
            "a",
            "collection",
            "of",
            "bundleable",
            "to",
            "an",
            "array",
            "list",
            "of",
            "bundle",
            "so",
            "that",
            "the",
            "returned",
            "list",
            "can",
            "be",
            "put",
            "to",
            "bundle",
            "using",
            "bundle",
            "put",
            "parcelable",
            "array",
            "list",
            "conveniently"
        ]
    },
    {
        "id": 433,
        "code": "public static <T extends Bundleable> SparseArray<T> fromBundleSparseArray(\n    Bundleable.Creator<T> creator, SparseArray<Bundle> bundleSparseArray) {\n  SparseArray<T> result = new SparseArray<>(bundleSparseArray.size());\n  for (int i = 0; i < bundleSparseArray.size(); i++) {\n    result.put(bundleSparseArray.keyAt(i), creator.fromBundle(bundleSparseArray.valueAt(i)));\n  }\n  return result;\n}",
        "summary_tokens": [
            "converts",
            "a",
            "sparse",
            "array",
            "of",
            "bundle",
            "to",
            "a",
            "sparse",
            "array",
            "of",
            "bundleable"
        ]
    },
    {
        "id": 434,
        "code": "public static <T extends Bundleable> SparseArray<Bundle> toBundleSparseArray(\n    SparseArray<T> bundleableSparseArray) {\n  SparseArray<Bundle> sparseArray = new SparseArray<>(bundleableSparseArray.size());\n  for (int i = 0; i < bundleableSparseArray.size(); i++) {\n    sparseArray.put(bundleableSparseArray.keyAt(i), bundleableSparseArray.valueAt(i).toBundle());\n  }\n  return sparseArray;\n}",
        "summary_tokens": [
            "converts",
            "a",
            "sparse",
            "array",
            "of",
            "bundleable",
            "to",
            "an",
            "sparse",
            "array",
            "of",
            "bundle",
            "so",
            "that",
            "the",
            "returned",
            "sparse",
            "array",
            "can",
            "be",
            "put",
            "to",
            "bundle",
            "using",
            "bundle",
            "put",
            "sparse",
            "parcelable",
            "array",
            "conveniently"
        ]
    },
    {
        "id": 435,
        "code": "public static void ensureClassLoader(@Nullable Bundle bundle) {\n  if (bundle != null) {\n    bundle.setClassLoader(castNonNull(BundleableUtil.class.getClassLoader()));\n  }\n}",
        "summary_tokens": [
            "sets",
            "the",
            "application",
            "class",
            "loader",
            "to",
            "the",
            "given",
            "bundle",
            "if",
            "no",
            "class",
            "loader",
            "is",
            "present"
        ]
    },
    {
        "id": 436,
        "code": "public static Pair<Integer, Integer> parseAlacAudioSpecificConfig(byte[] audioSpecificConfig) {\n  ParsableByteArray byteArray = new ParsableByteArray(audioSpecificConfig);\n  byteArray.setPosition(9);\n  int channelCount = byteArray.readUnsignedByte();\n  byteArray.setPosition(20);\n  int sampleRate = byteArray.readUnsignedIntToInt();\n  return Pair.create(sampleRate, channelCount);\n}",
        "summary_tokens": [
            "parses",
            "an",
            "alac",
            "audio",
            "specific",
            "config",
            "i"
        ]
    },
    {
        "id": 437,
        "code": "public static List<byte[]> buildCea708InitializationData(boolean isWideAspectRatio) {\n  return Collections.singletonList(isWideAspectRatio ? new byte[] {1} : new byte[] {0});\n}",
        "summary_tokens": [
            "returns",
            "initialization",
            "data",
            "for",
            "formats",
            "with",
            "mime",
            "type",
            "mime",
            "types",
            "application",
            "cea",
            "0"
        ]
    },
    {
        "id": 438,
        "code": "public static boolean parseCea708InitializationData(List<byte[]> initializationData) {\n  return initializationData.size() == 1\n      && initializationData.get(0).length == 1\n      && initializationData.get(0)[0] == 1;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "cea",
            "0",
            "closed",
            "caption",
            "service",
            "with",
            "the",
            "given",
            "initialization",
            "data",
            "is",
            "formatted",
            "for",
            "displays",
            "with",
            "0",
            "0",
            "aspect",
            "ratio"
        ]
    },
    {
        "id": 439,
        "code": "public static Pair<Integer, Integer> getVideoResolutionFromMpeg4VideoConfig(\n    byte[] videoSpecificConfig) {\n  int offset = 0;\n  boolean foundVOL = false;\n  ParsableByteArray scratchBytes = new ParsableByteArray(videoSpecificConfig);\n  while (offset + 3 < videoSpecificConfig.length) {\n    if (scratchBytes.readUnsignedInt24() != VISUAL_OBJECT_LAYER\n        || (videoSpecificConfig[offset + 3] & 0xF0) != VISUAL_OBJECT_LAYER_START) {\n      scratchBytes.setPosition(scratchBytes.getPosition() - 2);\n      offset++;\n      continue;\n    }\n    foundVOL = true;\n    break;\n  }\n\n  checkArgument(foundVOL, \"Invalid input: VOL not found.\");\n\n  ParsableBitArray scratchBits = new ParsableBitArray(videoSpecificConfig);\n    \n  scratchBits.skipBits((offset + 4) * 8);\n  scratchBits.skipBits(1); \n  scratchBits.skipBits(8); \n\n  if (scratchBits.readBit()) { \n    scratchBits.skipBits(4); \n    scratchBits.skipBits(3); \n  }\n\n  int aspectRatioInfo = scratchBits.readBits(4);\n  if (aspectRatioInfo == EXTENDED_PAR) {\n    scratchBits.skipBits(8); \n    scratchBits.skipBits(8); \n  }\n\n  if (scratchBits.readBit()) { \n    scratchBits.skipBits(2); \n    scratchBits.skipBits(1); \n    if (scratchBits.readBit()) { \n      scratchBits.skipBits(79);\n    }\n  }\n\n  int videoObjectLayerShape = scratchBits.readBits(2);\n  checkArgument(\n      videoObjectLayerShape == RECTANGULAR,\n      \"Only supports rectangular video object layer shape.\");\n\n  checkArgument(scratchBits.readBit()); \n  int vopTimeIncrementResolution = scratchBits.readBits(16);\n  checkArgument(scratchBits.readBit()); \n\n  if (scratchBits.readBit()) { \n    checkArgument(vopTimeIncrementResolution > 0);\n    vopTimeIncrementResolution--;\n    int numBitsToSkip = 0;\n    while (vopTimeIncrementResolution > 0) {\n      numBitsToSkip++;\n      vopTimeIncrementResolution >>= 1;\n    }\n    scratchBits.skipBits(numBitsToSkip); \n  }\n\n  checkArgument(scratchBits.readBit()); \n  int videoObjectLayerWidth = scratchBits.readBits(13);\n  checkArgument(scratchBits.readBit()); \n  int videoObjectLayerHeight = scratchBits.readBits(13);\n  checkArgument(scratchBits.readBit()); \n\n  scratchBits.skipBits(1); \n\n  return Pair.create(videoObjectLayerWidth, videoObjectLayerHeight);\n}",
        "summary_tokens": [
            "parses",
            "an",
            "mpeg",
            "0",
            "visual",
            "configuration",
            "information",
            "as",
            "defined",
            "in",
            "iso",
            "iec",
            "0",
            "0"
        ]
    },
    {
        "id": 440,
        "code": "public static String buildAvcCodecString(\n    int profileIdc, int constraintsFlagsAndReservedZero2Bits, int levelIdc) {\n  return String.format(\n      \"avc1.%02X%02X%02X\", profileIdc, constraintsFlagsAndReservedZero2Bits, levelIdc);\n}",
        "summary_tokens": [
            "builds",
            "an",
            "rfc",
            "0",
            "avc",
            "codec",
            "string",
            "using",
            "the",
            "provided",
            "parameters"
        ]
    },
    {
        "id": 441,
        "code": "public static String buildHevcCodecString(\n    int generalProfileSpace,\n    boolean generalTierFlag,\n    int generalProfileIdc,\n    int generalProfileCompatibilityFlags,\n    int[] constraintBytes,\n    int generalLevelIdc) {\n  StringBuilder builder =\n      new StringBuilder(\n          Util.formatInvariant(\n              \"hvc1.%s%d.%X.%c%d\",\n              HEVC_GENERAL_PROFILE_SPACE_STRINGS[generalProfileSpace],\n              generalProfileIdc,\n              generalProfileCompatibilityFlags,\n              generalTierFlag ? 'H' : 'L',\n              generalLevelIdc));\n    \n  int trailingZeroIndex = constraintBytes.length;\n  while (trailingZeroIndex > 0 && constraintBytes[trailingZeroIndex - 1] == 0) {\n    trailingZeroIndex--;\n  }\n  for (int i = 0; i < trailingZeroIndex; i++) {\n    builder.append(String.format(\".%02X\", constraintBytes[i]));\n  }\n  return builder.toString();\n}",
        "summary_tokens": [
            "builds",
            "an",
            "rfc",
            "0",
            "hevc",
            "codec",
            "string",
            "using",
            "the",
            "provided",
            "parameters"
        ]
    },
    {
        "id": 442,
        "code": "public static byte[] buildNalUnit(byte[] data, int offset, int length) {\n  byte[] nalUnit = new byte[length + NAL_START_CODE.length];\n  System.arraycopy(NAL_START_CODE, 0, nalUnit, 0, NAL_START_CODE.length);\n  System.arraycopy(data, offset, nalUnit, NAL_START_CODE.length, length);\n  return nalUnit;\n}",
        "summary_tokens": [
            "constructs",
            "a",
            "nal",
            "unit",
            "consisting",
            "of",
            "the",
            "nal",
            "start",
            "code",
            "followed",
            "by",
            "the",
            "specified",
            "data"
        ]
    },
    {
        "id": 443,
        "code": "public static byte[][] splitNalUnits(byte[] data) {\n  if (!isNalStartCode(data, 0)) {\n      \n    return null;\n  }\n  List<Integer> starts = new ArrayList<>();\n  int nalUnitIndex = 0;\n  do {\n    starts.add(nalUnitIndex);\n    nalUnitIndex = findNalStartCode(data, nalUnitIndex + NAL_START_CODE.length);\n  } while (nalUnitIndex != C.INDEX_UNSET);\n  byte[][] split = new byte[starts.size()][];\n  for (int i = 0; i < starts.size(); i++) {\n    int startIndex = starts.get(i);\n    int endIndex = i < starts.size() - 1 ? starts.get(i + 1) : data.length;\n    byte[] nal = new byte[endIndex - startIndex];\n    System.arraycopy(data, startIndex, nal, 0, nal.length);\n    split[i] = nal;\n  }\n  return split;\n}",
        "summary_tokens": [
            "splits",
            "an",
            "array",
            "of",
            "nal",
            "units"
        ]
    },
    {
        "id": 444,
        "code": "private static int findNalStartCode(byte[] data, int index) {\n  int endIndex = data.length - NAL_START_CODE.length;\n  for (int i = index; i <= endIndex; i++) {\n    if (isNalStartCode(data, i)) {\n      return i;\n    }\n  }\n  return C.INDEX_UNSET;\n}",
        "summary_tokens": [
            "finds",
            "the",
            "next",
            "occurrence",
            "of",
            "the",
            "nal",
            "start",
            "code",
            "from",
            "a",
            "given",
            "index"
        ]
    },
    {
        "id": 445,
        "code": "private static boolean isNalStartCode(byte[] data, int index) {\n  if (data.length - index <= NAL_START_CODE.length) {\n    return false;\n  }\n  for (int j = 0; j < NAL_START_CODE.length; j++) {\n    if (data[index + j] != NAL_START_CODE[j]) {\n      return false;\n    }\n  }\n  return true;\n}",
        "summary_tokens": [
            "tests",
            "whether",
            "there",
            "exists",
            "a",
            "nal",
            "start",
            "code",
            "at",
            "a",
            "given",
            "index"
        ]
    },
    {
        "id": 446,
        "code": "public static int parseTtmlColor(String colorExpression) {\n  return parseColorInternal(colorExpression, false);\n}",
        "summary_tokens": [
            "parses",
            "a",
            "ttml",
            "color",
            "expression"
        ]
    },
    {
        "id": 447,
        "code": "public static int parseCssColor(String colorExpression) {\n  return parseColorInternal(colorExpression, true);\n}",
        "summary_tokens": [
            "parses",
            "a",
            "css",
            "color",
            "expression"
        ]
    },
    {
        "id": 448,
        "code": "public synchronized boolean open() {\n  if (isOpen) {\n    return false;\n  }\n  isOpen = true;\n  notifyAll();\n  return true;\n}",
        "summary_tokens": [
            "opens",
            "the",
            "condition",
            "and",
            "releases",
            "all",
            "threads",
            "that",
            "are",
            "blocked"
        ]
    },
    {
        "id": 449,
        "code": "public synchronized boolean block(long timeoutMs) throws InterruptedException {\n  if (timeoutMs <= 0) {\n    return isOpen;\n  }\n  long nowMs = clock.elapsedRealtime();\n  long endMs = nowMs + timeoutMs;\n  if (endMs < nowMs) {\n      \n    block();\n  } else {\n    while (!isOpen && nowMs < endMs) {\n      wait(endMs - nowMs);\n      nowMs = clock.elapsedRealtime();\n    }\n  }\n  return isOpen;\n}",
        "summary_tokens": [
            "blocks",
            "until",
            "the",
            "condition",
            "is",
            "opened",
            "or",
            "until",
            "timeout",
            "ms",
            "have",
            "passed"
        ]
    },
    {
        "id": 450,
        "code": "public synchronized void blockUninterruptible() {\n  boolean wasInterrupted = false;\n  while (!isOpen) {\n    try {\n      wait();\n    } catch (InterruptedException e) {\n      wasInterrupted = true;\n    }\n  }\n  if (wasInterrupted) {\n      \n    Thread.currentThread().interrupt();\n  }\n}",
        "summary_tokens": [
            "blocks",
            "until",
            "the",
            "condition",
            "is",
            "open"
        ]
    },
    {
        "id": 451,
        "code": "public synchronized boolean isOpen() {\n  return isOpen;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "condition",
            "is",
            "opened"
        ]
    },
    {
        "id": 452,
        "code": "public void add(E element) {\n  synchronized (lock) {\n    List<E> elements = new ArrayList<>(this.elements);\n    elements.add(element);\n    this.elements = Collections.unmodifiableList(elements);\n\n    @Nullable Integer count = elementCounts.get(element);\n    if (count == null) {\n      Set<E> elementSet = new HashSet<>(this.elementSet);\n      elementSet.add(element);\n      this.elementSet = Collections.unmodifiableSet(elementSet);\n    }\n    elementCounts.put(element, count != null ? count + 1 : 1);\n  }\n}",
        "summary_tokens": [
            "adds",
            "element",
            "to",
            "the",
            "multiset"
        ]
    },
    {
        "id": 453,
        "code": "public void remove(E element) {\n  synchronized (lock) {\n    @Nullable Integer count = elementCounts.get(element);\n    if (count == null) {\n      return;\n    }\n\n    List<E> elements = new ArrayList<>(this.elements);\n    elements.remove(element);\n    this.elements = Collections.unmodifiableList(elements);\n\n    if (count == 1) {\n      elementCounts.remove(element);\n      Set<E> elementSet = new HashSet<>(this.elementSet);\n      elementSet.remove(element);\n      this.elementSet = Collections.unmodifiableSet(elementSet);\n    } else {\n      elementCounts.put(element, count - 1);\n    }\n  }\n}",
        "summary_tokens": [
            "removes",
            "element",
            "from",
            "the",
            "multiset"
        ]
    },
    {
        "id": 454,
        "code": "public Set<E> elementSet() {\n  synchronized (lock) {\n    return elementSet;\n  }\n}",
        "summary_tokens": [
            "returns",
            "a",
            "snapshot",
            "of",
            "the",
            "unique",
            "elements",
            "currently",
            "in",
            "this",
            "multiset"
        ]
    },
    {
        "id": 455,
        "code": "public Iterator<E> iterator() {\n  synchronized (lock) {\n    return elements.iterator();\n  }\n}",
        "summary_tokens": [
            "returns",
            "an",
            "iterator",
            "over",
            "a",
            "snapshot",
            "of",
            "all",
            "the",
            "elements",
            "currently",
            "in",
            "this",
            "multiset",
            "including",
            "duplicates"
        ]
    },
    {
        "id": 456,
        "code": "public int count(E element) {\n  synchronized (lock) {\n    return elementCounts.containsKey(element) ? elementCounts.get(element) : 0;\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "occurrences",
            "of",
            "an",
            "element",
            "in",
            "this",
            "multiset"
        ]
    },
    {
        "id": 457,
        "code": "public void init(@SecureMode int secureMode) {\n  display = getDefaultDisplay();\n  EGLConfig config = chooseEGLConfig(display);\n  context = createEGLContext(display, config, secureMode);\n  surface = createEGLSurface(display, config, context, secureMode);\n  generateTextureIds(textureIdHolder);\n  texture = new SurfaceTexture(textureIdHolder[0]);\n  texture.setOnFrameAvailableListener(this);\n}",
        "summary_tokens": [
            "initializes",
            "required",
            "egl",
            "parameters",
            "and",
            "creates",
            "the",
            "surface",
            "texture"
        ]
    },
    {
        "id": 458,
        "code": "public void release() {\n  handler.removeCallbacks(this);\n  try {\n    if (texture != null) {\n      texture.release();\n      GLES20.glDeleteTextures(1, textureIdHolder, 0);\n    }\n  } finally {\n    if (display != null && !display.equals(EGL14.EGL_NO_DISPLAY)) {\n      EGL14.eglMakeCurrent(\n          display, EGL14.EGL_NO_SURFACE, EGL14.EGL_NO_SURFACE, EGL14.EGL_NO_CONTEXT);\n    }\n    if (surface != null && !surface.equals(EGL14.EGL_NO_SURFACE)) {\n      EGL14.eglDestroySurface(display, surface);\n    }\n    if (context != null) {\n      EGL14.eglDestroyContext(display, context);\n    }\n      \n    if (Util.SDK_INT >= 19) {\n      EGL14.eglReleaseThread();\n    }\n    if (display != null && !display.equals(EGL14.EGL_NO_DISPLAY)) {\n        \n        \n      EGL14.eglTerminate(display);\n    }\n    display = null;\n    context = null;\n    surface = null;\n    texture = null;\n  }\n}",
        "summary_tokens": [
            "releases",
            "all",
            "allocated",
            "resources"
        ]
    },
    {
        "id": 459,
        "code": "public SurfaceTexture getSurfaceTexture() {\n  return Assertions.checkNotNull(texture);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "wrapped",
            "surface",
            "texture"
        ]
    },
    {
        "id": 460,
        "code": "public static @FileTypes.Type int inferFileTypeFromResponseHeaders(\n    Map<String, List<String>> responseHeaders) {\n  @Nullable List<String> contentTypes = responseHeaders.get(HEADER_CONTENT_TYPE);\n  @Nullable\n  String mimeType = contentTypes == null || contentTypes.isEmpty() ? null : contentTypes.get(0);\n  return inferFileTypeFromMimeType(mimeType);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "type",
            "corresponding",
            "to",
            "the",
            "response",
            "headers",
            "provided"
        ]
    },
    {
        "id": 461,
        "code": "public static @FileTypes.Type int inferFileTypeFromMimeType(@Nullable String mimeType) {\n  if (mimeType == null) {\n    return FileTypes.UNKNOWN;\n  }\n  mimeType = normalizeMimeType(mimeType);\n  switch (mimeType) {\n    case MimeTypes.AUDIO_AC3:\n    case MimeTypes.AUDIO_E_AC3:\n    case MimeTypes.AUDIO_E_AC3_JOC:\n      return FileTypes.AC3;\n    case MimeTypes.AUDIO_AC4:\n      return FileTypes.AC4;\n    case MimeTypes.AUDIO_AMR:\n    case MimeTypes.AUDIO_AMR_NB:\n    case MimeTypes.AUDIO_AMR_WB:\n      return FileTypes.AMR;\n    case MimeTypes.AUDIO_FLAC:\n      return FileTypes.FLAC;\n    case MimeTypes.VIDEO_FLV:\n      return FileTypes.FLV;\n    case MimeTypes.AUDIO_MIDI:\n      return FileTypes.MIDI;\n    case MimeTypes.VIDEO_MATROSKA:\n    case MimeTypes.AUDIO_MATROSKA:\n    case MimeTypes.VIDEO_WEBM:\n    case MimeTypes.AUDIO_WEBM:\n    case MimeTypes.APPLICATION_WEBM:\n      return FileTypes.MATROSKA;\n    case MimeTypes.AUDIO_MPEG:\n      return FileTypes.MP3;\n    case MimeTypes.VIDEO_MP4:\n    case MimeTypes.AUDIO_MP4:\n    case MimeTypes.APPLICATION_MP4:\n      return FileTypes.MP4;\n    case MimeTypes.AUDIO_OGG:\n      return FileTypes.OGG;\n    case MimeTypes.VIDEO_PS:\n      return FileTypes.PS;\n    case MimeTypes.VIDEO_MP2T:\n      return FileTypes.TS;\n    case MimeTypes.AUDIO_WAV:\n      return FileTypes.WAV;\n    case MimeTypes.TEXT_VTT:\n      return FileTypes.WEBVTT;\n    case MimeTypes.IMAGE_JPEG:\n      return FileTypes.JPEG;\n    case MimeTypes.VIDEO_AVI:\n      return FileTypes.AVI;\n    default:\n      return FileTypes.UNKNOWN;\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "type",
            "corresponding",
            "to",
            "the",
            "mime",
            "type",
            "provided"
        ]
    },
    {
        "id": 462,
        "code": "public static @FileTypes.Type int inferFileTypeFromUri(Uri uri) {\n  @Nullable String filename = uri.getLastPathSegment();\n  if (filename == null) {\n    return FileTypes.UNKNOWN;\n  } else if (filename.endsWith(EXTENSION_AC3) || filename.endsWith(EXTENSION_EC3)) {\n    return FileTypes.AC3;\n  } else if (filename.endsWith(EXTENSION_AC4)) {\n    return FileTypes.AC4;\n  } else if (filename.endsWith(EXTENSION_ADTS) || filename.endsWith(EXTENSION_AAC)) {\n    return FileTypes.ADTS;\n  } else if (filename.endsWith(EXTENSION_AMR)) {\n    return FileTypes.AMR;\n  } else if (filename.endsWith(EXTENSION_FLAC)) {\n    return FileTypes.FLAC;\n  } else if (filename.endsWith(EXTENSION_FLV)) {\n    return FileTypes.FLV;\n  } else if (filename.endsWith(EXTENSION_MID)\n      || filename.endsWith(EXTENSION_MIDI)\n      || filename.endsWith(EXTENSION_SMF)) {\n    return FileTypes.MIDI;\n  } else if (filename.startsWith(\n          EXTENSION_PREFIX_MK,\n           filename.length() - (EXTENSION_PREFIX_MK.length() + 1))\n      || filename.endsWith(EXTENSION_WEBM)) {\n    return FileTypes.MATROSKA;\n  } else if (filename.endsWith(EXTENSION_MP3)) {\n    return FileTypes.MP3;\n  } else if (filename.endsWith(EXTENSION_MP4)\n      || filename.startsWith(\n          EXTENSION_PREFIX_M4,\n           filename.length() - (EXTENSION_PREFIX_M4.length() + 1))\n      || filename.startsWith(\n          EXTENSION_PREFIX_MP4,\n           filename.length() - (EXTENSION_PREFIX_MP4.length() + 1))\n      || filename.startsWith(\n          EXTENSION_PREFIX_CMF,\n           filename.length() - (EXTENSION_PREFIX_CMF.length() + 1))) {\n    return FileTypes.MP4;\n  } else if (filename.startsWith(\n          EXTENSION_PREFIX_OG,\n           filename.length() - (EXTENSION_PREFIX_OG.length() + 1))\n      || filename.endsWith(EXTENSION_OPUS)) {\n    return FileTypes.OGG;\n  } else if (filename.endsWith(EXTENSION_PS)\n      || filename.endsWith(EXTENSION_MPEG)\n      || filename.endsWith(EXTENSION_MPG)\n      || filename.endsWith(EXTENSION_M2P)) {\n    return FileTypes.PS;\n  } else if (filename.endsWith(EXTENSION_TS)\n      || filename.startsWith(\n          EXTENSION_PREFIX_TS,\n           filename.length() - (EXTENSION_PREFIX_TS.length() + 1))) {\n    return FileTypes.TS;\n  } else if (filename.endsWith(EXTENSION_WAV) || filename.endsWith(EXTENSION_WAVE)) {\n    return FileTypes.WAV;\n  } else if (filename.endsWith(EXTENSION_VTT) || filename.endsWith(EXTENSION_WEBVTT)) {\n    return FileTypes.WEBVTT;\n  } else if (filename.endsWith(EXTENSION_JPG) || filename.endsWith(EXTENSION_JPEG)) {\n    return FileTypes.JPEG;\n  } else if (filename.endsWith(EXTENSION_AVI)) {\n    return FileTypes.AVI;\n  } else {\n    return FileTypes.UNKNOWN;\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "type",
            "corresponding",
            "to",
            "the",
            "uri",
            "provided"
        ]
    },
    {
        "id": 463,
        "code": "public boolean contains(int flag) {\n  return flags.get(flag);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "set",
            "contains",
            "the",
            "given",
            "flag"
        ]
    },
    {
        "id": 464,
        "code": "public boolean containsAny(int... flags) {\n  for (int flag : flags) {\n    if (contains(flag)) {\n      return true;\n    }\n  }\n  return false;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "set",
            "contains",
            "at",
            "least",
            "one",
            "of",
            "the",
            "given",
            "flags"
        ]
    },
    {
        "id": 465,
        "code": "public int size() {\n  return flags.size();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "flags",
            "in",
            "this",
            "set"
        ]
    },
    {
        "id": 466,
        "code": "public int get(int index) {\n  checkIndex(index,  0,  size());\n  return flags.keyAt(index);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "flag",
            "at",
            "the",
            "given",
            "index"
        ]
    },
    {
        "id": 467,
        "code": "private int getAttributeLocation(String attributeName) {\n  return getAttributeLocation(programId, attributeName);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "location",
            "of",
            "an",
            "attribute"
        ]
    },
    {
        "id": 468,
        "code": "public int getUniformLocation(String uniformName) {\n  return getUniformLocation(programId, uniformName);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "location",
            "of",
            "a",
            "uniform"
        ]
    },
    {
        "id": 469,
        "code": "public int getAttributeArrayLocationAndEnable(String attributeName) {\n  int location = getAttributeLocation(attributeName);\n  GLES20.glEnableVertexAttribArray(location);\n  GlUtil.checkGlError();\n  return location;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "location",
            "of",
            "an",
            "attribute",
            "which",
            "has",
            "been",
            "enabled",
            "as",
            "a",
            "vertex",
            "attribute",
            "array"
        ]
    },
    {
        "id": 470,
        "code": "public void setBufferAttribute(String name, float[] values, int size) {\n  checkNotNull(attributeByName.get(name)).setBuffer(values, size);\n}",
        "summary_tokens": [
            "sets",
            "a",
            "float",
            "buffer",
            "type",
            "attribute"
        ]
    },
    {
        "id": 471,
        "code": "public void setSamplerTexIdUniform(String name, int texId, int texUnitIndex) {\n  checkNotNull(uniformByName.get(name)).setSamplerTexId(texId, texUnitIndex);\n}",
        "summary_tokens": [
            "sets",
            "a",
            "texture",
            "sampler",
            "type",
            "uniform"
        ]
    },
    {
        "id": 472,
        "code": "public void setFloatUniform(String name, float value) {\n  checkNotNull(uniformByName.get(name)).setFloat(value);\n}",
        "summary_tokens": [
            "sets",
            "a",
            "float",
            "type",
            "uniform"
        ]
    },
    {
        "id": 473,
        "code": "public void setFloatsUniform(String name, float[] value) {\n  checkNotNull(uniformByName.get(name)).setFloats(value);\n}",
        "summary_tokens": [
            "sets",
            "a",
            "float",
            "array",
            "type",
            "uniform"
        ]
    },
    {
        "id": 474,
        "code": "public void bindAttributesAndUniforms() {\n  for (Attribute attribute : attributes) {\n    attribute.bind();\n  }\n  for (Uniform uniform : uniforms) {\n    uniform.bind();\n  }\n}",
        "summary_tokens": [
            "binds",
            "all",
            "attributes",
            "and",
            "uniforms",
            "in",
            "the",
            "program"
        ]
    },
    {
        "id": 475,
        "code": "private static int getCStringLength(byte[] cString) {\n  for (int i = 0; i < cString.length; ++i) {\n    if (cString[i] == '\\0') {\n      return i;\n    }\n  }\n  return cString.length;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "length",
            "of",
            "the",
            "null",
            "terminated",
            "c",
            "string",
            "in",
            "c",
            "string"
        ]
    },
    {
        "id": 476,
        "code": "public static float[] getNormalizedCoordinateBounds() {\n  return new float[] {\n    -1, -1, 0, 1,\n    1, -1, 0, 1,\n    -1, 1, 0, 1,\n    1, 1, 0, 1\n  };\n}",
        "summary_tokens": [
            "bounds",
            "of",
            "normalized",
            "device",
            "coordinates",
            "commonly",
            "used",
            "for",
            "defining",
            "viewport",
            "boundaries"
        ]
    },
    {
        "id": 477,
        "code": "public static float[] getTextureCoordinateBounds() {\n  return new float[] {\n    0, 0, 0, 1,\n    1, 0, 0, 1,\n    0, 1, 0, 1,\n    1, 1, 0, 1\n  };\n}",
        "summary_tokens": [
            "typical",
            "bounds",
            "used",
            "for",
            "sampling",
            "from",
            "textures"
        ]
    },
    {
        "id": 478,
        "code": "public static float[] createVertexBuffer(List<float[]> vertexList) {\n  float[] vertexBuffer = new float[HOMOGENEOUS_COORDINATE_VECTOR_SIZE * vertexList.size()];\n  for (int i = 0; i < vertexList.size(); i++) {\n    System.arraycopy(\n         vertexList.get(i),\n         0,\n         vertexBuffer,\n         HOMOGENEOUS_COORDINATE_VECTOR_SIZE * i,\n         HOMOGENEOUS_COORDINATE_VECTOR_SIZE);\n  }\n  return vertexBuffer;\n}",
        "summary_tokens": [
            "flattens",
            "the",
            "list",
            "of",
            "0",
            "element",
            "ndc",
            "coordinate",
            "vectors",
            "into",
            "a",
            "buffer"
        ]
    },
    {
        "id": 479,
        "code": "public static boolean isProtectedContentExtensionSupported(Context context) {\n  if (Util.SDK_INT < 24) {\n    return false;\n  }\n  if (Util.SDK_INT < 26 && (\"samsung\".equals(Util.MANUFACTURER) || \"XT1650\".equals(Util.MODEL))) {\n      \n      \n      \n      \n    return false;\n  }\n  if (Util.SDK_INT < 26\n      && !context\n          .getPackageManager()\n          .hasSystemFeature(PackageManager.FEATURE_VR_MODE_HIGH_PERFORMANCE)) {\n      \n    return false;\n  }\n\n  EGLDisplay display = EGL14.eglGetDisplay(EGL14.EGL_DEFAULT_DISPLAY);\n  @Nullable String eglExtensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);\n  return eglExtensions != null && eglExtensions.contains(EXTENSION_PROTECTED_CONTENT);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "creating",
            "a",
            "gl",
            "context",
            "with",
            "extension",
            "protected",
            "content",
            "is",
            "possible"
        ]
    },
    {
        "id": 480,
        "code": "public static boolean isSurfacelessContextExtensionSupported() {\n  if (Util.SDK_INT < 17) {\n    return false;\n  }\n  EGLDisplay display = EGL14.eglGetDisplay(EGL14.EGL_DEFAULT_DISPLAY);\n  @Nullable String eglExtensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);\n  return eglExtensions != null && eglExtensions.contains(EXTENSION_SURFACELESS_CONTEXT);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "extension",
            "surfaceless",
            "context",
            "extension",
            "is",
            "supported"
        ]
    },
    {
        "id": 481,
        "code": "public static EGLDisplay createEglDisplay() {\n  return Api17.createEglDisplay();\n}",
        "summary_tokens": [
            "returns",
            "an",
            "initialized",
            "default",
            "egldisplay"
        ]
    },
    {
        "id": 482,
        "code": "public static EGLContext createEglContext(EGLDisplay eglDisplay) {\n  return Api17.createEglContext(eglDisplay,  2, EGL_CONFIG_ATTRIBUTES_RGBA_8888);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "eglcontext",
            "for",
            "the",
            "specified",
            "egldisplay"
        ]
    },
    {
        "id": 483,
        "code": "public static EGLContext createEglContextEs3Rgba1010102(EGLDisplay eglDisplay) {\n  return Api17.createEglContext(eglDisplay,  3, EGL_CONFIG_ATTRIBUTES_RGBA_1010102);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "eglcontext",
            "for",
            "the",
            "specified",
            "egldisplay",
            "requesting",
            "es",
            "0",
            "and",
            "an",
            "rgba",
            "0",
            "config"
        ]
    },
    {
        "id": 484,
        "code": "public static EGLSurface getEglSurface(EGLDisplay eglDisplay, Object surface) {\n  return Api17.getEglSurface(\n      eglDisplay, surface, EGL_CONFIG_ATTRIBUTES_RGBA_8888, EGL_WINDOW_SURFACE_ATTRIBUTES_NONE);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "eglsurface",
            "wrapping",
            "the",
            "specified",
            "surface"
        ]
    },
    {
        "id": 485,
        "code": "public static EGLSurface getEglSurfaceBt2020Pq(EGLDisplay eglDisplay, Object surface) {\n  return Api17.getEglSurface(\n      eglDisplay,\n      surface,\n      EGL_CONFIG_ATTRIBUTES_RGBA_1010102,\n      EGL_WINDOW_SURFACE_ATTRIBUTES_BT2020_PQ);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "eglsurface",
            "wrapping",
            "the",
            "specified",
            "surface",
            "for",
            "hdr",
            "rendering",
            "with",
            "rec"
        ]
    },
    {
        "id": 486,
        "code": "private static EGLSurface createPbufferSurface(EGLDisplay eglDisplay, int width, int height) {\n  int[] pbufferAttributes =\n      new int[] {\n        EGL14.EGL_WIDTH, width,\n        EGL14.EGL_HEIGHT, height,\n        EGL14.EGL_NONE\n      };\n  return Api17.createEglPbufferSurface(\n      eglDisplay, EGL_CONFIG_ATTRIBUTES_RGBA_8888, pbufferAttributes);\n}",
        "summary_tokens": [
            "creates",
            "a",
            "new",
            "eglsurface",
            "wrapping",
            "a",
            "pixel",
            "buffer"
        ]
    },
    {
        "id": 487,
        "code": "public static EGLSurface createPlaceholderEglSurface(EGLDisplay eglDisplay) {\n  return isSurfacelessContextExtensionSupported()\n      ? EGL14.EGL_NO_SURFACE\n      : createPbufferSurface(eglDisplay,  1,  1);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "placeholder",
            "eglsurface",
            "to",
            "use",
            "when",
            "reading",
            "and",
            "writing",
            "to",
            "the",
            "surface",
            "is",
            "not",
            "required"
        ]
    },
    {
        "id": 488,
        "code": "public static void focusPlaceholderEglSurface(EGLContext eglContext, EGLDisplay eglDisplay) {\n  EGLSurface eglSurface = createPbufferSurface(eglDisplay,  1,  1);\n  focusEglSurface(eglDisplay, eglContext, eglSurface,  1,  1);\n}",
        "summary_tokens": [
            "creates",
            "and",
            "focuses",
            "a",
            "new",
            "eglsurface",
            "wrapping",
            "a",
            "0",
            "x",
            "0",
            "pixel",
            "buffer"
        ]
    },
    {
        "id": 489,
        "code": "public static void focusPlaceholderEglSurfaceBt2020Pq(\n    EGLContext eglContext, EGLDisplay eglDisplay) {\n  int[] pbufferAttributes =\n      new int[] {\n        EGL14.EGL_WIDTH,\n         1,\n        EGL14.EGL_HEIGHT,\n         1,\n        EGL_GL_COLORSPACE_KHR,\n        EGL_GL_COLORSPACE_BT2020_PQ_EXT,\n        EGL14.EGL_NONE\n      };\n  EGLSurface eglSurface =\n      Api17.createEglPbufferSurface(\n          eglDisplay, EGL_CONFIG_ATTRIBUTES_RGBA_1010102, pbufferAttributes);\n  focusEglSurface(eglDisplay, eglContext, eglSurface,  1,  1);\n}",
        "summary_tokens": [
            "creates",
            "and",
            "focuses",
            "a",
            "new",
            "eglsurface",
            "wrapping",
            "a",
            "0",
            "x",
            "0",
            "pixel",
            "buffer",
            "for",
            "hdr",
            "rendering",
            "with",
            "rec"
        ]
    },
    {
        "id": 490,
        "code": "public static void checkGlError() {\n  int lastError = GLES20.GL_NO_ERROR;\n  int error;\n  while ((error = GLES20.glGetError()) != GLES20.GL_NO_ERROR) {\n    Log.e(TAG, \"glError: \" + gluErrorString(error));\n    lastError = error;\n  }\n  if (lastError != GLES20.GL_NO_ERROR) {\n    throwGlException(\"glError: \" + gluErrorString(lastError));\n  }\n}",
        "summary_tokens": [
            "if",
            "there",
            "is",
            "an",
            "open",
            "gl",
            "error",
            "logs",
            "the",
            "error",
            "and",
            "if",
            "gl",
            "assertions",
            "enabled",
            "is",
            "true",
            "throws",
            "a",
            "gl",
            "exception"
        ]
    },
    {
        "id": 491,
        "code": "public static void assertValidTextureSize(int width, int height) {\n    \n    \n    \n\n    \n    \n  int[] maxTextureSizeBuffer = new int[1];\n  GLES20.glGetIntegerv(GLES20.GL_MAX_TEXTURE_SIZE, maxTextureSizeBuffer, 0);\n  int maxTextureSize = maxTextureSizeBuffer[0];\n  if (width < 0 || height < 0) {\n    throwGlException(\"width or height is less than 0\");\n  }\n  if (width > maxTextureSize || height > maxTextureSize) {\n    throwGlException(\"width or height is greater than GL_MAX_TEXTURE_SIZE \" + maxTextureSize);\n  }\n}",
        "summary_tokens": [
            "asserts",
            "the",
            "texture",
            "size",
            "is",
            "valid"
        ]
    },
    {
        "id": 492,
        "code": "public static void focusEglSurface(\n    EGLDisplay eglDisplay, EGLContext eglContext, EGLSurface eglSurface, int width, int height) {\n  Api17.focusRenderTarget(\n      eglDisplay, eglContext, eglSurface,  0, width, height);\n}",
        "summary_tokens": [
            "makes",
            "the",
            "specified",
            "egl",
            "surface",
            "the",
            "render",
            "target",
            "using",
            "a",
            "viewport",
            "of",
            "width",
            "by",
            "height",
            "pixels"
        ]
    },
    {
        "id": 493,
        "code": "public static void focusFramebuffer(\n    EGLDisplay eglDisplay,\n    EGLContext eglContext,\n    EGLSurface eglSurface,\n    int framebuffer,\n    int width,\n    int height) {\n  Api17.focusRenderTarget(eglDisplay, eglContext, eglSurface, framebuffer, width, height);\n}",
        "summary_tokens": [
            "makes",
            "the",
            "specified",
            "framebuffer",
            "the",
            "render",
            "target",
            "using",
            "a",
            "viewport",
            "of",
            "width",
            "by",
            "height",
            "pixels"
        ]
    },
    {
        "id": 494,
        "code": "public static void deleteTexture(int textureId) {\n  GLES20.glDeleteTextures( 1, new int[] {textureId},  0);\n  checkGlError();\n}",
        "summary_tokens": [
            "deletes",
            "a",
            "gl",
            "texture"
        ]
    },
    {
        "id": 495,
        "code": "public static void destroyEglContext(\n    @Nullable EGLDisplay eglDisplay, @Nullable EGLContext eglContext) {\n  Api17.destroyEglContext(eglDisplay, eglContext);\n}",
        "summary_tokens": [
            "destroys",
            "the",
            "eglcontext",
            "identified",
            "by",
            "the",
            "provided",
            "egldisplay",
            "and",
            "eglcontext"
        ]
    },
    {
        "id": 496,
        "code": "public static FloatBuffer createBuffer(int capacity) {\n  ByteBuffer byteBuffer = ByteBuffer.allocateDirect(capacity * C.BYTES_PER_FLOAT);\n  return byteBuffer.order(ByteOrder.nativeOrder()).asFloatBuffer();\n}",
        "summary_tokens": [
            "allocates",
            "a",
            "float",
            "buffer"
        ]
    },
    {
        "id": 497,
        "code": "public static String loadAsset(Context context, String assetPath) throws IOException {\n  @Nullable InputStream inputStream = null;\n  try {\n    inputStream = context.getAssets().open(assetPath);\n    return Util.fromUtf8Bytes(Util.toByteArray(inputStream));\n  } finally {\n    Util.closeQuietly(inputStream);\n  }\n}",
        "summary_tokens": [
            "loads",
            "a",
            "file",
            "from",
            "the",
            "assets",
            "folder"
        ]
    },
    {
        "id": 498,
        "code": "public static int createExternalTexture() {\n  int texId = generateTexture();\n  bindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, texId);\n  return texId;\n}",
        "summary_tokens": [
            "creates",
            "a",
            "gl",
            "texture",
            "external",
            "oes",
            "with",
            "default",
            "configuration",
            "of",
            "gl",
            "linear",
            "filtering",
            "and",
            "gl",
            "clamp",
            "to",
            "edge",
            "wrapping"
        ]
    },
    {
        "id": 499,
        "code": "public static int createTexture(int width, int height) {\n  assertValidTextureSize(width, height);\n  int texId = generateTexture();\n  bindTexture(GLES20.GL_TEXTURE_2D, texId);\n  ByteBuffer byteBuffer = ByteBuffer.allocateDirect(width * height * 4);\n  GLES20.glTexImage2D(\n      GLES20.GL_TEXTURE_2D,\n       0,\n      GLES20.GL_RGBA,\n      width,\n      height,\n       0,\n      GLES20.GL_RGBA,\n      GLES20.GL_UNSIGNED_BYTE,\n      byteBuffer);\n  checkGlError();\n  return texId;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "texture",
            "identifier",
            "for",
            "a",
            "newly",
            "allocated",
            "texture",
            "with",
            "the",
            "specified",
            "dimensions"
        ]
    },
    {
        "id": 500,
        "code": "private static int generateTexture() {\n  checkEglException(\n      !Util.areEqual(EGL14.eglGetCurrentContext(), EGL14.EGL_NO_CONTEXT), \"No current context\");\n\n  int[] texId = new int[1];\n  GLES20.glGenTextures( 1, texId,  0);\n  checkGlError();\n  return texId[0];\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "gl",
            "texture",
            "identifier"
        ]
    },
    {
        "id": 501,
        "code": "public static void bindTexture(int textureTarget, int texId) {\n  GLES20.glBindTexture(textureTarget, texId);\n  checkGlError();\n  GLES20.glTexParameteri(textureTarget, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);\n  checkGlError();\n  GLES20.glTexParameteri(textureTarget, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);\n  checkGlError();\n  GLES20.glTexParameteri(textureTarget, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);\n  checkGlError();\n  GLES20.glTexParameteri(textureTarget, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);\n  checkGlError();\n}",
        "summary_tokens": [
            "binds",
            "the",
            "texture",
            "of",
            "the",
            "given",
            "type",
            "with",
            "default",
            "configuration",
            "of",
            "gl",
            "linear",
            "filtering",
            "and",
            "gl",
            "clamp",
            "to",
            "edge",
            "wrapping"
        ]
    },
    {
        "id": 502,
        "code": "public static int createFboForTexture(int texId) {\n  checkEglException(\n      !Util.areEqual(EGL14.eglGetCurrentContext(), EGL14.EGL_NO_CONTEXT), \"No current context\");\n\n  int[] fboId = new int[1];\n  GLES20.glGenFramebuffers( 1, fboId,  0);\n  checkGlError();\n  GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, fboId[0]);\n  checkGlError();\n  GLES20.glFramebufferTexture2D(\n      GLES20.GL_FRAMEBUFFER, GLES20.GL_COLOR_ATTACHMENT0, GLES20.GL_TEXTURE_2D, texId, 0);\n  checkGlError();\n  return fboId[0];\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "framebuffer",
            "for",
            "the",
            "texture"
        ]
    },
    {
        "id": 503,
        "code": "public synchronized void setLibraries(String... libraries) {\n  Assertions.checkState(!loadAttempted, \"Cannot set libraries after loading\");\n  nativeLibraries = libraries;\n}",
        "summary_tokens": [
            "overrides",
            "the",
            "names",
            "of",
            "the",
            "libraries",
            "to",
            "load"
        ]
    },
    {
        "id": 504,
        "code": "public synchronized boolean isAvailable() {\n  if (loadAttempted) {\n    return isAvailable;\n  }\n  loadAttempted = true;\n  try {\n    for (String lib : nativeLibraries) {\n      loadLibrary(lib);\n    }\n    isAvailable = true;\n  } catch (UnsatisfiedLinkError exception) {\n      \n      \n    Log.w(TAG, \"Failed to load \" + Arrays.toString(nativeLibraries));\n  }\n  return isAvailable;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "underlying",
            "libraries",
            "are",
            "available",
            "loading",
            "them",
            "if",
            "necessary"
        ]
    },
    {
        "id": 505,
        "code": "public static @LogLevel int getLogLevel() {\n  synchronized (lock) {\n    return logLevel;\n  }\n}",
        "summary_tokens": [
            "returns",
            "current",
            "log",
            "level",
            "for",
            "exo",
            "player",
            "logcat",
            "logging"
        ]
    },
    {
        "id": 506,
        "code": "public static void setLogLevel(@LogLevel int logLevel) {\n  synchronized (lock) {\n    Log.logLevel = logLevel;\n  }\n}",
        "summary_tokens": [
            "sets",
            "the",
            "log",
            "level",
            "for",
            "exo",
            "player",
            "logcat",
            "logging"
        ]
    },
    {
        "id": 507,
        "code": "public static void setLogStackTraces(boolean logStackTraces) {\n  synchronized (lock) {\n    Log.logStackTraces = logStackTraces;\n  }\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "stack",
            "traces",
            "of",
            "throwable",
            "s",
            "will",
            "be",
            "logged",
            "to",
            "logcat"
        ]
    },
    {
        "id": 508,
        "code": "public static void setLogger(Logger logger) {\n  synchronized (lock) {\n    Log.logger = logger;\n  }\n}",
        "summary_tokens": [
            "sets",
            "a",
            "custom",
            "logger",
            "as",
            "the",
            "output"
        ]
    },
    {
        "id": 509,
        "code": "public static String getThrowableString(@Nullable Throwable throwable) {\n  synchronized (lock) {\n    if (throwable == null) {\n      return null;\n    } else if (isCausedByUnknownHostException(throwable)) {\n        \n        \n        \n        \n        \n        \n        \n      return \"UnknownHostException (no network)\";\n    } else if (!logStackTraces) {\n      return throwable.getMessage();\n    } else {\n      return android.util.Log.getStackTraceString(throwable).trim().replace(\"\\t\", \"    \");\n    }\n  }\n}",
        "summary_tokens": [
            "returns",
            "a",
            "string",
            "representation",
            "of",
            "a",
            "throwable",
            "suitable",
            "for",
            "logging",
            "taking",
            "into",
            "account",
            "whether",
            "set",
            "log",
            "stack",
            "traces",
            "boolean",
            "stack",
            "trace",
            "logging",
            "is",
            "enabled"
        ]
    },
    {
        "id": 510,
        "code": "public long get(int index) {\n  if (index < 0 || index >= size) {\n    throw new IndexOutOfBoundsException(\"Invalid index \" + index + \", size is \" + size);\n  }\n  return values[index];\n}",
        "summary_tokens": [
            "returns",
            "the",
            "value",
            "at",
            "a",
            "specified",
            "index"
        ]
    },
    {
        "id": 511,
        "code": "public int size() {\n  return size;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "current",
            "size",
            "of",
            "the",
            "array"
        ]
    },
    {
        "id": 512,
        "code": "public long[] toArray() {\n  return Arrays.copyOf(values, size);\n}",
        "summary_tokens": [
            "copies",
            "the",
            "current",
            "values",
            "into",
            "a",
            "newly",
            "allocated",
            "primitive",
            "array"
        ]
    },
    {
        "id": 513,
        "code": "public static MediaFormat createMediaFormatFromFormat(Format format) {\n  MediaFormat result = new MediaFormat();\n  maybeSetInteger(result, MediaFormat.KEY_BIT_RATE, format.bitrate);\n  maybeSetInteger(result, KEY_MAX_BIT_RATE, format.peakBitrate);\n  maybeSetInteger(result, MediaFormat.KEY_CHANNEL_COUNT, format.channelCount);\n\n  maybeSetColorInfo(result, format.colorInfo);\n\n  maybeSetString(result, MediaFormat.KEY_MIME, format.sampleMimeType);\n  maybeSetString(result, MediaFormat.KEY_CODECS_STRING, format.codecs);\n  maybeSetFloat(result, MediaFormat.KEY_FRAME_RATE, format.frameRate);\n  maybeSetInteger(result, MediaFormat.KEY_WIDTH, format.width);\n  maybeSetInteger(result, MediaFormat.KEY_HEIGHT, format.height);\n\n  setCsdBuffers(result, format.initializationData);\n  maybeSetPcmEncoding(result, format.pcmEncoding);\n  maybeSetString(result, MediaFormat.KEY_LANGUAGE, format.language);\n  maybeSetInteger(result, MediaFormat.KEY_MAX_INPUT_SIZE, format.maxInputSize);\n  maybeSetInteger(result, MediaFormat.KEY_SAMPLE_RATE, format.sampleRate);\n  maybeSetInteger(result, MediaFormat.KEY_CAPTION_SERVICE_NUMBER, format.accessibilityChannel);\n  result.setInteger(MediaFormat.KEY_ROTATION, format.rotationDegrees);\n\n  int selectionFlags = format.selectionFlags;\n  setBooleanAsInt(\n      result, MediaFormat.KEY_IS_AUTOSELECT, selectionFlags & C.SELECTION_FLAG_AUTOSELECT);\n  setBooleanAsInt(result, MediaFormat.KEY_IS_DEFAULT, selectionFlags & C.SELECTION_FLAG_DEFAULT);\n  setBooleanAsInt(\n      result, MediaFormat.KEY_IS_FORCED_SUBTITLE, selectionFlags & C.SELECTION_FLAG_FORCED);\n\n  result.setInteger(MediaFormat.KEY_ENCODER_DELAY, format.encoderDelay);\n  result.setInteger(MediaFormat.KEY_ENCODER_PADDING, format.encoderPadding);\n\n  maybeSetPixelAspectRatio(result, format.pixelWidthHeightRatio);\n  return result;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "media",
            "format",
            "representing",
            "the",
            "given",
            "exo",
            "player",
            "format"
        ]
    },
    {
        "id": 514,
        "code": "public static void maybeSetString(MediaFormat format, String key, @Nullable String value) {\n  if (value != null) {\n    format.setString(key, value);\n  }\n}",
        "summary_tokens": [
            "sets",
            "a",
            "media",
            "format",
            "string",
            "value"
        ]
    },
    {
        "id": 515,
        "code": "public static void setCsdBuffers(MediaFormat format, List<byte[]> csdBuffers) {\n  for (int i = 0; i < csdBuffers.size(); i++) {\n    format.setByteBuffer(\"csd-\" + i, ByteBuffer.wrap(csdBuffers.get(i)));\n  }\n}",
        "summary_tokens": [
            "sets",
            "a",
            "media",
            "format",
            "s",
            "codec",
            "specific",
            "data",
            "buffers"
        ]
    },
    {
        "id": 516,
        "code": "public static void maybeSetInteger(MediaFormat format, String key, int value) {\n  if (value != Format.NO_VALUE) {\n    format.setInteger(key, value);\n  }\n}",
        "summary_tokens": [
            "sets",
            "a",
            "media",
            "format",
            "integer",
            "value"
        ]
    },
    {
        "id": 517,
        "code": "public static void maybeSetFloat(MediaFormat format, String key, float value) {\n  if (value != Format.NO_VALUE) {\n    format.setFloat(key, value);\n  }\n}",
        "summary_tokens": [
            "sets",
            "a",
            "media",
            "format",
            "float",
            "value"
        ]
    },
    {
        "id": 518,
        "code": "public static void maybeSetByteBuffer(MediaFormat format, String key, @Nullable byte[] value) {\n  if (value != null) {\n    format.setByteBuffer(key, ByteBuffer.wrap(value));\n  }\n}",
        "summary_tokens": [
            "sets",
            "a",
            "media",
            "format",
            "byte",
            "buffer",
            "value"
        ]
    },
    {
        "id": 519,
        "code": "public static void maybeSetColorInfo(MediaFormat format, @Nullable ColorInfo colorInfo) {\n  if (colorInfo != null) {\n    maybeSetInteger(format, MediaFormat.KEY_COLOR_TRANSFER, colorInfo.colorTransfer);\n    maybeSetInteger(format, MediaFormat.KEY_COLOR_STANDARD, colorInfo.colorSpace);\n    maybeSetInteger(format, MediaFormat.KEY_COLOR_RANGE, colorInfo.colorRange);\n    maybeSetByteBuffer(format, MediaFormat.KEY_HDR_STATIC_INFO, colorInfo.hdrStaticInfo);\n  }\n}",
        "summary_tokens": [
            "sets",
            "a",
            "media",
            "format",
            "s",
            "color",
            "information"
        ]
    },
    {
        "id": 520,
        "code": "public static void registerCustomMimeType(\n    String mimeType, String codecPrefix, @C.TrackType int trackType) {\n  CustomMimeType customMimeType = new CustomMimeType(mimeType, codecPrefix, trackType);\n  int customMimeTypeCount = customMimeTypes.size();\n  for (int i = 0; i < customMimeTypeCount; i++) {\n    if (mimeType.equals(customMimeTypes.get(i).mimeType)) {\n      customMimeTypes.remove(i);\n      break;\n    }\n  }\n  customMimeTypes.add(customMimeType);\n}",
        "summary_tokens": [
            "registers",
            "a",
            "custom",
            "mime",
            "type"
        ]
    },
    {
        "id": 521,
        "code": "public static boolean isAudio(@Nullable String mimeType) {\n  return BASE_TYPE_AUDIO.equals(getTopLevelType(mimeType));\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "given",
            "string",
            "is",
            "an",
            "audio",
            "mime",
            "type"
        ]
    },
    {
        "id": 522,
        "code": "public static boolean isVideo(@Nullable String mimeType) {\n  return BASE_TYPE_VIDEO.equals(getTopLevelType(mimeType));\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "given",
            "string",
            "is",
            "a",
            "video",
            "mime",
            "type"
        ]
    },
    {
        "id": 523,
        "code": "public static boolean isText(@Nullable String mimeType) {\n  return BASE_TYPE_TEXT.equals(getTopLevelType(mimeType))\n      || APPLICATION_CEA608.equals(mimeType)\n      || APPLICATION_CEA708.equals(mimeType)\n      || APPLICATION_MP4CEA608.equals(mimeType)\n      || APPLICATION_SUBRIP.equals(mimeType)\n      || APPLICATION_TTML.equals(mimeType)\n      || APPLICATION_TX3G.equals(mimeType)\n      || APPLICATION_MP4VTT.equals(mimeType)\n      || APPLICATION_RAWCC.equals(mimeType)\n      || APPLICATION_VOBSUB.equals(mimeType)\n      || APPLICATION_PGS.equals(mimeType)\n      || APPLICATION_DVBSUBS.equals(mimeType);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "given",
            "string",
            "is",
            "a",
            "text",
            "mime",
            "type",
            "including",
            "known",
            "text",
            "types",
            "that",
            "use",
            "quot",
            "application",
            "quot",
            "as",
            "their",
            "base",
            "type"
        ]
    },
    {
        "id": 524,
        "code": "public static boolean isImage(@Nullable String mimeType) {\n  return BASE_TYPE_IMAGE.equals(getTopLevelType(mimeType));\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "given",
            "string",
            "is",
            "an",
            "image",
            "mime",
            "type"
        ]
    },
    {
        "id": 525,
        "code": "public static boolean allSamplesAreSyncSamples(\n    @Nullable String mimeType, @Nullable String codec) {\n  if (mimeType == null) {\n    return false;\n  }\n    \n    \n    \n    \n  switch (mimeType) {\n    case AUDIO_MPEG:\n    case AUDIO_MPEG_L1:\n    case AUDIO_MPEG_L2:\n    case AUDIO_RAW:\n    case AUDIO_ALAW:\n    case AUDIO_MLAW:\n    case AUDIO_FLAC:\n    case AUDIO_AC3:\n    case AUDIO_E_AC3:\n    case AUDIO_E_AC3_JOC:\n      return true;\n    case AUDIO_AAC:\n      if (codec == null) {\n        return false;\n      }\n      @Nullable Mp4aObjectType objectType = getObjectTypeFromMp4aRFC6381CodecString(codec);\n      if (objectType == null) {\n        return false;\n      }\n      @C.Encoding int encoding = objectType.getEncoding();\n        \n        \n        \n      return encoding != C.ENCODING_INVALID && encoding != C.ENCODING_AAC_XHE;\n    default:\n      return false;\n  }\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "it",
            "is",
            "known",
            "that",
            "all",
            "samples",
            "in",
            "a",
            "stream",
            "of",
            "the",
            "given",
            "mime",
            "type",
            "and",
            "codec",
            "are",
            "guaranteed",
            "to",
            "be",
            "sync",
            "samples",
            "i"
        ]
    },
    {
        "id": 526,
        "code": "public static String getVideoMediaMimeType(@Nullable String codecs) {\n  if (codecs == null) {\n    return null;\n  }\n  String[] codecList = Util.splitCodecs(codecs);\n  for (String codec : codecList) {\n    @Nullable String mimeType = getMediaMimeType(codec);\n    if (mimeType != null && isVideo(mimeType)) {\n      return mimeType;\n    }\n  }\n  return null;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "first",
            "video",
            "mime",
            "type",
            "derived",
            "from",
            "an",
            "rfc",
            "0",
            "codecs",
            "string"
        ]
    },
    {
        "id": 527,
        "code": "public static boolean containsCodecsCorrespondingToMimeType(\n    @Nullable String codecs, String mimeType) {\n  return getCodecsCorrespondingToMimeType(codecs, mimeType) != null;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "given",
            "codecs",
            "string",
            "contains",
            "a",
            "codec",
            "which",
            "corresponds",
            "to",
            "the",
            "given",
            "mime",
            "type"
        ]
    },
    {
        "id": 528,
        "code": "public static String getCodecsCorrespondingToMimeType(\n    @Nullable String codecs, @Nullable String mimeType) {\n  if (codecs == null || mimeType == null) {\n    return null;\n  }\n  String[] codecList = Util.splitCodecs(codecs);\n  StringBuilder builder = new StringBuilder();\n  for (String codec : codecList) {\n    if (mimeType.equals(getMediaMimeType(codec))) {\n      if (builder.length() > 0) {\n        builder.append(\",\");\n      }\n      builder.append(codec);\n    }\n  }\n  return builder.length() > 0 ? builder.toString() : null;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "subsequence",
            "of",
            "codecs",
            "containing",
            "the",
            "codec",
            "strings",
            "that",
            "correspond",
            "to",
            "the",
            "given",
            "mime",
            "type"
        ]
    },
    {
        "id": 529,
        "code": "public static String getAudioMediaMimeType(@Nullable String codecs) {\n  if (codecs == null) {\n    return null;\n  }\n  String[] codecList = Util.splitCodecs(codecs);\n  for (String codec : codecList) {\n    @Nullable String mimeType = getMediaMimeType(codec);\n    if (mimeType != null && isAudio(mimeType)) {\n      return mimeType;\n    }\n  }\n  return null;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "first",
            "audio",
            "mime",
            "type",
            "derived",
            "from",
            "an",
            "rfc",
            "0",
            "codecs",
            "string"
        ]
    },
    {
        "id": 530,
        "code": "public static String getTextMediaMimeType(@Nullable String codecs) {\n  if (codecs == null) {\n    return null;\n  }\n  String[] codecList = Util.splitCodecs(codecs);\n  for (String codec : codecList) {\n    @Nullable String mimeType = getMediaMimeType(codec);\n    if (mimeType != null && isText(mimeType)) {\n      return mimeType;\n    }\n  }\n  return null;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "first",
            "text",
            "mime",
            "type",
            "derived",
            "from",
            "an",
            "rfc",
            "0",
            "codecs",
            "string"
        ]
    },
    {
        "id": 531,
        "code": "public static String getMediaMimeType(@Nullable String codec) {\n  if (codec == null) {\n    return null;\n  }\n  codec = Ascii.toLowerCase(codec.trim());\n  if (codec.startsWith(\"avc1\") || codec.startsWith(\"avc3\")) {\n    return MimeTypes.VIDEO_H264;\n  } else if (codec.startsWith(\"hev1\") || codec.startsWith(\"hvc1\")) {\n    return MimeTypes.VIDEO_H265;\n  } else if (codec.startsWith(\"dvav\")\n      || codec.startsWith(\"dva1\")\n      || codec.startsWith(\"dvhe\")\n      || codec.startsWith(\"dvh1\")) {\n    return MimeTypes.VIDEO_DOLBY_VISION;\n  } else if (codec.startsWith(\"av01\")) {\n    return MimeTypes.VIDEO_AV1;\n  } else if (codec.startsWith(\"vp9\") || codec.startsWith(\"vp09\")) {\n    return MimeTypes.VIDEO_VP9;\n  } else if (codec.startsWith(\"vp8\") || codec.startsWith(\"vp08\")) {\n    return MimeTypes.VIDEO_VP8;\n  } else if (codec.startsWith(\"mp4a\")) {\n    @Nullable String mimeType = null;\n    if (codec.startsWith(\"mp4a.\")) {\n      @Nullable Mp4aObjectType objectType = getObjectTypeFromMp4aRFC6381CodecString(codec);\n      if (objectType != null) {\n        mimeType = getMimeTypeFromMp4ObjectType(objectType.objectTypeIndication);\n      }\n    }\n    return mimeType == null ? MimeTypes.AUDIO_AAC : mimeType;\n  } else if (codec.startsWith(\"mha1\")) {\n    return MimeTypes.AUDIO_MPEGH_MHA1;\n  } else if (codec.startsWith(\"mhm1\")) {\n    return MimeTypes.AUDIO_MPEGH_MHM1;\n  } else if (codec.startsWith(\"ac-3\") || codec.startsWith(\"dac3\")) {\n    return MimeTypes.AUDIO_AC3;\n  } else if (codec.startsWith(\"ec-3\") || codec.startsWith(\"dec3\")) {\n    return MimeTypes.AUDIO_E_AC3;\n  } else if (codec.startsWith(CODEC_E_AC3_JOC)) {\n    return MimeTypes.AUDIO_E_AC3_JOC;\n  } else if (codec.startsWith(\"ac-4\") || codec.startsWith(\"dac4\")) {\n    return MimeTypes.AUDIO_AC4;\n  } else if (codec.startsWith(\"dtsc\")) {\n    return MimeTypes.AUDIO_DTS;\n  } else if (codec.startsWith(\"dtse\")) {\n    return MimeTypes.AUDIO_DTS_EXPRESS;\n  } else if (codec.startsWith(\"dtsh\") || codec.startsWith(\"dtsl\")) {\n    return MimeTypes.AUDIO_DTS_HD;\n  } else if (codec.startsWith(\"dtsx\")) {\n    return MimeTypes.AUDIO_DTS_X;\n  } else if (codec.startsWith(\"opus\")) {\n    return MimeTypes.AUDIO_OPUS;\n  } else if (codec.startsWith(\"vorbis\")) {\n    return MimeTypes.AUDIO_VORBIS;\n  } else if (codec.startsWith(\"flac\")) {\n    return MimeTypes.AUDIO_FLAC;\n  } else if (codec.startsWith(\"stpp\")) {\n    return MimeTypes.APPLICATION_TTML;\n  } else if (codec.startsWith(\"wvtt\")) {\n    return MimeTypes.TEXT_VTT;\n  } else if (codec.contains(\"cea708\")) {\n    return MimeTypes.APPLICATION_CEA708;\n  } else if (codec.contains(\"eia608\") || codec.contains(\"cea608\")) {\n    return MimeTypes.APPLICATION_CEA608;\n  } else {\n    return getCustomMimeTypeForCodec(codec);\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "mime",
            "type",
            "corresponding",
            "to",
            "an",
            "rfc",
            "0",
            "codec",
            "string",
            "or",
            "null",
            "if",
            "it",
            "could",
            "not",
            "be",
            "determined"
        ]
    },
    {
        "id": 532,
        "code": "public static String getMimeTypeFromMp4ObjectType(int objectType) {\n  switch (objectType) {\n    case 0x20:\n      return MimeTypes.VIDEO_MP4V;\n    case 0x21:\n      return MimeTypes.VIDEO_H264;\n    case 0x23:\n      return MimeTypes.VIDEO_H265;\n    case 0x60:\n    case 0x61:\n    case 0x62:\n    case 0x63:\n    case 0x64:\n    case 0x65:\n      return MimeTypes.VIDEO_MPEG2;\n    case 0x6A:\n      return MimeTypes.VIDEO_MPEG;\n    case 0x69:\n    case 0x6B:\n      return MimeTypes.AUDIO_MPEG;\n    case 0xA3:\n      return MimeTypes.VIDEO_VC1;\n    case 0xB1:\n      return MimeTypes.VIDEO_VP9;\n    case 0x40:\n    case 0x66:\n    case 0x67:\n    case 0x68:\n      return MimeTypes.AUDIO_AAC;\n    case 0xA5:\n      return MimeTypes.AUDIO_AC3;\n    case 0xA6:\n      return MimeTypes.AUDIO_E_AC3;\n    case 0xA9:\n    case 0xAC:\n      return MimeTypes.AUDIO_DTS;\n    case 0xAA:\n    case 0xAB:\n      return MimeTypes.AUDIO_DTS_HD;\n    case 0xAD:\n      return MimeTypes.AUDIO_OPUS;\n    case 0xAE:\n      return MimeTypes.AUDIO_AC4;\n    default:\n      return null;\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "mime",
            "type",
            "corresponding",
            "to",
            "an",
            "mp",
            "0",
            "object",
            "type",
            "identifier",
            "as",
            "defined",
            "in",
            "rfc",
            "0",
            "and",
            "https",
            "mp",
            "0",
            "ra"
        ]
    },
    {
        "id": 533,
        "code": "public static @C.TrackType int getTrackTypeOfCodec(String codec) {\n  return getTrackType(getMediaMimeType(codec));\n}",
        "summary_tokens": [
            "equivalent",
            "to",
            "get",
            "track",
            "type",
            "get",
            "media",
            "mime",
            "type",
            "codec"
        ]
    },
    {
        "id": 534,
        "code": "public static String normalizeMimeType(String mimeType) {\n  switch (mimeType) {\n    case BASE_TYPE_AUDIO + \"/x-flac\":\n      return AUDIO_FLAC;\n    case BASE_TYPE_AUDIO + \"/mp3\":\n      return AUDIO_MPEG;\n    case BASE_TYPE_AUDIO + \"/x-wav\":\n      return AUDIO_WAV;\n    default:\n      return mimeType;\n  }\n}",
        "summary_tokens": [
            "normalizes",
            "the",
            "mime",
            "type",
            "provided",
            "so",
            "that",
            "equivalent",
            "mime",
            "types",
            "are",
            "uniquely",
            "represented"
        ]
    },
    {
        "id": 535,
        "code": "public static boolean isMatroska(@Nullable String mimeType) {\n  if (mimeType == null) {\n    return false;\n  }\n  return mimeType.startsWith(MimeTypes.VIDEO_WEBM)\n      || mimeType.startsWith(MimeTypes.AUDIO_WEBM)\n      || mimeType.startsWith(MimeTypes.APPLICATION_WEBM)\n      || mimeType.startsWith(MimeTypes.VIDEO_MATROSKA)\n      || mimeType.startsWith(MimeTypes.AUDIO_MATROSKA)\n      || mimeType.startsWith(MimeTypes.APPLICATION_MATROSKA);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "given",
            "mime",
            "type",
            "is",
            "a",
            "matroska",
            "mime",
            "type",
            "including",
            "web",
            "m"
        ]
    },
    {
        "id": 536,
        "code": "private static String getTopLevelType(@Nullable String mimeType) {\n  if (mimeType == null) {\n    return null;\n  }\n  int indexOfSlash = mimeType.indexOf('/');\n  if (indexOfSlash == -1) {\n    return null;\n  }\n  return mimeType.substring(0, indexOfSlash);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "top",
            "level",
            "type",
            "of",
            "mime",
            "type",
            "or",
            "null",
            "if",
            "mime",
            "type",
            "is",
            "null",
            "or",
            "does",
            "not",
            "contain",
            "a",
            "forward",
            "slash",
            "character"
        ]
    },
    {
        "id": 537,
        "code": " static Mp4aObjectType getObjectTypeFromMp4aRFC6381CodecString(String codec) {\n  Matcher matcher = MP4A_RFC_6381_CODEC_PATTERN.matcher(codec);\n  if (!matcher.matches()) {\n    return null;\n  }\n  String objectTypeIndicationHex = Assertions.checkNotNull(matcher.group(1));\n  @Nullable String audioObjectTypeIndicationDec = matcher.group(2);\n  int objectTypeIndication;\n  int audioObjectTypeIndication = 0;\n  try {\n    objectTypeIndication = Integer.parseInt(objectTypeIndicationHex, 16);\n    if (audioObjectTypeIndicationDec != null) {\n      audioObjectTypeIndication = Integer.parseInt(audioObjectTypeIndicationDec);\n    }\n  } catch (NumberFormatException e) {\n    return null;\n  }\n  return new Mp4aObjectType(objectTypeIndication, audioObjectTypeIndication);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "mp",
            "0",
            "a",
            "object",
            "type",
            "of",
            "an",
            "rfc",
            "0",
            "mp",
            "0",
            "audio",
            "codec",
            "string"
        ]
    },
    {
        "id": 538,
        "code": "public static synchronized NetworkTypeObserver getInstance(Context context) {\n  if (staticInstance == null) {\n    staticInstance = new NetworkTypeObserver(context);\n  }\n  return staticInstance;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "network",
            "type",
            "observer",
            "instance"
        ]
    },
    {
        "id": 539,
        "code": "public static synchronized void resetForTests() {\n  staticInstance = null;\n}",
        "summary_tokens": [
            "resets",
            "the",
            "network",
            "type",
            "observer",
            "for",
            "tests"
        ]
    },
    {
        "id": 540,
        "code": "public @C.NetworkType int getNetworkType() {\n  synchronized (networkTypeLock) {\n    return networkType;\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "current",
            "network",
            "type"
        ]
    },
    {
        "id": 541,
        "code": "public static void createNotificationChannel(\n    Context context,\n    String id,\n    @StringRes int nameResourceId,\n    @StringRes int descriptionResourceId,\n    @Importance int importance) {\n  if (Util.SDK_INT >= 26) {\n    NotificationManager notificationManager =\n        checkNotNull(\n            (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE));\n    NotificationChannel channel =\n        new NotificationChannel(id, context.getString(nameResourceId), importance);\n    if (descriptionResourceId != 0) {\n      channel.setDescription(context.getString(descriptionResourceId));\n    }\n    notificationManager.createNotificationChannel(channel);\n  }\n}",
        "summary_tokens": [
            "creates",
            "a",
            "notification",
            "channel",
            "that",
            "notifications",
            "can",
            "be",
            "posted",
            "to"
        ]
    },
    {
        "id": 542,
        "code": "public static void setNotification(Context context, int id, @Nullable Notification notification) {\n  NotificationManager notificationManager =\n      checkNotNull((NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE));\n  if (notification != null) {\n    notificationManager.notify(id, notification);\n  } else {\n    notificationManager.cancel(id);\n  }\n}",
        "summary_tokens": [
            "post",
            "a",
            "notification",
            "to",
            "be",
            "shown",
            "in",
            "the",
            "status",
            "bar"
        ]
    },
    {
        "id": 543,
        "code": "public void reset(byte[] data, int limit) {\n  this.data = data;\n  byteOffset = 0;\n  bitOffset = 0;\n  byteLimit = limit;\n}",
        "summary_tokens": [
            "updates",
            "the",
            "instance",
            "to",
            "wrap",
            "data",
            "and",
            "resets",
            "the",
            "position",
            "to",
            "zero"
        ]
    },
    {
        "id": 544,
        "code": "public int bitsLeft() {\n  return (byteLimit - byteOffset) * 8 - bitOffset;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "bits",
            "yet",
            "to",
            "be",
            "read"
        ]
    },
    {
        "id": 545,
        "code": "public int getPosition() {\n  return byteOffset * 8 + bitOffset;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "current",
            "bit",
            "offset"
        ]
    },
    {
        "id": 546,
        "code": "public int getBytePosition() {\n  Assertions.checkState(bitOffset == 0);\n  return byteOffset;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "current",
            "byte",
            "offset"
        ]
    },
    {
        "id": 547,
        "code": "public void setPosition(int position) {\n  byteOffset = position / 8;\n  bitOffset = position - (byteOffset * 8);\n  assertValidOffset();\n}",
        "summary_tokens": [
            "sets",
            "the",
            "current",
            "bit",
            "offset"
        ]
    },
    {
        "id": 548,
        "code": "public void skipBit() {\n  if (++bitOffset == 8) {\n    bitOffset = 0;\n    byteOffset++;\n  }\n  assertValidOffset();\n}",
        "summary_tokens": [
            "skips",
            "a",
            "single",
            "bit"
        ]
    },
    {
        "id": 549,
        "code": "public void skipBits(int numBits) {\n  int numBytes = numBits / 8;\n  byteOffset += numBytes;\n  bitOffset += numBits - (numBytes * 8);\n  if (bitOffset > 7) {\n    byteOffset++;\n    bitOffset -= 8;\n  }\n  assertValidOffset();\n}",
        "summary_tokens": [
            "skips",
            "bits",
            "and",
            "moves",
            "current",
            "reading",
            "position",
            "forward"
        ]
    },
    {
        "id": 550,
        "code": "public boolean readBit() {\n  boolean returnValue = (data[byteOffset] & (0x80 >> bitOffset)) != 0;\n  skipBit();\n  return returnValue;\n}",
        "summary_tokens": [
            "reads",
            "a",
            "single",
            "bit"
        ]
    },
    {
        "id": 551,
        "code": "public void readBits(byte[] buffer, int offset, int numBits) {\n    \n  int to = offset + (numBits >> 3) ;\n  for (int i = offset; i < to; i++) {\n    buffer[i] = (byte) (data[byteOffset++] << bitOffset);\n    buffer[i] = (byte) (buffer[i] | ((data[byteOffset] & 0xFF) >> (8 - bitOffset)));\n  }\n    \n  int bitsLeft = numBits & 7 ;\n  if (bitsLeft == 0) {\n    return;\n  }\n    \n  buffer[to] = (byte) (buffer[to] & (0xFF >> bitsLeft));\n  if (bitOffset + bitsLeft > 8) {\n      \n    buffer[to] = (byte) (buffer[to] | ((data[byteOffset++] & 0xFF) << bitOffset));\n    bitOffset -= 8;\n  }\n  bitOffset += bitsLeft;\n  int lastDataByteTrailingBits = (data[byteOffset] & 0xFF) >> (8 - bitOffset);\n  buffer[to] |= (byte) (lastDataByteTrailingBits << (8 - bitsLeft));\n  if (bitOffset == 8) {\n    bitOffset = 0;\n    byteOffset++;\n  }\n  assertValidOffset();\n}",
        "summary_tokens": [
            "reads",
            "num",
            "bits",
            "bits",
            "into",
            "buffer"
        ]
    },
    {
        "id": 552,
        "code": "public long readBitsToLong(int numBits) {\n  if (numBits <= 32) {\n    return Util.toUnsignedLong(readBits(numBits));\n  }\n  return Util.toLong(readBits(numBits - 32), readBits(32));\n}",
        "summary_tokens": [
            "reads",
            "up",
            "to",
            "0",
            "bits"
        ]
    },
    {
        "id": 553,
        "code": "public void byteAlign() {\n  if (bitOffset == 0) {\n    return;\n  }\n  bitOffset = 0;\n  byteOffset++;\n  assertValidOffset();\n}",
        "summary_tokens": [
            "aligns",
            "the",
            "position",
            "to",
            "the",
            "next",
            "byte",
            "boundary"
        ]
    },
    {
        "id": 554,
        "code": "public void readBytes(byte[] buffer, int offset, int length) {\n  Assertions.checkState(bitOffset == 0);\n  System.arraycopy(data, byteOffset, buffer, offset, length);\n  byteOffset += length;\n  assertValidOffset();\n}",
        "summary_tokens": [
            "reads",
            "the",
            "next",
            "length",
            "bytes",
            "into",
            "buffer"
        ]
    },
    {
        "id": 555,
        "code": "public void skipBytes(int length) {\n  Assertions.checkState(bitOffset == 0);\n  byteOffset += length;\n  assertValidOffset();\n}",
        "summary_tokens": [
            "skips",
            "the",
            "next",
            "length",
            "bytes"
        ]
    },
    {
        "id": 556,
        "code": "public String readBytesAsString(int length, Charset charset) {\n  byte[] bytes = new byte[length];\n  readBytes(bytes, 0, length);\n  return new String(bytes, charset);\n}",
        "summary_tokens": [
            "reads",
            "the",
            "next",
            "length",
            "bytes",
            "as",
            "a",
            "string",
            "encoded",
            "in",
            "charset"
        ]
    },
    {
        "id": 557,
        "code": "public void putInt(int value, int numBits) {\n  int remainingBitsToRead = numBits;\n  if (numBits < 32) {\n    value &= (1 << numBits) - 1;\n  }\n  int firstByteReadSize = min(8 - bitOffset, numBits);\n  int firstByteRightPaddingSize = 8 - bitOffset - firstByteReadSize;\n  int firstByteBitmask = (0xFF00 >> bitOffset) | ((1 << firstByteRightPaddingSize) - 1);\n  data[byteOffset] = (byte) (data[byteOffset] & firstByteBitmask);\n  int firstByteInputBits = value >>> (numBits - firstByteReadSize);\n  data[byteOffset] =\n      (byte) (data[byteOffset] | (firstByteInputBits << firstByteRightPaddingSize));\n  remainingBitsToRead -= firstByteReadSize;\n  int currentByteIndex = byteOffset + 1;\n  while (remainingBitsToRead > 8) {\n    data[currentByteIndex++] = (byte) (value >>> (remainingBitsToRead - 8));\n    remainingBitsToRead -= 8;\n  }\n  int lastByteRightPaddingSize = 8 - remainingBitsToRead;\n  data[currentByteIndex] =\n      (byte) (data[currentByteIndex] & ((1 << lastByteRightPaddingSize) - 1));\n  int lastByteInput = value & ((1 << remainingBitsToRead) - 1);\n  data[currentByteIndex] =\n      (byte) (data[currentByteIndex] | (lastByteInput << lastByteRightPaddingSize));\n  skipBits(numBits);\n  assertValidOffset();\n}",
        "summary_tokens": [
            "overwrites",
            "num",
            "bits",
            "from",
            "this",
            "array",
            "using",
            "the",
            "num",
            "bits",
            "least",
            "significant",
            "bits",
            "from",
            "value"
        ]
    },
    {
        "id": 558,
        "code": "public void reset(byte[] data, int limit) {\n  this.data = data;\n  this.limit = limit;\n  position = 0;\n}",
        "summary_tokens": [
            "updates",
            "the",
            "instance",
            "to",
            "wrap",
            "data",
            "and",
            "resets",
            "the",
            "position",
            "to",
            "zero"
        ]
    },
    {
        "id": 559,
        "code": "public void ensureCapacity(int requiredCapacity) {\n  if (requiredCapacity > capacity()) {\n    data = Arrays.copyOf(data, requiredCapacity);\n  }\n}",
        "summary_tokens": [
            "ensures",
            "the",
            "backing",
            "array",
            "is",
            "at",
            "least",
            "required",
            "capacity",
            "long"
        ]
    },
    {
        "id": 560,
        "code": "public int bytesLeft() {\n  return limit - position;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "bytes",
            "yet",
            "to",
            "be",
            "read"
        ]
    },
    {
        "id": 561,
        "code": "public int getPosition() {\n  return position;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "current",
            "offset",
            "in",
            "the",
            "array",
            "in",
            "bytes"
        ]
    },
    {
        "id": 562,
        "code": "public void setPosition(int position) {\n    \n  Assertions.checkArgument(position >= 0 && position <= limit);\n  this.position = position;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "reading",
            "offset",
            "in",
            "the",
            "array"
        ]
    },
    {
        "id": 563,
        "code": "public byte[] getData() {\n  return data;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "underlying",
            "array"
        ]
    },
    {
        "id": 564,
        "code": "public int capacity() {\n  return data.length;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "capacity",
            "of",
            "the",
            "array",
            "which",
            "may",
            "be",
            "larger",
            "than",
            "the",
            "limit"
        ]
    },
    {
        "id": 565,
        "code": "public void skipBytes(int bytes) {\n  setPosition(position + bytes);\n}",
        "summary_tokens": [
            "moves",
            "the",
            "reading",
            "offset",
            "by",
            "bytes"
        ]
    },
    {
        "id": 566,
        "code": "public void readBytes(ByteBuffer buffer, int length) {\n  buffer.put(data, position, length);\n  position += length;\n}",
        "summary_tokens": [
            "reads",
            "the",
            "next",
            "length",
            "bytes",
            "into",
            "buffer"
        ]
    },
    {
        "id": 567,
        "code": "public int peekUnsignedByte() {\n  return (data[position] & 0xFF);\n}",
        "summary_tokens": [
            "peeks",
            "at",
            "the",
            "next",
            "byte",
            "as",
            "an",
            "unsigned",
            "value"
        ]
    },
    {
        "id": 568,
        "code": "public char peekChar() {\n  return (char) ((data[position] & 0xFF) << 8 | (data[position + 1] & 0xFF));\n}",
        "summary_tokens": [
            "peeks",
            "at",
            "the",
            "next",
            "char"
        ]
    },
    {
        "id": 569,
        "code": "public int readUnsignedByte() {\n  return (data[position++] & 0xFF);\n}",
        "summary_tokens": [
            "reads",
            "the",
            "next",
            "byte",
            "as",
            "an",
            "unsigned",
            "value"
        ]
    },
    {
        "id": 570,
        "code": "public int readUnsignedShort() {\n  return (data[position++] & 0xFF) << 8 | (data[position++] & 0xFF);\n}",
        "summary_tokens": [
            "reads",
            "the",
            "next",
            "two",
            "bytes",
            "as",
            "an",
            "unsigned",
            "value"
        ]
    },
    {
        "id": 571,
        "code": "public int readLittleEndianUnsignedShort() {\n  return (data[position++] & 0xFF) | (data[position++] & 0xFF) << 8;\n}",
        "summary_tokens": [
            "reads",
            "the",
            "next",
            "two",
            "bytes",
            "as",
            "an",
            "unsigned",
            "value"
        ]
    },
    {
        "id": 572,
        "code": "public short readShort() {\n  return (short) ((data[position++] & 0xFF) << 8 | (data[position++] & 0xFF));\n}",
        "summary_tokens": [
            "reads",
            "the",
            "next",
            "two",
            "bytes",
            "as",
            "a",
            "signed",
            "value"
        ]
    },
    {
        "id": 573,
        "code": "public short readLittleEndianShort() {\n  return (short) ((data[position++] & 0xFF) | (data[position++] & 0xFF) << 8);\n}",
        "summary_tokens": [
            "reads",
            "the",
            "next",
            "two",
            "bytes",
            "as",
            "a",
            "signed",
            "value"
        ]
    },
    {
        "id": 574,
        "code": "public int readUnsignedInt24() {\n  return (data[position++] & 0xFF) << 16\n      | (data[position++] & 0xFF) << 8\n      | (data[position++] & 0xFF);\n}",
        "summary_tokens": [
            "reads",
            "the",
            "next",
            "three",
            "bytes",
            "as",
            "an",
            "unsigned",
            "value"
        ]
    },
    {
        "id": 575,
        "code": "public int readInt24() {\n  return ((data[position++] & 0xFF) << 24) >> 8\n      | (data[position++] & 0xFF) << 8\n      | (data[position++] & 0xFF);\n}",
        "summary_tokens": [
            "reads",
            "the",
            "next",
            "three",
            "bytes",
            "as",
            "a",
            "signed",
            "value"
        ]
    },
    {
        "id": 576,
        "code": "public int readLittleEndianInt24() {\n  return (data[position++] & 0xFF)\n      | (data[position++] & 0xFF) << 8\n      | (data[position++] & 0xFF) << 16;\n}",
        "summary_tokens": [
            "reads",
            "the",
            "next",
            "three",
            "bytes",
            "as",
            "a",
            "signed",
            "value",
            "in",
            "little",
            "endian",
            "order"
        ]
    },
    {
        "id": 577,
        "code": "public int readLittleEndianUnsignedInt24() {\n  return (data[position++] & 0xFF)\n      | (data[position++] & 0xFF) << 8\n      | (data[position++] & 0xFF) << 16;\n}",
        "summary_tokens": [
            "reads",
            "the",
            "next",
            "three",
            "bytes",
            "as",
            "an",
            "unsigned",
            "value",
            "in",
            "little",
            "endian",
            "order"
        ]
    },
    {
        "id": 578,
        "code": "public long readUnsignedInt() {\n  return (data[position++] & 0xFFL) << 24\n      | (data[position++] & 0xFFL) << 16\n      | (data[position++] & 0xFFL) << 8\n      | (data[position++] & 0xFFL);\n}",
        "summary_tokens": [
            "reads",
            "the",
            "next",
            "four",
            "bytes",
            "as",
            "an",
            "unsigned",
            "value"
        ]
    },
    {
        "id": 579,
        "code": "public long readLittleEndianUnsignedInt() {\n  return (data[position++] & 0xFFL)\n      | (data[position++] & 0xFFL) << 8\n      | (data[position++] & 0xFFL) << 16\n      | (data[position++] & 0xFFL) << 24;\n}",
        "summary_tokens": [
            "reads",
            "the",
            "next",
            "four",
            "bytes",
            "as",
            "an",
            "unsigned",
            "value",
            "in",
            "little",
            "endian",
            "order"
        ]
    },
    {
        "id": 580,
        "code": "public int readInt() {\n  return (data[position++] & 0xFF) << 24\n      | (data[position++] & 0xFF) << 16\n      | (data[position++] & 0xFF) << 8\n      | (data[position++] & 0xFF);\n}",
        "summary_tokens": [
            "reads",
            "the",
            "next",
            "four",
            "bytes",
            "as",
            "a",
            "signed",
            "value"
        ]
    },
    {
        "id": 581,
        "code": "public int readLittleEndianInt() {\n  return (data[position++] & 0xFF)\n      | (data[position++] & 0xFF) << 8\n      | (data[position++] & 0xFF) << 16\n      | (data[position++] & 0xFF) << 24;\n}",
        "summary_tokens": [
            "reads",
            "the",
            "next",
            "four",
            "bytes",
            "as",
            "a",
            "signed",
            "value",
            "in",
            "little",
            "endian",
            "order"
        ]
    },
    {
        "id": 582,
        "code": "public long readLong() {\n  return (data[position++] & 0xFFL) << 56\n      | (data[position++] & 0xFFL) << 48\n      | (data[position++] & 0xFFL) << 40\n      | (data[position++] & 0xFFL) << 32\n      | (data[position++] & 0xFFL) << 24\n      | (data[position++] & 0xFFL) << 16\n      | (data[position++] & 0xFFL) << 8\n      | (data[position++] & 0xFFL);\n}",
        "summary_tokens": [
            "reads",
            "the",
            "next",
            "eight",
            "bytes",
            "as",
            "a",
            "signed",
            "value"
        ]
    },
    {
        "id": 583,
        "code": "public long readLittleEndianLong() {\n  return (data[position++] & 0xFFL)\n      | (data[position++] & 0xFFL) << 8\n      | (data[position++] & 0xFFL) << 16\n      | (data[position++] & 0xFFL) << 24\n      | (data[position++] & 0xFFL) << 32\n      | (data[position++] & 0xFFL) << 40\n      | (data[position++] & 0xFFL) << 48\n      | (data[position++] & 0xFFL) << 56;\n}",
        "summary_tokens": [
            "reads",
            "the",
            "next",
            "eight",
            "bytes",
            "as",
            "a",
            "signed",
            "value",
            "in",
            "little",
            "endian",
            "order"
        ]
    },
    {
        "id": 584,
        "code": "public int readUnsignedFixedPoint1616() {\n  int result = (data[position++] & 0xFF) << 8 | (data[position++] & 0xFF);\n  position += 2; \n  return result;\n}",
        "summary_tokens": [
            "reads",
            "the",
            "next",
            "four",
            "bytes",
            "returning",
            "the",
            "integer",
            "portion",
            "of",
            "the",
            "fixed",
            "point",
            "0"
        ]
    },
    {
        "id": 585,
        "code": "public int readSynchSafeInt() {\n  int b1 = readUnsignedByte();\n  int b2 = readUnsignedByte();\n  int b3 = readUnsignedByte();\n  int b4 = readUnsignedByte();\n  return (b1 << 21) | (b2 << 14) | (b3 << 7) | b4;\n}",
        "summary_tokens": [
            "reads",
            "a",
            "synchsafe",
            "integer"
        ]
    },
    {
        "id": 586,
        "code": "public int readUnsignedIntToInt() {\n  int result = readInt();\n  if (result < 0) {\n    throw new IllegalStateException(\"Top bit not zero: \" + result);\n  }\n  return result;\n}",
        "summary_tokens": [
            "reads",
            "the",
            "next",
            "four",
            "bytes",
            "as",
            "an",
            "unsigned",
            "integer",
            "into",
            "an",
            "integer",
            "if",
            "the",
            "top",
            "bit",
            "is",
            "a",
            "zero"
        ]
    },
    {
        "id": 587,
        "code": "public int readLittleEndianUnsignedIntToInt() {\n  int result = readLittleEndianInt();\n  if (result < 0) {\n    throw new IllegalStateException(\"Top bit not zero: \" + result);\n  }\n  return result;\n}",
        "summary_tokens": [
            "reads",
            "the",
            "next",
            "four",
            "bytes",
            "as",
            "a",
            "little",
            "endian",
            "unsigned",
            "integer",
            "into",
            "an",
            "integer",
            "if",
            "the",
            "top",
            "bit",
            "is",
            "a",
            "zero"
        ]
    },
    {
        "id": 588,
        "code": "public long readUnsignedLongToLong() {\n  long result = readLong();\n  if (result < 0) {\n    throw new IllegalStateException(\"Top bit not zero: \" + result);\n  }\n  return result;\n}",
        "summary_tokens": [
            "reads",
            "the",
            "next",
            "eight",
            "bytes",
            "as",
            "an",
            "unsigned",
            "long",
            "into",
            "a",
            "long",
            "if",
            "the",
            "top",
            "bit",
            "is",
            "a",
            "zero"
        ]
    },
    {
        "id": 589,
        "code": "public float readFloat() {\n  return Float.intBitsToFloat(readInt());\n}",
        "summary_tokens": [
            "reads",
            "the",
            "next",
            "four",
            "bytes",
            "as",
            "a",
            "0",
            "bit",
            "floating",
            "point",
            "value"
        ]
    },
    {
        "id": 590,
        "code": "public double readDouble() {\n  return Double.longBitsToDouble(readLong());\n}",
        "summary_tokens": [
            "reads",
            "the",
            "next",
            "eight",
            "bytes",
            "as",
            "a",
            "0",
            "bit",
            "floating",
            "point",
            "value"
        ]
    },
    {
        "id": 591,
        "code": "public String readString(int length, Charset charset) {\n  String result = new String(data, position, length, charset);\n  position += length;\n  return result;\n}",
        "summary_tokens": [
            "reads",
            "the",
            "next",
            "length",
            "bytes",
            "as",
            "characters",
            "in",
            "the",
            "specified",
            "charset"
        ]
    },
    {
        "id": 592,
        "code": "public String readNullTerminatedString() {\n  return readDelimiterTerminatedString('\\0');\n}",
        "summary_tokens": [
            "reads",
            "up",
            "to",
            "the",
            "next",
            "nul",
            "byte",
            "or",
            "the",
            "limit",
            "as",
            "utf",
            "0",
            "characters"
        ]
    },
    {
        "id": 593,
        "code": "public String readDelimiterTerminatedString(char delimiter) {\n  if (bytesLeft() == 0) {\n    return null;\n  }\n  int stringLimit = position;\n  while (stringLimit < limit && data[stringLimit] != delimiter) {\n    stringLimit++;\n  }\n  String string = Util.fromUtf8Bytes(data, position, stringLimit - position);\n  position = stringLimit;\n  if (position < limit) {\n    position++;\n  }\n  return string;\n}",
        "summary_tokens": [
            "reads",
            "up",
            "to",
            "the",
            "next",
            "delimiter",
            "byte",
            "or",
            "the",
            "limit",
            "as",
            "utf",
            "0",
            "characters"
        ]
    },
    {
        "id": 594,
        "code": "public String readLine() {\n  if (bytesLeft() == 0) {\n    return null;\n  }\n  int lineLimit = position;\n  while (lineLimit < limit && !Util.isLinebreak(data[lineLimit])) {\n    lineLimit++;\n  }\n  if (lineLimit - position >= 3\n      && data[position] == (byte) 0xEF\n      && data[position + 1] == (byte) 0xBB\n      && data[position + 2] == (byte) 0xBF) {\n      \n    position += 3;\n  }\n  String line = Util.fromUtf8Bytes(data, position, lineLimit - position);\n  position = lineLimit;\n  if (position == limit) {\n    return line;\n  }\n  if (data[position] == '\\r') {\n    position++;\n    if (position == limit) {\n      return line;\n    }\n  }\n  if (data[position] == '\\n') {\n    position++;\n  }\n  return line;\n}",
        "summary_tokens": [
            "reads",
            "a",
            "line",
            "of",
            "text"
        ]
    },
    {
        "id": 595,
        "code": "public long readUtf8EncodedLong() {\n  int length = 0;\n  long value = data[position];\n    \n  for (int j = 7; j >= 0; j--) {\n    if ((value & (1 << j)) == 0) {\n      if (j < 6) {\n        value &= (1 << j) - 1;\n        length = 7 - j;\n      } else if (j == 7) {\n        length = 1;\n      }\n      break;\n    }\n  }\n  if (length == 0) {\n    throw new NumberFormatException(\"Invalid UTF-8 sequence first byte: \" + value);\n  }\n  for (int i = 1; i < length; i++) {\n    int x = data[position + i];\n    if ((x & 0xC0) != 0x80) { \n      throw new NumberFormatException(\"Invalid UTF-8 sequence continuation byte: \" + value);\n    }\n    value = (value << 6) | (x & 0x3F);\n  }\n  position += length;\n  return value;\n}",
        "summary_tokens": [
            "reads",
            "a",
            "long",
            "value",
            "encoded",
            "by",
            "utf",
            "0",
            "encoding"
        ]
    },
    {
        "id": 596,
        "code": "public void add(int priority) {\n  synchronized (lock) {\n    queue.add(priority);\n    highestPriority = max(highestPriority, priority);\n  }\n}",
        "summary_tokens": [
            "register",
            "a",
            "new",
            "task"
        ]
    },
    {
        "id": 597,
        "code": "public void proceed(int priority) throws InterruptedException {\n  synchronized (lock) {\n    while (highestPriority != priority) {\n      lock.wait();\n    }\n  }\n}",
        "summary_tokens": [
            "blocks",
            "until",
            "the",
            "task",
            "is",
            "allowed",
            "to",
            "proceed"
        ]
    },
    {
        "id": 598,
        "code": "public boolean proceedNonBlocking(int priority) {\n  synchronized (lock) {\n    return highestPriority == priority;\n  }\n}",
        "summary_tokens": [
            "a",
            "non",
            "blocking",
            "variant",
            "of",
            "proceed",
            "int"
        ]
    },
    {
        "id": 599,
        "code": "public void proceedOrThrow(int priority) throws PriorityTooLowException {\n  synchronized (lock) {\n    if (highestPriority != priority) {\n      throw new PriorityTooLowException(priority, highestPriority);\n    }\n  }\n}",
        "summary_tokens": [
            "a",
            "throwing",
            "variant",
            "of",
            "proceed",
            "int"
        ]
    },
    {
        "id": 600,
        "code": "public static @Player.RepeatMode int getNextRepeatMode(\n    @Player.RepeatMode int currentMode, int enabledModes) {\n  for (int offset = 1; offset <= 2; offset++) {\n    @Player.RepeatMode int proposedMode = (currentMode + offset) % 3;\n    if (isRepeatModeEnabled(proposedMode, enabledModes)) {\n      return proposedMode;\n    }\n  }\n  return currentMode;\n}",
        "summary_tokens": [
            "gets",
            "the",
            "next",
            "repeat",
            "mode",
            "out",
            "of",
            "enabled",
            "modes",
            "starting",
            "from",
            "current",
            "mode"
        ]
    },
    {
        "id": 601,
        "code": "public static boolean isRepeatModeEnabled(@Player.RepeatMode int repeatMode, int enabledModes) {\n  switch (repeatMode) {\n    case Player.REPEAT_MODE_OFF:\n      return true;\n    case Player.REPEAT_MODE_ONE:\n      return (enabledModes & REPEAT_TOGGLE_MODE_ONE) != 0;\n    case Player.REPEAT_MODE_ALL:\n      return (enabledModes & REPEAT_TOGGLE_MODE_ALL) != 0;\n    default:\n      return false;\n  }\n}",
        "summary_tokens": [
            "verifies",
            "whether",
            "a",
            "given",
            "repeat",
            "mode",
            "is",
            "enabled",
            "in",
            "the",
            "bitmask",
            "enabled",
            "modes"
        ]
    },
    {
        "id": 602,
        "code": "public final void blockUntilStarted() {\n  started.blockUninterruptible();\n}",
        "summary_tokens": [
            "blocks",
            "until",
            "the",
            "task",
            "has",
            "started",
            "or",
            "has",
            "been",
            "canceled",
            "without",
            "having",
            "been",
            "started"
        ]
    },
    {
        "id": 603,
        "code": "public final void blockUntilFinished() {\n  finished.blockUninterruptible();\n}",
        "summary_tokens": [
            "blocks",
            "until",
            "the",
            "task",
            "has",
            "finished",
            "or",
            "has",
            "been",
            "canceled",
            "without",
            "having",
            "been",
            "started"
        ]
    },
    {
        "id": 604,
        "code": "protected void cancelWork() {\n    \n}",
        "summary_tokens": [
            "cancels",
            "any",
            "work",
            "being",
            "done",
            "by",
            "do",
            "work"
        ]
    },
    {
        "id": 605,
        "code": "public synchronized void sharedInitializeOrWait(boolean canInitialize, long nextSampleTimestampUs)\n    throws InterruptedException {\n  Assertions.checkState(firstSampleTimestampUs == MODE_SHARED);\n  if (timestampOffsetUs != C.TIME_UNSET) {\n      \n    return;\n  } else if (canInitialize) {\n    this.nextSampleTimestampUs.set(nextSampleTimestampUs);\n  } else {\n      \n    while (timestampOffsetUs == C.TIME_UNSET) {\n      wait();\n    }\n  }\n}",
        "summary_tokens": [
            "for",
            "shared",
            "timestamp",
            "adjusters",
            "performs",
            "necessary",
            "initialization",
            "actions",
            "for",
            "a",
            "caller"
        ]
    },
    {
        "id": 606,
        "code": "public synchronized long getFirstSampleTimestampUs() {\n  return firstSampleTimestampUs == MODE_NO_OFFSET || firstSampleTimestampUs == MODE_SHARED\n      ? C.TIME_UNSET\n      : firstSampleTimestampUs;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "value",
            "of",
            "the",
            "first",
            "adjusted",
            "sample",
            "timestamp",
            "in",
            "microseconds",
            "or",
            "c",
            "time",
            "unset",
            "if",
            "timestamps",
            "will",
            "not",
            "be",
            "offset",
            "or",
            "if",
            "the",
            "adjuster",
            "is",
            "in",
            "shared",
            "mode"
        ]
    },
    {
        "id": 607,
        "code": "public synchronized long getLastAdjustedTimestampUs() {\n  return lastUnadjustedTimestampUs != C.TIME_UNSET\n      ? lastUnadjustedTimestampUs + timestampOffsetUs\n      : getFirstSampleTimestampUs();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "last",
            "adjusted",
            "timestamp",
            "in",
            "microseconds"
        ]
    },
    {
        "id": 608,
        "code": "public synchronized long getTimestampOffsetUs() {\n  return timestampOffsetUs;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "offset",
            "between",
            "the",
            "input",
            "of",
            "adjust",
            "sample",
            "timestamp",
            "long",
            "and",
            "its",
            "output",
            "or",
            "c",
            "time",
            "unset",
            "if",
            "the",
            "offset",
            "has",
            "not",
            "yet",
            "been",
            "determined"
        ]
    },
    {
        "id": 609,
        "code": "public synchronized long adjustTsTimestamp(long pts90Khz) {\n  if (pts90Khz == C.TIME_UNSET) {\n    return C.TIME_UNSET;\n  }\n  if (lastUnadjustedTimestampUs != C.TIME_UNSET) {\n      \n      \n    long lastPts = usToNonWrappedPts(lastUnadjustedTimestampUs);\n    long closestWrapCount = (lastPts + (MAX_PTS_PLUS_ONE / 2)) / MAX_PTS_PLUS_ONE;\n    long ptsWrapBelow = pts90Khz + (MAX_PTS_PLUS_ONE * (closestWrapCount - 1));\n    long ptsWrapAbove = pts90Khz + (MAX_PTS_PLUS_ONE * closestWrapCount);\n    pts90Khz =\n        Math.abs(ptsWrapBelow - lastPts) < Math.abs(ptsWrapAbove - lastPts)\n            ? ptsWrapBelow\n            : ptsWrapAbove;\n  }\n  return adjustSampleTimestamp(ptsToUs(pts90Khz));\n}",
        "summary_tokens": [
            "scales",
            "and",
            "offsets",
            "an",
            "mpeg",
            "0",
            "ts",
            "presentation",
            "timestamp",
            "considering",
            "wraparound"
        ]
    },
    {
        "id": 610,
        "code": "public synchronized long adjustSampleTimestamp(long timeUs) {\n  if (timeUs == C.TIME_UNSET) {\n    return C.TIME_UNSET;\n  }\n  if (timestampOffsetUs == C.TIME_UNSET) {\n    long desiredSampleTimestampUs =\n        firstSampleTimestampUs == MODE_SHARED\n            ? Assertions.checkNotNull(nextSampleTimestampUs.get())\n            : firstSampleTimestampUs;\n    timestampOffsetUs = desiredSampleTimestampUs - timeUs;\n      \n    notifyAll();\n  }\n  lastUnadjustedTimestampUs = timeUs;\n  return timeUs + timestampOffsetUs;\n}",
        "summary_tokens": [
            "offsets",
            "a",
            "timestamp",
            "in",
            "microseconds"
        ]
    },
    {
        "id": 611,
        "code": "public static long ptsToUs(long pts) {\n  return (pts * C.MICROS_PER_SECOND) / 90000;\n}",
        "summary_tokens": [
            "converts",
            "a",
            "0",
            "k",
            "hz",
            "clock",
            "timestamp",
            "to",
            "a",
            "timestamp",
            "in",
            "microseconds"
        ]
    },
    {
        "id": 612,
        "code": "public static long usToWrappedPts(long us) {\n  return usToNonWrappedPts(us) % MAX_PTS_PLUS_ONE;\n}",
        "summary_tokens": [
            "converts",
            "a",
            "timestamp",
            "in",
            "microseconds",
            "to",
            "a",
            "0",
            "k",
            "hz",
            "clock",
            "timestamp",
            "performing",
            "wraparound",
            "to",
            "keep",
            "the",
            "result",
            "within",
            "0",
            "bits"
        ]
    },
    {
        "id": 613,
        "code": "public static long usToNonWrappedPts(long us) {\n  return (us * 90000) / C.MICROS_PER_SECOND;\n}",
        "summary_tokens": [
            "converts",
            "a",
            "timestamp",
            "in",
            "microseconds",
            "to",
            "a",
            "0",
            "k",
            "hz",
            "clock",
            "timestamp"
        ]
    },
    {
        "id": 614,
        "code": "public static void beginSection(String sectionName) {\n  if (ExoPlayerLibraryInfo.TRACE_ENABLED && Util.SDK_INT >= 18) {\n    beginSectionV18(sectionName);\n  }\n}",
        "summary_tokens": [
            "writes",
            "a",
            "trace",
            "message",
            "to",
            "indicate",
            "that",
            "a",
            "given",
            "section",
            "of",
            "code",
            "has",
            "begun"
        ]
    },
    {
        "id": 615,
        "code": "public static void endSection() {\n  if (ExoPlayerLibraryInfo.TRACE_ENABLED && Util.SDK_INT >= 18) {\n    endSectionV18();\n  }\n}",
        "summary_tokens": [
            "writes",
            "a",
            "trace",
            "message",
            "to",
            "indicate",
            "that",
            "a",
            "given",
            "section",
            "of",
            "code",
            "has",
            "ended"
        ]
    },
    {
        "id": 616,
        "code": "public static Uri resolveToUri(@Nullable String baseUri, @Nullable String referenceUri) {\n  return Uri.parse(resolve(baseUri, referenceUri));\n}",
        "summary_tokens": [
            "like",
            "resolve",
            "string",
            "string",
            "but",
            "returns",
            "a",
            "uri",
            "instead",
            "of",
            "a",
            "string"
        ]
    },
    {
        "id": 617,
        "code": "public static String resolve(@Nullable String baseUri, @Nullable String referenceUri) {\n  StringBuilder uri = new StringBuilder();\n\n    \n  baseUri = baseUri == null ? \"\" : baseUri;\n  referenceUri = referenceUri == null ? \"\" : referenceUri;\n\n  int[] refIndices = getUriIndices(referenceUri);\n  if (refIndices[SCHEME_COLON] != -1) {\n      \n    uri.append(referenceUri);\n    removeDotSegments(uri, refIndices[PATH], refIndices[QUERY]);\n    return uri.toString();\n  }\n\n  int[] baseIndices = getUriIndices(baseUri);\n  if (refIndices[FRAGMENT] == 0) {\n      \n      \n    return uri.append(baseUri, 0, baseIndices[FRAGMENT]).append(referenceUri).toString();\n  }\n\n  if (refIndices[QUERY] == 0) {\n      \n      \n    return uri.append(baseUri, 0, baseIndices[QUERY]).append(referenceUri).toString();\n  }\n\n  if (refIndices[PATH] != 0) {\n      \n    int baseLimit = baseIndices[SCHEME_COLON] + 1;\n    uri.append(baseUri, 0, baseLimit).append(referenceUri);\n    return removeDotSegments(uri, baseLimit + refIndices[PATH], baseLimit + refIndices[QUERY]);\n  }\n\n  if (referenceUri.charAt(refIndices[PATH]) == '/') {\n      \n      \n    uri.append(baseUri, 0, baseIndices[PATH]).append(referenceUri);\n    return removeDotSegments(uri, baseIndices[PATH], baseIndices[PATH] + refIndices[QUERY]);\n  }\n\n    \n    \n  if (baseIndices[SCHEME_COLON] + 2 < baseIndices[PATH]\n      && baseIndices[PATH] == baseIndices[QUERY]) {\n      \n      \n    uri.append(baseUri, 0, baseIndices[PATH]).append('/').append(referenceUri);\n    return removeDotSegments(uri, baseIndices[PATH], baseIndices[PATH] + refIndices[QUERY] + 1);\n  } else {\n      \n      \n      \n      \n    int lastSlashIndex = baseUri.lastIndexOf('/', baseIndices[QUERY] - 1);\n    int baseLimit = lastSlashIndex == -1 ? baseIndices[PATH] : lastSlashIndex + 1;\n    uri.append(baseUri, 0, baseLimit).append(referenceUri);\n    return removeDotSegments(uri, baseIndices[PATH], baseLimit + refIndices[QUERY]);\n  }\n}",
        "summary_tokens": [
            "performs",
            "relative",
            "resolution",
            "of",
            "a",
            "reference",
            "uri",
            "with",
            "respect",
            "to",
            "a",
            "base",
            "uri"
        ]
    },
    {
        "id": 618,
        "code": "public static boolean isAbsolute(@Nullable String uri) {\n  return uri != null && getUriIndices(uri)[SCHEME_COLON] != -1;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "the",
            "uri",
            "is",
            "starting",
            "with",
            "a",
            "scheme",
            "component",
            "false",
            "otherwise"
        ]
    },
    {
        "id": 619,
        "code": "public static Uri removeQueryParameter(Uri uri, String queryParameterName) {\n  Uri.Builder builder = uri.buildUpon();\n  builder.clearQuery();\n  for (String key : uri.getQueryParameterNames()) {\n    if (!key.equals(queryParameterName)) {\n      for (String value : uri.getQueryParameters(key)) {\n        builder.appendQueryParameter(key, value);\n      }\n    }\n  }\n  return builder.build();\n}",
        "summary_tokens": [
            "removes",
            "query",
            "parameter",
            "from",
            "a",
            "uri",
            "if",
            "present"
        ]
    },
    {
        "id": 620,
        "code": "private static String removeDotSegments(StringBuilder uri, int offset, int limit) {\n  if (offset >= limit) {\n      \n    return uri.toString();\n  }\n  if (uri.charAt(offset) == '/') {\n      \n    offset++;\n  }\n    \n  int segmentStart = offset;\n  int i = offset;\n  while (i <= limit) {\n    int nextSegmentStart;\n    if (i == limit) {\n      nextSegmentStart = i;\n    } else if (uri.charAt(i) == '/') {\n      nextSegmentStart = i + 1;\n    } else {\n      i++;\n      continue;\n    }\n      \n      \n    if (i == segmentStart + 1 && uri.charAt(segmentStart) == '.') {\n        \n      uri.delete(segmentStart, nextSegmentStart);\n      limit -= nextSegmentStart - segmentStart;\n      i = segmentStart;\n    } else if (i == segmentStart + 2\n        && uri.charAt(segmentStart) == '.'\n        && uri.charAt(segmentStart + 1) == '.') {\n        \n      int prevSegmentStart = uri.lastIndexOf(\"/\", segmentStart - 2) + 1;\n      int removeFrom = prevSegmentStart > offset ? prevSegmentStart : offset;\n      uri.delete(removeFrom, nextSegmentStart);\n      limit -= nextSegmentStart - removeFrom;\n      segmentStart = prevSegmentStart;\n      i = prevSegmentStart;\n    } else {\n      i++;\n      segmentStart = i;\n    }\n  }\n  return uri.toString();\n}",
        "summary_tokens": [
            "removes",
            "dot",
            "segments",
            "from",
            "the",
            "path",
            "of",
            "a",
            "uri"
        ]
    },
    {
        "id": 621,
        "code": "private static int[] getUriIndices(String uriString) {\n  int[] indices = new int[INDEX_COUNT];\n  if (TextUtils.isEmpty(uriString)) {\n    indices[SCHEME_COLON] = -1;\n    return indices;\n  }\n\n    \n    \n  int length = uriString.length();\n  int fragmentIndex = uriString.indexOf('#');\n  if (fragmentIndex == -1) {\n    fragmentIndex = length;\n  }\n  int queryIndex = uriString.indexOf('?');\n  if (queryIndex == -1 || queryIndex > fragmentIndex) {\n      \n    queryIndex = fragmentIndex;\n  }\n    \n    \n  int schemeIndexLimit = uriString.indexOf('/');\n  if (schemeIndexLimit == -1 || schemeIndexLimit > queryIndex) {\n    schemeIndexLimit = queryIndex;\n  }\n  int schemeIndex = uriString.indexOf(':');\n  if (schemeIndex > schemeIndexLimit) {\n      \n    schemeIndex = -1;\n  }\n\n    \n    \n  boolean hasAuthority =\n      schemeIndex + 2 < queryIndex\n          && uriString.charAt(schemeIndex + 1) == '/'\n          && uriString.charAt(schemeIndex + 2) == '/';\n  int pathIndex;\n  if (hasAuthority) {\n    pathIndex = uriString.indexOf('/', schemeIndex + 3); \n    if (pathIndex == -1 || pathIndex > queryIndex) {\n      pathIndex = queryIndex;\n    }\n  } else {\n    pathIndex = schemeIndex + 1;\n  }\n\n  indices[SCHEME_COLON] = schemeIndex;\n  indices[PATH] = pathIndex;\n  indices[QUERY] = queryIndex;\n  indices[FRAGMENT] = fragmentIndex;\n  return indices;\n}",
        "summary_tokens": [
            "calculates",
            "indices",
            "of",
            "the",
            "constituent",
            "components",
            "of",
            "a",
            "uri"
        ]
    },
    {
        "id": 622,
        "code": "public static boolean isEndTag(XmlPullParser xpp) throws XmlPullParserException {\n  return xpp.getEventType() == XmlPullParser.END_TAG;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "current",
            "event",
            "is",
            "an",
            "end",
            "tag"
        ]
    },
    {
        "id": 623,
        "code": "public static boolean isStartTag(XmlPullParser xpp) throws XmlPullParserException {\n  return xpp.getEventType() == XmlPullParser.START_TAG;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "current",
            "event",
            "is",
            "a",
            "start",
            "tag"
        ]
    },
    {
        "id": 624,
        "code": "public static boolean isStartTagIgnorePrefix(XmlPullParser xpp, String name)\n    throws XmlPullParserException {\n  return isStartTag(xpp) && stripPrefix(xpp.getName()).equals(name);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "current",
            "event",
            "is",
            "a",
            "start",
            "tag",
            "with",
            "the",
            "specified",
            "name"
        ]
    },
    {
        "id": 625,
        "code": "public static String getAttributeValue(XmlPullParser xpp, String attributeName) {\n  int attributeCount = xpp.getAttributeCount();\n  for (int i = 0; i < attributeCount; i++) {\n    if (xpp.getAttributeName(i).equals(attributeName)) {\n      return xpp.getAttributeValue(i);\n    }\n  }\n  return null;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "value",
            "of",
            "an",
            "attribute",
            "of",
            "the",
            "current",
            "start",
            "tag"
        ]
    },
    {
        "id": 626,
        "code": "public static String getAttributeValueIgnorePrefix(XmlPullParser xpp, String attributeName) {\n  int attributeCount = xpp.getAttributeCount();\n  for (int i = 0; i < attributeCount; i++) {\n    if (stripPrefix(xpp.getAttributeName(i)).equals(attributeName)) {\n      return xpp.getAttributeValue(i);\n    }\n  }\n  return null;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "value",
            "of",
            "an",
            "attribute",
            "of",
            "the",
            "current",
            "start",
            "tag"
        ]
    },
    {
        "id": 627,
        "code": "private static byte[] buildTestData(int length, int seed) {\n  byte[] source = new byte[length];\n  new Random(seed).nextBytes(source);\n  return source;\n}",
        "summary_tokens": [
            "generates",
            "an",
            "array",
            "of",
            "random",
            "bytes",
            "with",
            "the",
            "specified",
            "length"
        ]
    },
    {
        "id": 628,
        "code": "private static byte[] buildTestData(int length, int seed) {\n  byte[] source = new byte[length];\n  new Random(seed).nextBytes(source);\n  return source;\n}",
        "summary_tokens": [
            "generates",
            "an",
            "array",
            "of",
            "random",
            "bytes",
            "with",
            "the",
            "specified",
            "length"
        ]
    },
    {
        "id": 629,
        "code": "private static byte[] createByteArray(int... bytes) {\n  byte[] byteArray = new byte[bytes.length];\n  for (int i = 0; i < byteArray.length; i++) {\n    Assertions.checkState(0x00 <= bytes[i] && bytes[i] <= 0xFF);\n    byteArray[i] = (byte) bytes[i];\n  }\n  return byteArray;\n}",
        "summary_tokens": [
            "converts",
            "an",
            "array",
            "of",
            "integers",
            "in",
            "the",
            "range",
            "0",
            "0",
            "into",
            "an",
            "equivalent",
            "byte",
            "array"
        ]
    },
    {
        "id": 630,
        "code": "public void resolveNormal() {\n  String base = \"http://a/b/c/d;p?q\";\n\n  assertThat(resolve(base, \"g:h\")).isEqualTo(\"g:h\");\n  assertThat(resolve(base, \"g\")).isEqualTo(\"http://a/b/c/g\");\n  assertThat(resolve(base, \"g/\")).isEqualTo(\"http://a/b/c/g/\");\n  assertThat(resolve(base, \"/g\")).isEqualTo(\"http://a/g\");\n  assertThat(resolve(base, \"//g\")).isEqualTo(\"http://g\");\n  assertThat(resolve(base, \"//g:80\")).isEqualTo(\"http://g:80\");\n  assertThat(resolve(base, \"?y\")).isEqualTo(\"http://a/b/c/d;p?y\");\n  assertThat(resolve(base, \"g?y\")).isEqualTo(\"http://a/b/c/g?y\");\n  assertThat(resolve(base, \"#s\")).isEqualTo(\"http://a/b/c/d;p?q#s\");\n  assertThat(resolve(base, \"g#s\")).isEqualTo(\"http://a/b/c/g#s\");\n  assertThat(resolve(base, \"g?y#s\")).isEqualTo(\"http://a/b/c/g?y#s\");\n  assertThat(resolve(base, \";x\")).isEqualTo(\"http://a/b/c/;x\");\n  assertThat(resolve(base, \"g;x\")).isEqualTo(\"http://a/b/c/g;x\");\n  assertThat(resolve(base, \"g;x?y#s\")).isEqualTo(\"http://a/b/c/g;x?y#s\");\n  assertThat(resolve(base, \"\")).isEqualTo(\"http://a/b/c/d;p?q\");\n  assertThat(resolve(base, \".\")).isEqualTo(\"http://a/b/c/\");\n  assertThat(resolve(base, \"./\")).isEqualTo(\"http://a/b/c/\");\n  assertThat(resolve(base, \"..\")).isEqualTo(\"http://a/b/\");\n  assertThat(resolve(base, \"../\")).isEqualTo(\"http://a/b/\");\n  assertThat(resolve(base, \"../g\")).isEqualTo(\"http://a/b/g\");\n  assertThat(resolve(base, \"../..\")).isEqualTo(\"http://a/\");\n  assertThat(resolve(base, \"../../\")).isEqualTo(\"http://a/\");\n  assertThat(resolve(base, \"../../g\")).isEqualTo(\"http://a/g\");\n}",
        "summary_tokens": [
            "tests",
            "normal",
            "usage",
            "of",
            "uri",
            "util",
            "resolve",
            "string",
            "string"
        ]
    },
    {
        "id": 631,
        "code": "public void resolveAbnormal() {\n  String base = \"http://a/b/c/d;p?q\";\n\n  assertThat(resolve(base, \"../../../g\")).isEqualTo(\"http://a/g\");\n  assertThat(resolve(base, \"../../../../g\")).isEqualTo(\"http://a/g\");\n\n  assertThat(resolve(base, \"/./g\")).isEqualTo(\"http://a/g\");\n  assertThat(resolve(base, \"/../g\")).isEqualTo(\"http://a/g\");\n  assertThat(resolve(base, \"g.\")).isEqualTo(\"http://a/b/c/g.\");\n  assertThat(resolve(base, \".g\")).isEqualTo(\"http://a/b/c/.g\");\n  assertThat(resolve(base, \"g..\")).isEqualTo(\"http://a/b/c/g..\");\n  assertThat(resolve(base, \"..g\")).isEqualTo(\"http://a/b/c/..g\");\n\n  assertThat(resolve(base, \"./../g\")).isEqualTo(\"http://a/b/g\");\n  assertThat(resolve(base, \"./g/.\")).isEqualTo(\"http://a/b/c/g/\");\n  assertThat(resolve(base, \"g/./h\")).isEqualTo(\"http://a/b/c/g/h\");\n  assertThat(resolve(base, \"g/../h\")).isEqualTo(\"http://a/b/c/h\");\n  assertThat(resolve(base, \"g;x=1/./y\")).isEqualTo(\"http://a/b/c/g;x=1/y\");\n  assertThat(resolve(base, \"g;x=1/../y\")).isEqualTo(\"http://a/b/c/y\");\n\n  assertThat(resolve(base, \"g?y/./x\")).isEqualTo(\"http://a/b/c/g?y/./x\");\n  assertThat(resolve(base, \"g?y/../x\")).isEqualTo(\"http://a/b/c/g?y/../x\");\n  assertThat(resolve(base, \"g#s/./x\")).isEqualTo(\"http://a/b/c/g#s/./x\");\n  assertThat(resolve(base, \"g#s/../x\")).isEqualTo(\"http://a/b/c/g#s/../x\");\n\n  assertThat(resolve(base, \"http:g\")).isEqualTo(\"http:g\");\n}",
        "summary_tokens": [
            "tests",
            "abnormal",
            "usage",
            "of",
            "uri",
            "util",
            "resolve",
            "string",
            "string"
        ]
    },
    {
        "id": 632,
        "code": "public void resolveAbnormalAdditional() {\n  assertThat(resolve(\"http://a/b\", \"c:d/../e\")).isEqualTo(\"c:e\");\n  assertThat(resolve(\"a:b\", \"../c\")).isEqualTo(\"a:c\");\n}",
        "summary_tokens": [
            "tests",
            "additional",
            "abnormal",
            "usage",
            "of",
            "uri",
            "util",
            "resolve",
            "string",
            "string"
        ]
    },
    {
        "id": 633,
        "code": "public void inferContentType_extensionAsPath() {\n  assertThat(Util.inferContentType(\".m3u8\")).isEqualTo(C.CONTENT_TYPE_HLS);\n  assertThat(Util.inferContentType(\".mpd\")).isEqualTo(C.CONTENT_TYPE_DASH);\n  assertThat(Util.inferContentType(\".ism\")).isEqualTo(C.TYPE_SS);\n  assertThat(Util.inferContentType(\".isml\")).isEqualTo(C.TYPE_SS);\n  assertThat(Util.inferContentType(\".mp4\")).isEqualTo(C.CONTENT_TYPE_OTHER);\n}",
        "summary_tokens": [
            "test",
            "that",
            "the",
            "deprecated",
            "util",
            "infer",
            "content",
            "type",
            "string",
            "works",
            "when",
            "passed",
            "only",
            "a",
            "file",
            "extension",
            "and",
            "the",
            "leading",
            "dot"
        ]
    },
    {
        "id": 634,
        "code": "private static SQLiteOpenHelper getInMemorySQLiteOpenHelper() {\n  return new SQLiteOpenHelper(\n       null,  null,  null,  1) {\n    @Override\n    public void onCreate(SQLiteDatabase db) {}\n\n    @Override\n    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {}\n  };\n}",
        "summary_tokens": [
            "returns",
            "a",
            "sqlite",
            "open",
            "helper",
            "that",
            "provides",
            "an",
            "in",
            "memory",
            "database"
        ]
    },
    {
        "id": 635,
        "code": "private static byte[] buildTestData(int length) {\n  return buildTestData(length, length);\n}",
        "summary_tokens": [
            "equivalent",
            "to",
            "build",
            "test",
            "data",
            "length",
            "length"
        ]
    },
    {
        "id": 636,
        "code": "private static String buildTestString(int maximumLength, Random random) {\n  int length = random.nextInt(maximumLength);\n  StringBuilder builder = new StringBuilder(length);\n  for (int i = 0; i < length; i++) {\n    builder.append((char) random.nextInt());\n  }\n  return builder.toString();\n}",
        "summary_tokens": [
            "generates",
            "a",
            "random",
            "string",
            "with",
            "the",
            "specified",
            "maximum",
            "length"
        ]
    },
    {
        "id": 637,
        "code": "private static byte[] createByteArray(int... bytes) {\n  byte[] byteArray = new byte[bytes.length];\n  for (int i = 0; i < byteArray.length; i++) {\n    Assertions.checkState(0x00 <= bytes[i] && bytes[i] <= 0xFF);\n    byteArray[i] = (byte) bytes[i];\n  }\n  return byteArray;\n}",
        "summary_tokens": [
            "converts",
            "an",
            "array",
            "of",
            "integers",
            "in",
            "the",
            "range",
            "0",
            "0",
            "into",
            "an",
            "equivalent",
            "byte",
            "array"
        ]
    },
    {
        "id": 638,
        "code": "public static Object getChildTimelineUidFromConcatenatedUid(Object concatenatedUid) {\n  return ((Pair<?, ?>) concatenatedUid).first;\n}",
        "summary_tokens": [
            "returns",
            "uid",
            "of",
            "child",
            "timeline",
            "from",
            "a",
            "concatenated",
            "period",
            "uid"
        ]
    },
    {
        "id": 639,
        "code": "public static Object getChildPeriodUidFromConcatenatedUid(Object concatenatedUid) {\n  return ((Pair<?, ?>) concatenatedUid).second;\n}",
        "summary_tokens": [
            "returns",
            "uid",
            "of",
            "the",
            "period",
            "in",
            "the",
            "child",
            "timeline",
            "from",
            "a",
            "concatenated",
            "period",
            "uid"
        ]
    },
    {
        "id": 640,
        "code": "public static Object getConcatenatedUid(Object childTimelineUid, Object childPeriodOrWindowUid) {\n  return Pair.create(childTimelineUid, childPeriodOrWindowUid);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "concatenated",
            "uid",
            "for",
            "a",
            "period",
            "or",
            "window",
            "in",
            "a",
            "child",
            "timeline"
        ]
    },
    {
        "id": 641,
        "code": "public void setEnabled(boolean enabled) {\n  if (enabled && !receiverRegistered) {\n    context.registerReceiver(\n        receiver, new IntentFilter(AudioManager.ACTION_AUDIO_BECOMING_NOISY));\n    receiverRegistered = true;\n  } else if (!enabled && receiverRegistered) {\n    context.unregisterReceiver(receiver);\n    receiverRegistered = false;\n  }\n}",
        "summary_tokens": [
            "enables",
            "the",
            "audio",
            "becoming",
            "noisy",
            "manager",
            "which",
            "calls",
            "event",
            "listener",
            "on",
            "audio",
            "becoming",
            "noisy",
            "upon",
            "receiving",
            "an",
            "intent",
            "of",
            "audio",
            "manager",
            "action",
            "audio",
            "becoming",
            "noisy"
        ]
    },
    {
        "id": 642,
        "code": "public float getVolumeMultiplier() {\n  return volumeMultiplier;\n}",
        "summary_tokens": [
            "gets",
            "the",
            "current",
            "player",
            "volume",
            "multiplier"
        ]
    },
    {
        "id": 643,
        "code": "public void setAudioAttributes(@Nullable AudioAttributes audioAttributes) {\n  if (!Util.areEqual(this.audioAttributes, audioAttributes)) {\n    this.audioAttributes = audioAttributes;\n    focusGainToRequest = convertAudioAttributesToFocusGain(audioAttributes);\n    Assertions.checkArgument(\n        focusGainToRequest == AUDIOFOCUS_GAIN || focusGainToRequest == AUDIOFOCUS_NONE,\n        \"Automatic handling of audio focus is only available for USAGE_MEDIA and USAGE_GAME.\");\n  }\n}",
        "summary_tokens": [
            "sets",
            "audio",
            "attributes",
            "that",
            "should",
            "be",
            "used",
            "to",
            "manage",
            "audio",
            "focus"
        ]
    },
    {
        "id": 644,
        "code": "public @PlayerCommand int updateAudioFocus(\n    boolean playWhenReady, @Player.State int playbackState) {\n  if (shouldAbandonAudioFocusIfHeld(playbackState)) {\n    abandonAudioFocusIfHeld();\n    return playWhenReady ? PLAYER_COMMAND_PLAY_WHEN_READY : PLAYER_COMMAND_DO_NOT_PLAY;\n  }\n  return playWhenReady ? requestAudioFocus() : PLAYER_COMMAND_DO_NOT_PLAY;\n}",
        "summary_tokens": [
            "called",
            "by",
            "the",
            "player",
            "to",
            "abandon",
            "or",
            "request",
            "audio",
            "focus",
            "based",
            "on",
            "the",
            "desired",
            "player",
            "state"
        ]
    },
    {
        "id": 645,
        "code": "public void release() {\n  playerControl = null;\n  abandonAudioFocusIfHeld();\n}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "manager",
            "is",
            "no",
            "longer",
            "required"
        ]
    },
    {
        "id": 646,
        "code": "private static @AudioFocusGain int convertAudioAttributesToFocusGain(\n    @Nullable AudioAttributes audioAttributes) {\n  if (audioAttributes == null) {\n      \n      \n    return AUDIOFOCUS_NONE;\n  }\n\n  switch (audioAttributes.usage) {\n        \n        \n        \n    case C.USAGE_VOICE_COMMUNICATION_SIGNALLING:\n      return AUDIOFOCUS_NONE;\n\n        \n        \n    case C.USAGE_GAME:\n    case C.USAGE_MEDIA:\n      return AUDIOFOCUS_GAIN;\n\n        \n        \n    case C.USAGE_UNKNOWN:\n      Log.w(\n          TAG,\n          \"Specify a proper usage in the audio attributes for audio focus\"\n              + \" handling. Using AUDIOFOCUS_GAIN by default.\");\n      return AUDIOFOCUS_GAIN;\n\n        \n        \n    case C.USAGE_ALARM:\n    case C.USAGE_VOICE_COMMUNICATION:\n      return AUDIOFOCUS_GAIN_TRANSIENT;\n\n        \n        \n    case C.USAGE_ASSISTANCE_NAVIGATION_GUIDANCE:\n    case C.USAGE_ASSISTANCE_SONIFICATION:\n    case C.USAGE_NOTIFICATION:\n    case C.USAGE_NOTIFICATION_COMMUNICATION_DELAYED:\n    case C.USAGE_NOTIFICATION_COMMUNICATION_INSTANT:\n    case C.USAGE_NOTIFICATION_COMMUNICATION_REQUEST:\n    case C.USAGE_NOTIFICATION_EVENT:\n    case C.USAGE_NOTIFICATION_RINGTONE:\n      return AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK;\n\n        \n        \n        \n    case C.USAGE_ASSISTANT:\n      if (Util.SDK_INT >= 19) {\n        return AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE;\n      } else {\n        return AUDIOFOCUS_GAIN_TRANSIENT;\n      }\n\n        \n    case C.USAGE_ASSISTANCE_ACCESSIBILITY:\n      if (audioAttributes.contentType == C.AUDIO_CONTENT_TYPE_SPEECH) {\n          \n        return AUDIOFOCUS_GAIN_TRANSIENT;\n      }\n      return AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK;\n    default:\n      Log.w(TAG, \"Unidentified audio usage: \" + audioAttributes.usage);\n      return AUDIOFOCUS_NONE;\n  }\n}",
        "summary_tokens": [
            "converts",
            "audio",
            "attributes",
            "to",
            "one",
            "of",
            "the",
            "audio",
            "focus",
            "request"
        ]
    },
    {
        "id": 647,
        "code": "protected void onEnabled(boolean joining, boolean mayRenderStartOfStream)",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "renderer",
            "is",
            "enabled"
        ]
    },
    {
        "id": 648,
        "code": "protected void onStreamChanged(Format[] formats, long startPositionUs, long offsetUs)",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "renderer",
            "s",
            "stream",
            "has",
            "changed"
        ]
    },
    {
        "id": 649,
        "code": "protected void onPositionReset(long positionUs, boolean joining) throws ExoPlaybackException {\n    \n}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "position",
            "is",
            "reset"
        ]
    },
    {
        "id": 650,
        "code": "protected void onStarted() throws ExoPlaybackException {\n    \n}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "renderer",
            "is",
            "started"
        ]
    },
    {
        "id": 651,
        "code": "protected void onStopped() {\n    \n}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "renderer",
            "is",
            "stopped"
        ]
    },
    {
        "id": 652,
        "code": "protected void onDisabled() {\n    \n}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "renderer",
            "is",
            "disabled"
        ]
    },
    {
        "id": 653,
        "code": "protected void onReset() {\n    \n}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "renderer",
            "is",
            "reset"
        ]
    },
    {
        "id": 654,
        "code": "protected final long getLastResetPositionUs() {\n  return lastResetPositionUs;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "position",
            "passed",
            "to",
            "the",
            "most",
            "recent",
            "call",
            "to",
            "enable",
            "or",
            "reset",
            "position"
        ]
    },
    {
        "id": 655,
        "code": "protected final FormatHolder getFormatHolder() {\n  formatHolder.clear();\n  return formatHolder;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "clear",
            "format",
            "holder"
        ]
    },
    {
        "id": 656,
        "code": "protected final Format[] getStreamFormats() {\n  return Assertions.checkNotNull(streamFormats);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "formats",
            "of",
            "the",
            "currently",
            "enabled",
            "stream"
        ]
    },
    {
        "id": 657,
        "code": "protected final RendererConfiguration getConfiguration() {\n  return Assertions.checkNotNull(configuration);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "configuration",
            "set",
            "when",
            "the",
            "renderer",
            "was",
            "most",
            "recently",
            "enabled"
        ]
    },
    {
        "id": 658,
        "code": "protected final int getIndex() {\n  return index;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "index",
            "of",
            "the",
            "renderer",
            "within",
            "the",
            "player"
        ]
    },
    {
        "id": 659,
        "code": "protected final PlayerId getPlayerId() {\n  return checkNotNull(playerId);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "player",
            "id",
            "of",
            "the",
            "player",
            "using",
            "this",
            "renderer"
        ]
    },
    {
        "id": 660,
        "code": "protected final ExoPlaybackException createRendererException(\n    Throwable cause,\n    @Nullable Format format,\n    boolean isRecoverable,\n    @PlaybackException.ErrorCode int errorCode) {\n  @C.FormatSupport int formatSupport = C.FORMAT_HANDLED;\n  if (format != null && !throwRendererExceptionIsExecuting) {\n      \n    throwRendererExceptionIsExecuting = true;\n    try {\n      formatSupport = RendererCapabilities.getFormatSupport(supportsFormat(format));\n    } catch (ExoPlaybackException e) {\n        \n    } finally {\n      throwRendererExceptionIsExecuting = false;\n    }\n  }\n  return ExoPlaybackException.createForRenderer(\n      cause, getName(), getIndex(), format, formatSupport, isRecoverable, errorCode);\n}",
        "summary_tokens": [
            "creates",
            "an",
            "exo",
            "playback",
            "exception",
            "of",
            "type",
            "exo",
            "playback",
            "exception",
            "type",
            "renderer",
            "for",
            "this",
            "renderer"
        ]
    },
    {
        "id": 661,
        "code": "protected final @ReadDataResult int readSource(\n    FormatHolder formatHolder, DecoderInputBuffer buffer, @ReadFlags int readFlags) {\n  @ReadDataResult\n  int result = Assertions.checkNotNull(stream).readData(formatHolder, buffer, readFlags);\n  if (result == C.RESULT_BUFFER_READ) {\n    if (buffer.isEndOfStream()) {\n      readingPositionUs = C.TIME_END_OF_SOURCE;\n      return streamIsFinal ? C.RESULT_BUFFER_READ : C.RESULT_NOTHING_READ;\n    }\n    buffer.timeUs += streamOffsetUs;\n    readingPositionUs = max(readingPositionUs, buffer.timeUs);\n  } else if (result == C.RESULT_FORMAT_READ) {\n    Format format = Assertions.checkNotNull(formatHolder.format);\n    if (format.subsampleOffsetUs != Format.OFFSET_SAMPLE_RELATIVE) {\n      format =\n          format\n              .buildUpon()\n              .setSubsampleOffsetUs(format.subsampleOffsetUs + streamOffsetUs)\n              .build();\n      formatHolder.format = format;\n    }\n  }\n  return result;\n}",
        "summary_tokens": [
            "reads",
            "from",
            "the",
            "enabled",
            "upstream",
            "source"
        ]
    },
    {
        "id": 662,
        "code": "protected int skipSource(long positionUs) {\n  return Assertions.checkNotNull(stream).skipData(positionUs - streamOffsetUs);\n}",
        "summary_tokens": [
            "attempts",
            "to",
            "skip",
            "to",
            "the",
            "keyframe",
            "before",
            "the",
            "specified",
            "position",
            "or",
            "to",
            "the",
            "end",
            "of",
            "the",
            "stream",
            "if",
            "position",
            "us",
            "is",
            "beyond",
            "it"
        ]
    },
    {
        "id": 663,
        "code": "protected final boolean isSourceReady() {\n  return hasReadStreamToEnd() ? streamIsFinal : Assertions.checkNotNull(stream).isReady();\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "upstream",
            "source",
            "is",
            "ready"
        ]
    },
    {
        "id": 664,
        "code": "protected int calculateTargetBufferBytes(\n    Renderer[] renderers, ExoTrackSelection[] trackSelectionArray) {\n  int targetBufferSize = 0;\n  for (int i = 0; i < renderers.length; i++) {\n    if (trackSelectionArray[i] != null) {\n      targetBufferSize += getDefaultBufferSize(renderers[i].getTrackType());\n    }\n  }\n  return max(DEFAULT_MIN_BUFFER_SIZE, targetBufferSize);\n}",
        "summary_tokens": [
            "calculate",
            "target",
            "buffer",
            "size",
            "in",
            "bytes",
            "based",
            "on",
            "the",
            "selected",
            "tracks"
        ]
    },
    {
        "id": 665,
        "code": "public void start() {\n  standaloneClockIsStarted = true;\n  standaloneClock.start();\n}",
        "summary_tokens": [
            "starts",
            "the",
            "standalone",
            "fallback",
            "clock"
        ]
    },
    {
        "id": 666,
        "code": "public void stop() {\n  standaloneClockIsStarted = false;\n  standaloneClock.stop();\n}",
        "summary_tokens": [
            "stops",
            "the",
            "standalone",
            "fallback",
            "clock"
        ]
    },
    {
        "id": 667,
        "code": "public void resetPosition(long positionUs) {\n  standaloneClock.resetPosition(positionUs);\n}",
        "summary_tokens": [
            "resets",
            "the",
            "position",
            "of",
            "the",
            "standalone",
            "fallback",
            "clock"
        ]
    },
    {
        "id": 668,
        "code": "public void onRendererEnabled(Renderer renderer) throws ExoPlaybackException {\n  @Nullable MediaClock rendererMediaClock = renderer.getMediaClock();\n  if (rendererMediaClock != null && rendererMediaClock != rendererClock) {\n    if (rendererClock != null) {\n      throw ExoPlaybackException.createForUnexpected(\n          new IllegalStateException(\"Multiple renderer media clocks enabled.\"));\n    }\n    this.rendererClock = rendererMediaClock;\n    this.rendererClockSource = renderer;\n    rendererClock.setPlaybackParameters(standaloneClock.getPlaybackParameters());\n  }\n}",
        "summary_tokens": [
            "notifies",
            "the",
            "media",
            "clock",
            "that",
            "a",
            "renderer",
            "has",
            "been",
            "enabled"
        ]
    },
    {
        "id": 669,
        "code": "public void onRendererDisabled(Renderer renderer) {\n  if (renderer == rendererClockSource) {\n    this.rendererClock = null;\n    this.rendererClockSource = null;\n    isUsingStandaloneClock = true;\n  }\n}",
        "summary_tokens": [
            "notifies",
            "the",
            "media",
            "clock",
            "that",
            "a",
            "renderer",
            "has",
            "been",
            "disabled"
        ]
    },
    {
        "id": 670,
        "code": "public long syncAndGetPositionUs(boolean isReadingAhead) {\n  syncClocks(isReadingAhead);\n  return getPositionUs();\n}",
        "summary_tokens": [
            "syncs",
            "internal",
            "clock",
            "if",
            "needed",
            "and",
            "returns",
            "current",
            "clock",
            "position",
            "in",
            "microseconds"
        ]
    },
    {
        "id": 671,
        "code": "public DefaultRenderersFactory setExtensionRendererMode(\n    @ExtensionRendererMode int extensionRendererMode) {\n  this.extensionRendererMode = extensionRendererMode;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "extension",
            "renderer",
            "mode",
            "which",
            "determines",
            "if",
            "and",
            "how",
            "available",
            "extension",
            "renderers",
            "are",
            "used"
        ]
    },
    {
        "id": 672,
        "code": "public DefaultRenderersFactory experimentalSetSynchronizeCodecInteractionsWithQueueingEnabled(\n    boolean enabled) {\n  codecAdapterFactory.experimentalSetSynchronizeCodecInteractionsWithQueueingEnabled(enabled);\n  return this;\n}",
        "summary_tokens": [
            "enable",
            "synchronizing",
            "codec",
            "interactions",
            "with",
            "asynchronous",
            "buffer",
            "queueing"
        ]
    },
    {
        "id": 673,
        "code": "public DefaultRenderersFactory setEnableDecoderFallback(boolean enableDecoderFallback) {\n  this.enableDecoderFallback = enableDecoderFallback;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "to",
            "enable",
            "fallback",
            "to",
            "lower",
            "priority",
            "decoders",
            "if",
            "decoder",
            "initialization",
            "fails"
        ]
    },
    {
        "id": 674,
        "code": "public DefaultRenderersFactory setMediaCodecSelector(MediaCodecSelector mediaCodecSelector) {\n  this.mediaCodecSelector = mediaCodecSelector;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "a",
            "media",
            "codec",
            "selector",
            "for",
            "use",
            "by",
            "media",
            "codec",
            "based",
            "renderers"
        ]
    },
    {
        "id": 675,
        "code": "public DefaultRenderersFactory setEnableAudioFloatOutput(boolean enableFloatOutput) {\n  this.enableFloatOutput = enableFloatOutput;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "floating",
            "point",
            "audio",
            "should",
            "be",
            "output",
            "when",
            "possible"
        ]
    },
    {
        "id": 676,
        "code": "public DefaultRenderersFactory setEnableAudioOffload(boolean enableOffload) {\n  this.enableOffload = enableOffload;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "audio",
            "should",
            "be",
            "played",
            "using",
            "the",
            "offload",
            "path"
        ]
    },
    {
        "id": 677,
        "code": "public DefaultRenderersFactory setEnableAudioTrackPlaybackParams(\n    boolean enableAudioTrackPlaybackParams) {\n  this.enableAudioTrackPlaybackParams = enableAudioTrackPlaybackParams;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "to",
            "enable",
            "setting",
            "playback",
            "speed",
            "using",
            "android"
        ]
    },
    {
        "id": 678,
        "code": "public DefaultRenderersFactory setAllowedVideoJoiningTimeMs(long allowedVideoJoiningTimeMs) {\n  this.allowedVideoJoiningTimeMs = allowedVideoJoiningTimeMs;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "maximum",
            "duration",
            "for",
            "which",
            "video",
            "renderers",
            "can",
            "attempt",
            "to",
            "seamlessly",
            "join",
            "an",
            "ongoing",
            "playback"
        ]
    },
    {
        "id": 679,
        "code": "protected void buildVideoRenderers(\n    Context context,\n    @ExtensionRendererMode int extensionRendererMode,\n    MediaCodecSelector mediaCodecSelector,\n    boolean enableDecoderFallback,\n    Handler eventHandler,\n    VideoRendererEventListener eventListener,\n    long allowedVideoJoiningTimeMs,\n    ArrayList<Renderer> out) {\n  MediaCodecVideoRenderer videoRenderer =\n      new MediaCodecVideoRenderer(\n          context,\n          getCodecAdapterFactory(),\n          mediaCodecSelector,\n          allowedVideoJoiningTimeMs,\n          enableDecoderFallback,\n          eventHandler,\n          eventListener,\n          MAX_DROPPED_VIDEO_FRAME_COUNT_TO_NOTIFY);\n  out.add(videoRenderer);\n\n  if (extensionRendererMode == EXTENSION_RENDERER_MODE_OFF) {\n    return;\n  }\n  int extensionRendererIndex = out.size();\n  if (extensionRendererMode == EXTENSION_RENDERER_MODE_PREFER) {\n    extensionRendererIndex--;\n  }\n\n  try {\n      \n    Class<?> clazz = Class.forName(\"com.google.android.exoplayer2.ext.vp9.LibvpxVideoRenderer\");\n    Constructor<?> constructor =\n        clazz.getConstructor(\n            long.class,\n            android.os.Handler.class,\n            com.google.android.exoplayer2.video.VideoRendererEventListener.class,\n            int.class);\n    Renderer renderer =\n        (Renderer)\n            constructor.newInstance(\n                allowedVideoJoiningTimeMs,\n                eventHandler,\n                eventListener,\n                MAX_DROPPED_VIDEO_FRAME_COUNT_TO_NOTIFY);\n    out.add(extensionRendererIndex++, renderer);\n    Log.i(TAG, \"Loaded LibvpxVideoRenderer.\");\n  } catch (ClassNotFoundException e) {\n      \n  } catch (Exception e) {\n      \n    throw new RuntimeException(\"Error instantiating VP9 extension\", e);\n  }\n\n  try {\n      \n    Class<?> clazz = Class.forName(\"com.google.android.exoplayer2.ext.av1.Libgav1VideoRenderer\");\n    Constructor<?> constructor =\n        clazz.getConstructor(\n            long.class,\n            android.os.Handler.class,\n            com.google.android.exoplayer2.video.VideoRendererEventListener.class,\n            int.class);\n    Renderer renderer =\n        (Renderer)\n            constructor.newInstance(\n                allowedVideoJoiningTimeMs,\n                eventHandler,\n                eventListener,\n                MAX_DROPPED_VIDEO_FRAME_COUNT_TO_NOTIFY);\n    out.add(extensionRendererIndex++, renderer);\n    Log.i(TAG, \"Loaded Libgav1VideoRenderer.\");\n  } catch (ClassNotFoundException e) {\n      \n  } catch (Exception e) {\n      \n    throw new RuntimeException(\"Error instantiating AV1 extension\", e);\n  }\n}",
        "summary_tokens": [
            "builds",
            "video",
            "renderers",
            "for",
            "use",
            "by",
            "the",
            "player"
        ]
    },
    {
        "id": 680,
        "code": "protected void buildAudioRenderers(\n    Context context,\n    @ExtensionRendererMode int extensionRendererMode,\n    MediaCodecSelector mediaCodecSelector,\n    boolean enableDecoderFallback,\n    AudioSink audioSink,\n    Handler eventHandler,\n    AudioRendererEventListener eventListener,\n    ArrayList<Renderer> out) {\n  MediaCodecAudioRenderer audioRenderer =\n      new MediaCodecAudioRenderer(\n          context,\n          getCodecAdapterFactory(),\n          mediaCodecSelector,\n          enableDecoderFallback,\n          eventHandler,\n          eventListener,\n          audioSink);\n  out.add(audioRenderer);\n\n  if (extensionRendererMode == EXTENSION_RENDERER_MODE_OFF) {\n    return;\n  }\n  int extensionRendererIndex = out.size();\n  if (extensionRendererMode == EXTENSION_RENDERER_MODE_PREFER) {\n    extensionRendererIndex--;\n  }\n\n  try {\n    Class<?> clazz = Class.forName(\"com.google.android.exoplayer2.decoder.midi.MidiRenderer\");\n    Constructor<?> constructor = clazz.getConstructor();\n    Renderer renderer = (Renderer) constructor.newInstance();\n    out.add(extensionRendererIndex++, renderer);\n    Log.i(TAG, \"Loaded MidiRenderer.\");\n  } catch (ClassNotFoundException e) {\n      \n  } catch (Exception e) {\n      \n    throw new RuntimeException(\"Error instantiating MIDI extension\", e);\n  }\n\n  try {\n      \n    Class<?> clazz = Class.forName(\"com.google.android.exoplayer2.ext.opus.LibopusAudioRenderer\");\n    Constructor<?> constructor =\n        clazz.getConstructor(\n            android.os.Handler.class,\n            com.google.android.exoplayer2.audio.AudioRendererEventListener.class,\n            com.google.android.exoplayer2.audio.AudioSink.class);\n    Renderer renderer =\n        (Renderer) constructor.newInstance(eventHandler, eventListener, audioSink);\n    out.add(extensionRendererIndex++, renderer);\n    Log.i(TAG, \"Loaded LibopusAudioRenderer.\");\n  } catch (ClassNotFoundException e) {\n      \n  } catch (Exception e) {\n      \n    throw new RuntimeException(\"Error instantiating Opus extension\", e);\n  }\n\n  try {\n      \n    Class<?> clazz = Class.forName(\"com.google.android.exoplayer2.ext.flac.LibflacAudioRenderer\");\n    Constructor<?> constructor =\n        clazz.getConstructor(\n            android.os.Handler.class,\n            com.google.android.exoplayer2.audio.AudioRendererEventListener.class,\n            com.google.android.exoplayer2.audio.AudioSink.class);\n    Renderer renderer =\n        (Renderer) constructor.newInstance(eventHandler, eventListener, audioSink);\n    out.add(extensionRendererIndex++, renderer);\n    Log.i(TAG, \"Loaded LibflacAudioRenderer.\");\n  } catch (ClassNotFoundException e) {\n      \n  } catch (Exception e) {\n      \n    throw new RuntimeException(\"Error instantiating FLAC extension\", e);\n  }\n\n  try {\n      \n    Class<?> clazz =\n        Class.forName(\"com.google.android.exoplayer2.ext.ffmpeg.FfmpegAudioRenderer\");\n    Constructor<?> constructor =\n        clazz.getConstructor(\n            android.os.Handler.class,\n            com.google.android.exoplayer2.audio.AudioRendererEventListener.class,\n            com.google.android.exoplayer2.audio.AudioSink.class);\n    Renderer renderer =\n        (Renderer) constructor.newInstance(eventHandler, eventListener, audioSink);\n    out.add(extensionRendererIndex++, renderer);\n    Log.i(TAG, \"Loaded FfmpegAudioRenderer.\");\n  } catch (ClassNotFoundException e) {\n      \n  } catch (Exception e) {\n      \n    throw new RuntimeException(\"Error instantiating FFmpeg extension\", e);\n  }\n}",
        "summary_tokens": [
            "builds",
            "audio",
            "renderers",
            "for",
            "use",
            "by",
            "the",
            "player"
        ]
    },
    {
        "id": 681,
        "code": "protected void buildTextRenderers(\n    Context context,\n    TextOutput output,\n    Looper outputLooper,\n    @ExtensionRendererMode int extensionRendererMode,\n    ArrayList<Renderer> out) {\n  out.add(new TextRenderer(output, outputLooper));\n}",
        "summary_tokens": [
            "builds",
            "text",
            "renderers",
            "for",
            "use",
            "by",
            "the",
            "player"
        ]
    },
    {
        "id": 682,
        "code": "protected void buildMetadataRenderers(\n    Context context,\n    MetadataOutput output,\n    Looper outputLooper,\n    @ExtensionRendererMode int extensionRendererMode,\n    ArrayList<Renderer> out) {\n  out.add(new MetadataRenderer(output, outputLooper));\n}",
        "summary_tokens": [
            "builds",
            "metadata",
            "renderers",
            "for",
            "use",
            "by",
            "the",
            "player"
        ]
    },
    {
        "id": 683,
        "code": "protected void buildCameraMotionRenderers(\n    Context context, @ExtensionRendererMode int extensionRendererMode, ArrayList<Renderer> out) {\n  out.add(new CameraMotionRenderer());\n}",
        "summary_tokens": [
            "builds",
            "camera",
            "motion",
            "renderers",
            "for",
            "use",
            "by",
            "the",
            "player"
        ]
    },
    {
        "id": 684,
        "code": "protected void buildMiscellaneousRenderers(\n    Context context,\n    Handler eventHandler,\n    @ExtensionRendererMode int extensionRendererMode,\n    ArrayList<Renderer> out) {\n    \n}",
        "summary_tokens": [
            "builds",
            "any",
            "miscellaneous",
            "renderers",
            "used",
            "by",
            "the",
            "player"
        ]
    },
    {
        "id": 685,
        "code": "protected AudioSink buildAudioSink(\n    Context context,\n    boolean enableFloatOutput,\n    boolean enableAudioTrackPlaybackParams,\n    boolean enableOffload) {\n  return new DefaultAudioSink.Builder()\n      .setAudioCapabilities(AudioCapabilities.getCapabilities(context))\n      .setEnableFloatOutput(enableFloatOutput)\n      .setEnableAudioTrackPlaybackParams(enableAudioTrackPlaybackParams)\n      .setOffloadMode(\n          enableOffload\n              ? DefaultAudioSink.OFFLOAD_MODE_ENABLED_GAPLESS_REQUIRED\n              : DefaultAudioSink.OFFLOAD_MODE_DISABLED)\n      .build();\n}",
        "summary_tokens": [
            "builds",
            "an",
            "audio",
            "sink",
            "to",
            "which",
            "the",
            "audio",
            "renderers",
            "will",
            "output"
        ]
    },
    {
        "id": 686,
        "code": "protected MediaCodecAdapter.Factory getCodecAdapterFactory() {\n  return codecAdapterFactory;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "media",
            "codec",
            "adapter"
        ]
    },
    {
        "id": 687,
        "code": "public static ExoPlaybackException createForSource(IOException cause, int errorCode) {\n  return new ExoPlaybackException(TYPE_SOURCE, cause, errorCode);\n}",
        "summary_tokens": [
            "creates",
            "an",
            "instance",
            "of",
            "type",
            "type",
            "source"
        ]
    },
    {
        "id": 688,
        "code": "public static ExoPlaybackException createForRenderer(\n    Throwable cause,\n    String rendererName,\n    int rendererIndex,\n    @Nullable Format rendererFormat,\n    @FormatSupport int rendererFormatSupport,\n    boolean isRecoverable,\n    @ErrorCode int errorCode) {\n\n  return new ExoPlaybackException(\n      TYPE_RENDERER,\n      cause,\n       null,\n      errorCode,\n      rendererName,\n      rendererIndex,\n      rendererFormat,\n      rendererFormat == null ? C.FORMAT_HANDLED : rendererFormatSupport,\n      isRecoverable);\n}",
        "summary_tokens": [
            "creates",
            "an",
            "instance",
            "of",
            "type",
            "type",
            "renderer"
        ]
    },
    {
        "id": 689,
        "code": "public static ExoPlaybackException createForUnexpected(\n    RuntimeException cause, @ErrorCode int errorCode) {\n  return new ExoPlaybackException(TYPE_UNEXPECTED, cause, errorCode);\n}",
        "summary_tokens": [
            "creates",
            "an",
            "instance",
            "of",
            "type",
            "type",
            "unexpected"
        ]
    },
    {
        "id": 690,
        "code": "public static ExoPlaybackException createForRemote(String message) {\n  return new ExoPlaybackException(\n      TYPE_REMOTE,\n       null,\n       message,\n      ERROR_CODE_REMOTE_ERROR,\n       null,\n       C.INDEX_UNSET,\n       null,\n       C.FORMAT_HANDLED,\n       false);\n}",
        "summary_tokens": [
            "creates",
            "an",
            "instance",
            "of",
            "type",
            "type",
            "remote"
        ]
    },
    {
        "id": 691,
        "code": "public IOException getSourceException() {\n  Assertions.checkState(type == TYPE_SOURCE);\n  return (IOException) Assertions.checkNotNull(getCause());\n}",
        "summary_tokens": [
            "retrieves",
            "the",
            "underlying",
            "error",
            "when",
            "type",
            "is",
            "type",
            "source"
        ]
    },
    {
        "id": 692,
        "code": "public Exception getRendererException() {\n  Assertions.checkState(type == TYPE_RENDERER);\n  return (Exception) Assertions.checkNotNull(getCause());\n}",
        "summary_tokens": [
            "retrieves",
            "the",
            "underlying",
            "error",
            "when",
            "type",
            "is",
            "type",
            "renderer"
        ]
    },
    {
        "id": 693,
        "code": "public RuntimeException getUnexpectedException() {\n  Assertions.checkState(type == TYPE_UNEXPECTED);\n  return (RuntimeException) Assertions.checkNotNull(getCause());\n}",
        "summary_tokens": [
            "retrieves",
            "the",
            "underlying",
            "error",
            "when",
            "type",
            "is",
            "type",
            "unexpected"
        ]
    },
    {
        "id": 694,
        "code": " ExoPlaybackException copyWithMediaPeriodId(@Nullable MediaPeriodId mediaPeriodId) {\n  return new ExoPlaybackException(\n      Util.castNonNull(getMessage()),\n      getCause(),\n      errorCode,\n      type,\n      rendererName,\n      rendererIndex,\n      rendererFormat,\n      rendererFormatSupport,\n      mediaPeriodId,\n      timestampMs,\n      isRecoverable);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "copy",
            "of",
            "this",
            "exception",
            "with",
            "the",
            "provided",
            "media",
            "period",
            "id"
        ]
    },
    {
        "id": 695,
        "code": "private MediaMetadata buildUpdatedMediaMetadata() {\n  Timeline timeline = getCurrentTimeline();\n  if (timeline.isEmpty()) {\n    return staticAndDynamicMediaMetadata;\n  }\n  MediaItem mediaItem = timeline.getWindow(getCurrentMediaItemIndex(), window).mediaItem;\n    \n  return staticAndDynamicMediaMetadata.buildUpon().populate(mediaItem.mediaMetadata).build();\n}",
        "summary_tokens": [
            "builds",
            "a",
            "media",
            "metadata",
            "from",
            "the",
            "main",
            "sources"
        ]
    },
    {
        "id": 696,
        "code": "private void setNonVideoOutputSurfaceHolderInternal(SurfaceHolder nonVideoOutputSurfaceHolder) {\n    \n    \n    \n  surfaceHolderSurfaceIsVideoOutput = false;\n  surfaceHolder = nonVideoOutputSurfaceHolder;\n  surfaceHolder.addCallback(componentListener);\n  Surface surface = surfaceHolder.getSurface();\n  if (surface != null && surface.isValid()) {\n    Rect surfaceSize = surfaceHolder.getSurfaceFrame();\n    maybeNotifySurfaceSizeChanged(surfaceSize.width(), surfaceSize.height());\n  } else {\n    maybeNotifySurfaceSizeChanged( 0,  0);\n  }\n}",
        "summary_tokens": [
            "sets",
            "the",
            "holder",
            "of",
            "the",
            "surface",
            "that",
            "will",
            "be",
            "displayed",
            "to",
            "the",
            "user",
            "but",
            "which",
            "should",
            "em",
            "not",
            "em",
            "be",
            "the",
            "output",
            "for",
            "video",
            "renderers"
        ]
    },
    {
        "id": 697,
        "code": "private int initializeKeepSessionIdAudioTrack(int audioSessionId) {\n  if (keepSessionIdAudioTrack != null\n      && keepSessionIdAudioTrack.getAudioSessionId() != audioSessionId) {\n    keepSessionIdAudioTrack.release();\n    keepSessionIdAudioTrack = null;\n  }\n  if (keepSessionIdAudioTrack == null) {\n    int sampleRate = 4000; \n    int channelConfig = AudioFormat.CHANNEL_OUT_MONO;\n    @C.PcmEncoding int encoding = C.ENCODING_PCM_16BIT;\n    int bufferSize = 2; \n    keepSessionIdAudioTrack =\n        new AudioTrack(\n            C.STREAM_TYPE_DEFAULT,\n            sampleRate,\n            channelConfig,\n            encoding,\n            bufferSize,\n            AudioTrack.MODE_STATIC,\n            audioSessionId);\n  }\n  return keepSessionIdAudioTrack.getAudioSessionId();\n}",
        "summary_tokens": [
            "initializes",
            "keep",
            "session",
            "id",
            "audio",
            "track",
            "to",
            "keep",
            "an",
            "audio",
            "session",
            "id",
            "alive"
        ]
    },
    {
        "id": 698,
        "code": "public synchronized boolean setForegroundMode(boolean foregroundMode) {\n  if (released || !internalPlaybackThread.isAlive()) {\n    return true;\n  }\n  if (foregroundMode) {\n    handler.obtainMessage(MSG_SET_FOREGROUND_MODE,  1, 0).sendToTarget();\n    return true;\n  } else {\n    AtomicBoolean processedFlag = new AtomicBoolean();\n    handler\n        .obtainMessage(MSG_SET_FOREGROUND_MODE,  0, 0, processedFlag)\n        .sendToTarget();\n    waitUninterruptibly( processedFlag::get, setForegroundModeTimeoutMs);\n    return processedFlag.get();\n  }\n}",
        "summary_tokens": [
            "sets",
            "the",
            "foreground",
            "mode"
        ]
    },
    {
        "id": 699,
        "code": "private synchronized void waitUninterruptibly(Supplier<Boolean> condition, long timeoutMs) {\n  long deadlineMs = clock.elapsedRealtime() + timeoutMs;\n  long remainingMs = timeoutMs;\n  boolean wasInterrupted = false;\n  while (!condition.get() && remainingMs > 0) {\n    try {\n      clock.onThreadBlocked();\n      wait(remainingMs);\n    } catch (InterruptedException e) {\n      wasInterrupted = true;\n    }\n    remainingMs = deadlineMs - clock.elapsedRealtime();\n  }\n  if (wasInterrupted) {\n      \n    Thread.currentThread().interrupt();\n  }\n}",
        "summary_tokens": [
            "blocks",
            "the",
            "current",
            "thread",
            "until",
            "a",
            "condition",
            "becomes",
            "true",
            "or",
            "the",
            "specified",
            "amount",
            "of",
            "time",
            "has",
            "elapsed"
        ]
    },
    {
        "id": 700,
        "code": "private static boolean resolvePendingMessagePosition(\n    PendingMessageInfo pendingMessageInfo,\n    Timeline newTimeline,\n    Timeline previousTimeline,\n    @Player.RepeatMode int repeatMode,\n    boolean shuffleModeEnabled,\n    Timeline.Window window,\n    Timeline.Period period) {\n  if (pendingMessageInfo.resolvedPeriodUid == null) {\n      \n    long requestPositionUs =\n        pendingMessageInfo.message.getPositionMs() == C.TIME_END_OF_SOURCE\n            ? C.TIME_UNSET\n            : Util.msToUs(pendingMessageInfo.message.getPositionMs());\n    @Nullable\n    Pair<Object, Long> periodPosition =\n        resolveSeekPositionUs(\n            newTimeline,\n            new SeekPosition(\n                pendingMessageInfo.message.getTimeline(),\n                pendingMessageInfo.message.getMediaItemIndex(),\n                requestPositionUs),\n             false,\n            repeatMode,\n            shuffleModeEnabled,\n            window,\n            period);\n    if (periodPosition == null) {\n      return false;\n    }\n    pendingMessageInfo.setResolvedPosition(\n         newTimeline.getIndexOfPeriod(periodPosition.first),\n         periodPosition.second,\n         periodPosition.first);\n    if (pendingMessageInfo.message.getPositionMs() == C.TIME_END_OF_SOURCE) {\n      resolvePendingMessageEndOfStreamPosition(newTimeline, pendingMessageInfo, window, period);\n    }\n    return true;\n  }\n    \n  int index = newTimeline.getIndexOfPeriod(pendingMessageInfo.resolvedPeriodUid);\n  if (index == C.INDEX_UNSET) {\n    return false;\n  }\n  if (pendingMessageInfo.message.getPositionMs() == C.TIME_END_OF_SOURCE) {\n      \n    resolvePendingMessageEndOfStreamPosition(newTimeline, pendingMessageInfo, window, period);\n    return true;\n  }\n  pendingMessageInfo.resolvedPeriodIndex = index;\n  previousTimeline.getPeriodByUid(pendingMessageInfo.resolvedPeriodUid, period);\n  if (period.isPlaceholder\n      && previousTimeline.getWindow(period.windowIndex, window).firstPeriodIndex\n          == previousTimeline.getIndexOfPeriod(pendingMessageInfo.resolvedPeriodUid)) {\n      \n      \n      \n    long windowPositionUs =\n        pendingMessageInfo.resolvedPeriodTimeUs + period.getPositionInWindowUs();\n    int windowIndex =\n        newTimeline.getPeriodByUid(pendingMessageInfo.resolvedPeriodUid, period).windowIndex;\n    Pair<Object, Long> periodPositionUs =\n        newTimeline.getPeriodPositionUs(window, period, windowIndex, windowPositionUs);\n    pendingMessageInfo.setResolvedPosition(\n         newTimeline.getIndexOfPeriod(periodPositionUs.first),\n         periodPositionUs.second,\n         periodPositionUs.first);\n  }\n  return true;\n}",
        "summary_tokens": [
            "updates",
            "pending",
            "message",
            "to",
            "a",
            "new",
            "timeline"
        ]
    },
    {
        "id": 701,
        "code": "private static Pair<Object, Long> resolveSeekPositionUs(\n    Timeline timeline,\n    SeekPosition seekPosition,\n    boolean trySubsequentPeriods,\n    @RepeatMode int repeatMode,\n    boolean shuffleModeEnabled,\n    Timeline.Window window,\n    Timeline.Period period) {\n  Timeline seekTimeline = seekPosition.timeline;\n  if (timeline.isEmpty()) {\n      \n    return null;\n  }\n  if (seekTimeline.isEmpty()) {\n      \n      \n    seekTimeline = timeline;\n  }\n    \n  Pair<Object, Long> periodPositionUs;\n  try {\n    periodPositionUs =\n        seekTimeline.getPeriodPositionUs(\n            window, period, seekPosition.windowIndex, seekPosition.windowPositionUs);\n  } catch (IndexOutOfBoundsException e) {\n      \n    return null;\n  }\n  if (timeline.equals(seekTimeline)) {\n      \n    return periodPositionUs;\n  }\n    \n  int periodIndex = timeline.getIndexOfPeriod(periodPositionUs.first);\n  if (periodIndex != C.INDEX_UNSET) {\n      \n    if (seekTimeline.getPeriodByUid(periodPositionUs.first, period).isPlaceholder\n        && seekTimeline.getWindow(period.windowIndex, window).firstPeriodIndex\n            == seekTimeline.getIndexOfPeriod(periodPositionUs.first)) {\n        \n        \n        \n      int newWindowIndex = timeline.getPeriodByUid(periodPositionUs.first, period).windowIndex;\n      periodPositionUs =\n          timeline.getPeriodPositionUs(\n              window, period, newWindowIndex, seekPosition.windowPositionUs);\n    }\n    return periodPositionUs;\n  }\n  if (trySubsequentPeriods) {\n      \n    @Nullable\n    Object periodUid =\n        resolveSubsequentPeriod(\n            window,\n            period,\n            repeatMode,\n            shuffleModeEnabled,\n            periodPositionUs.first,\n            seekTimeline,\n            timeline);\n    if (periodUid != null) {\n        \n      return timeline.getPeriodPositionUs(\n          window,\n          period,\n          timeline.getPeriodByUid(periodUid, period).windowIndex,\n           C.TIME_UNSET);\n    }\n  }\n    \n  return null;\n}",
        "summary_tokens": [
            "converts",
            "a",
            "seek",
            "position",
            "into",
            "the",
            "corresponding",
            "period",
            "uid",
            "period",
            "position",
            "us",
            "for",
            "the",
            "internal",
            "timeline"
        ]
    },
    {
        "id": 702,
        "code": "static Object resolveSubsequentPeriod(\n    Timeline.Window window,\n    Timeline.Period period,\n    @Player.RepeatMode int repeatMode,\n    boolean shuffleModeEnabled,\n    Object oldPeriodUid,\n    Timeline oldTimeline,\n    Timeline newTimeline) {\n  int oldPeriodIndex = oldTimeline.getIndexOfPeriod(oldPeriodUid);\n  int newPeriodIndex = C.INDEX_UNSET;\n  int maxIterations = oldTimeline.getPeriodCount();\n  for (int i = 0; i < maxIterations && newPeriodIndex == C.INDEX_UNSET; i++) {\n    oldPeriodIndex =\n        oldTimeline.getNextPeriodIndex(\n            oldPeriodIndex, period, window, repeatMode, shuffleModeEnabled);\n    if (oldPeriodIndex == C.INDEX_UNSET) {\n        \n      break;\n    }\n    newPeriodIndex = newTimeline.getIndexOfPeriod(oldTimeline.getUidOfPeriod(oldPeriodIndex));\n  }\n  return newPeriodIndex == C.INDEX_UNSET ? null : newTimeline.getUidOfPeriod(newPeriodIndex);\n}",
        "summary_tokens": [
            "given",
            "a",
            "period",
            "index",
            "into",
            "an",
            "old",
            "timeline",
            "finds",
            "the",
            "first",
            "subsequent",
            "period",
            "that",
            "also",
            "exists",
            "in",
            "a",
            "new",
            "timeline"
        ]
    },
    {
        "id": 703,
        "code": "public long toRendererTime(long periodTimeUs) {\n  return periodTimeUs + getRendererOffset();\n}",
        "summary_tokens": [
            "converts",
            "time",
            "relative",
            "to",
            "the",
            "start",
            "of",
            "the",
            "period",
            "to",
            "the",
            "respective",
            "renderer",
            "time",
            "using",
            "get",
            "renderer",
            "offset",
            "in",
            "microseconds"
        ]
    },
    {
        "id": 704,
        "code": "public long toPeriodTime(long rendererTimeUs) {\n  return rendererTimeUs - getRendererOffset();\n}",
        "summary_tokens": [
            "converts",
            "renderer",
            "time",
            "to",
            "the",
            "respective",
            "time",
            "relative",
            "to",
            "the",
            "start",
            "of",
            "the",
            "period",
            "using",
            "get",
            "renderer",
            "offset",
            "in",
            "microseconds"
        ]
    },
    {
        "id": 705,
        "code": "public long getRendererOffset() {\n  return rendererPositionOffsetUs;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "renderer",
            "time",
            "of",
            "the",
            "start",
            "of",
            "the",
            "period",
            "in",
            "microseconds"
        ]
    },
    {
        "id": 706,
        "code": "public void setRendererOffset(long rendererPositionOffsetUs) {\n  this.rendererPositionOffsetUs = rendererPositionOffsetUs;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "renderer",
            "time",
            "of",
            "the",
            "start",
            "of",
            "the",
            "period",
            "in",
            "microseconds"
        ]
    },
    {
        "id": 707,
        "code": "public long getStartPositionRendererTime() {\n  return info.startPositionUs + rendererPositionOffsetUs;\n}",
        "summary_tokens": [
            "returns",
            "start",
            "position",
            "of",
            "period",
            "in",
            "renderer",
            "time"
        ]
    },
    {
        "id": 708,
        "code": "public boolean isFullyBuffered() {\n  return prepared\n      && (!hasEnabledTracks || mediaPeriod.getBufferedPositionUs() == C.TIME_END_OF_SOURCE);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "period",
            "is",
            "fully",
            "buffered"
        ]
    },
    {
        "id": 709,
        "code": "public long getBufferedPositionUs() {\n  if (!prepared) {\n    return info.startPositionUs;\n  }\n  long bufferedPositionUs =\n      hasEnabledTracks ? mediaPeriod.getBufferedPositionUs() : C.TIME_END_OF_SOURCE;\n  return bufferedPositionUs == C.TIME_END_OF_SOURCE ? info.durationUs : bufferedPositionUs;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "buffered",
            "position",
            "in",
            "microseconds"
        ]
    },
    {
        "id": 710,
        "code": "public long getNextLoadPositionUs() {\n  return !prepared ? 0 : mediaPeriod.getNextLoadPositionUs();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "next",
            "load",
            "time",
            "relative",
            "to",
            "the",
            "start",
            "of",
            "the",
            "period",
            "or",
            "c",
            "time",
            "end",
            "of",
            "source",
            "if",
            "loading",
            "has",
            "finished"
        ]
    },
    {
        "id": 711,
        "code": "public void reevaluateBuffer(long rendererPositionUs) {\n  Assertions.checkState(isLoadingMediaPeriod());\n  if (prepared) {\n    mediaPeriod.reevaluateBuffer(toPeriodTime(rendererPositionUs));\n  }\n}",
        "summary_tokens": [
            "reevaluates",
            "the",
            "buffer",
            "of",
            "the",
            "media",
            "period",
            "at",
            "the",
            "given",
            "renderer",
            "position"
        ]
    },
    {
        "id": 712,
        "code": "public void continueLoading(long rendererPositionUs) {\n  Assertions.checkState(isLoadingMediaPeriod());\n  long loadingPeriodPositionUs = toPeriodTime(rendererPositionUs);\n  mediaPeriod.continueLoading(loadingPeriodPositionUs);\n}",
        "summary_tokens": [
            "continues",
            "loading",
            "the",
            "media",
            "period",
            "at",
            "the",
            "given",
            "renderer",
            "position"
        ]
    },
    {
        "id": 713,
        "code": "public TrackSelectorResult selectTracks(float playbackSpeed, Timeline timeline)\n    throws ExoPlaybackException {\n  TrackSelectorResult selectorResult =\n      trackSelector.selectTracks(rendererCapabilities, getTrackGroups(), info.id, timeline);\n  for (ExoTrackSelection trackSelection : selectorResult.selections) {\n    if (trackSelection != null) {\n      trackSelection.onPlaybackSpeed(playbackSpeed);\n    }\n  }\n  return selectorResult;\n}",
        "summary_tokens": [
            "selects",
            "tracks",
            "for",
            "the",
            "period"
        ]
    },
    {
        "id": 714,
        "code": "public long applyTrackSelection(\n    TrackSelectorResult newTrackSelectorResult,\n    long positionUs,\n    boolean forceRecreateStreams,\n    boolean[] streamResetFlags) {\n  for (int i = 0; i < newTrackSelectorResult.length; i++) {\n    mayRetainStreamFlags[i] =\n        !forceRecreateStreams && newTrackSelectorResult.isEquivalent(trackSelectorResult, i);\n  }\n\n    \n    \n  disassociateNoSampleRenderersWithEmptySampleStream(sampleStreams);\n  disableTrackSelectionsInResult();\n  trackSelectorResult = newTrackSelectorResult;\n  enableTrackSelectionsInResult();\n    \n  positionUs =\n      mediaPeriod.selectTracks(\n          newTrackSelectorResult.selections,\n          mayRetainStreamFlags,\n          sampleStreams,\n          streamResetFlags,\n          positionUs);\n  associateNoSampleRenderersWithEmptySampleStream(sampleStreams);\n\n    \n  hasEnabledTracks = false;\n  for (int i = 0; i < sampleStreams.length; i++) {\n    if (sampleStreams[i] != null) {\n      Assertions.checkState(newTrackSelectorResult.isRendererEnabled(i));\n        \n      if (rendererCapabilities[i].getTrackType() != C.TRACK_TYPE_NONE) {\n        hasEnabledTracks = true;\n      }\n    } else {\n      Assertions.checkState(newTrackSelectorResult.selections[i] == null);\n    }\n  }\n  return positionUs;\n}",
        "summary_tokens": [
            "applies",
            "a",
            "track",
            "selector",
            "result",
            "to",
            "the",
            "period"
        ]
    },
    {
        "id": 715,
        "code": "public void release() {\n  disableTrackSelectionsInResult();\n  releaseMediaPeriod(mediaSourceList, mediaPeriod);\n}",
        "summary_tokens": [
            "releases",
            "the",
            "media",
            "period"
        ]
    },
    {
        "id": 716,
        "code": "public void setNext(@Nullable MediaPeriodHolder nextMediaPeriodHolder) {\n  if (nextMediaPeriodHolder == next) {\n    return;\n  }\n  disableTrackSelectionsInResult();\n  next = nextMediaPeriodHolder;\n  enableTrackSelectionsInResult();\n}",
        "summary_tokens": [
            "sets",
            "the",
            "next",
            "media",
            "period",
            "holder",
            "in",
            "the",
            "queue"
        ]
    },
    {
        "id": 717,
        "code": "public MediaPeriodHolder getNext() {\n  return next;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "next",
            "media",
            "period",
            "holder",
            "in",
            "the",
            "queue",
            "or",
            "null",
            "if",
            "this",
            "is",
            "the",
            "last",
            "media",
            "period",
            "and",
            "thus",
            "the",
            "loading",
            "media",
            "period"
        ]
    },
    {
        "id": 718,
        "code": "public TrackGroupArray getTrackGroups() {\n  return trackGroups;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "track",
            "group",
            "array",
            "exposed",
            "by",
            "this",
            "media",
            "period"
        ]
    },
    {
        "id": 719,
        "code": "public TrackSelectorResult getTrackSelectorResult() {\n  return trackSelectorResult;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "track",
            "selector",
            "result",
            "which",
            "is",
            "currently",
            "applied"
        ]
    },
    {
        "id": 720,
        "code": "public void updateClipping() {\n  if (mediaPeriod instanceof ClippingMediaPeriod) {\n    long endPositionUs =\n        info.endPositionUs == C.TIME_UNSET ? C.TIME_END_OF_SOURCE : info.endPositionUs;\n    ((ClippingMediaPeriod) mediaPeriod).updateClipping( 0, endPositionUs);\n  }\n}",
        "summary_tokens": [
            "updates",
            "the",
            "clipping",
            "to",
            "media",
            "period",
            "info",
            "end",
            "position",
            "us",
            "if",
            "required"
        ]
    },
    {
        "id": 721,
        "code": "private void disassociateNoSampleRenderersWithEmptySampleStream(\n    @NullableType SampleStream[] sampleStreams) {\n  for (int i = 0; i < rendererCapabilities.length; i++) {\n    if (rendererCapabilities[i].getTrackType() == C.TRACK_TYPE_NONE) {\n      sampleStreams[i] = null;\n    }\n  }\n}",
        "summary_tokens": [
            "for",
            "each",
            "renderer",
            "of",
            "type",
            "c",
            "track",
            "type",
            "none",
            "we",
            "will",
            "remove",
            "the",
            "empty",
            "sample",
            "stream",
            "that",
            "was",
            "associated",
            "with",
            "it"
        ]
    },
    {
        "id": 722,
        "code": "private void associateNoSampleRenderersWithEmptySampleStream(\n    @NullableType SampleStream[] sampleStreams) {\n  for (int i = 0; i < rendererCapabilities.length; i++) {\n    if (rendererCapabilities[i].getTrackType() == C.TRACK_TYPE_NONE\n        && trackSelectorResult.isRendererEnabled(i)) {\n      sampleStreams[i] = new EmptySampleStream();\n    }\n  }\n}",
        "summary_tokens": [
            "for",
            "each",
            "renderer",
            "of",
            "type",
            "c",
            "track",
            "type",
            "none",
            "that",
            "was",
            "enabled",
            "we",
            "will",
            "associate",
            "it",
            "with",
            "an",
            "empty",
            "sample",
            "stream"
        ]
    },
    {
        "id": 723,
        "code": "private static MediaPeriod createMediaPeriod(\n    MediaPeriodId id,\n    MediaSourceList mediaSourceList,\n    Allocator allocator,\n    long startPositionUs,\n    long endPositionUs) {\n  MediaPeriod mediaPeriod = mediaSourceList.createPeriod(id, allocator, startPositionUs);\n  if (endPositionUs != C.TIME_UNSET) {\n    mediaPeriod =\n        new ClippingMediaPeriod(\n            mediaPeriod,  true,  0, endPositionUs);\n  }\n  return mediaPeriod;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "media",
            "period",
            "corresponding",
            "to",
            "the",
            "given",
            "id"
        ]
    },
    {
        "id": 724,
        "code": "private static void releaseMediaPeriod(MediaSourceList mediaSourceList, MediaPeriod mediaPeriod) {\n  try {\n    if (mediaPeriod instanceof ClippingMediaPeriod) {\n      mediaSourceList.releasePeriod(((ClippingMediaPeriod) mediaPeriod).mediaPeriod);\n    } else {\n      mediaSourceList.releasePeriod(mediaPeriod);\n    }\n  } catch (RuntimeException e) {\n      \n    Log.e(TAG, \"Period release failed.\", e);\n  }\n}",
        "summary_tokens": [
            "releases",
            "the",
            "given",
            "media",
            "period",
            "logging",
            "and",
            "suppressing",
            "any",
            "errors"
        ]
    },
    {
        "id": 725,
        "code": "public MediaPeriodInfo copyWithStartPositionUs(long startPositionUs) {\n  return startPositionUs == this.startPositionUs\n      ? this\n      : new MediaPeriodInfo(\n          id,\n          startPositionUs,\n          requestedContentPositionUs,\n          endPositionUs,\n          durationUs,\n          isFollowedByTransitionToSameStream,\n          isLastInTimelinePeriod,\n          isLastInTimelineWindow,\n          isFinal);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "copy",
            "of",
            "this",
            "instance",
            "with",
            "the",
            "start",
            "position",
            "set",
            "to",
            "the",
            "specified",
            "value"
        ]
    },
    {
        "id": 726,
        "code": "public MediaPeriodInfo copyWithRequestedContentPositionUs(long requestedContentPositionUs) {\n  return requestedContentPositionUs == this.requestedContentPositionUs\n      ? this\n      : new MediaPeriodInfo(\n          id,\n          startPositionUs,\n          requestedContentPositionUs,\n          endPositionUs,\n          durationUs,\n          isFollowedByTransitionToSameStream,\n          isLastInTimelinePeriod,\n          isLastInTimelineWindow,\n          isFinal);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "copy",
            "of",
            "this",
            "instance",
            "with",
            "the",
            "requested",
            "content",
            "position",
            "set",
            "to",
            "the",
            "specified",
            "value"
        ]
    },
    {
        "id": 727,
        "code": "public boolean updateRepeatMode(Timeline timeline, @RepeatMode int repeatMode) {\n  this.repeatMode = repeatMode;\n  return updateForPlaybackModeChange(timeline);\n}",
        "summary_tokens": [
            "sets",
            "the",
            "repeat",
            "mode",
            "and",
            "returns",
            "whether",
            "the",
            "repeat",
            "mode",
            "change",
            "has",
            "been",
            "fully",
            "handled"
        ]
    },
    {
        "id": 728,
        "code": "public boolean updateShuffleModeEnabled(Timeline timeline, boolean shuffleModeEnabled) {\n  this.shuffleModeEnabled = shuffleModeEnabled;\n  return updateForPlaybackModeChange(timeline);\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "shuffling",
            "is",
            "enabled",
            "and",
            "returns",
            "whether",
            "the",
            "shuffle",
            "mode",
            "change",
            "has",
            "been",
            "fully",
            "handled"
        ]
    },
    {
        "id": 729,
        "code": "public boolean isLoading(MediaPeriod mediaPeriod) {\n  return loading != null && loading.mediaPeriod == mediaPeriod;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "media",
            "period",
            "is",
            "the",
            "current",
            "loading",
            "media",
            "period"
        ]
    },
    {
        "id": 730,
        "code": "public void reevaluateBuffer(long rendererPositionUs) {\n  if (loading != null) {\n    loading.reevaluateBuffer(rendererPositionUs);\n  }\n}",
        "summary_tokens": [
            "if",
            "there",
            "is",
            "a",
            "loading",
            "period",
            "reevaluates",
            "its",
            "buffer"
        ]
    },
    {
        "id": 731,
        "code": "public boolean shouldLoadNextMediaPeriod() {\n  return loading == null\n      || (!loading.info.isFinal\n          && loading.isFullyBuffered()\n          && loading.info.durationUs != C.TIME_UNSET\n          && length < MAXIMUM_BUFFER_AHEAD_PERIODS);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "a",
            "new",
            "loading",
            "media",
            "period",
            "should",
            "be",
            "enqueued",
            "if",
            "available"
        ]
    },
    {
        "id": 732,
        "code": "public MediaPeriodInfo getNextMediaPeriodInfo(\n    long rendererPositionUs, PlaybackInfo playbackInfo) {\n  return loading == null\n      ? getFirstMediaPeriodInfo(playbackInfo)\n      : getFollowingMediaPeriodInfo(playbackInfo.timeline, loading, rendererPositionUs);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "media",
            "period",
            "info",
            "for",
            "the",
            "next",
            "media",
            "period",
            "to",
            "load"
        ]
    },
    {
        "id": 733,
        "code": "public MediaPeriodHolder enqueueNextMediaPeriodHolder(\n    RendererCapabilities[] rendererCapabilities,\n    TrackSelector trackSelector,\n    Allocator allocator,\n    MediaSourceList mediaSourceList,\n    MediaPeriodInfo info,\n    TrackSelectorResult emptyTrackSelectorResult) {\n  long rendererPositionOffsetUs =\n      loading == null\n          ? INITIAL_RENDERER_POSITION_OFFSET_US\n          : (loading.getRendererOffset() + loading.info.durationUs - info.startPositionUs);\n  MediaPeriodHolder newPeriodHolder =\n      new MediaPeriodHolder(\n          rendererCapabilities,\n          rendererPositionOffsetUs,\n          trackSelector,\n          allocator,\n          mediaSourceList,\n          info,\n          emptyTrackSelectorResult);\n  if (loading != null) {\n    loading.setNext(newPeriodHolder);\n  } else {\n    playing = newPeriodHolder;\n    reading = newPeriodHolder;\n  }\n  oldFrontPeriodUid = null;\n  loading = newPeriodHolder;\n  length++;\n  notifyQueueUpdate();\n  return newPeriodHolder;\n}",
        "summary_tokens": [
            "enqueues",
            "a",
            "new",
            "media",
            "period",
            "holder",
            "based",
            "on",
            "the",
            "specified",
            "information",
            "as",
            "the",
            "new",
            "loading",
            "media",
            "period",
            "and",
            "returns",
            "it"
        ]
    },
    {
        "id": 734,
        "code": "public MediaPeriodHolder getLoadingPeriod() {\n  return loading;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "loading",
            "period",
            "holder",
            "which",
            "is",
            "at",
            "the",
            "end",
            "of",
            "the",
            "queue",
            "or",
            "null",
            "if",
            "the",
            "queue",
            "is",
            "empty"
        ]
    },
    {
        "id": 735,
        "code": "public MediaPeriodHolder getPlayingPeriod() {\n  return playing;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "playing",
            "period",
            "holder",
            "which",
            "is",
            "at",
            "the",
            "front",
            "of",
            "the",
            "queue",
            "or",
            "null",
            "if",
            "the",
            "queue",
            "is",
            "empty"
        ]
    },
    {
        "id": 736,
        "code": "public MediaPeriodHolder getReadingPeriod() {\n  return reading;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "reading",
            "period",
            "holder",
            "or",
            "null",
            "if",
            "the",
            "queue",
            "is",
            "empty"
        ]
    },
    {
        "id": 737,
        "code": "public MediaPeriodHolder advanceReadingPeriod() {\n  Assertions.checkState(reading != null && reading.getNext() != null);\n  reading = reading.getNext();\n  notifyQueueUpdate();\n  return reading;\n}",
        "summary_tokens": [
            "continues",
            "reading",
            "from",
            "the",
            "next",
            "period",
            "holder",
            "in",
            "the",
            "queue"
        ]
    },
    {
        "id": 738,
        "code": "public MediaPeriodHolder advancePlayingPeriod() {\n  if (playing == null) {\n    return null;\n  }\n  if (playing == reading) {\n    reading = playing.getNext();\n  }\n  playing.release();\n  length--;\n  if (length == 0) {\n    loading = null;\n    oldFrontPeriodUid = playing.uid;\n    oldFrontPeriodWindowSequenceNumber = playing.info.id.windowSequenceNumber;\n  }\n  playing = playing.getNext();\n  notifyQueueUpdate();\n  return playing;\n}",
        "summary_tokens": [
            "dequeues",
            "the",
            "playing",
            "period",
            "holder",
            "from",
            "the",
            "front",
            "of",
            "the",
            "queue",
            "and",
            "advances",
            "the",
            "playing",
            "period",
            "holder",
            "to",
            "be",
            "the",
            "next",
            "item",
            "in",
            "the",
            "queue"
        ]
    },
    {
        "id": 739,
        "code": "public boolean removeAfter(MediaPeriodHolder mediaPeriodHolder) {\n  Assertions.checkState(mediaPeriodHolder != null);\n  if (mediaPeriodHolder.equals(loading)) {\n    return false;\n  }\n  boolean removedReading = false;\n  loading = mediaPeriodHolder;\n  while (mediaPeriodHolder.getNext() != null) {\n    mediaPeriodHolder = mediaPeriodHolder.getNext();\n    if (mediaPeriodHolder == reading) {\n      reading = playing;\n      removedReading = true;\n    }\n    mediaPeriodHolder.release();\n    length--;\n  }\n  loading.setNext(null);\n  notifyQueueUpdate();\n  return removedReading;\n}",
        "summary_tokens": [
            "removes",
            "all",
            "period",
            "holders",
            "after",
            "the",
            "given",
            "period",
            "holder"
        ]
    },
    {
        "id": 740,
        "code": "public boolean updateQueuedPeriods(\n    Timeline timeline, long rendererPositionUs, long maxRendererReadPositionUs) {\n    \n    \n    \n  MediaPeriodHolder previousPeriodHolder = null;\n  MediaPeriodHolder periodHolder = playing;\n  while (periodHolder != null) {\n    MediaPeriodInfo oldPeriodInfo = periodHolder.info;\n\n      \n    MediaPeriodInfo newPeriodInfo;\n    if (previousPeriodHolder == null) {\n        \n        \n        \n      newPeriodInfo = getUpdatedMediaPeriodInfo(timeline, oldPeriodInfo);\n    } else {\n      newPeriodInfo =\n          getFollowingMediaPeriodInfo(timeline, previousPeriodHolder, rendererPositionUs);\n      if (newPeriodInfo == null) {\n          \n        return !removeAfter(previousPeriodHolder);\n      }\n      if (!canKeepMediaPeriodHolder(oldPeriodInfo, newPeriodInfo)) {\n          \n        return !removeAfter(previousPeriodHolder);\n      }\n    }\n\n      \n      \n    periodHolder.info =\n        newPeriodInfo.copyWithRequestedContentPositionUs(\n            oldPeriodInfo.requestedContentPositionUs);\n\n    if (!areDurationsCompatible(oldPeriodInfo.durationUs, newPeriodInfo.durationUs)) {\n        \n        \n      periodHolder.updateClipping();\n      long newDurationInRendererTime =\n          newPeriodInfo.durationUs == C.TIME_UNSET\n              ? Long.MAX_VALUE\n              : periodHolder.toRendererTime(newPeriodInfo.durationUs);\n      boolean isReadingAndReadBeyondNewDuration =\n          periodHolder == reading\n              && !periodHolder.info.isFollowedByTransitionToSameStream\n              && (maxRendererReadPositionUs == C.TIME_END_OF_SOURCE\n                  || maxRendererReadPositionUs >= newDurationInRendererTime);\n      boolean readingPeriodRemoved = removeAfter(periodHolder);\n      return !readingPeriodRemoved && !isReadingAndReadBeyondNewDuration;\n    }\n\n    previousPeriodHolder = periodHolder;\n    periodHolder = periodHolder.getNext();\n  }\n  return true;\n}",
        "summary_tokens": [
            "updates",
            "media",
            "periods",
            "in",
            "the",
            "queue",
            "to",
            "take",
            "into",
            "account",
            "the",
            "latest",
            "timeline",
            "and",
            "returns",
            "whether",
            "the",
            "timeline",
            "change",
            "has",
            "been",
            "fully",
            "handled"
        ]
    },
    {
        "id": 741,
        "code": "public MediaPeriodInfo getUpdatedMediaPeriodInfo(Timeline timeline, MediaPeriodInfo info) {\n  MediaPeriodId id = info.id;\n  boolean isLastInPeriod = isLastInPeriod(id);\n  boolean isLastInWindow = isLastInWindow(timeline, id);\n  boolean isLastInTimeline = isLastInTimeline(timeline, id, isLastInPeriod);\n  timeline.getPeriodByUid(info.id.periodUid, period);\n  long endPositionUs =\n      id.isAd() || id.nextAdGroupIndex == C.INDEX_UNSET\n          ? C.TIME_UNSET\n          : period.getAdGroupTimeUs(id.nextAdGroupIndex);\n  long durationUs =\n      id.isAd()\n          ? period.getAdDurationUs(id.adGroupIndex, id.adIndexInAdGroup)\n          : (endPositionUs == C.TIME_UNSET || endPositionUs == C.TIME_END_OF_SOURCE\n              ? period.getDurationUs()\n              : endPositionUs);\n  boolean isFollowedByTransitionToSameStream =\n      id.isAd()\n          ? period.isServerSideInsertedAdGroup(id.adGroupIndex)\n          : (id.nextAdGroupIndex != C.INDEX_UNSET\n              && period.isServerSideInsertedAdGroup(id.nextAdGroupIndex));\n  return new MediaPeriodInfo(\n      id,\n      info.startPositionUs,\n      info.requestedContentPositionUs,\n      endPositionUs,\n      durationUs,\n      isFollowedByTransitionToSameStream,\n      isLastInPeriod,\n      isLastInWindow,\n      isLastInTimeline);\n}",
        "summary_tokens": [
            "returns",
            "new",
            "media",
            "period",
            "info",
            "based",
            "on",
            "specified",
            "media",
            "period",
            "info",
            "but",
            "taking",
            "into",
            "account",
            "the",
            "current",
            "timeline"
        ]
    },
    {
        "id": 742,
        "code": "private static MediaPeriodId resolveMediaPeriodIdForAds(\n    Timeline timeline,\n    Object periodUid,\n    long positionUs,\n    long windowSequenceNumber,\n    Timeline.Window window,\n    Timeline.Period period) {\n  timeline.getPeriodByUid(periodUid, period);\n  timeline.getWindow(period.windowIndex, window);\n  int periodIndex = timeline.getIndexOfPeriod(periodUid);\n    \n  while ((period.durationUs == 0\n          && period.getAdGroupCount() > 0\n          && period.isServerSideInsertedAdGroup(period.getRemovedAdGroupCount())\n          && period.getAdGroupIndexForPositionUs(0) == C.INDEX_UNSET)\n      && periodIndex++ < window.lastPeriodIndex) {\n    timeline.getPeriod(periodIndex, period,  true);\n    periodUid = checkNotNull(period.uid);\n  }\n  timeline.getPeriodByUid(periodUid, period);\n  int adGroupIndex = period.getAdGroupIndexForPositionUs(positionUs);\n  if (adGroupIndex == C.INDEX_UNSET) {\n    int nextAdGroupIndex = period.getAdGroupIndexAfterPositionUs(positionUs);\n    return new MediaPeriodId(periodUid, windowSequenceNumber, nextAdGroupIndex);\n  } else {\n    int adIndexInAdGroup = period.getFirstAdIndexToPlay(adGroupIndex);\n    return new MediaPeriodId(periodUid, adGroupIndex, adIndexInAdGroup, windowSequenceNumber);\n  }\n}",
        "summary_tokens": [
            "resolves",
            "the",
            "specified",
            "timeline",
            "period",
            "and",
            "position",
            "to",
            "a",
            "media",
            "period",
            "id",
            "that",
            "should",
            "be",
            "played",
            "returning",
            "an",
            "identifier",
            "for",
            "an",
            "ad",
            "group",
            "if",
            "one",
            "needs",
            "to",
            "be",
            "played",
            "before",
            "the",
            "specified",
            "position",
            "or",
            "an",
            "identifier",
            "for",
            "a",
            "content",
            "media",
            "period",
            "if",
            "not"
        ]
    },
    {
        "id": 743,
        "code": "public MediaPeriodId resolveMediaPeriodIdForAdsAfterPeriodPositionChange(\n    Timeline timeline, Object periodUid, long positionUs) {\n  long windowSequenceNumber = resolvePeriodIndexToWindowSequenceNumber(timeline, periodUid);\n    \n  timeline.getPeriodByUid(periodUid, period);\n  timeline.getWindow(period.windowIndex, window);\n  Object periodUidToPlay = periodUid;\n  boolean seenAdPeriod = false;\n  for (int i = timeline.getIndexOfPeriod(periodUid); i >= window.firstPeriodIndex; i--) {\n    timeline.getPeriod( i, period,  true);\n    boolean isAdPeriod = period.getAdGroupCount() > 0;\n    seenAdPeriod |= isAdPeriod;\n    if (period.getAdGroupIndexForPositionUs(period.durationUs) != C.INDEX_UNSET) {\n        \n      periodUidToPlay = checkNotNull(period.uid);\n    }\n    if (seenAdPeriod && (!isAdPeriod || period.durationUs != 0)) {\n        \n      break;\n    }\n  }\n  return resolveMediaPeriodIdForAds(\n      timeline, periodUidToPlay, positionUs, windowSequenceNumber, window, period);\n}",
        "summary_tokens": [
            "resolves",
            "the",
            "specified",
            "timeline",
            "period",
            "and",
            "position",
            "to",
            "a",
            "media",
            "period",
            "id",
            "that",
            "should",
            "be",
            "played",
            "after",
            "a",
            "period",
            "position",
            "change",
            "returning",
            "an",
            "identifier",
            "for",
            "an",
            "ad",
            "group",
            "if",
            "one",
            "needs",
            "to",
            "be",
            "played",
            "before",
            "the",
            "specified",
            "position",
            "or",
            "an",
            "identifier",
            "for",
            "a",
            "content",
            "media",
            "period",
            "if",
            "not"
        ]
    },
    {
        "id": 744,
        "code": "private long resolvePeriodIndexToWindowSequenceNumber(Timeline timeline, Object periodUid) {\n  int windowIndex = timeline.getPeriodByUid(periodUid, period).windowIndex;\n  if (oldFrontPeriodUid != null) {\n    int oldFrontPeriodIndex = timeline.getIndexOfPeriod(oldFrontPeriodUid);\n    if (oldFrontPeriodIndex != C.INDEX_UNSET) {\n      int oldFrontWindowIndex = timeline.getPeriod(oldFrontPeriodIndex, period).windowIndex;\n      if (oldFrontWindowIndex == windowIndex) {\n          \n        return oldFrontPeriodWindowSequenceNumber;\n      }\n    }\n  }\n  MediaPeriodHolder mediaPeriodHolder = playing;\n  while (mediaPeriodHolder != null) {\n    if (mediaPeriodHolder.uid.equals(periodUid)) {\n        \n      return mediaPeriodHolder.info.id.windowSequenceNumber;\n    }\n    mediaPeriodHolder = mediaPeriodHolder.getNext();\n  }\n  mediaPeriodHolder = playing;\n  while (mediaPeriodHolder != null) {\n    int indexOfHolderInTimeline = timeline.getIndexOfPeriod(mediaPeriodHolder.uid);\n    if (indexOfHolderInTimeline != C.INDEX_UNSET) {\n      int holderWindowIndex = timeline.getPeriod(indexOfHolderInTimeline, period).windowIndex;\n      if (holderWindowIndex == windowIndex) {\n          \n        return mediaPeriodHolder.info.id.windowSequenceNumber;\n      }\n    }\n    mediaPeriodHolder = mediaPeriodHolder.getNext();\n  }\n    \n  long windowSequenceNumber = nextWindowSequenceNumber++;\n  if (playing == null) {\n      \n    oldFrontPeriodUid = periodUid;\n    oldFrontPeriodWindowSequenceNumber = windowSequenceNumber;\n  }\n  return windowSequenceNumber;\n}",
        "summary_tokens": [
            "resolves",
            "the",
            "specified",
            "period",
            "uid",
            "to",
            "a",
            "corresponding",
            "window",
            "sequence",
            "number"
        ]
    },
    {
        "id": 745,
        "code": "private boolean canKeepMediaPeriodHolder(MediaPeriodInfo oldInfo, MediaPeriodInfo newInfo) {\n  return oldInfo.startPositionUs == newInfo.startPositionUs && oldInfo.id.equals(newInfo.id);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "a",
            "period",
            "described",
            "by",
            "old",
            "info",
            "can",
            "be",
            "kept",
            "for",
            "playing",
            "the",
            "media",
            "period",
            "described",
            "by",
            "new",
            "info"
        ]
    },
    {
        "id": 746,
        "code": "private boolean areDurationsCompatible(long previousDurationUs, long newDurationUs) {\n  return previousDurationUs == C.TIME_UNSET || previousDurationUs == newDurationUs;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "a",
            "duration",
            "change",
            "of",
            "a",
            "period",
            "is",
            "compatible",
            "with",
            "keeping",
            "the",
            "following",
            "periods"
        ]
    },
    {
        "id": 747,
        "code": "private boolean updateForPlaybackModeChange(Timeline timeline) {\n    \n  MediaPeriodHolder lastValidPeriodHolder = playing;\n  if (lastValidPeriodHolder == null) {\n    return true;\n  }\n  int currentPeriodIndex = timeline.getIndexOfPeriod(lastValidPeriodHolder.uid);\n  while (true) {\n    int nextPeriodIndex =\n        timeline.getNextPeriodIndex(\n            currentPeriodIndex, period, window, repeatMode, shuffleModeEnabled);\n    while (lastValidPeriodHolder.getNext() != null\n        && !lastValidPeriodHolder.info.isLastInTimelinePeriod) {\n      lastValidPeriodHolder = lastValidPeriodHolder.getNext();\n    }\n\n    MediaPeriodHolder nextMediaPeriodHolder = lastValidPeriodHolder.getNext();\n    if (nextPeriodIndex == C.INDEX_UNSET || nextMediaPeriodHolder == null) {\n      break;\n    }\n    int nextPeriodHolderPeriodIndex = timeline.getIndexOfPeriod(nextMediaPeriodHolder.uid);\n    if (nextPeriodHolderPeriodIndex != nextPeriodIndex) {\n      break;\n    }\n    lastValidPeriodHolder = nextMediaPeriodHolder;\n    currentPeriodIndex = nextPeriodIndex;\n  }\n\n    \n  boolean readingPeriodRemoved = removeAfter(lastValidPeriodHolder);\n\n    \n  lastValidPeriodHolder.info = getUpdatedMediaPeriodInfo(timeline, lastValidPeriodHolder.info);\n\n    \n  return !readingPeriodRemoved;\n}",
        "summary_tokens": [
            "updates",
            "the",
            "queue",
            "for",
            "any",
            "playback",
            "mode",
            "change",
            "and",
            "returns",
            "whether",
            "the",
            "change",
            "was",
            "fully",
            "handled"
        ]
    },
    {
        "id": 748,
        "code": "private MediaPeriodInfo getFirstMediaPeriodInfo(PlaybackInfo playbackInfo) {\n  return getMediaPeriodInfo(\n      playbackInfo.timeline,\n      playbackInfo.periodId,\n      playbackInfo.requestedContentPositionUs,\n      playbackInfo.positionUs);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "first",
            "media",
            "period",
            "info",
            "to",
            "play",
            "based",
            "on",
            "the",
            "specified",
            "playback",
            "position"
        ]
    },
    {
        "id": 749,
        "code": "private MediaPeriodInfo getFollowingMediaPeriodInfo(\n    Timeline timeline, MediaPeriodHolder mediaPeriodHolder, long rendererPositionUs) {\n    \n    \n    \n    \n  MediaPeriodInfo mediaPeriodInfo = mediaPeriodHolder.info;\n    \n    \n    \n  long bufferedDurationUs =\n      mediaPeriodHolder.getRendererOffset() + mediaPeriodInfo.durationUs - rendererPositionUs;\n  if (mediaPeriodInfo.isLastInTimelinePeriod) {\n    int currentPeriodIndex = timeline.getIndexOfPeriod(mediaPeriodInfo.id.periodUid);\n    int nextPeriodIndex =\n        timeline.getNextPeriodIndex(\n            currentPeriodIndex, period, window, repeatMode, shuffleModeEnabled);\n    if (nextPeriodIndex == C.INDEX_UNSET) {\n        \n      return null;\n    }\n      \n    long startPositionUs = 0;\n    long contentPositionUs = 0;\n    int nextWindowIndex =\n        timeline.getPeriod(nextPeriodIndex, period,  true).windowIndex;\n    Object nextPeriodUid = checkNotNull(period.uid);\n    long windowSequenceNumber = mediaPeriodInfo.id.windowSequenceNumber;\n    if (timeline.getWindow(nextWindowIndex, window).firstPeriodIndex == nextPeriodIndex) {\n        \n        \n        \n      contentPositionUs = C.TIME_UNSET;\n      @Nullable\n      Pair<Object, Long> defaultPositionUs =\n          timeline.getPeriodPositionUs(\n              window,\n              period,\n              nextWindowIndex,\n               C.TIME_UNSET,\n               max(0, bufferedDurationUs));\n      if (defaultPositionUs == null) {\n        return null;\n      }\n      nextPeriodUid = defaultPositionUs.first;\n      startPositionUs = defaultPositionUs.second;\n      @Nullable MediaPeriodHolder nextMediaPeriodHolder = mediaPeriodHolder.getNext();\n      if (nextMediaPeriodHolder != null && nextMediaPeriodHolder.uid.equals(nextPeriodUid)) {\n        windowSequenceNumber = nextMediaPeriodHolder.info.id.windowSequenceNumber;\n      } else {\n        windowSequenceNumber = nextWindowSequenceNumber++;\n      }\n    }\n\n    @Nullable\n    MediaPeriodId periodId =\n        resolveMediaPeriodIdForAds(\n            timeline, nextPeriodUid, startPositionUs, windowSequenceNumber, window, period);\n    if (contentPositionUs != C.TIME_UNSET\n        && mediaPeriodInfo.requestedContentPositionUs != C.TIME_UNSET) {\n      boolean isPrecedingPeriodAnAd =\n          timeline.getPeriodByUid(mediaPeriodInfo.id.periodUid, period).getAdGroupCount() > 0\n              && period.isServerSideInsertedAdGroup(period.getRemovedAdGroupCount());\n        \n      if (periodId.isAd() && isPrecedingPeriodAnAd) {\n          \n        contentPositionUs = mediaPeriodInfo.requestedContentPositionUs;\n      } else if (isPrecedingPeriodAnAd) {\n          \n        startPositionUs = mediaPeriodInfo.requestedContentPositionUs;\n      }\n    }\n    return getMediaPeriodInfo(timeline, periodId, contentPositionUs, startPositionUs);\n  }\n\n  MediaPeriodId currentPeriodId = mediaPeriodInfo.id;\n  timeline.getPeriodByUid(currentPeriodId.periodUid, period);\n  if (currentPeriodId.isAd()) {\n    int adGroupIndex = currentPeriodId.adGroupIndex;\n    int adCountInCurrentAdGroup = period.getAdCountInAdGroup(adGroupIndex);\n    if (adCountInCurrentAdGroup == C.LENGTH_UNSET) {\n      return null;\n    }\n    int nextAdIndexInAdGroup =\n        period.getNextAdIndexToPlay(adGroupIndex, currentPeriodId.adIndexInAdGroup);\n    if (nextAdIndexInAdGroup < adCountInCurrentAdGroup) {\n        \n      return getMediaPeriodInfoForAd(\n          timeline,\n          currentPeriodId.periodUid,\n          adGroupIndex,\n          nextAdIndexInAdGroup,\n          mediaPeriodInfo.requestedContentPositionUs,\n          currentPeriodId.windowSequenceNumber);\n    } else {\n        \n      long startPositionUs = mediaPeriodInfo.requestedContentPositionUs;\n      if (startPositionUs == C.TIME_UNSET) {\n          \n          \n        @Nullable\n        Pair<Object, Long> defaultPositionUs =\n            timeline.getPeriodPositionUs(\n                window,\n                period,\n                period.windowIndex,\n                 C.TIME_UNSET,\n                 max(0, bufferedDurationUs));\n        if (defaultPositionUs == null) {\n          return null;\n        }\n        startPositionUs = defaultPositionUs.second;\n      }\n      long minStartPositionUs =\n          getMinStartPositionAfterAdGroupUs(\n              timeline, currentPeriodId.periodUid, currentPeriodId.adGroupIndex);\n      return getMediaPeriodInfoForContent(\n          timeline,\n          currentPeriodId.periodUid,\n          max(minStartPositionUs, startPositionUs),\n          mediaPeriodInfo.requestedContentPositionUs,\n          currentPeriodId.windowSequenceNumber);\n    }\n  } else {\n      \n    int adIndexInAdGroup = period.getFirstAdIndexToPlay(currentPeriodId.nextAdGroupIndex);\n    boolean isPlayedServerSideInsertedAd =\n        period.isServerSideInsertedAdGroup(currentPeriodId.nextAdGroupIndex)\n            && period.getAdState(currentPeriodId.nextAdGroupIndex, adIndexInAdGroup)\n                == AdPlaybackState.AD_STATE_PLAYED;\n    if (adIndexInAdGroup == period.getAdCountInAdGroup(currentPeriodId.nextAdGroupIndex)\n        || isPlayedServerSideInsertedAd) {\n        \n        \n      long startPositionUs =\n          getMinStartPositionAfterAdGroupUs(\n              timeline, currentPeriodId.periodUid, currentPeriodId.nextAdGroupIndex);\n      return getMediaPeriodInfoForContent(\n          timeline,\n          currentPeriodId.periodUid,\n          startPositionUs,\n           mediaPeriodInfo.durationUs,\n          currentPeriodId.windowSequenceNumber);\n    }\n    return getMediaPeriodInfoForAd(\n        timeline,\n        currentPeriodId.periodUid,\n        currentPeriodId.nextAdGroupIndex,\n        adIndexInAdGroup,\n         mediaPeriodInfo.durationUs,\n        currentPeriodId.windowSequenceNumber);\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "media",
            "period",
            "info",
            "for",
            "the",
            "media",
            "period",
            "following",
            "media",
            "period",
            "holder",
            "s",
            "media",
            "period"
        ]
    },
    {
        "id": 750,
        "code": "public Timeline setMediaSources(List<MediaSourceHolder> holders, ShuffleOrder shuffleOrder) {\n  removeMediaSourcesInternal( 0,  mediaSourceHolders.size());\n  return addMediaSources( this.mediaSourceHolders.size(), holders, shuffleOrder);\n}",
        "summary_tokens": [
            "sets",
            "the",
            "media",
            "sources",
            "replacing",
            "any",
            "sources",
            "previously",
            "contained",
            "in",
            "the",
            "playlist"
        ]
    },
    {
        "id": 751,
        "code": "public Timeline addMediaSources(\n    int index, List<MediaSourceHolder> holders, ShuffleOrder shuffleOrder) {\n  if (!holders.isEmpty()) {\n    this.shuffleOrder = shuffleOrder;\n    for (int insertionIndex = index; insertionIndex < index + holders.size(); insertionIndex++) {\n      MediaSourceHolder holder = holders.get(insertionIndex - index);\n      if (insertionIndex > 0) {\n        MediaSourceHolder previousHolder = mediaSourceHolders.get(insertionIndex - 1);\n        Timeline previousTimeline = previousHolder.mediaSource.getTimeline();\n        holder.reset(\n             previousHolder.firstWindowIndexInChild\n                + previousTimeline.getWindowCount());\n      } else {\n        holder.reset( 0);\n      }\n      Timeline newTimeline = holder.mediaSource.getTimeline();\n      correctOffsets(\n           insertionIndex,\n           newTimeline.getWindowCount());\n      mediaSourceHolders.add(insertionIndex, holder);\n      mediaSourceByUid.put(holder.uid, holder);\n      if (isPrepared) {\n        prepareChildSource(holder);\n        if (mediaSourceByMediaPeriod.isEmpty()) {\n          enabledMediaSourceHolders.add(holder);\n        } else {\n          disableChildSource(holder);\n        }\n      }\n    }\n  }\n  return createTimeline();\n}",
        "summary_tokens": [
            "adds",
            "multiple",
            "media",
            "source",
            "holder",
            "s",
            "to",
            "the",
            "playlist"
        ]
    },
    {
        "id": 752,
        "code": "public Timeline removeMediaSourceRange(int fromIndex, int toIndex, ShuffleOrder shuffleOrder) {\n  Assertions.checkArgument(fromIndex >= 0 && fromIndex <= toIndex && toIndex <= getSize());\n  this.shuffleOrder = shuffleOrder;\n  removeMediaSourcesInternal(fromIndex, toIndex);\n  return createTimeline();\n}",
        "summary_tokens": [
            "removes",
            "a",
            "range",
            "of",
            "media",
            "source",
            "holder",
            "s",
            "from",
            "the",
            "playlist",
            "by",
            "specifying",
            "an",
            "initial",
            "index",
            "included",
            "and",
            "a",
            "final",
            "index",
            "excluded"
        ]
    },
    {
        "id": 753,
        "code": "public Timeline moveMediaSource(int currentIndex, int newIndex, ShuffleOrder shuffleOrder) {\n  return moveMediaSourceRange(currentIndex, currentIndex + 1, newIndex, shuffleOrder);\n}",
        "summary_tokens": [
            "moves",
            "an",
            "existing",
            "media",
            "source",
            "within",
            "the",
            "playlist"
        ]
    },
    {
        "id": 754,
        "code": "public Timeline moveMediaSourceRange(\n    int fromIndex, int toIndex, int newFromIndex, ShuffleOrder shuffleOrder) {\n  Assertions.checkArgument(\n      fromIndex >= 0 && fromIndex <= toIndex && toIndex <= getSize() && newFromIndex >= 0);\n  this.shuffleOrder = shuffleOrder;\n  if (fromIndex == toIndex || fromIndex == newFromIndex) {\n    return createTimeline();\n  }\n  int startIndex = min(fromIndex, newFromIndex);\n  int newEndIndex = newFromIndex + (toIndex - fromIndex) - 1;\n  int endIndex = max(newEndIndex, toIndex - 1);\n  int windowOffset = mediaSourceHolders.get(startIndex).firstWindowIndexInChild;\n  Util.moveItems(mediaSourceHolders, fromIndex, toIndex, newFromIndex);\n  for (int i = startIndex; i <= endIndex; i++) {\n    MediaSourceHolder holder = mediaSourceHolders.get(i);\n    holder.firstWindowIndexInChild = windowOffset;\n    windowOffset += holder.mediaSource.getTimeline().getWindowCount();\n  }\n  return createTimeline();\n}",
        "summary_tokens": [
            "moves",
            "a",
            "range",
            "of",
            "media",
            "sources",
            "within",
            "the",
            "playlist"
        ]
    },
    {
        "id": 755,
        "code": "public boolean isPrepared() {\n  return isPrepared;\n}",
        "summary_tokens": [
            "whether",
            "the",
            "playlist",
            "is",
            "prepared"
        ]
    },
    {
        "id": 756,
        "code": "public int getSize() {\n  return mediaSourceHolders.size();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "media",
            "sources",
            "in",
            "the",
            "playlist"
        ]
    },
    {
        "id": 757,
        "code": "public Timeline setShuffleOrder(ShuffleOrder shuffleOrder) {\n  int size = getSize();\n  if (shuffleOrder.getLength() != size) {\n    shuffleOrder =\n        shuffleOrder\n            .cloneAndClear()\n            .cloneAndInsert( 0,  size);\n  }\n  this.shuffleOrder = shuffleOrder;\n  return createTimeline();\n}",
        "summary_tokens": [
            "sets",
            "a",
            "new",
            "shuffle",
            "order",
            "to",
            "use",
            "when",
            "shuffling",
            "the",
            "child",
            "media",
            "sources"
        ]
    },
    {
        "id": 758,
        "code": "public MediaPeriod createPeriod(\n    MediaSource.MediaPeriodId id, Allocator allocator, long startPositionUs) {\n  Object mediaSourceHolderUid = getMediaSourceHolderUid(id.periodUid);\n  MediaSource.MediaPeriodId childMediaPeriodId =\n      id.copyWithPeriodUid(getChildPeriodUid(id.periodUid));\n  MediaSourceHolder holder = Assertions.checkNotNull(mediaSourceByUid.get(mediaSourceHolderUid));\n  enableMediaSource(holder);\n  holder.activeMediaPeriodIds.add(childMediaPeriodId);\n  MediaPeriod mediaPeriod =\n      holder.mediaSource.createPeriod(childMediaPeriodId, allocator, startPositionUs);\n  mediaSourceByMediaPeriod.put(mediaPeriod, holder);\n  disableUnusedMediaSources();\n  return mediaPeriod;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "media",
            "period",
            "identified",
            "by",
            "period",
            "id"
        ]
    },
    {
        "id": 759,
        "code": "public Timeline createTimeline() {\n  if (mediaSourceHolders.isEmpty()) {\n    return Timeline.EMPTY;\n  }\n  int windowOffset = 0;\n  for (int i = 0; i < mediaSourceHolders.size(); i++) {\n    MediaSourceHolder mediaSourceHolder = mediaSourceHolders.get(i);\n    mediaSourceHolder.firstWindowIndexInChild = windowOffset;\n    windowOffset += mediaSourceHolder.mediaSource.getTimeline().getWindowCount();\n  }\n  return new PlaylistTimeline(mediaSourceHolders, shuffleOrder);\n}",
        "summary_tokens": [
            "creates",
            "a",
            "timeline",
            "reflecting",
            "the",
            "current",
            "state",
            "of",
            "the",
            "playlist"
        ]
    },
    {
        "id": 760,
        "code": "private static Object getMediaSourceHolderUid(Object periodUid) {\n  return PlaylistTimeline.getChildTimelineUidFromConcatenatedUid(periodUid);\n}",
        "summary_tokens": [
            "return",
            "uid",
            "of",
            "media",
            "source",
            "holder",
            "from",
            "period",
            "uid",
            "of",
            "concatenated",
            "source"
        ]
    },
    {
        "id": 761,
        "code": "private static Object getChildPeriodUid(Object periodUid) {\n  return PlaylistTimeline.getChildPeriodUidFromConcatenatedUid(periodUid);\n}",
        "summary_tokens": [
            "return",
            "uid",
            "of",
            "child",
            "period",
            "from",
            "period",
            "uid",
            "of",
            "concatenated",
            "source"
        ]
    },
    {
        "id": 762,
        "code": "public static ListenableFuture<TrackGroupArray> retrieveMetadata(\n    MediaSource.Factory mediaSourceFactory, MediaItem mediaItem) {\n  return retrieveMetadata(mediaSourceFactory, mediaItem, Clock.DEFAULT);\n}",
        "summary_tokens": [
            "retrieves",
            "the",
            "track",
            "group",
            "array",
            "corresponding",
            "to",
            "a",
            "media",
            "item"
        ]
    },
    {
        "id": 763,
        "code": "protected void onEnabled(boolean joining) throws ExoPlaybackException {\n    \n}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "renderer",
            "is",
            "enabled"
        ]
    },
    {
        "id": 764,
        "code": "protected void onRendererOffsetChanged(long offsetUs) throws ExoPlaybackException {\n    \n}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "renderer",
            "s",
            "offset",
            "has",
            "been",
            "changed"
        ]
    },
    {
        "id": 765,
        "code": "protected void onPositionReset(long positionUs, boolean joining) throws ExoPlaybackException {\n    \n}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "position",
            "is",
            "reset"
        ]
    },
    {
        "id": 766,
        "code": "protected void onStarted() throws ExoPlaybackException {\n    \n}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "renderer",
            "is",
            "started"
        ]
    },
    {
        "id": 767,
        "code": "protected void onStopped() {\n    \n}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "renderer",
            "is",
            "stopped"
        ]
    },
    {
        "id": 768,
        "code": "protected void onDisabled() {\n    \n}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "renderer",
            "is",
            "disabled"
        ]
    },
    {
        "id": 769,
        "code": "protected void onReset() {\n    \n}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "renderer",
            "is",
            "reset"
        ]
    },
    {
        "id": 770,
        "code": "protected final RendererConfiguration getConfiguration() {\n  return configuration;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "configuration",
            "set",
            "when",
            "the",
            "renderer",
            "was",
            "most",
            "recently",
            "enabled",
            "or",
            "null",
            "if",
            "the",
            "renderer",
            "has",
            "never",
            "been",
            "enabled"
        ]
    },
    {
        "id": 771,
        "code": "protected final int getIndex() {\n  return index;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "index",
            "of",
            "the",
            "renderer",
            "within",
            "the",
            "player"
        ]
    },
    {
        "id": 772,
        "code": "public static PlaybackInfo createDummy(TrackSelectorResult emptyTrackSelectorResult) {\n  return new PlaybackInfo(\n      Timeline.EMPTY,\n      PLACEHOLDER_MEDIA_PERIOD_ID,\n       C.TIME_UNSET,\n       0,\n      Player.STATE_IDLE,\n       null,\n       false,\n      TrackGroupArray.EMPTY,\n      emptyTrackSelectorResult,\n       ImmutableList.of(),\n      PLACEHOLDER_MEDIA_PERIOD_ID,\n       false,\n      Player.PLAYBACK_SUPPRESSION_REASON_NONE,\n      PlaybackParameters.DEFAULT,\n       0,\n       0,\n       0,\n       false);\n}",
        "summary_tokens": [
            "creates",
            "an",
            "empty",
            "placeholder",
            "playback",
            "info",
            "which",
            "can",
            "be",
            "used",
            "for",
            "masking",
            "as",
            "long",
            "as",
            "no",
            "real",
            "playback",
            "info",
            "is",
            "available"
        ]
    },
    {
        "id": 773,
        "code": "public static MediaPeriodId getDummyPeriodForEmptyTimeline() {\n  return PLACEHOLDER_MEDIA_PERIOD_ID;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "placeholder",
            "period",
            "id",
            "for",
            "an",
            "empty",
            "timeline"
        ]
    },
    {
        "id": 774,
        "code": "public PlaybackInfo copyWithNewPosition(\n    MediaPeriodId periodId,\n    long positionUs,\n    long requestedContentPositionUs,\n    long discontinuityStartPositionUs,\n    long totalBufferedDurationUs,\n    TrackGroupArray trackGroups,\n    TrackSelectorResult trackSelectorResult,\n    List<Metadata> staticMetadata) {\n  return new PlaybackInfo(\n      timeline,\n      periodId,\n      requestedContentPositionUs,\n      discontinuityStartPositionUs,\n      playbackState,\n      playbackError,\n      isLoading,\n      trackGroups,\n      trackSelectorResult,\n      staticMetadata,\n      loadingMediaPeriodId,\n      playWhenReady,\n      playbackSuppressionReason,\n      playbackParameters,\n      bufferedPositionUs,\n      totalBufferedDurationUs,\n      positionUs,\n      sleepingForOffload);\n}",
        "summary_tokens": [
            "copies",
            "playback",
            "info",
            "with",
            "new",
            "playing",
            "position"
        ]
    },
    {
        "id": 775,
        "code": "public PlaybackInfo copyWithTimeline(Timeline timeline) {\n  return new PlaybackInfo(\n      timeline,\n      periodId,\n      requestedContentPositionUs,\n      discontinuityStartPositionUs,\n      playbackState,\n      playbackError,\n      isLoading,\n      trackGroups,\n      trackSelectorResult,\n      staticMetadata,\n      loadingMediaPeriodId,\n      playWhenReady,\n      playbackSuppressionReason,\n      playbackParameters,\n      bufferedPositionUs,\n      totalBufferedDurationUs,\n      positionUs,\n      sleepingForOffload);\n}",
        "summary_tokens": [
            "copies",
            "playback",
            "info",
            "with",
            "the",
            "new",
            "timeline"
        ]
    },
    {
        "id": 776,
        "code": "public PlaybackInfo copyWithPlaybackState(int playbackState) {\n  return new PlaybackInfo(\n      timeline,\n      periodId,\n      requestedContentPositionUs,\n      discontinuityStartPositionUs,\n      playbackState,\n      playbackError,\n      isLoading,\n      trackGroups,\n      trackSelectorResult,\n      staticMetadata,\n      loadingMediaPeriodId,\n      playWhenReady,\n      playbackSuppressionReason,\n      playbackParameters,\n      bufferedPositionUs,\n      totalBufferedDurationUs,\n      positionUs,\n      sleepingForOffload);\n}",
        "summary_tokens": [
            "copies",
            "playback",
            "info",
            "with",
            "new",
            "playback",
            "state"
        ]
    },
    {
        "id": 777,
        "code": "public PlaybackInfo copyWithPlaybackError(@Nullable ExoPlaybackException playbackError) {\n  return new PlaybackInfo(\n      timeline,\n      periodId,\n      requestedContentPositionUs,\n      discontinuityStartPositionUs,\n      playbackState,\n      playbackError,\n      isLoading,\n      trackGroups,\n      trackSelectorResult,\n      staticMetadata,\n      loadingMediaPeriodId,\n      playWhenReady,\n      playbackSuppressionReason,\n      playbackParameters,\n      bufferedPositionUs,\n      totalBufferedDurationUs,\n      positionUs,\n      sleepingForOffload);\n}",
        "summary_tokens": [
            "copies",
            "playback",
            "info",
            "with",
            "a",
            "playback",
            "error"
        ]
    },
    {
        "id": 778,
        "code": "public PlaybackInfo copyWithIsLoading(boolean isLoading) {\n  return new PlaybackInfo(\n      timeline,\n      periodId,\n      requestedContentPositionUs,\n      discontinuityStartPositionUs,\n      playbackState,\n      playbackError,\n      isLoading,\n      trackGroups,\n      trackSelectorResult,\n      staticMetadata,\n      loadingMediaPeriodId,\n      playWhenReady,\n      playbackSuppressionReason,\n      playbackParameters,\n      bufferedPositionUs,\n      totalBufferedDurationUs,\n      positionUs,\n      sleepingForOffload);\n}",
        "summary_tokens": [
            "copies",
            "playback",
            "info",
            "with",
            "new",
            "loading",
            "state"
        ]
    },
    {
        "id": 779,
        "code": "public PlaybackInfo copyWithLoadingMediaPeriodId(MediaPeriodId loadingMediaPeriodId) {\n  return new PlaybackInfo(\n      timeline,\n      periodId,\n      requestedContentPositionUs,\n      discontinuityStartPositionUs,\n      playbackState,\n      playbackError,\n      isLoading,\n      trackGroups,\n      trackSelectorResult,\n      staticMetadata,\n      loadingMediaPeriodId,\n      playWhenReady,\n      playbackSuppressionReason,\n      playbackParameters,\n      bufferedPositionUs,\n      totalBufferedDurationUs,\n      positionUs,\n      sleepingForOffload);\n}",
        "summary_tokens": [
            "copies",
            "playback",
            "info",
            "with",
            "new",
            "loading",
            "media",
            "period"
        ]
    },
    {
        "id": 780,
        "code": "public PlaybackInfo copyWithPlayWhenReady(\n    boolean playWhenReady, @PlaybackSuppressionReason int playbackSuppressionReason) {\n  return new PlaybackInfo(\n      timeline,\n      periodId,\n      requestedContentPositionUs,\n      discontinuityStartPositionUs,\n      playbackState,\n      playbackError,\n      isLoading,\n      trackGroups,\n      trackSelectorResult,\n      staticMetadata,\n      loadingMediaPeriodId,\n      playWhenReady,\n      playbackSuppressionReason,\n      playbackParameters,\n      bufferedPositionUs,\n      totalBufferedDurationUs,\n      positionUs,\n      sleepingForOffload);\n}",
        "summary_tokens": [
            "copies",
            "playback",
            "info",
            "with",
            "new",
            "information",
            "about",
            "whether",
            "playback",
            "should",
            "proceed",
            "when",
            "ready"
        ]
    },
    {
        "id": 781,
        "code": "public PlaybackInfo copyWithPlaybackParameters(PlaybackParameters playbackParameters) {\n  return new PlaybackInfo(\n      timeline,\n      periodId,\n      requestedContentPositionUs,\n      discontinuityStartPositionUs,\n      playbackState,\n      playbackError,\n      isLoading,\n      trackGroups,\n      trackSelectorResult,\n      staticMetadata,\n      loadingMediaPeriodId,\n      playWhenReady,\n      playbackSuppressionReason,\n      playbackParameters,\n      bufferedPositionUs,\n      totalBufferedDurationUs,\n      positionUs,\n      sleepingForOffload);\n}",
        "summary_tokens": [
            "copies",
            "playback",
            "info",
            "with",
            "new",
            "playback",
            "parameters"
        ]
    },
    {
        "id": 782,
        "code": "public PlaybackInfo copyWithSleepingForOffload(boolean sleepingForOffload) {\n  return new PlaybackInfo(\n      timeline,\n      periodId,\n      requestedContentPositionUs,\n      discontinuityStartPositionUs,\n      playbackState,\n      playbackError,\n      isLoading,\n      trackGroups,\n      trackSelectorResult,\n      staticMetadata,\n      loadingMediaPeriodId,\n      playWhenReady,\n      playbackSuppressionReason,\n      playbackParameters,\n      bufferedPositionUs,\n      totalBufferedDurationUs,\n      positionUs,\n      sleepingForOffload);\n}",
        "summary_tokens": [
            "copies",
            "playback",
            "info",
            "with",
            "new",
            "sleeping",
            "for",
            "offload"
        ]
    },
    {
        "id": 783,
        "code": "public Timeline getTimeline() {\n  return timeline;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "timeline",
            "used",
            "for",
            "setting",
            "the",
            "position",
            "with",
            "set",
            "position",
            "long"
        ]
    },
    {
        "id": 784,
        "code": "public Target getTarget() {\n  return target;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "target",
            "the",
            "message",
            "is",
            "sent",
            "to"
        ]
    },
    {
        "id": 785,
        "code": "public PlayerMessage setType(int messageType) {\n  Assertions.checkState(!isSent);\n  this.type = messageType;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "message",
            "type",
            "forwarded",
            "to",
            "target",
            "handle",
            "message",
            "int",
            "object"
        ]
    },
    {
        "id": 786,
        "code": "public int getType() {\n  return type;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "message",
            "type",
            "forwarded",
            "to",
            "target",
            "handle",
            "message",
            "int",
            "object"
        ]
    },
    {
        "id": 787,
        "code": "public PlayerMessage setPayload(@Nullable Object payload) {\n  Assertions.checkState(!isSent);\n  this.payload = payload;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "message",
            "payload",
            "forwarded",
            "to",
            "target",
            "handle",
            "message",
            "int",
            "object"
        ]
    },
    {
        "id": 788,
        "code": "public Object getPayload() {\n  return payload;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "message",
            "payload",
            "forwarded",
            "to",
            "target",
            "handle",
            "message",
            "int",
            "object"
        ]
    },
    {
        "id": 789,
        "code": "public PlayerMessage setHandler(Handler handler) {\n  return setLooper(handler.getLooper());\n}",
        "summary_tokens": [
            "use",
            "set",
            "looper",
            "looper",
            "instead"
        ]
    },
    {
        "id": 790,
        "code": "public PlayerMessage setLooper(Looper looper) {\n  Assertions.checkState(!isSent);\n  this.looper = looper;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "looper",
            "the",
            "message",
            "is",
            "delivered",
            "on"
        ]
    },
    {
        "id": 791,
        "code": "public Looper getLooper() {\n  return looper;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "looper",
            "the",
            "message",
            "is",
            "delivered",
            "on"
        ]
    },
    {
        "id": 792,
        "code": "public long getPositionMs() {\n  return positionMs;\n}",
        "summary_tokens": [
            "returns",
            "position",
            "in",
            "the",
            "media",
            "item",
            "at",
            "get",
            "media",
            "item",
            "index",
            "at",
            "which",
            "the",
            "message",
            "will",
            "be",
            "delivered",
            "in",
            "milliseconds"
        ]
    },
    {
        "id": 793,
        "code": "public PlayerMessage setPosition(int mediaItemIndex, long positionMs) {\n  Assertions.checkState(!isSent);\n  Assertions.checkArgument(positionMs != C.TIME_UNSET);\n  if (mediaItemIndex < 0\n      || (!timeline.isEmpty() && mediaItemIndex >= timeline.getWindowCount())) {\n    throw new IllegalSeekPositionException(timeline, mediaItemIndex, positionMs);\n  }\n  this.mediaItemIndex = mediaItemIndex;\n  this.positionMs = positionMs;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "a",
            "position",
            "in",
            "a",
            "media",
            "item",
            "at",
            "which",
            "the",
            "message",
            "will",
            "be",
            "delivered"
        ]
    },
    {
        "id": 794,
        "code": "public int getMediaItemIndex() {\n  return mediaItemIndex;\n}",
        "summary_tokens": [
            "returns",
            "media",
            "item",
            "index",
            "at",
            "which",
            "the",
            "message",
            "will",
            "be",
            "delivered"
        ]
    },
    {
        "id": 795,
        "code": "public PlayerMessage setDeleteAfterDelivery(boolean deleteAfterDelivery) {\n  Assertions.checkState(!isSent);\n  this.deleteAfterDelivery = deleteAfterDelivery;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "message",
            "will",
            "be",
            "deleted",
            "after",
            "delivery"
        ]
    },
    {
        "id": 796,
        "code": "public boolean getDeleteAfterDelivery() {\n  return deleteAfterDelivery;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "message",
            "will",
            "be",
            "deleted",
            "after",
            "delivery"
        ]
    },
    {
        "id": 797,
        "code": "public synchronized PlayerMessage cancel() {\n  Assertions.checkState(isSent);\n  isCanceled = true;\n  markAsProcessed( false);\n  return this;\n}",
        "summary_tokens": [
            "cancels",
            "the",
            "message",
            "delivery"
        ]
    },
    {
        "id": 798,
        "code": "public synchronized boolean isCanceled() {\n  return isCanceled;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "message",
            "delivery",
            "has",
            "been",
            "canceled"
        ]
    },
    {
        "id": 799,
        "code": "public synchronized void markAsProcessed(boolean isDelivered) {\n  this.isDelivered |= isDelivered;\n  isProcessed = true;\n  notifyAll();\n}",
        "summary_tokens": [
            "marks",
            "the",
            "message",
            "as",
            "processed"
        ]
    },
    {
        "id": 800,
        "code": "public synchronized boolean blockUntilDelivered(long timeoutMs)\n    throws InterruptedException, TimeoutException {\n  Assertions.checkState(isSent);\n  Assertions.checkState(looper.getThread() != Thread.currentThread());\n\n  long deadlineMs = clock.elapsedRealtime() + timeoutMs;\n  long remainingMs = timeoutMs;\n  while (!isProcessed && remainingMs > 0) {\n    clock.onThreadBlocked();\n    wait(remainingMs);\n    remainingMs = deadlineMs - clock.elapsedRealtime();\n  }\n  if (!isProcessed) {\n    throw new TimeoutException(\"Message delivery timed out.\");\n  }\n  return isDelivered;\n}",
        "summary_tokens": [
            "blocks",
            "until",
            "after",
            "the",
            "message",
            "has",
            "been",
            "delivered",
            "or",
            "the",
            "player",
            "is",
            "no",
            "longer",
            "able",
            "to",
            "deliver",
            "the",
            "message",
            "or",
            "the",
            "specified",
            "timeout",
            "elapsed"
        ]
    },
    {
        "id": 801,
        "code": " List<Timeline> getChildTimelines() {\n  return Arrays.asList(timelines);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "child",
            "timelines"
        ]
    },
    {
        "id": 802,
        "code": "default void setPlaybackSpeed(float currentPlaybackSpeed, float targetPlaybackSpeed)",
        "summary_tokens": [
            "indicates",
            "the",
            "playback",
            "speed",
            "to",
            "this",
            "renderer"
        ]
    },
    {
        "id": 803,
        "code": "static @Capabilities int create(\n    @C.FormatSupport int formatSupport,\n    @AdaptiveSupport int adaptiveSupport,\n    @TunnelingSupport int tunnelingSupport,\n    @HardwareAccelerationSupport int hardwareAccelerationSupport,\n    @DecoderSupport int decoderSupport) {\n  return formatSupport\n      | adaptiveSupport\n      | tunnelingSupport\n      | hardwareAccelerationSupport\n      | decoderSupport;\n}",
        "summary_tokens": [
            "returns",
            "capabilities",
            "combining",
            "the",
            "given",
            "c"
        ]
    },
    {
        "id": 804,
        "code": "static @AdaptiveSupport int getAdaptiveSupport(@Capabilities int supportFlags) {\n  return supportFlags & ADAPTIVE_SUPPORT_MASK;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "adaptive",
            "support",
            "from",
            "the",
            "combined",
            "capabilities"
        ]
    },
    {
        "id": 805,
        "code": "static @TunnelingSupport int getTunnelingSupport(@Capabilities int supportFlags) {\n  return supportFlags & TUNNELING_SUPPORT_MASK;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "tunneling",
            "support",
            "from",
            "the",
            "combined",
            "capabilities"
        ]
    },
    {
        "id": 806,
        "code": "static @HardwareAccelerationSupport int getHardwareAccelerationSupport(\n    @Capabilities int supportFlags) {\n  return supportFlags & HARDWARE_ACCELERATION_SUPPORT_MASK;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "hardware",
            "acceleration",
            "support",
            "from",
            "the",
            "combined",
            "capabilities"
        ]
    },
    {
        "id": 807,
        "code": "static @DecoderSupport int getDecoderSupport(@Capabilities int supportFlags) {\n  return supportFlags & MODE_SUPPORT_MASK;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "decoder",
            "support",
            "from",
            "the",
            "combined",
            "capabilities"
        ]
    },
    {
        "id": 808,
        "code": "public long resolveSeekPositionUs(long positionUs, long firstSyncUs, long secondSyncUs) {\n  if (toleranceBeforeUs == 0 && toleranceAfterUs == 0) {\n    return positionUs;\n  }\n  long minPositionUs =\n      Util.subtractWithOverflowDefault(positionUs, toleranceBeforeUs, Long.MIN_VALUE);\n  long maxPositionUs = Util.addWithOverflowDefault(positionUs, toleranceAfterUs, Long.MAX_VALUE);\n  boolean firstSyncPositionValid = minPositionUs <= firstSyncUs && firstSyncUs <= maxPositionUs;\n  boolean secondSyncPositionValid =\n      minPositionUs <= secondSyncUs && secondSyncUs <= maxPositionUs;\n  if (firstSyncPositionValid && secondSyncPositionValid) {\n    if (Math.abs(firstSyncUs - positionUs) <= Math.abs(secondSyncUs - positionUs)) {\n      return firstSyncUs;\n    } else {\n      return secondSyncUs;\n    }\n  } else if (firstSyncPositionValid) {\n    return firstSyncUs;\n  } else if (secondSyncPositionValid) {\n    return secondSyncUs;\n  } else {\n    return minPositionUs;\n  }\n}",
        "summary_tokens": [
            "resolves",
            "a",
            "seek",
            "based",
            "on",
            "the",
            "parameters",
            "given",
            "the",
            "requested",
            "seek",
            "position",
            "and",
            "two",
            "candidate",
            "sync",
            "points"
        ]
    },
    {
        "id": 809,
        "code": "public AudioComponent getAudioComponent() {\n  return this;\n}",
        "summary_tokens": [
            "use",
            "exo",
            "player",
            "as",
            "the",
            "audio",
            "component",
            "methods",
            "are",
            "defined",
            "by",
            "that",
            "interface"
        ]
    },
    {
        "id": 810,
        "code": "public VideoComponent getVideoComponent() {\n  return this;\n}",
        "summary_tokens": [
            "use",
            "exo",
            "player",
            "as",
            "the",
            "video",
            "component",
            "methods",
            "are",
            "defined",
            "by",
            "that",
            "interface"
        ]
    },
    {
        "id": 811,
        "code": "public TextComponent getTextComponent() {\n  return this;\n}",
        "summary_tokens": [
            "use",
            "player",
            "as",
            "the",
            "text",
            "component",
            "methods",
            "are",
            "defined",
            "by",
            "that",
            "interface"
        ]
    },
    {
        "id": 812,
        "code": "public DeviceComponent getDeviceComponent() {\n  return this;\n}",
        "summary_tokens": [
            "use",
            "player",
            "as",
            "the",
            "device",
            "component",
            "methods",
            "are",
            "defined",
            "by",
            "that",
            "interface"
        ]
    },
    {
        "id": 813,
        "code": "public void prepare(MediaSource mediaSource, boolean resetPosition, boolean resetState) {\n  blockUntilConstructorFinished();\n  player.prepare(mediaSource, resetPosition, resetState);\n}",
        "summary_tokens": [
            "use",
            "set",
            "media",
            "source",
            "media",
            "source",
            "boolean",
            "and",
            "exo",
            "player",
            "prepare",
            "instead"
        ]
    },
    {
        "id": 814,
        "code": "public void stop(boolean reset) {\n  blockUntilConstructorFinished();\n  player.stop(reset);\n}",
        "summary_tokens": [
            "use",
            "stop",
            "and",
            "clear",
            "media",
            "items",
            "if",
            "reset",
            "is",
            "true",
            "or",
            "just",
            "stop",
            "if",
            "reset",
            "is",
            "false"
        ]
    },
    {
        "id": 815,
        "code": "public TrackGroupArray getCurrentTrackGroups() {\n  blockUntilConstructorFinished();\n  return player.getCurrentTrackGroups();\n}",
        "summary_tokens": [
            "use",
            "get",
            "current",
            "tracks"
        ]
    },
    {
        "id": 816,
        "code": "public TrackSelectionArray getCurrentTrackSelections() {\n  blockUntilConstructorFinished();\n  return player.getCurrentTrackSelections();\n}",
        "summary_tokens": [
            "use",
            "get",
            "current",
            "tracks"
        ]
    },
    {
        "id": 817,
        "code": "public void setHandleWakeLock(boolean handleWakeLock) {\n  blockUntilConstructorFinished();\n  player.setHandleWakeLock(handleWakeLock);\n}",
        "summary_tokens": [
            "use",
            "set",
            "wake",
            "mode",
            "int",
            "instead"
        ]
    },
    {
        "id": 818,
        "code": "public void setStreamType(@C.StreamType int streamType) {\n  if (this.streamType == streamType) {\n    return;\n  }\n  this.streamType = streamType;\n\n  updateVolumeAndNotifyIfChanged();\n  listener.onStreamTypeChanged(streamType);\n}",
        "summary_tokens": [
            "sets",
            "the",
            "audio",
            "stream",
            "type"
        ]
    },
    {
        "id": 819,
        "code": "public int getMinVolume() {\n  return Util.SDK_INT >= 28 ? audioManager.getStreamMinVolume(streamType) : 0;\n}",
        "summary_tokens": [
            "gets",
            "the",
            "minimum",
            "volume",
            "for",
            "the",
            "current",
            "audio",
            "stream"
        ]
    },
    {
        "id": 820,
        "code": "public int getMaxVolume() {\n  return audioManager.getStreamMaxVolume(streamType);\n}",
        "summary_tokens": [
            "gets",
            "the",
            "maximum",
            "volume",
            "for",
            "the",
            "current",
            "audio",
            "stream"
        ]
    },
    {
        "id": 821,
        "code": "public int getVolume() {\n  return volume;\n}",
        "summary_tokens": [
            "gets",
            "the",
            "current",
            "volume",
            "for",
            "the",
            "current",
            "audio",
            "stream"
        ]
    },
    {
        "id": 822,
        "code": "public boolean isMuted() {\n  return muted;\n}",
        "summary_tokens": [
            "gets",
            "whether",
            "the",
            "current",
            "audio",
            "stream",
            "is",
            "muted",
            "or",
            "not"
        ]
    },
    {
        "id": 823,
        "code": "public void setVolume(int volume) {\n  if (volume < getMinVolume() || volume > getMaxVolume()) {\n    return;\n  }\n  audioManager.setStreamVolume(streamType, volume, VOLUME_FLAGS);\n  updateVolumeAndNotifyIfChanged();\n}",
        "summary_tokens": [
            "sets",
            "the",
            "volume",
            "with",
            "the",
            "given",
            "value",
            "for",
            "the",
            "current",
            "audio",
            "stream"
        ]
    },
    {
        "id": 824,
        "code": "public void increaseVolume() {\n  if (volume >= getMaxVolume()) {\n    return;\n  }\n  audioManager.adjustStreamVolume(streamType, AudioManager.ADJUST_RAISE, VOLUME_FLAGS);\n  updateVolumeAndNotifyIfChanged();\n}",
        "summary_tokens": [
            "increases",
            "the",
            "volume",
            "by",
            "one",
            "for",
            "the",
            "current",
            "audio",
            "stream"
        ]
    },
    {
        "id": 825,
        "code": "public void decreaseVolume() {\n  if (volume <= getMinVolume()) {\n    return;\n  }\n  audioManager.adjustStreamVolume(streamType, AudioManager.ADJUST_LOWER, VOLUME_FLAGS);\n  updateVolumeAndNotifyIfChanged();\n}",
        "summary_tokens": [
            "decreases",
            "the",
            "volume",
            "by",
            "one",
            "for",
            "the",
            "current",
            "audio",
            "stream"
        ]
    },
    {
        "id": 826,
        "code": "public void setMuted(boolean muted) {\n  if (Util.SDK_INT >= 23) {\n    audioManager.adjustStreamVolume(\n        streamType, muted ? AudioManager.ADJUST_MUTE : AudioManager.ADJUST_UNMUTE, VOLUME_FLAGS);\n  } else {\n    audioManager.setStreamMute(streamType, muted);\n  }\n  updateVolumeAndNotifyIfChanged();\n}",
        "summary_tokens": [
            "sets",
            "the",
            "mute",
            "state",
            "of",
            "the",
            "current",
            "audio",
            "stream"
        ]
    },
    {
        "id": 827,
        "code": "public void setEnabled(boolean enabled) {\n  if (enabled) {\n    if (wakeLock == null) {\n      if (powerManager == null) {\n        Log.w(TAG, \"PowerManager is null, therefore not creating the WakeLock.\");\n        return;\n      }\n      wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, WAKE_LOCK_TAG);\n      wakeLock.setReferenceCounted(false);\n    }\n  }\n\n  this.enabled = enabled;\n  updateWakeLock();\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "to",
            "enable",
            "the",
            "acquiring",
            "and",
            "releasing",
            "of",
            "the",
            "wake",
            "lock"
        ]
    },
    {
        "id": 828,
        "code": "public void setStayAwake(boolean stayAwake) {\n  this.stayAwake = stayAwake;\n  updateWakeLock();\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "to",
            "acquire",
            "or",
            "release",
            "the",
            "wake",
            "lock"
        ]
    },
    {
        "id": 829,
        "code": "public void setEnabled(boolean enabled) {\n  if (enabled && wifiLock == null) {\n    if (wifiManager == null) {\n      Log.w(TAG, \"WifiManager is null, therefore not creating the WifiLock.\");\n      return;\n    }\n    wifiLock = wifiManager.createWifiLock(WifiManager.WIFI_MODE_FULL_HIGH_PERF, WIFI_LOCK_TAG);\n    wifiLock.setReferenceCounted(false);\n  }\n\n  this.enabled = enabled;\n  updateWifiLock();\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "to",
            "enable",
            "the",
            "usage",
            "of",
            "a",
            "wifi",
            "lock"
        ]
    },
    {
        "id": 830,
        "code": "public void setStayAwake(boolean stayAwake) {\n  this.stayAwake = stayAwake;\n  updateWifiLock();\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "to",
            "acquire",
            "or",
            "release",
            "the",
            "wifi",
            "lock"
        ]
    },
    {
        "id": 831,
        "code": "default void onPlayerStateChanged(\n    EventTime eventTime, boolean playWhenReady, @Player.State int playbackState) {}",
        "summary_tokens": [
            "use",
            "on",
            "playback",
            "state",
            "changed",
            "event",
            "time",
            "int",
            "and",
            "on",
            "play",
            "when",
            "ready",
            "changed",
            "event",
            "time",
            "boolean",
            "int",
            "instead"
        ]
    },
    {
        "id": 832,
        "code": "default void onPlaybackStateChanged(EventTime eventTime, @Player.State int state) {}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "playback",
            "state",
            "changed"
        ]
    },
    {
        "id": 833,
        "code": "default void onPlayWhenReadyChanged(\n    EventTime eventTime, boolean playWhenReady, @Player.PlayWhenReadyChangeReason int reason) {}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "value",
            "changed",
            "that",
            "indicates",
            "whether",
            "playback",
            "will",
            "proceed",
            "when",
            "ready"
        ]
    },
    {
        "id": 834,
        "code": "default void onPlaybackSuppressionReasonChanged(\n    EventTime eventTime, @PlaybackSuppressionReason int playbackSuppressionReason) {}",
        "summary_tokens": [
            "called",
            "when",
            "playback",
            "suppression",
            "reason",
            "changed"
        ]
    },
    {
        "id": 835,
        "code": "default void onIsPlayingChanged(EventTime eventTime, boolean isPlaying) {}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "player",
            "starts",
            "or",
            "stops",
            "playing"
        ]
    },
    {
        "id": 836,
        "code": "default void onTimelineChanged(EventTime eventTime, @TimelineChangeReason int reason) {}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "timeline",
            "changed"
        ]
    },
    {
        "id": 837,
        "code": "default void onMediaItemTransition(\n    EventTime eventTime,\n    @Nullable MediaItem mediaItem,\n    @Player.MediaItemTransitionReason int reason) {}",
        "summary_tokens": [
            "called",
            "when",
            "playback",
            "transitions",
            "to",
            "a",
            "different",
            "media",
            "item"
        ]
    },
    {
        "id": 838,
        "code": "default void onPositionDiscontinuity(\n    EventTime eventTime,\n    Player.PositionInfo oldPosition,\n    Player.PositionInfo newPosition,\n    @DiscontinuityReason int reason) {}",
        "summary_tokens": [
            "called",
            "when",
            "a",
            "position",
            "discontinuity",
            "occurred"
        ]
    },
    {
        "id": 839,
        "code": "default void onSeekStarted(EventTime eventTime) {}",
        "summary_tokens": [
            "use",
            "on",
            "position",
            "discontinuity",
            "event",
            "time",
            "player"
        ]
    },
    {
        "id": 840,
        "code": "default void onSeekProcessed(EventTime eventTime) {}",
        "summary_tokens": [
            "seeks",
            "are",
            "processed",
            "without",
            "delay"
        ]
    },
    {
        "id": 841,
        "code": "default void onPlaybackParametersChanged(\n    EventTime eventTime, PlaybackParameters playbackParameters) {}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "playback",
            "parameters",
            "changed"
        ]
    },
    {
        "id": 842,
        "code": "default void onSeekBackIncrementChanged(EventTime eventTime, long seekBackIncrementMs) {}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "seek",
            "back",
            "increment",
            "changed"
        ]
    },
    {
        "id": 843,
        "code": "default void onSeekForwardIncrementChanged(EventTime eventTime, long seekForwardIncrementMs) {}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "seek",
            "forward",
            "increment",
            "changed"
        ]
    },
    {
        "id": 844,
        "code": "default void onMaxSeekToPreviousPositionChanged(\n    EventTime eventTime, long maxSeekToPreviousPositionMs) {}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "maximum",
            "position",
            "for",
            "which",
            "player",
            "seek",
            "to",
            "previous",
            "seeks",
            "to",
            "the",
            "previous",
            "window",
            "changes"
        ]
    },
    {
        "id": 845,
        "code": "default void onRepeatModeChanged(EventTime eventTime, @Player.RepeatMode int repeatMode) {}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "repeat",
            "mode",
            "changed"
        ]
    },
    {
        "id": 846,
        "code": "default void onShuffleModeChanged(EventTime eventTime, boolean shuffleModeEnabled) {}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "shuffle",
            "mode",
            "changed"
        ]
    },
    {
        "id": 847,
        "code": "default void onIsLoadingChanged(EventTime eventTime, boolean isLoading) {}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "player",
            "starts",
            "or",
            "stops",
            "loading",
            "data",
            "from",
            "a",
            "source"
        ]
    },
    {
        "id": 848,
        "code": "default void onLoadingChanged(EventTime eventTime, boolean isLoading) {}",
        "summary_tokens": [
            "use",
            "on",
            "is",
            "loading",
            "changed",
            "event",
            "time",
            "boolean",
            "instead"
        ]
    },
    {
        "id": 849,
        "code": "default void onAvailableCommandsChanged(EventTime eventTime, Player.Commands availableCommands) {}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "player",
            "s",
            "available",
            "commands",
            "changed"
        ]
    },
    {
        "id": 850,
        "code": "default void onPlayerError(EventTime eventTime, PlaybackException error) {}",
        "summary_tokens": [
            "called",
            "when",
            "a",
            "fatal",
            "player",
            "error",
            "occurred"
        ]
    },
    {
        "id": 851,
        "code": "default void onPlayerErrorChanged(EventTime eventTime, @Nullable PlaybackException error) {}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "playback",
            "exception",
            "returned",
            "by",
            "player",
            "get",
            "player",
            "error",
            "changes"
        ]
    },
    {
        "id": 852,
        "code": "default void onTracksChanged(EventTime eventTime, Tracks tracks) {}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "tracks",
            "change"
        ]
    },
    {
        "id": 853,
        "code": "default void onTrackSelectionParametersChanged(\n    EventTime eventTime, TrackSelectionParameters trackSelectionParameters) {}",
        "summary_tokens": [
            "called",
            "when",
            "track",
            "selection",
            "parameters",
            "change"
        ]
    },
    {
        "id": 854,
        "code": "default void onMediaMetadataChanged(EventTime eventTime, MediaMetadata mediaMetadata) {}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "combined",
            "media",
            "metadata",
            "changes"
        ]
    },
    {
        "id": 855,
        "code": "default void onPlaylistMetadataChanged(EventTime eventTime, MediaMetadata playlistMetadata) {}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "playlist",
            "media",
            "metadata",
            "changes"
        ]
    },
    {
        "id": 856,
        "code": "default void onLoadStarted(\n    EventTime eventTime, LoadEventInfo loadEventInfo, MediaLoadData mediaLoadData) {}",
        "summary_tokens": [
            "called",
            "when",
            "a",
            "media",
            "source",
            "started",
            "loading",
            "data"
        ]
    },
    {
        "id": 857,
        "code": "default void onLoadCompleted(\n    EventTime eventTime, LoadEventInfo loadEventInfo, MediaLoadData mediaLoadData) {}",
        "summary_tokens": [
            "called",
            "when",
            "a",
            "media",
            "source",
            "completed",
            "loading",
            "data"
        ]
    },
    {
        "id": 858,
        "code": "default void onLoadCanceled(\n    EventTime eventTime, LoadEventInfo loadEventInfo, MediaLoadData mediaLoadData) {}",
        "summary_tokens": [
            "called",
            "when",
            "a",
            "media",
            "source",
            "canceled",
            "loading",
            "data"
        ]
    },
    {
        "id": 859,
        "code": "default void onLoadError(\n    EventTime eventTime,\n    LoadEventInfo loadEventInfo,\n    MediaLoadData mediaLoadData,\n    IOException error,\n    boolean wasCanceled) {}",
        "summary_tokens": [
            "called",
            "when",
            "a",
            "media",
            "source",
            "loading",
            "error",
            "occurred"
        ]
    },
    {
        "id": 860,
        "code": "default void onDownstreamFormatChanged(EventTime eventTime, MediaLoadData mediaLoadData) {}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "downstream",
            "format",
            "sent",
            "to",
            "the",
            "renderers",
            "changed"
        ]
    },
    {
        "id": 861,
        "code": "default void onUpstreamDiscarded(EventTime eventTime, MediaLoadData mediaLoadData) {}",
        "summary_tokens": [
            "called",
            "when",
            "data",
            "is",
            "removed",
            "from",
            "the",
            "back",
            "of",
            "a",
            "media",
            "buffer",
            "typically",
            "so",
            "that",
            "it",
            "can",
            "be",
            "re",
            "buffered",
            "in",
            "a",
            "different",
            "format"
        ]
    },
    {
        "id": 862,
        "code": "default void onBandwidthEstimate(\n    EventTime eventTime, int totalLoadTimeMs, long totalBytesLoaded, long bitrateEstimate) {}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "bandwidth",
            "estimate",
            "for",
            "the",
            "current",
            "data",
            "source",
            "has",
            "been",
            "updated"
        ]
    },
    {
        "id": 863,
        "code": "default void onMetadata(EventTime eventTime, Metadata metadata) {}",
        "summary_tokens": [
            "called",
            "when",
            "there",
            "is",
            "metadata",
            "associated",
            "with",
            "the",
            "current",
            "playback",
            "time"
        ]
    },
    {
        "id": 864,
        "code": "default void onCues(EventTime eventTime, CueGroup cueGroup) {}",
        "summary_tokens": [
            "called",
            "when",
            "there",
            "is",
            "a",
            "change",
            "in",
            "the",
            "cue",
            "group"
        ]
    },
    {
        "id": 865,
        "code": "default void onDecoderEnabled(\n    EventTime eventTime, int trackType, DecoderCounters decoderCounters) {}",
        "summary_tokens": [
            "use",
            "on",
            "audio",
            "enabled",
            "and",
            "on",
            "video",
            "enabled",
            "instead"
        ]
    },
    {
        "id": 866,
        "code": "default void onDecoderInitialized(\n    EventTime eventTime, int trackType, String decoderName, long initializationDurationMs) {}",
        "summary_tokens": [
            "use",
            "on",
            "audio",
            "decoder",
            "initialized",
            "and",
            "on",
            "video",
            "decoder",
            "initialized",
            "instead"
        ]
    },
    {
        "id": 867,
        "code": "default void onDecoderInputFormatChanged(EventTime eventTime, int trackType, Format format) {}",
        "summary_tokens": [
            "use",
            "on",
            "audio",
            "input",
            "format",
            "changed",
            "event",
            "time",
            "format",
            "decoder",
            "reuse",
            "evaluation",
            "and",
            "on",
            "video",
            "input",
            "format",
            "changed",
            "event",
            "time",
            "format",
            "decoder",
            "reuse",
            "evaluation"
        ]
    },
    {
        "id": 868,
        "code": "default void onDecoderDisabled(\n    EventTime eventTime, int trackType, DecoderCounters decoderCounters) {}",
        "summary_tokens": [
            "use",
            "on",
            "audio",
            "disabled",
            "and",
            "on",
            "video",
            "disabled",
            "instead"
        ]
    },
    {
        "id": 869,
        "code": "default void onAudioEnabled(EventTime eventTime, DecoderCounters decoderCounters) {}",
        "summary_tokens": [
            "called",
            "when",
            "an",
            "audio",
            "renderer",
            "is",
            "enabled"
        ]
    },
    {
        "id": 870,
        "code": "default void onAudioDecoderInitialized(\n    EventTime eventTime, String decoderName, long initializationDurationMs) {}",
        "summary_tokens": [
            "use",
            "on",
            "audio",
            "decoder",
            "initialized",
            "event",
            "time",
            "string",
            "long",
            "long"
        ]
    },
    {
        "id": 871,
        "code": "default void onAudioInputFormatChanged(\n    EventTime eventTime,\n    Format format,\n    @Nullable DecoderReuseEvaluation decoderReuseEvaluation) {}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "format",
            "of",
            "the",
            "media",
            "being",
            "consumed",
            "by",
            "an",
            "audio",
            "renderer",
            "changes"
        ]
    },
    {
        "id": 872,
        "code": "default void onAudioPositionAdvancing(EventTime eventTime, long playoutStartSystemTimeMs) {}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "audio",
            "position",
            "has",
            "increased",
            "for",
            "the",
            "first",
            "time",
            "since",
            "the",
            "last",
            "pause",
            "or",
            "position",
            "reset"
        ]
    },
    {
        "id": 873,
        "code": "default void onAudioUnderrun(\n    EventTime eventTime, int bufferSize, long bufferSizeMs, long elapsedSinceLastFeedMs) {}",
        "summary_tokens": [
            "called",
            "when",
            "an",
            "audio",
            "underrun",
            "occurs"
        ]
    },
    {
        "id": 874,
        "code": "default void onAudioDecoderReleased(EventTime eventTime, String decoderName) {}",
        "summary_tokens": [
            "called",
            "when",
            "an",
            "audio",
            "renderer",
            "releases",
            "a",
            "decoder"
        ]
    },
    {
        "id": 875,
        "code": "default void onAudioDisabled(EventTime eventTime, DecoderCounters decoderCounters) {}",
        "summary_tokens": [
            "called",
            "when",
            "an",
            "audio",
            "renderer",
            "is",
            "disabled"
        ]
    },
    {
        "id": 876,
        "code": "default void onAudioSessionIdChanged(EventTime eventTime, int audioSessionId) {}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "audio",
            "session",
            "id",
            "changes"
        ]
    },
    {
        "id": 877,
        "code": "default void onAudioAttributesChanged(EventTime eventTime, AudioAttributes audioAttributes) {}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "audio",
            "attributes",
            "change"
        ]
    },
    {
        "id": 878,
        "code": "default void onSkipSilenceEnabledChanged(EventTime eventTime, boolean skipSilenceEnabled) {}",
        "summary_tokens": [
            "called",
            "when",
            "skipping",
            "silences",
            "is",
            "enabled",
            "or",
            "disabled",
            "in",
            "the",
            "audio",
            "stream"
        ]
    },
    {
        "id": 879,
        "code": "default void onAudioSinkError(EventTime eventTime, Exception audioSinkError) {}",
        "summary_tokens": [
            "called",
            "when",
            "audio",
            "sink",
            "has",
            "encountered",
            "an",
            "error"
        ]
    },
    {
        "id": 880,
        "code": "default void onAudioCodecError(EventTime eventTime, Exception audioCodecError) {}",
        "summary_tokens": [
            "called",
            "when",
            "an",
            "audio",
            "decoder",
            "encounters",
            "an",
            "error"
        ]
    },
    {
        "id": 881,
        "code": "default void onVolumeChanged(EventTime eventTime, float volume) {}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "volume",
            "changes"
        ]
    },
    {
        "id": 882,
        "code": "default void onDeviceInfoChanged(EventTime eventTime, DeviceInfo deviceInfo) {}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "device",
            "information",
            "changes"
        ]
    },
    {
        "id": 883,
        "code": "default void onDeviceVolumeChanged(EventTime eventTime, int volume, boolean muted) {}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "device",
            "volume",
            "or",
            "mute",
            "state",
            "changes"
        ]
    },
    {
        "id": 884,
        "code": "default void onVideoEnabled(EventTime eventTime, DecoderCounters decoderCounters) {}",
        "summary_tokens": [
            "called",
            "when",
            "a",
            "video",
            "renderer",
            "is",
            "enabled"
        ]
    },
    {
        "id": 885,
        "code": "default void onVideoDecoderInitialized(\n    EventTime eventTime, String decoderName, long initializationDurationMs) {}",
        "summary_tokens": [
            "use",
            "on",
            "video",
            "decoder",
            "initialized",
            "event",
            "time",
            "string",
            "long",
            "long"
        ]
    },
    {
        "id": 886,
        "code": "default void onVideoInputFormatChanged(\n    EventTime eventTime,\n    Format format,\n    @Nullable DecoderReuseEvaluation decoderReuseEvaluation) {}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "format",
            "of",
            "the",
            "media",
            "being",
            "consumed",
            "by",
            "a",
            "video",
            "renderer",
            "changes"
        ]
    },
    {
        "id": 887,
        "code": "default void onDroppedVideoFrames(EventTime eventTime, int droppedFrames, long elapsedMs) {}",
        "summary_tokens": [
            "called",
            "after",
            "video",
            "frames",
            "have",
            "been",
            "dropped"
        ]
    },
    {
        "id": 888,
        "code": "default void onVideoDecoderReleased(EventTime eventTime, String decoderName) {}",
        "summary_tokens": [
            "called",
            "when",
            "a",
            "video",
            "renderer",
            "releases",
            "a",
            "decoder"
        ]
    },
    {
        "id": 889,
        "code": "default void onVideoDisabled(EventTime eventTime, DecoderCounters decoderCounters) {}",
        "summary_tokens": [
            "called",
            "when",
            "a",
            "video",
            "renderer",
            "is",
            "disabled"
        ]
    },
    {
        "id": 890,
        "code": "default void onVideoFrameProcessingOffset(\n    EventTime eventTime, long totalProcessingOffsetUs, int frameCount) {}",
        "summary_tokens": [
            "called",
            "when",
            "there",
            "is",
            "an",
            "update",
            "to",
            "the",
            "video",
            "frame",
            "processing",
            "offset",
            "reported",
            "by",
            "a",
            "video",
            "renderer"
        ]
    },
    {
        "id": 891,
        "code": "default void onVideoCodecError(EventTime eventTime, Exception videoCodecError) {}",
        "summary_tokens": [
            "called",
            "when",
            "a",
            "video",
            "decoder",
            "encounters",
            "an",
            "error"
        ]
    },
    {
        "id": 892,
        "code": "default void onRenderedFirstFrame(EventTime eventTime, Object output, long renderTimeMs) {}",
        "summary_tokens": [
            "called",
            "when",
            "a",
            "frame",
            "is",
            "rendered",
            "for",
            "the",
            "first",
            "time",
            "since",
            "setting",
            "the",
            "surface",
            "or",
            "since",
            "the",
            "renderer",
            "was",
            "reset",
            "or",
            "since",
            "the",
            "stream",
            "being",
            "rendered",
            "was",
            "changed"
        ]
    },
    {
        "id": 893,
        "code": "default void onVideoSizeChanged(\n    EventTime eventTime,\n    int width,\n    int height,\n    int unappliedRotationDegrees,\n    float pixelWidthHeightRatio) {}",
        "summary_tokens": [
            "implement",
            "on",
            "video",
            "size",
            "changed",
            "event",
            "time",
            "event",
            "time",
            "video",
            "size",
            "instead"
        ]
    },
    {
        "id": 894,
        "code": "default void onSurfaceSizeChanged(EventTime eventTime, int width, int height) {}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "output",
            "surface",
            "size",
            "changed"
        ]
    },
    {
        "id": 895,
        "code": "default void onDrmSessionAcquired(EventTime eventTime, @DrmSession.State int state) {}",
        "summary_tokens": [
            "called",
            "each",
            "time",
            "a",
            "drm",
            "session",
            "is",
            "acquired"
        ]
    },
    {
        "id": 896,
        "code": "default void onDrmKeysLoaded(EventTime eventTime) {}",
        "summary_tokens": [
            "called",
            "each",
            "time",
            "drm",
            "keys",
            "are",
            "loaded"
        ]
    },
    {
        "id": 897,
        "code": "default void onDrmSessionManagerError(EventTime eventTime, Exception error) {}",
        "summary_tokens": [
            "called",
            "when",
            "a",
            "drm",
            "error",
            "occurs"
        ]
    },
    {
        "id": 898,
        "code": "default void onDrmKeysRestored(EventTime eventTime) {}",
        "summary_tokens": [
            "called",
            "each",
            "time",
            "offline",
            "drm",
            "keys",
            "are",
            "restored"
        ]
    },
    {
        "id": 899,
        "code": "default void onDrmKeysRemoved(EventTime eventTime) {}",
        "summary_tokens": [
            "called",
            "each",
            "time",
            "offline",
            "drm",
            "keys",
            "are",
            "removed"
        ]
    },
    {
        "id": 900,
        "code": "default void onDrmSessionReleased(EventTime eventTime) {}",
        "summary_tokens": [
            "called",
            "each",
            "time",
            "a",
            "drm",
            "session",
            "is",
            "released"
        ]
    },
    {
        "id": 901,
        "code": "default void onPlayerReleased(EventTime eventTime) {}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "player",
            "is",
            "released"
        ]
    },
    {
        "id": 902,
        "code": "default void onEvents(Player player, Events events) {}",
        "summary_tokens": [
            "called",
            "after",
            "one",
            "or",
            "more",
            "events",
            "occurred"
        ]
    },
    {
        "id": 903,
        "code": "protected final void sendEvent(\n    EventTime eventTime, int eventFlag, ListenerSet.Event<AnalyticsListener> eventInvocation) {\n  eventTimes.put(eventFlag, eventTime);\n  listeners.sendEvent(eventFlag, eventInvocation);\n}",
        "summary_tokens": [
            "sends",
            "an",
            "event",
            "to",
            "registered",
            "listeners"
        ]
    },
    {
        "id": 904,
        "code": "protected final EventTime generateCurrentPlayerMediaPeriodEventTime() {\n  return generateEventTime(mediaPeriodQueueTracker.getCurrentPlayerMediaPeriod());\n}",
        "summary_tokens": [
            "generates",
            "an",
            "event",
            "time",
            "for",
            "the",
            "currently",
            "playing",
            "item",
            "in",
            "the",
            "player"
        ]
    },
    {
        "id": 905,
        "code": "protected final EventTime generateEventTime(\n    Timeline timeline, int windowIndex, @Nullable MediaPeriodId mediaPeriodId) {\n  if (timeline.isEmpty()) {\n      \n    mediaPeriodId = null;\n  }\n  long realtimeMs = clock.elapsedRealtime();\n  long eventPositionMs;\n  boolean isInCurrentWindow =\n      timeline.equals(player.getCurrentTimeline())\n          && windowIndex == player.getCurrentMediaItemIndex();\n  if (mediaPeriodId != null && mediaPeriodId.isAd()) {\n    boolean isCurrentAd =\n        isInCurrentWindow\n            && player.getCurrentAdGroupIndex() == mediaPeriodId.adGroupIndex\n            && player.getCurrentAdIndexInAdGroup() == mediaPeriodId.adIndexInAdGroup;\n      \n    eventPositionMs = isCurrentAd ? player.getCurrentPosition() : 0;\n  } else if (isInCurrentWindow) {\n    eventPositionMs = player.getContentPosition();\n  } else {\n      \n      \n    eventPositionMs =\n        timeline.isEmpty() ? 0 : timeline.getWindow(windowIndex, window).getDefaultPositionMs();\n  }\n  @Nullable\n  MediaPeriodId currentMediaPeriodId = mediaPeriodQueueTracker.getCurrentPlayerMediaPeriod();\n  return new EventTime(\n      realtimeMs,\n      timeline,\n      windowIndex,\n      mediaPeriodId,\n      eventPositionMs,\n      player.getCurrentTimeline(),\n      player.getCurrentMediaItemIndex(),\n      currentMediaPeriodId,\n      player.getCurrentPosition(),\n      player.getTotalBufferedDuration());\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "event",
            "time",
            "for",
            "the",
            "specified",
            "timeline",
            "window",
            "and",
            "media",
            "period",
            "id"
        ]
    },
    {
        "id": 906,
        "code": "public static PlaybackStats merge(PlaybackStats... playbackStats) {\n  int playbackCount = 0;\n  long[] playbackStateDurationsMs = new long[PLAYBACK_STATE_COUNT];\n  long firstReportedTimeMs = C.TIME_UNSET;\n  int foregroundPlaybackCount = 0;\n  int abandonedBeforeReadyCount = 0;\n  int endedCount = 0;\n  int backgroundJoiningCount = 0;\n  long totalValidJoinTimeMs = C.TIME_UNSET;\n  int validJoinTimeCount = 0;\n  int totalPauseCount = 0;\n  int totalPauseBufferCount = 0;\n  int totalSeekCount = 0;\n  int totalRebufferCount = 0;\n  long maxRebufferTimeMs = C.TIME_UNSET;\n  int adPlaybackCount = 0;\n  long totalVideoFormatHeightTimeMs = 0;\n  long totalVideoFormatHeightTimeProduct = 0;\n  long totalVideoFormatBitrateTimeMs = 0;\n  long totalVideoFormatBitrateTimeProduct = 0;\n  long totalAudioFormatTimeMs = 0;\n  long totalAudioFormatBitrateTimeProduct = 0;\n  int initialVideoFormatHeightCount = 0;\n  int initialVideoFormatBitrateCount = 0;\n  int totalInitialVideoFormatHeight = C.LENGTH_UNSET;\n  long totalInitialVideoFormatBitrate = C.LENGTH_UNSET;\n  int initialAudioFormatBitrateCount = 0;\n  long totalInitialAudioFormatBitrate = C.LENGTH_UNSET;\n  long totalBandwidthTimeMs = 0;\n  long totalBandwidthBytes = 0;\n  long totalDroppedFrames = 0;\n  long totalAudioUnderruns = 0;\n  int fatalErrorPlaybackCount = 0;\n  int fatalErrorCount = 0;\n  int nonFatalErrorCount = 0;\n  for (PlaybackStats stats : playbackStats) {\n    playbackCount += stats.playbackCount;\n    for (int i = 0; i < PLAYBACK_STATE_COUNT; i++) {\n      playbackStateDurationsMs[i] += stats.playbackStateDurationsMs[i];\n    }\n    if (firstReportedTimeMs == C.TIME_UNSET) {\n      firstReportedTimeMs = stats.firstReportedTimeMs;\n    } else if (stats.firstReportedTimeMs != C.TIME_UNSET) {\n      firstReportedTimeMs = min(firstReportedTimeMs, stats.firstReportedTimeMs);\n    }\n    foregroundPlaybackCount += stats.foregroundPlaybackCount;\n    abandonedBeforeReadyCount += stats.abandonedBeforeReadyCount;\n    endedCount += stats.endedCount;\n    backgroundJoiningCount += stats.backgroundJoiningCount;\n    if (totalValidJoinTimeMs == C.TIME_UNSET) {\n      totalValidJoinTimeMs = stats.totalValidJoinTimeMs;\n    } else if (stats.totalValidJoinTimeMs != C.TIME_UNSET) {\n      totalValidJoinTimeMs += stats.totalValidJoinTimeMs;\n    }\n    validJoinTimeCount += stats.validJoinTimeCount;\n    totalPauseCount += stats.totalPauseCount;\n    totalPauseBufferCount += stats.totalPauseBufferCount;\n    totalSeekCount += stats.totalSeekCount;\n    totalRebufferCount += stats.totalRebufferCount;\n    if (maxRebufferTimeMs == C.TIME_UNSET) {\n      maxRebufferTimeMs = stats.maxRebufferTimeMs;\n    } else if (stats.maxRebufferTimeMs != C.TIME_UNSET) {\n      maxRebufferTimeMs = max(maxRebufferTimeMs, stats.maxRebufferTimeMs);\n    }\n    adPlaybackCount += stats.adPlaybackCount;\n    totalVideoFormatHeightTimeMs += stats.totalVideoFormatHeightTimeMs;\n    totalVideoFormatHeightTimeProduct += stats.totalVideoFormatHeightTimeProduct;\n    totalVideoFormatBitrateTimeMs += stats.totalVideoFormatBitrateTimeMs;\n    totalVideoFormatBitrateTimeProduct += stats.totalVideoFormatBitrateTimeProduct;\n    totalAudioFormatTimeMs += stats.totalAudioFormatTimeMs;\n    totalAudioFormatBitrateTimeProduct += stats.totalAudioFormatBitrateTimeProduct;\n    initialVideoFormatHeightCount += stats.initialVideoFormatHeightCount;\n    initialVideoFormatBitrateCount += stats.initialVideoFormatBitrateCount;\n    if (totalInitialVideoFormatHeight == C.LENGTH_UNSET) {\n      totalInitialVideoFormatHeight = stats.totalInitialVideoFormatHeight;\n    } else if (stats.totalInitialVideoFormatHeight != C.LENGTH_UNSET) {\n      totalInitialVideoFormatHeight += stats.totalInitialVideoFormatHeight;\n    }\n    if (totalInitialVideoFormatBitrate == C.LENGTH_UNSET) {\n      totalInitialVideoFormatBitrate = stats.totalInitialVideoFormatBitrate;\n    } else if (stats.totalInitialVideoFormatBitrate != C.LENGTH_UNSET) {\n      totalInitialVideoFormatBitrate += stats.totalInitialVideoFormatBitrate;\n    }\n    initialAudioFormatBitrateCount += stats.initialAudioFormatBitrateCount;\n    if (totalInitialAudioFormatBitrate == C.LENGTH_UNSET) {\n      totalInitialAudioFormatBitrate = stats.totalInitialAudioFormatBitrate;\n    } else if (stats.totalInitialAudioFormatBitrate != C.LENGTH_UNSET) {\n      totalInitialAudioFormatBitrate += stats.totalInitialAudioFormatBitrate;\n    }\n    totalBandwidthTimeMs += stats.totalBandwidthTimeMs;\n    totalBandwidthBytes += stats.totalBandwidthBytes;\n    totalDroppedFrames += stats.totalDroppedFrames;\n    totalAudioUnderruns += stats.totalAudioUnderruns;\n    fatalErrorPlaybackCount += stats.fatalErrorPlaybackCount;\n    fatalErrorCount += stats.fatalErrorCount;\n    nonFatalErrorCount += stats.nonFatalErrorCount;\n  }\n  return new PlaybackStats(\n      playbackCount,\n      playbackStateDurationsMs,\n       Collections.emptyList(),\n       Collections.emptyList(),\n      firstReportedTimeMs,\n      foregroundPlaybackCount,\n      abandonedBeforeReadyCount,\n      endedCount,\n      backgroundJoiningCount,\n      totalValidJoinTimeMs,\n      validJoinTimeCount,\n      totalPauseCount,\n      totalPauseBufferCount,\n      totalSeekCount,\n      totalRebufferCount,\n      maxRebufferTimeMs,\n      adPlaybackCount,\n       Collections.emptyList(),\n       Collections.emptyList(),\n      totalVideoFormatHeightTimeMs,\n      totalVideoFormatHeightTimeProduct,\n      totalVideoFormatBitrateTimeMs,\n      totalVideoFormatBitrateTimeProduct,\n      totalAudioFormatTimeMs,\n      totalAudioFormatBitrateTimeProduct,\n      initialVideoFormatHeightCount,\n      initialVideoFormatBitrateCount,\n      totalInitialVideoFormatHeight,\n      totalInitialVideoFormatBitrate,\n      initialAudioFormatBitrateCount,\n      totalInitialAudioFormatBitrate,\n      totalBandwidthTimeMs,\n      totalBandwidthBytes,\n      totalDroppedFrames,\n      totalAudioUnderruns,\n      fatalErrorPlaybackCount,\n      fatalErrorCount,\n      nonFatalErrorCount,\n       Collections.emptyList(),\n       Collections.emptyList());\n}",
        "summary_tokens": [
            "returns",
            "the",
            "combined",
            "playback",
            "stats",
            "for",
            "all",
            "input",
            "playback",
            "stats"
        ]
    },
    {
        "id": 907,
        "code": "public long getPlaybackStateDurationMs(@PlaybackState int playbackState) {\n  return playbackStateDurationsMs[playbackState];\n}",
        "summary_tokens": [
            "returns",
            "the",
            "total",
            "time",
            "spent",
            "in",
            "a",
            "given",
            "playback",
            "state",
            "in",
            "milliseconds"
        ]
    },
    {
        "id": 908,
        "code": "public @PlaybackState int getPlaybackStateAtTime(long realtimeMs) {\n  @PlaybackState int state = PLAYBACK_STATE_NOT_STARTED;\n  for (EventTimeAndPlaybackState timeAndState : playbackStateHistory) {\n    if (timeAndState.eventTime.realtimeMs > realtimeMs) {\n      break;\n    }\n    state = timeAndState.playbackState;\n  }\n  return state;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "playback",
            "state",
            "at",
            "the",
            "given",
            "time"
        ]
    },
    {
        "id": 909,
        "code": "public long getMediaTimeMsAtRealtimeMs(long realtimeMs) {\n  if (mediaTimeHistory.isEmpty()) {\n    return C.TIME_UNSET;\n  }\n  int nextIndex = 0;\n  while (nextIndex < mediaTimeHistory.size()\n      && mediaTimeHistory.get(nextIndex)[0] <= realtimeMs) {\n    nextIndex++;\n  }\n  if (nextIndex == 0) {\n    return mediaTimeHistory.get(0)[1];\n  }\n  if (nextIndex == mediaTimeHistory.size()) {\n    return mediaTimeHistory.get(mediaTimeHistory.size() - 1)[1];\n  }\n  long prevRealtimeMs = mediaTimeHistory.get(nextIndex - 1)[0];\n  long prevMediaTimeMs = mediaTimeHistory.get(nextIndex - 1)[1];\n  long nextRealtimeMs = mediaTimeHistory.get(nextIndex)[0];\n  long nextMediaTimeMs = mediaTimeHistory.get(nextIndex)[1];\n  long realtimeDurationMs = nextRealtimeMs - prevRealtimeMs;\n  if (realtimeDurationMs == 0) {\n    return prevMediaTimeMs;\n  }\n  float fraction = (float) (realtimeMs - prevRealtimeMs) / realtimeDurationMs;\n  return prevMediaTimeMs + (long) ((nextMediaTimeMs - prevMediaTimeMs) * fraction);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "estimated",
            "media",
            "time",
            "at",
            "the",
            "given",
            "realtime",
            "in",
            "milliseconds",
            "or",
            "c",
            "time",
            "unset",
            "if",
            "the",
            "media",
            "time",
            "history",
            "is",
            "unknown"
        ]
    },
    {
        "id": 910,
        "code": "public long getMeanJoinTimeMs() {\n  return validJoinTimeCount == 0 ? C.TIME_UNSET : totalValidJoinTimeMs / validJoinTimeCount;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "mean",
            "time",
            "spent",
            "joining",
            "the",
            "playback",
            "in",
            "milliseconds",
            "or",
            "c",
            "time",
            "unset",
            "if",
            "no",
            "valid",
            "join",
            "time",
            "is",
            "available"
        ]
    },
    {
        "id": 911,
        "code": "public long getTotalJoinTimeMs() {\n  return getPlaybackStateDurationMs(PLAYBACK_STATE_JOINING_FOREGROUND);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "total",
            "time",
            "spent",
            "joining",
            "the",
            "playback",
            "in",
            "foreground",
            "in",
            "milliseconds"
        ]
    },
    {
        "id": 912,
        "code": "public long getTotalPlayTimeMs() {\n  return getPlaybackStateDurationMs(PLAYBACK_STATE_PLAYING);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "total",
            "time",
            "spent",
            "actively",
            "playing",
            "in",
            "milliseconds"
        ]
    },
    {
        "id": 913,
        "code": "public long getMeanPlayTimeMs() {\n  return foregroundPlaybackCount == 0\n      ? C.TIME_UNSET\n      : getTotalPlayTimeMs() / foregroundPlaybackCount;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "mean",
            "time",
            "spent",
            "actively",
            "playing",
            "per",
            "foreground",
            "playback",
            "in",
            "milliseconds",
            "or",
            "c",
            "time",
            "unset",
            "if",
            "no",
            "playback",
            "has",
            "been",
            "in",
            "foreground"
        ]
    },
    {
        "id": 914,
        "code": "public long getTotalPausedTimeMs() {\n  return getPlaybackStateDurationMs(PLAYBACK_STATE_PAUSED)\n      + getPlaybackStateDurationMs(PLAYBACK_STATE_PAUSED_BUFFERING);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "total",
            "time",
            "spent",
            "in",
            "a",
            "paused",
            "state",
            "in",
            "milliseconds"
        ]
    },
    {
        "id": 915,
        "code": "public long getMeanPausedTimeMs() {\n  return foregroundPlaybackCount == 0\n      ? C.TIME_UNSET\n      : getTotalPausedTimeMs() / foregroundPlaybackCount;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "mean",
            "time",
            "spent",
            "in",
            "a",
            "paused",
            "state",
            "per",
            "foreground",
            "playback",
            "in",
            "milliseconds",
            "or",
            "c",
            "time",
            "unset",
            "if",
            "no",
            "playback",
            "has",
            "been",
            "in",
            "foreground"
        ]
    },
    {
        "id": 916,
        "code": "public long getTotalRebufferTimeMs() {\n  return getPlaybackStateDurationMs(PLAYBACK_STATE_BUFFERING);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "total",
            "time",
            "spent",
            "rebuffering",
            "in",
            "milliseconds"
        ]
    },
    {
        "id": 917,
        "code": "public long getMeanRebufferTimeMs() {\n  return foregroundPlaybackCount == 0\n      ? C.TIME_UNSET\n      : getTotalRebufferTimeMs() / foregroundPlaybackCount;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "mean",
            "time",
            "spent",
            "rebuffering",
            "per",
            "foreground",
            "playback",
            "in",
            "milliseconds",
            "or",
            "c",
            "time",
            "unset",
            "if",
            "no",
            "playback",
            "has",
            "been",
            "in",
            "foreground"
        ]
    },
    {
        "id": 918,
        "code": "public long getMeanSingleRebufferTimeMs() {\n  return totalRebufferCount == 0\n      ? C.TIME_UNSET\n      : (getPlaybackStateDurationMs(PLAYBACK_STATE_BUFFERING)\n              + getPlaybackStateDurationMs(PLAYBACK_STATE_PAUSED_BUFFERING))\n          / totalRebufferCount;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "mean",
            "time",
            "spent",
            "during",
            "a",
            "single",
            "rebuffer",
            "in",
            "milliseconds",
            "or",
            "c",
            "time",
            "unset",
            "if",
            "no",
            "rebuffer",
            "was",
            "recorded"
        ]
    },
    {
        "id": 919,
        "code": "public long getTotalSeekTimeMs() {\n  return getPlaybackStateDurationMs(PLAYBACK_STATE_SEEKING);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "total",
            "time",
            "spent",
            "from",
            "the",
            "start",
            "of",
            "a",
            "seek",
            "until",
            "playback",
            "is",
            "ready",
            "again",
            "in",
            "milliseconds"
        ]
    },
    {
        "id": 920,
        "code": "public long getMeanSeekTimeMs() {\n  return foregroundPlaybackCount == 0\n      ? C.TIME_UNSET\n      : getTotalSeekTimeMs() / foregroundPlaybackCount;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "mean",
            "time",
            "spent",
            "per",
            "foreground",
            "playback",
            "from",
            "the",
            "start",
            "of",
            "a",
            "seek",
            "until",
            "playback",
            "is",
            "ready",
            "again",
            "in",
            "milliseconds",
            "or",
            "c",
            "time",
            "unset",
            "if",
            "no",
            "playback",
            "has",
            "been",
            "in",
            "foreground"
        ]
    },
    {
        "id": 921,
        "code": "public long getMeanSingleSeekTimeMs() {\n  return totalSeekCount == 0 ? C.TIME_UNSET : getTotalSeekTimeMs() / totalSeekCount;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "mean",
            "time",
            "spent",
            "from",
            "the",
            "start",
            "of",
            "a",
            "single",
            "seek",
            "until",
            "playback",
            "is",
            "ready",
            "again",
            "in",
            "milliseconds",
            "or",
            "c",
            "time",
            "unset",
            "if",
            "no",
            "seek",
            "occurred"
        ]
    },
    {
        "id": 922,
        "code": "public long getTotalWaitTimeMs() {\n  return getPlaybackStateDurationMs(PLAYBACK_STATE_JOINING_FOREGROUND)\n      + getPlaybackStateDurationMs(PLAYBACK_STATE_BUFFERING)\n      + getPlaybackStateDurationMs(PLAYBACK_STATE_SEEKING);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "total",
            "time",
            "spent",
            "actively",
            "waiting",
            "for",
            "playback",
            "in",
            "milliseconds"
        ]
    },
    {
        "id": 923,
        "code": "public long getMeanWaitTimeMs() {\n  return foregroundPlaybackCount == 0\n      ? C.TIME_UNSET\n      : getTotalWaitTimeMs() / foregroundPlaybackCount;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "mean",
            "time",
            "spent",
            "actively",
            "waiting",
            "for",
            "playback",
            "per",
            "foreground",
            "playback",
            "in",
            "milliseconds",
            "or",
            "c",
            "time",
            "unset",
            "if",
            "no",
            "playback",
            "has",
            "been",
            "in",
            "foreground"
        ]
    },
    {
        "id": 924,
        "code": "public long getTotalPlayAndWaitTimeMs() {\n  return getTotalPlayTimeMs() + getTotalWaitTimeMs();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "total",
            "time",
            "spent",
            "playing",
            "or",
            "actively",
            "waiting",
            "for",
            "playback",
            "in",
            "milliseconds"
        ]
    },
    {
        "id": 925,
        "code": "public long getMeanPlayAndWaitTimeMs() {\n  return foregroundPlaybackCount == 0\n      ? C.TIME_UNSET\n      : getTotalPlayAndWaitTimeMs() / foregroundPlaybackCount;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "mean",
            "time",
            "spent",
            "playing",
            "or",
            "actively",
            "waiting",
            "for",
            "playback",
            "per",
            "foreground",
            "playback",
            "in",
            "milliseconds",
            "or",
            "c",
            "time",
            "unset",
            "if",
            "no",
            "playback",
            "has",
            "been",
            "in",
            "foreground"
        ]
    },
    {
        "id": 926,
        "code": "public long getTotalElapsedTimeMs() {\n  long totalTimeMs = 0;\n  for (int i = 0; i < PLAYBACK_STATE_COUNT; i++) {\n    totalTimeMs += playbackStateDurationsMs[i];\n  }\n  return totalTimeMs;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "total",
            "time",
            "covered",
            "by",
            "any",
            "playback",
            "state",
            "in",
            "milliseconds"
        ]
    },
    {
        "id": 927,
        "code": "public long getMeanElapsedTimeMs() {\n  return playbackCount == 0 ? C.TIME_UNSET : getTotalElapsedTimeMs() / playbackCount;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "mean",
            "time",
            "covered",
            "by",
            "any",
            "playback",
            "state",
            "per",
            "playback",
            "in",
            "milliseconds",
            "or",
            "c",
            "time",
            "unset",
            "if",
            "no",
            "playback",
            "was",
            "recorded"
        ]
    },
    {
        "id": 928,
        "code": "public float getAbandonedBeforeReadyRatio() {\n  int foregroundAbandonedBeforeReady =\n      abandonedBeforeReadyCount - (playbackCount - foregroundPlaybackCount);\n  return foregroundPlaybackCount == 0\n      ? 0f\n      : (float) foregroundAbandonedBeforeReady / foregroundPlaybackCount;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "ratio",
            "of",
            "foreground",
            "playbacks",
            "which",
            "were",
            "abandoned",
            "before",
            "they",
            "were",
            "ready",
            "to",
            "play",
            "or",
            "0"
        ]
    },
    {
        "id": 929,
        "code": "public float getEndedRatio() {\n  return foregroundPlaybackCount == 0 ? 0f : (float) endedCount / foregroundPlaybackCount;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "ratio",
            "of",
            "foreground",
            "playbacks",
            "which",
            "reached",
            "the",
            "ended",
            "state",
            "at",
            "least",
            "once",
            "or",
            "0"
        ]
    },
    {
        "id": 930,
        "code": "public float getMeanPauseCount() {\n  return foregroundPlaybackCount == 0 ? 0f : (float) totalPauseCount / foregroundPlaybackCount;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "mean",
            "number",
            "of",
            "times",
            "a",
            "playback",
            "has",
            "been",
            "paused",
            "per",
            "foreground",
            "playback",
            "or",
            "0"
        ]
    },
    {
        "id": 931,
        "code": "public float getMeanPauseBufferCount() {\n  return foregroundPlaybackCount == 0\n      ? 0f\n      : (float) totalPauseBufferCount / foregroundPlaybackCount;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "mean",
            "number",
            "of",
            "times",
            "a",
            "playback",
            "has",
            "been",
            "paused",
            "while",
            "rebuffering",
            "per",
            "foreground",
            "playback",
            "or",
            "0"
        ]
    },
    {
        "id": 932,
        "code": "public float getMeanSeekCount() {\n  return foregroundPlaybackCount == 0 ? 0f : (float) totalSeekCount / foregroundPlaybackCount;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "mean",
            "number",
            "of",
            "times",
            "a",
            "seek",
            "occurred",
            "per",
            "foreground",
            "playback",
            "or",
            "0"
        ]
    },
    {
        "id": 933,
        "code": "public float getMeanRebufferCount() {\n  return foregroundPlaybackCount == 0 ? 0f : (float) totalRebufferCount / foregroundPlaybackCount;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "mean",
            "number",
            "of",
            "times",
            "a",
            "rebuffer",
            "occurred",
            "per",
            "foreground",
            "playback",
            "or",
            "0"
        ]
    },
    {
        "id": 934,
        "code": "public float getWaitTimeRatio() {\n  long playAndWaitTimeMs = getTotalPlayAndWaitTimeMs();\n  return playAndWaitTimeMs == 0 ? 0f : (float) getTotalWaitTimeMs() / playAndWaitTimeMs;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "ratio",
            "of",
            "wait",
            "times",
            "to",
            "the",
            "total",
            "time",
            "spent",
            "playing",
            "and",
            "waiting",
            "or",
            "0"
        ]
    },
    {
        "id": 935,
        "code": "public float getJoinTimeRatio() {\n  long playAndWaitTimeMs = getTotalPlayAndWaitTimeMs();\n  return playAndWaitTimeMs == 0 ? 0f : (float) getTotalJoinTimeMs() / playAndWaitTimeMs;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "ratio",
            "of",
            "foreground",
            "join",
            "time",
            "to",
            "the",
            "total",
            "time",
            "spent",
            "playing",
            "and",
            "waiting",
            "or",
            "0"
        ]
    },
    {
        "id": 936,
        "code": "public float getRebufferTimeRatio() {\n  long playAndWaitTimeMs = getTotalPlayAndWaitTimeMs();\n  return playAndWaitTimeMs == 0 ? 0f : (float) getTotalRebufferTimeMs() / playAndWaitTimeMs;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "ratio",
            "of",
            "rebuffer",
            "time",
            "to",
            "the",
            "total",
            "time",
            "spent",
            "playing",
            "and",
            "waiting",
            "or",
            "0"
        ]
    },
    {
        "id": 937,
        "code": "public float getSeekTimeRatio() {\n  long playAndWaitTimeMs = getTotalPlayAndWaitTimeMs();\n  return playAndWaitTimeMs == 0 ? 0f : (float) getTotalSeekTimeMs() / playAndWaitTimeMs;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "ratio",
            "of",
            "seek",
            "time",
            "to",
            "the",
            "total",
            "time",
            "spent",
            "playing",
            "and",
            "waiting",
            "or",
            "0"
        ]
    },
    {
        "id": 938,
        "code": "public float getRebufferRate() {\n  long playTimeMs = getTotalPlayTimeMs();\n  return playTimeMs == 0 ? 0f : 1000f * totalRebufferCount / playTimeMs;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "rate",
            "of",
            "rebuffer",
            "events",
            "in",
            "rebuffers",
            "per",
            "play",
            "time",
            "second",
            "or",
            "0"
        ]
    },
    {
        "id": 939,
        "code": "public float getMeanTimeBetweenRebuffers() {\n  return 1f / getRebufferRate();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "mean",
            "play",
            "time",
            "between",
            "rebuffer",
            "events",
            "in",
            "seconds"
        ]
    },
    {
        "id": 940,
        "code": "public int getMeanInitialVideoFormatHeight() {\n  return initialVideoFormatHeightCount == 0\n      ? C.LENGTH_UNSET\n      : totalInitialVideoFormatHeight / initialVideoFormatHeightCount;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "mean",
            "initial",
            "video",
            "format",
            "height",
            "in",
            "pixels",
            "or",
            "c",
            "length",
            "unset",
            "if",
            "no",
            "video",
            "format",
            "data",
            "is",
            "available"
        ]
    },
    {
        "id": 941,
        "code": "public int getMeanInitialVideoFormatBitrate() {\n  return initialVideoFormatBitrateCount == 0\n      ? C.LENGTH_UNSET\n      : (int) (totalInitialVideoFormatBitrate / initialVideoFormatBitrateCount);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "mean",
            "initial",
            "video",
            "format",
            "bitrate",
            "in",
            "bits",
            "per",
            "second",
            "or",
            "c",
            "length",
            "unset",
            "if",
            "no",
            "video",
            "format",
            "data",
            "is",
            "available"
        ]
    },
    {
        "id": 942,
        "code": "public int getMeanInitialAudioFormatBitrate() {\n  return initialAudioFormatBitrateCount == 0\n      ? C.LENGTH_UNSET\n      : (int) (totalInitialAudioFormatBitrate / initialAudioFormatBitrateCount);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "mean",
            "initial",
            "audio",
            "format",
            "bitrate",
            "in",
            "bits",
            "per",
            "second",
            "or",
            "c",
            "length",
            "unset",
            "if",
            "no",
            "audio",
            "format",
            "data",
            "is",
            "available"
        ]
    },
    {
        "id": 943,
        "code": "public int getMeanVideoFormatHeight() {\n  return totalVideoFormatHeightTimeMs == 0\n      ? C.LENGTH_UNSET\n      : (int) (totalVideoFormatHeightTimeProduct / totalVideoFormatHeightTimeMs);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "mean",
            "video",
            "format",
            "height",
            "in",
            "pixels",
            "or",
            "c",
            "length",
            "unset",
            "if",
            "no",
            "video",
            "format",
            "data",
            "is",
            "available"
        ]
    },
    {
        "id": 944,
        "code": "public int getMeanVideoFormatBitrate() {\n  return totalVideoFormatBitrateTimeMs == 0\n      ? C.LENGTH_UNSET\n      : (int) (totalVideoFormatBitrateTimeProduct / totalVideoFormatBitrateTimeMs);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "mean",
            "video",
            "format",
            "bitrate",
            "in",
            "bits",
            "per",
            "second",
            "or",
            "c",
            "length",
            "unset",
            "if",
            "no",
            "video",
            "format",
            "data",
            "is",
            "available"
        ]
    },
    {
        "id": 945,
        "code": "public int getMeanAudioFormatBitrate() {\n  return totalAudioFormatTimeMs == 0\n      ? C.LENGTH_UNSET\n      : (int) (totalAudioFormatBitrateTimeProduct / totalAudioFormatTimeMs);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "mean",
            "audio",
            "format",
            "bitrate",
            "in",
            "bits",
            "per",
            "second",
            "or",
            "c",
            "length",
            "unset",
            "if",
            "no",
            "audio",
            "format",
            "data",
            "is",
            "available"
        ]
    },
    {
        "id": 946,
        "code": "public int getMeanBandwidth() {\n  return totalBandwidthTimeMs == 0\n      ? C.LENGTH_UNSET\n      : (int) (totalBandwidthBytes * 8000 / totalBandwidthTimeMs);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "mean",
            "network",
            "bandwidth",
            "based",
            "on",
            "transfer",
            "measurements",
            "in",
            "bits",
            "per",
            "second",
            "or",
            "c",
            "length",
            "unset",
            "if",
            "no",
            "transfer",
            "data",
            "is",
            "available"
        ]
    },
    {
        "id": 947,
        "code": "public float getDroppedFramesRate() {\n  long playTimeMs = getTotalPlayTimeMs();\n  return playTimeMs == 0 ? 0f : 1000f * totalDroppedFrames / playTimeMs;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "mean",
            "rate",
            "at",
            "which",
            "video",
            "frames",
            "are",
            "dropped",
            "in",
            "dropped",
            "frames",
            "per",
            "play",
            "time",
            "second",
            "or",
            "0"
        ]
    },
    {
        "id": 948,
        "code": "public float getAudioUnderrunRate() {\n  long playTimeMs = getTotalPlayTimeMs();\n  return playTimeMs == 0 ? 0f : 1000f * totalAudioUnderruns / playTimeMs;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "mean",
            "rate",
            "at",
            "which",
            "audio",
            "underruns",
            "occurred",
            "in",
            "underruns",
            "per",
            "play",
            "time",
            "second",
            "or",
            "0"
        ]
    },
    {
        "id": 949,
        "code": "public float getFatalErrorRatio() {\n  return foregroundPlaybackCount == 0\n      ? 0f\n      : (float) fatalErrorPlaybackCount / foregroundPlaybackCount;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "ratio",
            "of",
            "foreground",
            "playbacks",
            "which",
            "experienced",
            "fatal",
            "errors",
            "or",
            "0"
        ]
    },
    {
        "id": 950,
        "code": "public float getFatalErrorRate() {\n  long playTimeMs = getTotalPlayTimeMs();\n  return playTimeMs == 0 ? 0f : 1000f * fatalErrorCount / playTimeMs;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "rate",
            "of",
            "fatal",
            "errors",
            "in",
            "errors",
            "per",
            "play",
            "time",
            "second",
            "or",
            "0"
        ]
    },
    {
        "id": 951,
        "code": "public float getMeanTimeBetweenFatalErrors() {\n  return 1f / getFatalErrorRate();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "mean",
            "play",
            "time",
            "between",
            "fatal",
            "errors",
            "in",
            "seconds"
        ]
    },
    {
        "id": 952,
        "code": "public float getMeanNonFatalErrorCount() {\n  return foregroundPlaybackCount == 0 ? 0f : (float) nonFatalErrorCount / foregroundPlaybackCount;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "mean",
            "number",
            "of",
            "non",
            "fatal",
            "errors",
            "per",
            "foreground",
            "playback",
            "or",
            "0"
        ]
    },
    {
        "id": 953,
        "code": "public float getNonFatalErrorRate() {\n  long playTimeMs = getTotalPlayTimeMs();\n  return playTimeMs == 0 ? 0f : 1000f * nonFatalErrorCount / playTimeMs;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "rate",
            "of",
            "non",
            "fatal",
            "errors",
            "in",
            "errors",
            "per",
            "play",
            "time",
            "second",
            "or",
            "0"
        ]
    },
    {
        "id": 954,
        "code": "public float getMeanTimeBetweenNonFatalErrors() {\n  return 1f / getNonFatalErrorRate();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "mean",
            "play",
            "time",
            "between",
            "non",
            "fatal",
            "errors",
            "in",
            "seconds"
        ]
    },
    {
        "id": 955,
        "code": "public PlaybackStats getCombinedPlaybackStats() {\n  PlaybackStats[] allPendingPlaybackStats = new PlaybackStats[playbackStatsTrackers.size() + 1];\n  allPendingPlaybackStats[0] = finishedPlaybackStats;\n  int index = 1;\n  for (PlaybackStatsTracker tracker : playbackStatsTrackers.values()) {\n    allPendingPlaybackStats[index++] = tracker.build( false);\n  }\n  return PlaybackStats.merge(allPendingPlaybackStats);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "combined",
            "playback",
            "stats",
            "for",
            "all",
            "playback",
            "sessions",
            "this",
            "listener",
            "was",
            "and",
            "is",
            "listening",
            "to"
        ]
    },
    {
        "id": 956,
        "code": "public PlaybackStats getPlaybackStats() {\n  @Nullable String activeSessionId = sessionManager.getActiveSessionId();\n  @Nullable\n  PlaybackStatsTracker activeStatsTracker =\n      activeSessionId == null ? null : playbackStatsTrackers.get(activeSessionId);\n  return activeStatsTracker == null ? null : activeStatsTracker.build( false);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "playback",
            "stats",
            "for",
            "the",
            "currently",
            "playback",
            "session",
            "or",
            "null",
            "if",
            "no",
            "session",
            "is",
            "active"
        ]
    },
    {
        "id": 957,
        "code": "public LogSessionId getLogSessionId() {\n  return checkNotNull(logSessionIdApi31).logSessionId;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "log",
            "session",
            "id",
            "for",
            "this",
            "player",
            "instance"
        ]
    },
    {
        "id": 958,
        "code": "public static AudioCapabilities getCapabilities(Context context) {\n  Intent intent =\n      context.registerReceiver(\n           null, new IntentFilter(AudioManager.ACTION_HDMI_AUDIO_PLUG));\n  return getCapabilities(context, intent);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "current",
            "audio",
            "capabilities",
            "for",
            "the",
            "device"
        ]
    },
    {
        "id": 959,
        "code": " static Uri getExternalSurroundSoundGlobalSettingUri() {\n  return deviceMaySetExternalSurroundSoundGlobalSetting()\n      ? Global.getUriFor(EXTERNAL_SURROUND_SOUND_KEY)\n      : null;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "global",
            "settings",
            "uri",
            "used",
            "by",
            "the",
            "device",
            "to",
            "specify",
            "external",
            "surround",
            "sound",
            "or",
            "null",
            "if",
            "the",
            "device",
            "does",
            "not",
            "support",
            "this",
            "functionality"
        ]
    },
    {
        "id": 960,
        "code": "public boolean supportsEncoding(@C.Encoding int encoding) {\n  return Arrays.binarySearch(supportedEncodings, encoding) >= 0;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "this",
            "device",
            "supports",
            "playback",
            "of",
            "the",
            "specified",
            "audio",
            "encoding"
        ]
    },
    {
        "id": 961,
        "code": "public int getMaxChannelCount() {\n  return maxChannelCount;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "maximum",
            "number",
            "of",
            "channels",
            "the",
            "device",
            "can",
            "play",
            "at",
            "the",
            "same",
            "time"
        ]
    },
    {
        "id": 962,
        "code": "public boolean isPassthroughPlaybackSupported(Format format) {\n  return getEncodingAndChannelConfigForPassthrough(format) != null;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "device",
            "can",
            "do",
            "passthrough",
            "playback",
            "for",
            "format"
        ]
    },
    {
        "id": 963,
        "code": "public Pair<Integer, Integer> getEncodingAndChannelConfigForPassthrough(Format format) {\n  @C.Encoding\n  int encoding = MimeTypes.getEncoding(checkNotNull(format.sampleMimeType), format.codecs);\n    \n    \n    \n  if (!ALL_SURROUND_ENCODINGS_AND_MAX_CHANNELS.containsKey(encoding)) {\n    return null;\n  }\n\n  if (encoding == C.ENCODING_E_AC3_JOC && !supportsEncoding(C.ENCODING_E_AC3_JOC)) {\n      \n    encoding = C.ENCODING_E_AC3;\n  } else if (encoding == C.ENCODING_DTS_HD && !supportsEncoding(C.ENCODING_DTS_HD)) {\n      \n    encoding = C.ENCODING_DTS;\n  }\n  if (!supportsEncoding(encoding)) {\n    return null;\n  }\n  int channelCount;\n  if (format.channelCount == Format.NO_VALUE || encoding == C.ENCODING_E_AC3_JOC) {\n      \n      \n      \n    int sampleRate =\n        format.sampleRate != Format.NO_VALUE ? format.sampleRate : DEFAULT_SAMPLE_RATE_HZ;\n    channelCount = getMaxSupportedChannelCountForPassthrough(encoding, sampleRate);\n  } else {\n    channelCount = format.channelCount;\n    if (channelCount > maxChannelCount) {\n      return null;\n    }\n  }\n  int channelConfig = getChannelConfigForPassthrough(channelCount);\n  if (channelConfig == AudioFormat.CHANNEL_INVALID) {\n    return null;\n  }\n  return Pair.create(encoding, channelConfig);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "encoding",
            "and",
            "channel",
            "config",
            "to",
            "use",
            "when",
            "configuring",
            "an",
            "audio",
            "track",
            "in",
            "passthrough",
            "mode",
            "for",
            "the",
            "specified",
            "format"
        ]
    },
    {
        "id": 964,
        "code": "private static int getMaxSupportedChannelCountForPassthrough(\n    @C.Encoding int encoding, int sampleRate) {\n    \n    \n    \n  if (Util.SDK_INT >= 29) {\n    return Api29.getMaxSupportedChannelCountForPassthrough(encoding, sampleRate);\n  }\n  return checkNotNull(ALL_SURROUND_ENCODINGS_AND_MAX_CHANNELS.getOrDefault(encoding, 0));\n}",
        "summary_tokens": [
            "returns",
            "the",
            "maximum",
            "number",
            "of",
            "channels",
            "supported",
            "for",
            "passthrough",
            "playback",
            "of",
            "audio",
            "in",
            "the",
            "given",
            "encoding",
            "or",
            "0",
            "if",
            "the",
            "format",
            "is",
            "unsupported"
        ]
    },
    {
        "id": 965,
        "code": "public AudioCapabilities register() {\n  if (registered) {\n    return Assertions.checkNotNull(audioCapabilities);\n  }\n  registered = true;\n  if (externalSurroundSoundSettingObserver != null) {\n    externalSurroundSoundSettingObserver.register();\n  }\n  Intent stickyIntent = null;\n  if (receiver != null) {\n    IntentFilter intentFilter = new IntentFilter(AudioManager.ACTION_HDMI_AUDIO_PLUG);\n    stickyIntent =\n        context.registerReceiver(\n            receiver, intentFilter,  null, handler);\n  }\n  audioCapabilities = AudioCapabilities.getCapabilities(context, stickyIntent);\n  return audioCapabilities;\n}",
        "summary_tokens": [
            "registers",
            "the",
            "receiver",
            "meaning",
            "it",
            "will",
            "notify",
            "the",
            "listener",
            "when",
            "audio",
            "capability",
            "changes",
            "occur"
        ]
    },
    {
        "id": 966,
        "code": "public void unregister() {\n  if (!registered) {\n    return;\n  }\n  audioCapabilities = null;\n  if (receiver != null) {\n    context.unregisterReceiver(receiver);\n  }\n  if (externalSurroundSoundSettingObserver != null) {\n    externalSurroundSoundSettingObserver.unregister();\n  }\n  registered = false;\n}",
        "summary_tokens": [
            "unregisters",
            "the",
            "receiver",
            "meaning",
            "it",
            "will",
            "no",
            "longer",
            "notify",
            "the",
            "listener",
            "when",
            "audio",
            "capability",
            "changes",
            "occur"
        ]
    },
    {
        "id": 967,
        "code": "default void onAudioEnabled(DecoderCounters counters) {}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "renderer",
            "is",
            "enabled"
        ]
    },
    {
        "id": 968,
        "code": "default void onAudioDecoderInitialized(\n    String decoderName, long initializedTimestampMs, long initializationDurationMs) {}",
        "summary_tokens": [
            "called",
            "when",
            "a",
            "decoder",
            "is",
            "created"
        ]
    },
    {
        "id": 969,
        "code": "default void onAudioInputFormatChanged(\n    Format format, @Nullable DecoderReuseEvaluation decoderReuseEvaluation) {}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "format",
            "of",
            "the",
            "media",
            "being",
            "consumed",
            "by",
            "the",
            "renderer",
            "changes"
        ]
    },
    {
        "id": 970,
        "code": "default void onAudioPositionAdvancing(long playoutStartSystemTimeMs) {}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "audio",
            "position",
            "has",
            "increased",
            "for",
            "the",
            "first",
            "time",
            "since",
            "the",
            "last",
            "pause",
            "or",
            "position",
            "reset"
        ]
    },
    {
        "id": 971,
        "code": "default void onAudioUnderrun(int bufferSize, long bufferSizeMs, long elapsedSinceLastFeedMs) {}",
        "summary_tokens": [
            "called",
            "when",
            "an",
            "audio",
            "underrun",
            "occurs"
        ]
    },
    {
        "id": 972,
        "code": "default void onAudioDecoderReleased(String decoderName) {}",
        "summary_tokens": [
            "called",
            "when",
            "a",
            "decoder",
            "is",
            "released"
        ]
    },
    {
        "id": 973,
        "code": "default void onAudioDisabled(DecoderCounters counters) {}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "renderer",
            "is",
            "disabled"
        ]
    },
    {
        "id": 974,
        "code": "default void onSkipSilenceEnabledChanged(boolean skipSilenceEnabled) {}",
        "summary_tokens": [
            "called",
            "when",
            "skipping",
            "silences",
            "is",
            "enabled",
            "or",
            "disabled",
            "in",
            "the",
            "audio",
            "stream"
        ]
    },
    {
        "id": 975,
        "code": "default void onAudioCodecError(Exception audioCodecError) {}",
        "summary_tokens": [
            "called",
            "when",
            "an",
            "audio",
            "decoder",
            "encounters",
            "an",
            "error"
        ]
    },
    {
        "id": 976,
        "code": "default void onAudioSinkError(Exception audioSinkError) {}",
        "summary_tokens": [
            "called",
            "when",
            "audio",
            "sink",
            "has",
            "encountered",
            "an",
            "error"
        ]
    },
    {
        "id": 977,
        "code": "default void setPlayerId(@Nullable PlayerId playerId) {}",
        "summary_tokens": [
            "sets",
            "the",
            "player",
            "id",
            "of",
            "the",
            "player",
            "using",
            "this",
            "audio",
            "sink"
        ]
    },
    {
        "id": 978,
        "code": "public boolean maybePollTimestamp(long systemTimeUs) {\n  if (audioTimestamp == null || (systemTimeUs - lastTimestampSampleTimeUs) < sampleIntervalUs) {\n    return false;\n  }\n  lastTimestampSampleTimeUs = systemTimeUs;\n  boolean updatedTimestamp = audioTimestamp.maybeUpdateTimestamp();\n  switch (state) {\n    case STATE_INITIALIZING:\n      if (updatedTimestamp) {\n        if (audioTimestamp.getTimestampSystemTimeUs() >= initializeSystemTimeUs) {\n            \n          initialTimestampPositionFrames = audioTimestamp.getTimestampPositionFrames();\n          updateState(STATE_TIMESTAMP);\n        } else {\n            \n          updatedTimestamp = false;\n        }\n      } else if (systemTimeUs - initializeSystemTimeUs > INITIALIZING_DURATION_US) {\n          \n          \n          \n          \n        updateState(STATE_NO_TIMESTAMP);\n      }\n      break;\n    case STATE_TIMESTAMP:\n      if (updatedTimestamp) {\n        long timestampPositionFrames = audioTimestamp.getTimestampPositionFrames();\n        if (timestampPositionFrames > initialTimestampPositionFrames) {\n          updateState(STATE_TIMESTAMP_ADVANCING);\n        }\n      } else {\n        reset();\n      }\n      break;\n    case STATE_TIMESTAMP_ADVANCING:\n      if (!updatedTimestamp) {\n          \n        reset();\n      }\n      break;\n    case STATE_NO_TIMESTAMP:\n      if (updatedTimestamp) {\n          \n        reset();\n      }\n      break;\n    case STATE_ERROR:\n        \n      break;\n    default:\n      throw new IllegalStateException();\n  }\n  return updatedTimestamp;\n}",
        "summary_tokens": [
            "polls",
            "the",
            "timestamp",
            "if",
            "required",
            "and",
            "returns",
            "whether",
            "it",
            "was",
            "updated"
        ]
    },
    {
        "id": 979,
        "code": "public void rejectTimestamp() {\n  updateState(STATE_ERROR);\n}",
        "summary_tokens": [
            "rejects",
            "the",
            "timestamp",
            "last",
            "polled",
            "in",
            "maybe",
            "poll",
            "timestamp",
            "long"
        ]
    },
    {
        "id": 980,
        "code": "public void acceptTimestamp() {\n  if (state == STATE_ERROR) {\n    reset();\n  }\n}",
        "summary_tokens": [
            "accepts",
            "the",
            "timestamp",
            "last",
            "polled",
            "in",
            "maybe",
            "poll",
            "timestamp",
            "long"
        ]
    },
    {
        "id": 981,
        "code": "public boolean hasTimestamp() {\n  return state == STATE_TIMESTAMP || state == STATE_TIMESTAMP_ADVANCING;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "this",
            "instance",
            "has",
            "a",
            "timestamp",
            "that",
            "can",
            "be",
            "used",
            "to",
            "calculate",
            "the",
            "audio",
            "track",
            "position"
        ]
    },
    {
        "id": 982,
        "code": "public boolean hasAdvancingTimestamp() {\n  return state == STATE_TIMESTAMP_ADVANCING;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "this",
            "instance",
            "has",
            "an",
            "advancing",
            "timestamp"
        ]
    },
    {
        "id": 983,
        "code": "public long getTimestampSystemTimeUs() {\n  return audioTimestamp != null ? audioTimestamp.getTimestampSystemTimeUs() : C.TIME_UNSET;\n}",
        "summary_tokens": [
            "if",
            "maybe",
            "poll",
            "timestamp",
            "long",
            "or",
            "has",
            "timestamp",
            "returned",
            "true",
            "returns",
            "the",
            "system",
            "time",
            "at",
            "which",
            "the",
            "latest",
            "timestamp",
            "was",
            "sampled",
            "in",
            "microseconds"
        ]
    },
    {
        "id": 984,
        "code": "public long getTimestampPositionFrames() {\n  return audioTimestamp != null ? audioTimestamp.getTimestampPositionFrames() : C.POSITION_UNSET;\n}",
        "summary_tokens": [
            "if",
            "maybe",
            "poll",
            "timestamp",
            "long",
            "or",
            "has",
            "timestamp",
            "returned",
            "true",
            "returns",
            "the",
            "latest",
            "timestamp",
            "s",
            "position",
            "in",
            "frames"
        ]
    },
    {
        "id": 985,
        "code": "public void setAudioTrack(\n    AudioTrack audioTrack,\n    boolean isPassthrough,\n    @C.Encoding int outputEncoding,\n    int outputPcmFrameSize,\n    int bufferSize) {\n  this.audioTrack = audioTrack;\n  this.outputPcmFrameSize = outputPcmFrameSize;\n  this.bufferSize = bufferSize;\n  audioTimestampPoller = new AudioTimestampPoller(audioTrack);\n  outputSampleRate = audioTrack.getSampleRate();\n  needsPassthroughWorkarounds = isPassthrough && needsPassthroughWorkarounds(outputEncoding);\n  isOutputPcm = Util.isEncodingLinearPcm(outputEncoding);\n  bufferSizeUs = isOutputPcm ? framesToDurationUs(bufferSize / outputPcmFrameSize) : C.TIME_UNSET;\n  lastRawPlaybackHeadPosition = 0;\n  rawPlaybackHeadWrapCount = 0;\n  passthroughWorkaroundPauseOffset = 0;\n  hasData = false;\n  stopTimestampUs = C.TIME_UNSET;\n  forceResetWorkaroundTimeMs = C.TIME_UNSET;\n  lastLatencySampleTimeUs = 0;\n  latencyUs = 0;\n  audioTrackPlaybackSpeed = 1f;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "audio",
            "track",
            "to",
            "wrap"
        ]
    },
    {
        "id": 986,
        "code": "public boolean isPlaying() {\n  return Assertions.checkNotNull(audioTrack).getPlayState() == PLAYSTATE_PLAYING;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "audio",
            "track",
            "is",
            "in",
            "the",
            "playing",
            "state"
        ]
    },
    {
        "id": 987,
        "code": "public boolean mayHandleBuffer(long writtenFrames) {\n  @PlayState int playState = Assertions.checkNotNull(audioTrack).getPlayState();\n  if (needsPassthroughWorkarounds) {\n      \n      \n    if (playState == PLAYSTATE_PAUSED) {\n        \n      hasData = false;\n      return false;\n    }\n\n      \n      \n      \n    if (playState == PLAYSTATE_STOPPED && getPlaybackHeadPosition() == 0) {\n      return false;\n    }\n  }\n\n  boolean hadData = hasData;\n  hasData = hasPendingData(writtenFrames);\n  if (hadData && !hasData && playState != PLAYSTATE_STOPPED) {\n    listener.onUnderrun(bufferSize, Util.usToMs(bufferSizeUs));\n  }\n\n  return true;\n}",
        "summary_tokens": [
            "checks",
            "the",
            "state",
            "of",
            "the",
            "audio",
            "track",
            "and",
            "returns",
            "whether",
            "the",
            "caller",
            "can",
            "write",
            "data",
            "to",
            "the",
            "track"
        ]
    },
    {
        "id": 988,
        "code": "public int getAvailableBufferSize(long writtenBytes) {\n  int bytesPending = (int) (writtenBytes - (getPlaybackHeadPosition() * outputPcmFrameSize));\n  return bufferSize - bytesPending;\n}",
        "summary_tokens": [
            "returns",
            "an",
            "estimate",
            "of",
            "the",
            "number",
            "of",
            "additional",
            "bytes",
            "that",
            "can",
            "be",
            "written",
            "to",
            "the",
            "audio",
            "track",
            "s",
            "buffer",
            "without",
            "running",
            "out",
            "of",
            "space"
        ]
    },
    {
        "id": 989,
        "code": "public boolean isStalled(long writtenFrames) {\n  return forceResetWorkaroundTimeMs != C.TIME_UNSET\n      && writtenFrames > 0\n      && SystemClock.elapsedRealtime() - forceResetWorkaroundTimeMs\n          >= FORCE_RESET_WORKAROUND_TIMEOUT_MS;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "track",
            "is",
            "in",
            "an",
            "invalid",
            "state",
            "and",
            "must",
            "be",
            "recreated"
        ]
    },
    {
        "id": 990,
        "code": "public void handleEndOfStream(long writtenFrames) {\n  stopPlaybackHeadPosition = getPlaybackHeadPosition();\n  stopTimestampUs = SystemClock.elapsedRealtime() * 1000;\n  endPlaybackHeadPosition = writtenFrames;\n}",
        "summary_tokens": [
            "records",
            "the",
            "writing",
            "position",
            "at",
            "which",
            "the",
            "stream",
            "ended",
            "so",
            "that",
            "the",
            "reported",
            "position",
            "can",
            "continue",
            "to",
            "increment",
            "while",
            "remaining",
            "data",
            "is",
            "played",
            "out"
        ]
    },
    {
        "id": 991,
        "code": "public boolean hasPendingData(long writtenFrames) {\n  return writtenFrames > getPlaybackHeadPosition() || forceHasPendingData();\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "audio",
            "track",
            "has",
            "any",
            "pending",
            "data",
            "to",
            "play",
            "out",
            "at",
            "its",
            "current",
            "position"
        ]
    },
    {
        "id": 992,
        "code": "public boolean pause() {\n  resetSyncParams();\n  if (stopTimestampUs == C.TIME_UNSET) {\n      \n      \n    Assertions.checkNotNull(audioTimestampPoller).reset();\n    return true;\n  }\n    \n  return false;\n}",
        "summary_tokens": [
            "pauses",
            "the",
            "audio",
            "track",
            "position",
            "tracker",
            "returning",
            "whether",
            "the",
            "audio",
            "track",
            "needs",
            "to",
            "be",
            "paused",
            "to",
            "cause",
            "playback",
            "to",
            "pause"
        ]
    },
    {
        "id": 993,
        "code": "public void reset() {\n  resetSyncParams();\n  audioTrack = null;\n  audioTimestampPoller = null;\n}",
        "summary_tokens": [
            "resets",
            "the",
            "position",
            "tracker"
        ]
    },
    {
        "id": 994,
        "code": "private boolean forceHasPendingData() {\n  return needsPassthroughWorkarounds\n      && Assertions.checkNotNull(audioTrack).getPlayState() == AudioTrack.PLAYSTATE_PAUSED\n      && getPlaybackHeadPosition() == 0;\n}",
        "summary_tokens": [
            "if",
            "passthrough",
            "workarounds",
            "are",
            "enabled",
            "pausing",
            "is",
            "implemented",
            "by",
            "forcing",
            "the",
            "audio",
            "track",
            "to",
            "underrun"
        ]
    },
    {
        "id": 995,
        "code": "private static boolean needsPassthroughWorkarounds(@C.Encoding int outputEncoding) {\n  return Util.SDK_INT < 23\n      && (outputEncoding == C.ENCODING_AC3 || outputEncoding == C.ENCODING_E_AC3);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "to",
            "work",
            "around",
            "problems",
            "with",
            "passthrough",
            "audio",
            "tracks"
        ]
    },
    {
        "id": 996,
        "code": "private long getPlaybackHeadPosition() {\n  AudioTrack audioTrack = Assertions.checkNotNull(this.audioTrack);\n  if (stopTimestampUs != C.TIME_UNSET) {\n      \n    long elapsedTimeSinceStopUs = (SystemClock.elapsedRealtime() * 1000) - stopTimestampUs;\n    long framesSinceStop = (elapsedTimeSinceStopUs * outputSampleRate) / C.MICROS_PER_SECOND;\n    return min(endPlaybackHeadPosition, stopPlaybackHeadPosition + framesSinceStop);\n  }\n\n  int state = audioTrack.getPlayState();\n  if (state == PLAYSTATE_STOPPED) {\n      \n    return 0;\n  }\n\n  long rawPlaybackHeadPosition = 0xFFFFFFFFL & audioTrack.getPlaybackHeadPosition();\n  if (needsPassthroughWorkarounds) {\n      \n      \n      \n    if (state == PLAYSTATE_PAUSED && rawPlaybackHeadPosition == 0) {\n      passthroughWorkaroundPauseOffset = lastRawPlaybackHeadPosition;\n    }\n    rawPlaybackHeadPosition += passthroughWorkaroundPauseOffset;\n  }\n\n  if (Util.SDK_INT <= 29) {\n    if (rawPlaybackHeadPosition == 0\n        && lastRawPlaybackHeadPosition > 0\n        && state == PLAYSTATE_PLAYING) {\n        \n        \n        \n        \n        \n      if (forceResetWorkaroundTimeMs == C.TIME_UNSET) {\n        forceResetWorkaroundTimeMs = SystemClock.elapsedRealtime();\n      }\n      return lastRawPlaybackHeadPosition;\n    } else {\n      forceResetWorkaroundTimeMs = C.TIME_UNSET;\n    }\n  }\n\n  if (lastRawPlaybackHeadPosition > rawPlaybackHeadPosition) {\n      \n    rawPlaybackHeadWrapCount++;\n  }\n  lastRawPlaybackHeadPosition = rawPlaybackHeadPosition;\n  return rawPlaybackHeadPosition + (rawPlaybackHeadWrapCount << 32);\n}",
        "summary_tokens": [
            "audio",
            "track",
            "get",
            "playback",
            "head",
            "position",
            "returns",
            "a",
            "value",
            "intended",
            "to",
            "be",
            "interpreted",
            "as",
            "an",
            "unsigned",
            "0",
            "bit",
            "integer",
            "which",
            "also",
            "wraps",
            "around",
            "periodically"
        ]
    },
    {
        "id": 997,
        "code": "protected final ByteBuffer replaceOutputBuffer(int count) {\n  if (buffer.capacity() < count) {\n    buffer = ByteBuffer.allocateDirect(count).order(ByteOrder.nativeOrder());\n  } else {\n    buffer.clear();\n  }\n  outputBuffer = buffer;\n  return buffer;\n}",
        "summary_tokens": [
            "replaces",
            "the",
            "current",
            "output",
            "buffer",
            "with",
            "a",
            "buffer",
            "of",
            "at",
            "least",
            "count",
            "bytes",
            "and",
            "returns",
            "it"
        ]
    },
    {
        "id": 998,
        "code": "protected final boolean hasPendingOutput() {\n  return outputBuffer.hasRemaining();\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "current",
            "output",
            "buffer",
            "has",
            "any",
            "data",
            "remaining"
        ]
    },
    {
        "id": 999,
        "code": "protected AudioFormat onConfigure(AudioFormat inputAudioFormat)\n    throws UnhandledAudioFormatException {\n  return AudioFormat.NOT_SET;\n}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "processor",
            "is",
            "configured",
            "for",
            "a",
            "new",
            "input",
            "format"
        ]
    },
    {
        "id": 1000,
        "code": "protected void onQueueEndOfStream() {\n    \n}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "end",
            "of",
            "stream",
            "is",
            "queued",
            "to",
            "the",
            "processor"
        ]
    },
    {
        "id": 1001,
        "code": "protected void onFlush() {\n    \n}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "processor",
            "is",
            "flushed",
            "directly",
            "or",
            "as",
            "part",
            "of",
            "resetting"
        ]
    },
    {
        "id": 1002,
        "code": "protected void onReset() {\n    \n}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "processor",
            "is",
            "reset"
        ]
    },
    {
        "id": 1003,
        "code": "public void setChannelMap(@Nullable int[] outputChannels) {\n  pendingOutputChannels = outputChannels;\n}",
        "summary_tokens": [
            "resets",
            "the",
            "channel",
            "mapping"
        ]
    },
    {
        "id": 1004,
        "code": "public void experimentalSetEnableKeepAudioTrackOnSeek(boolean enableKeepAudioTrackOnSeek) {\n  this.experimentalKeepAudioTrackOnSeek = enableKeepAudioTrackOnSeek;\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "to",
            "enable",
            "the",
            "experimental",
            "feature",
            "that",
            "keeps",
            "and",
            "flushes",
            "the",
            "android"
        ]
    },
    {
        "id": 1005,
        "code": "protected final boolean sinkSupportsFormat(Format format) {\n  return audioSink.supportsFormat(format);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "renderer",
            "s",
            "audio",
            "sink",
            "supports",
            "a",
            "given",
            "format"
        ]
    },
    {
        "id": 1006,
        "code": "protected final @SinkFormatSupport int getSinkFormatSupport(Format format) {\n  return audioSink.getFormatSupport(format);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "level",
            "of",
            "support",
            "that",
            "the",
            "renderer",
            "s",
            "audio",
            "sink",
            "provides",
            "for",
            "a",
            "given",
            "format"
        ]
    },
    {
        "id": 1007,
        "code": "protected DecoderReuseEvaluation canReuseDecoder(\n    String decoderName, Format oldFormat, Format newFormat) {\n  return new DecoderReuseEvaluation(\n      decoderName, oldFormat, newFormat, REUSE_RESULT_NO, DISCARD_REASON_REUSE_NOT_IMPLEMENTED);\n}",
        "summary_tokens": [
            "evaluates",
            "whether",
            "the",
            "existing",
            "decoder",
            "can",
            "be",
            "reused",
            "for",
            "a",
            "new",
            "format"
        ]
    },
    {
        "id": 1008,
        "code": "private boolean shouldApplyAudioProcessorPlaybackParameters() {\n    \n    \n    \n    \n    \n    \n    \n  return !tunneling\n      && MimeTypes.AUDIO_RAW.equals(configuration.inputFormat.sampleMimeType)\n      && !shouldUseFloatOutput(configuration.inputFormat.pcmEncoding);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "audio",
            "processor",
            "playback",
            "parameters",
            "should",
            "be",
            "applied",
            "in",
            "the",
            "current",
            "configuration"
        ]
    },
    {
        "id": 1009,
        "code": "private boolean shouldUseFloatOutput(@C.PcmEncoding int pcmEncoding) {\n  return enableFloatOutput && Util.isEncodingHighResolutionPcm(pcmEncoding);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "audio",
            "in",
            "the",
            "specified",
            "pcm",
            "encoding",
            "should",
            "be",
            "written",
            "to",
            "the",
            "audio",
            "track",
            "as",
            "float",
            "pcm"
        ]
    },
    {
        "id": 1010,
        "code": "private long applyMediaPositionParameters(long positionUs) {\n  while (!mediaPositionParametersCheckpoints.isEmpty()\n      && positionUs >= mediaPositionParametersCheckpoints.getFirst().audioTrackPositionUs) {\n      \n    mediaPositionParameters = mediaPositionParametersCheckpoints.remove();\n  }\n\n  long playoutDurationSinceLastCheckpointUs =\n      positionUs - mediaPositionParameters.audioTrackPositionUs;\n  if (mediaPositionParameters.playbackParameters.equals(PlaybackParameters.DEFAULT)) {\n    return mediaPositionParameters.mediaTimeUs + playoutDurationSinceLastCheckpointUs;\n  } else if (mediaPositionParametersCheckpoints.isEmpty()) {\n    long mediaDurationSinceLastCheckpointUs =\n        audioProcessorChain.getMediaDuration(playoutDurationSinceLastCheckpointUs);\n    return mediaPositionParameters.mediaTimeUs + mediaDurationSinceLastCheckpointUs;\n  } else {\n      \n      \n      \n      \n      \n      \n      \n      \n    MediaPositionParameters nextMediaPositionParameters =\n        mediaPositionParametersCheckpoints.getFirst();\n    long playoutDurationUntilNextCheckpointUs =\n        nextMediaPositionParameters.audioTrackPositionUs - positionUs;\n    long mediaDurationUntilNextCheckpointUs =\n        Util.getMediaDurationForPlayoutDuration(\n            playoutDurationUntilNextCheckpointUs,\n            mediaPositionParameters.playbackParameters.speed);\n    return nextMediaPositionParameters.mediaTimeUs - mediaDurationUntilNextCheckpointUs;\n  }\n}",
        "summary_tokens": [
            "applies",
            "and",
            "updates",
            "media",
            "position",
            "parameters"
        ]
    },
    {
        "id": 1011,
        "code": "protected int get1xBufferSizeInBytes(\n    int minBufferSizeInBytes, int encoding, int outputMode, int pcmFrameSize, int sampleRate) {\n  switch (outputMode) {\n    case OUTPUT_MODE_PCM:\n      return getPcmBufferSizeInBytes(minBufferSizeInBytes, sampleRate, pcmFrameSize);\n    case OUTPUT_MODE_PASSTHROUGH:\n      return getPassthroughBufferSizeInBytes(encoding);\n    case OUTPUT_MODE_OFFLOAD:\n      return getOffloadBufferSizeInBytes(encoding);\n    default:\n      throw new IllegalArgumentException();\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "buffer",
            "size",
            "for",
            "playback",
            "at",
            "0",
            "x",
            "speed"
        ]
    },
    {
        "id": 1012,
        "code": "protected int getPcmBufferSizeInBytes(int minBufferSizeInBytes, int samplingRate, int frameSize) {\n  int targetBufferSize = minBufferSizeInBytes * pcmBufferMultiplicationFactor;\n  int minAppBufferSize = durationUsToBytes(minPcmBufferDurationUs, samplingRate, frameSize);\n  int maxAppBufferSize = durationUsToBytes(maxPcmBufferDurationUs, samplingRate, frameSize);\n  return constrainValue(targetBufferSize, minAppBufferSize, maxAppBufferSize);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "buffer",
            "size",
            "for",
            "pcm",
            "playback"
        ]
    },
    {
        "id": 1013,
        "code": "protected int getPassthroughBufferSizeInBytes(@C.Encoding int encoding) {\n  int bufferSizeUs = passthroughBufferDurationUs;\n  if (encoding == C.ENCODING_AC3) {\n    bufferSizeUs *= ac3BufferMultiplicationFactor;\n  }\n  int maxByteRate = getMaximumEncodedRateBytesPerSecond(encoding);\n  return checkedCast((long) bufferSizeUs * maxByteRate / C.MICROS_PER_SECOND);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "buffer",
            "size",
            "for",
            "passthrough",
            "playback"
        ]
    },
    {
        "id": 1014,
        "code": "protected int getOffloadBufferSizeInBytes(@C.Encoding int encoding) {\n  int maxByteRate = getMaximumEncodedRateBytesPerSecond(encoding);\n  return checkedCast((long) offloadBufferDurationUs * maxByteRate / C.MICROS_PER_SECOND);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "buffer",
            "size",
            "for",
            "offload",
            "playback"
        ]
    },
    {
        "id": 1015,
        "code": "private static void writePcm32BitFloat(int pcm32BitInt, ByteBuffer buffer) {\n  float pcm32BitFloat = (float) (PCM_32_BIT_INT_TO_PCM_32_BIT_FLOAT_FACTOR * pcm32BitInt);\n  int floatBits = Float.floatToIntBits(pcm32BitFloat);\n  if (floatBits == FLOAT_NAN_AS_INT) {\n    floatBits = Float.floatToIntBits((float) 0.0);\n  }\n  buffer.putInt(floatBits);\n}",
        "summary_tokens": [
            "converts",
            "the",
            "provided",
            "0",
            "bit",
            "integer",
            "to",
            "a",
            "0",
            "bit",
            "float",
            "value",
            "and",
            "writes",
            "it",
            "to",
            "buffer"
        ]
    },
    {
        "id": 1016,
        "code": "public void experimentalSetEnableKeepAudioTrackOnSeek(boolean enableKeepAudioTrackOnSeek) {\n  this.experimentalKeepAudioTrackOnSeek = enableKeepAudioTrackOnSeek;\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "to",
            "enable",
            "the",
            "experimental",
            "feature",
            "that",
            "keeps",
            "and",
            "flushes",
            "the",
            "android"
        ]
    },
    {
        "id": 1017,
        "code": "private static List<MediaCodecInfo> getDecoderInfos(\n    MediaCodecSelector mediaCodecSelector,\n    Format format,\n    boolean requiresSecureDecoder,\n    AudioSink audioSink)\n    throws DecoderQueryException {\n  @Nullable String mimeType = format.sampleMimeType;\n  if (mimeType == null) {\n    return ImmutableList.of();\n  }\n  if (audioSink.supportsFormat(format)) {\n      \n    @Nullable MediaCodecInfo codecInfo = MediaCodecUtil.getDecryptOnlyDecoderInfo();\n    if (codecInfo != null) {\n      return ImmutableList.of(codecInfo);\n    }\n  }\n  List<MediaCodecInfo> decoderInfos =\n      mediaCodecSelector.getDecoderInfos(\n          mimeType, requiresSecureDecoder,  false);\n  @Nullable String alternativeMimeType = MediaCodecUtil.getAlternativeCodecMimeType(format);\n  if (alternativeMimeType == null) {\n    return ImmutableList.copyOf(decoderInfos);\n  }\n  List<MediaCodecInfo> alternativeDecoderInfos =\n      mediaCodecSelector.getDecoderInfos(\n          alternativeMimeType, requiresSecureDecoder,  false);\n  return ImmutableList.<MediaCodecInfo>builder()\n      .addAll(decoderInfos)\n      .addAll(alternativeDecoderInfos)\n      .build();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "list",
            "of",
            "decoders",
            "that",
            "can",
            "decode",
            "media",
            "in",
            "the",
            "specified",
            "format",
            "in",
            "the",
            "priority",
            "order",
            "specified",
            "by",
            "the",
            "media",
            "codec",
            "selector"
        ]
    },
    {
        "id": 1018,
        "code": "private int getCodecMaxInputSize(MediaCodecInfo codecInfo, Format format) {\n  if (\"OMX.google.raw.decoder\".equals(codecInfo.name)) {\n      \n      \n      \n      \n    if (Util.SDK_INT < 24 && !(Util.SDK_INT == 23 && Util.isTv(context))) {\n      return Format.NO_VALUE;\n    }\n  }\n  return format.maxInputSize;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "maximum",
            "input",
            "buffer",
            "size",
            "for",
            "a",
            "given",
            "format"
        ]
    },
    {
        "id": 1019,
        "code": "protected MediaFormat getMediaFormat(\n    Format format, String codecMimeType, int codecMaxInputSize, float codecOperatingRate) {\n  MediaFormat mediaFormat = new MediaFormat();\n    \n  mediaFormat.setString(MediaFormat.KEY_MIME, codecMimeType);\n  mediaFormat.setInteger(MediaFormat.KEY_CHANNEL_COUNT, format.channelCount);\n  mediaFormat.setInteger(MediaFormat.KEY_SAMPLE_RATE, format.sampleRate);\n  MediaFormatUtil.setCsdBuffers(mediaFormat, format.initializationData);\n    \n  MediaFormatUtil.maybeSetInteger(mediaFormat, MediaFormat.KEY_MAX_INPUT_SIZE, codecMaxInputSize);\n    \n  if (Util.SDK_INT >= 23) {\n    mediaFormat.setInteger(MediaFormat.KEY_PRIORITY, 0 );\n    if (codecOperatingRate != CODEC_OPERATING_RATE_UNSET && !deviceDoesntSupportOperatingRate()) {\n      mediaFormat.setFloat(MediaFormat.KEY_OPERATING_RATE, codecOperatingRate);\n    }\n  }\n  if (Util.SDK_INT <= 28 && MimeTypes.AUDIO_AC4.equals(format.sampleMimeType)) {\n      \n      \n    mediaFormat.setInteger(\"ac4-is-sync\", 1);\n  }\n  if (Util.SDK_INT >= 24\n      && audioSink.getFormatSupport(\n              Util.getPcmFormat(C.ENCODING_PCM_FLOAT, format.channelCount, format.sampleRate))\n          == AudioSink.SINK_FORMAT_SUPPORTED_DIRECTLY) {\n    mediaFormat.setInteger(MediaFormat.KEY_PCM_ENCODING, AudioFormat.ENCODING_PCM_FLOAT);\n  }\n  if (Util.SDK_INT >= 32) {\n    mediaFormat.setInteger(MediaFormat.KEY_MAX_OUTPUT_CHANNEL_COUNT, 99);\n  }\n\n  return mediaFormat;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "framework",
            "media",
            "format",
            "that",
            "can",
            "be",
            "used",
            "to",
            "configure",
            "a",
            "media",
            "codec",
            "for",
            "decoding",
            "the",
            "given",
            "format",
            "for",
            "playback"
        ]
    },
    {
        "id": 1020,
        "code": "private static boolean deviceDoesntSupportOperatingRate() {\n  return Util.SDK_INT == 23\n      && (\"ZTE B2017G\".equals(Util.MODEL) || \"AXON 7 mini\".equals(Util.MODEL));\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "device",
            "s",
            "decoders",
            "are",
            "known",
            "to",
            "not",
            "support",
            "setting",
            "the",
            "codec",
            "operating",
            "rate"
        ]
    },
    {
        "id": 1021,
        "code": "private static boolean codecNeedsDiscardChannelsWorkaround(String codecName) {\n    \n  return Util.SDK_INT < 24\n      && \"OMX.SEC.aac.dec\".equals(codecName)\n      && \"samsung\".equals(Util.MANUFACTURER)\n      && (Util.DEVICE.startsWith(\"zeroflte\")\n          || Util.DEVICE.startsWith(\"herolte\")\n          || Util.DEVICE.startsWith(\"heroqlte\"));\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "decoder",
            "is",
            "known",
            "to",
            "output",
            "six",
            "audio",
            "channels",
            "when",
            "provided",
            "with",
            "input",
            "with",
            "fewer",
            "than",
            "six",
            "channels"
        ]
    },
    {
        "id": 1022,
        "code": "public void setEnabled(boolean enabled) {\n  this.enabled = enabled;\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "to",
            "skip",
            "silence",
            "in",
            "the",
            "input"
        ]
    },
    {
        "id": 1023,
        "code": "public long getSkippedFrames() {\n  return skippedFrames;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "total",
            "number",
            "of",
            "frames",
            "of",
            "input",
            "audio",
            "that",
            "were",
            "skipped",
            "due",
            "to",
            "being",
            "classified",
            "as",
            "silence",
            "since",
            "the",
            "last",
            "call",
            "to",
            "flush"
        ]
    },
    {
        "id": 1024,
        "code": "private void processNoisy(ByteBuffer inputBuffer) {\n  int limit = inputBuffer.limit();\n\n    \n  inputBuffer.limit(min(limit, inputBuffer.position() + maybeSilenceBuffer.length));\n  int noiseLimit = findNoiseLimit(inputBuffer);\n  if (noiseLimit == inputBuffer.position()) {\n      \n    state = STATE_MAYBE_SILENT;\n  } else {\n    inputBuffer.limit(noiseLimit);\n    output(inputBuffer);\n  }\n\n    \n  inputBuffer.limit(limit);\n}",
        "summary_tokens": [
            "incrementally",
            "processes",
            "new",
            "input",
            "from",
            "input",
            "buffer",
            "while",
            "in",
            "state",
            "noisy",
            "updating",
            "the",
            "state",
            "if",
            "needed"
        ]
    },
    {
        "id": 1025,
        "code": "private void processMaybeSilence(ByteBuffer inputBuffer) {\n  int limit = inputBuffer.limit();\n  int noisePosition = findNoisePosition(inputBuffer);\n  int maybeSilenceInputSize = noisePosition - inputBuffer.position();\n  int maybeSilenceBufferRemaining = maybeSilenceBuffer.length - maybeSilenceBufferSize;\n  if (noisePosition < limit && maybeSilenceInputSize < maybeSilenceBufferRemaining) {\n      \n    output(maybeSilenceBuffer, maybeSilenceBufferSize);\n    maybeSilenceBufferSize = 0;\n    state = STATE_NOISY;\n  } else {\n      \n    int bytesToWrite = min(maybeSilenceInputSize, maybeSilenceBufferRemaining);\n    inputBuffer.limit(inputBuffer.position() + bytesToWrite);\n    inputBuffer.get(maybeSilenceBuffer, maybeSilenceBufferSize, bytesToWrite);\n    maybeSilenceBufferSize += bytesToWrite;\n    if (maybeSilenceBufferSize == maybeSilenceBuffer.length) {\n        \n        \n      if (hasOutputNoise) {\n        output(maybeSilenceBuffer, paddingSize);\n        skippedFrames += (maybeSilenceBufferSize - paddingSize * 2) / bytesPerFrame;\n      } else {\n        skippedFrames += (maybeSilenceBufferSize - paddingSize) / bytesPerFrame;\n      }\n      updatePaddingBuffer(inputBuffer, maybeSilenceBuffer, maybeSilenceBufferSize);\n      maybeSilenceBufferSize = 0;\n      state = STATE_SILENT;\n    }\n\n      \n    inputBuffer.limit(limit);\n  }\n}",
        "summary_tokens": [
            "incrementally",
            "processes",
            "new",
            "input",
            "from",
            "input",
            "buffer",
            "while",
            "in",
            "state",
            "maybe",
            "silent",
            "updating",
            "the",
            "state",
            "if",
            "needed"
        ]
    },
    {
        "id": 1026,
        "code": "private void processSilence(ByteBuffer inputBuffer) {\n  int limit = inputBuffer.limit();\n  int noisyPosition = findNoisePosition(inputBuffer);\n  inputBuffer.limit(noisyPosition);\n  skippedFrames += inputBuffer.remaining() / bytesPerFrame;\n  updatePaddingBuffer(inputBuffer, paddingBuffer, paddingSize);\n  if (noisyPosition < limit) {\n      \n      \n    output(paddingBuffer, paddingSize);\n    state = STATE_NOISY;\n\n      \n    inputBuffer.limit(limit);\n  }\n}",
        "summary_tokens": [
            "incrementally",
            "processes",
            "new",
            "input",
            "from",
            "input",
            "buffer",
            "while",
            "in",
            "state",
            "silent",
            "updating",
            "the",
            "state",
            "if",
            "needed"
        ]
    },
    {
        "id": 1027,
        "code": "private void output(ByteBuffer data) {\n  int length = data.remaining();\n  replaceOutputBuffer(length).put(data).flip();\n  if (length > 0) {\n    hasOutputNoise = true;\n  }\n}",
        "summary_tokens": [
            "copies",
            "remaining",
            "bytes",
            "from",
            "data",
            "to",
            "populate",
            "a",
            "new",
            "output",
            "buffer",
            "from",
            "the",
            "processor"
        ]
    },
    {
        "id": 1028,
        "code": "private void updatePaddingBuffer(ByteBuffer input, byte[] buffer, int size) {\n  int fromInputSize = min(input.remaining(), paddingSize);\n  int fromBufferSize = paddingSize - fromInputSize;\n  System.arraycopy(\n       buffer,\n       size - fromBufferSize,\n       paddingBuffer,\n       0,\n       fromBufferSize);\n  input.position(input.limit() - fromInputSize);\n  input.get(paddingBuffer, fromBufferSize, fromInputSize);\n}",
        "summary_tokens": [
            "fills",
            "padding",
            "buffer",
            "using",
            "data",
            "from",
            "input",
            "plus",
            "any",
            "additional",
            "buffered",
            "data",
            "at",
            "the",
            "end",
            "of",
            "buffer",
            "up",
            "to",
            "its",
            "size",
            "required",
            "to",
            "fill",
            "it",
            "advancing",
            "the",
            "input",
            "position"
        ]
    },
    {
        "id": 1029,
        "code": "private int durationUsToFrames(long durationUs) {\n  return (int) ((durationUs * inputAudioFormat.sampleRate) / C.MICROS_PER_SECOND);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "input",
            "frames",
            "corresponding",
            "to",
            "duration",
            "us",
            "microseconds",
            "of",
            "audio"
        ]
    },
    {
        "id": 1030,
        "code": "private int findNoisePosition(ByteBuffer buffer) {\n    \n  for (int i = buffer.position(); i < buffer.limit(); i += 2) {\n    if (Math.abs(buffer.getShort(i)) > silenceThresholdLevel) {\n        \n      return bytesPerFrame * (i / bytesPerFrame);\n    }\n  }\n  return buffer.limit();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "earliest",
            "byte",
            "position",
            "in",
            "position",
            "limit",
            "of",
            "buffer",
            "that",
            "contains",
            "a",
            "frame",
            "classified",
            "as",
            "a",
            "noisy",
            "frame",
            "or",
            "the",
            "limit",
            "of",
            "the",
            "buffer",
            "if",
            "no",
            "such",
            "frame",
            "exists"
        ]
    },
    {
        "id": 1031,
        "code": "private int findNoiseLimit(ByteBuffer buffer) {\n    \n  for (int i = buffer.limit() - 2; i >= buffer.position(); i -= 2) {\n    if (Math.abs(buffer.getShort(i)) > silenceThresholdLevel) {\n        \n      return bytesPerFrame * (i / bytesPerFrame) + bytesPerFrame;\n    }\n  }\n  return buffer.position();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "earliest",
            "byte",
            "position",
            "in",
            "position",
            "limit",
            "of",
            "buffer",
            "such",
            "that",
            "all",
            "frames",
            "from",
            "the",
            "byte",
            "position",
            "to",
            "the",
            "limit",
            "are",
            "classified",
            "as",
            "silent"
        ]
    },
    {
        "id": 1032,
        "code": "public int getPendingInputBytes() {\n  return inputFrameCount * channelCount * BYTES_PER_SAMPLE;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "bytes",
            "that",
            "have",
            "been",
            "input",
            "but",
            "will",
            "not",
            "be",
            "processed",
            "until",
            "more",
            "input",
            "data",
            "is",
            "provided"
        ]
    },
    {
        "id": 1033,
        "code": "public void queueInput(ShortBuffer buffer) {\n  int framesToWrite = buffer.remaining() / channelCount;\n  int bytesToWrite = framesToWrite * channelCount * 2;\n  inputBuffer = ensureSpaceForAdditionalFrames(inputBuffer, inputFrameCount, framesToWrite);\n  buffer.get(inputBuffer, inputFrameCount * channelCount, bytesToWrite / 2);\n  inputFrameCount += framesToWrite;\n  processStreamInput();\n}",
        "summary_tokens": [
            "queues",
            "remaining",
            "data",
            "from",
            "buffer",
            "and",
            "advances",
            "its",
            "position",
            "by",
            "the",
            "number",
            "of",
            "bytes",
            "consumed"
        ]
    },
    {
        "id": 1034,
        "code": "public void getOutput(ShortBuffer buffer) {\n  int framesToRead = min(buffer.remaining() / channelCount, outputFrameCount);\n  buffer.put(outputBuffer, 0, framesToRead * channelCount);\n  outputFrameCount -= framesToRead;\n  System.arraycopy(\n      outputBuffer,\n      framesToRead * channelCount,\n      outputBuffer,\n      0,\n      outputFrameCount * channelCount);\n}",
        "summary_tokens": [
            "gets",
            "available",
            "output",
            "outputting",
            "to",
            "the",
            "start",
            "of",
            "buffer"
        ]
    },
    {
        "id": 1035,
        "code": "public void queueEndOfStream() {\n  int remainingFrameCount = inputFrameCount;\n  float s = speed / pitch;\n  float r = rate * pitch;\n  int expectedOutputFrames =\n      outputFrameCount + (int) ((remainingFrameCount / s + pitchFrameCount) / r + 0.5f);\n\n    \n  inputBuffer =\n      ensureSpaceForAdditionalFrames(\n          inputBuffer, inputFrameCount, remainingFrameCount + 2 * maxRequiredFrameCount);\n  for (int xSample = 0; xSample < 2 * maxRequiredFrameCount * channelCount; xSample++) {\n    inputBuffer[remainingFrameCount * channelCount + xSample] = 0;\n  }\n  inputFrameCount += 2 * maxRequiredFrameCount;\n  processStreamInput();\n    \n  if (outputFrameCount > expectedOutputFrames) {\n    outputFrameCount = expectedOutputFrames;\n  }\n    \n  inputFrameCount = 0;\n  remainingInputToCopyFrameCount = 0;\n  pitchFrameCount = 0;\n}",
        "summary_tokens": [
            "forces",
            "generating",
            "output",
            "using",
            "whatever",
            "data",
            "has",
            "been",
            "queued",
            "already"
        ]
    },
    {
        "id": 1036,
        "code": "public void flush() {\n  inputFrameCount = 0;\n  outputFrameCount = 0;\n  pitchFrameCount = 0;\n  oldRatePosition = 0;\n  newRatePosition = 0;\n  remainingInputToCopyFrameCount = 0;\n  prevPeriod = 0;\n  prevMinDiff = 0;\n  minDiff = 0;\n  maxDiff = 0;\n}",
        "summary_tokens": [
            "clears",
            "state",
            "in",
            "preparation",
            "for",
            "receiving",
            "a",
            "new",
            "stream",
            "of",
            "input",
            "buffers"
        ]
    },
    {
        "id": 1037,
        "code": "public int getOutputSize() {\n  return outputFrameCount * channelCount * BYTES_PER_SAMPLE;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "size",
            "of",
            "output",
            "that",
            "can",
            "be",
            "read",
            "with",
            "get",
            "output",
            "short",
            "buffer",
            "in",
            "bytes"
        ]
    },
    {
        "id": 1038,
        "code": "private short[] ensureSpaceForAdditionalFrames(\n    short[] buffer, int frameCount, int additionalFrameCount) {\n  int currentCapacityFrames = buffer.length / channelCount;\n  if (frameCount + additionalFrameCount <= currentCapacityFrames) {\n    return buffer;\n  } else {\n    int newCapacityFrames = 3 * currentCapacityFrames / 2 + additionalFrameCount;\n    return Arrays.copyOf(buffer, newCapacityFrames * channelCount);\n  }\n}",
        "summary_tokens": [
            "returns",
            "buffer",
            "or",
            "a",
            "copy",
            "of",
            "it",
            "such",
            "that",
            "there",
            "is",
            "enough",
            "space",
            "in",
            "the",
            "returned",
            "buffer",
            "to",
            "store",
            "new",
            "frame",
            "count",
            "additional",
            "frames"
        ]
    },
    {
        "id": 1039,
        "code": "private boolean previousPeriodBetter(int minDiff, int maxDiff) {\n  if (minDiff == 0 || prevPeriod == 0) {\n    return false;\n  }\n  if (maxDiff > minDiff * 3) {\n      \n    return false;\n  }\n  if (minDiff * 2 <= prevMinDiff * 3) {\n      \n    return false;\n  }\n  return true;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "previous",
            "pitch",
            "period",
            "estimate",
            "is",
            "a",
            "better",
            "approximation",
            "which",
            "can",
            "occur",
            "at",
            "the",
            "abrupt",
            "end",
            "of",
            "voiced",
            "words"
        ]
    },
    {
        "id": 1040,
        "code": "public void setSpeed(float speed) {\n  if (this.speed != speed) {\n    this.speed = speed;\n    pendingSonicRecreation = true;\n  }\n}",
        "summary_tokens": [
            "sets",
            "the",
            "target",
            "playback",
            "speed"
        ]
    },
    {
        "id": 1041,
        "code": "public void setPitch(float pitch) {\n  if (this.pitch != pitch) {\n    this.pitch = pitch;\n    pendingSonicRecreation = true;\n  }\n}",
        "summary_tokens": [
            "sets",
            "the",
            "target",
            "playback",
            "pitch"
        ]
    },
    {
        "id": 1042,
        "code": "public void setOutputSampleRateHz(int sampleRateHz) {\n  pendingOutputSampleRate = sampleRateHz;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "sample",
            "rate",
            "for",
            "output",
            "audio",
            "in",
            "hertz"
        ]
    },
    {
        "id": 1043,
        "code": "public long getMediaDuration(long playoutDuration) {\n  if (outputBytes >= MIN_BYTES_FOR_DURATION_SCALING_CALCULATION) {\n    long processedInputBytes = inputBytes - checkNotNull(sonic).getPendingInputBytes();\n    return outputAudioFormat.sampleRate == inputAudioFormat.sampleRate\n        ? Util.scaleLargeTimestamp(playoutDuration, processedInputBytes, outputBytes)\n        : Util.scaleLargeTimestamp(\n            playoutDuration,\n            processedInputBytes * outputAudioFormat.sampleRate,\n            outputBytes * inputAudioFormat.sampleRate);\n  } else {\n    return (long) ((double) speed * playoutDuration);\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "media",
            "duration",
            "corresponding",
            "to",
            "the",
            "specified",
            "playout",
            "duration",
            "taking",
            "speed",
            "adjustment",
            "into",
            "account"
        ]
    },
    {
        "id": 1044,
        "code": "public void setTrimFrameCount(int trimStartFrames, int trimEndFrames) {\n  this.trimStartFrames = trimStartFrames;\n  this.trimEndFrames = trimEndFrames;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "number",
            "of",
            "audio",
            "frames",
            "to",
            "trim",
            "from",
            "the",
            "start",
            "and",
            "end",
            "of",
            "audio",
            "passed",
            "to",
            "this",
            "processor"
        ]
    },
    {
        "id": 1045,
        "code": "public void resetTrimmedFrameCount() {\n  trimmedFrameCount = 0;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "trimmed",
            "frame",
            "count",
            "returned",
            "by",
            "get",
            "trimmed",
            "frame",
            "count",
            "to",
            "zero"
        ]
    },
    {
        "id": 1046,
        "code": "public long getTrimmedFrameCount() {\n  return trimmedFrameCount;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "audio",
            "frames",
            "trimmed",
            "since",
            "the",
            "last",
            "call",
            "to",
            "reset",
            "trimmed",
            "frame",
            "count"
        ]
    },
    {
        "id": 1047,
        "code": "public synchronized void ensureUpdated() {\n    \n    \n}",
        "summary_tokens": [
            "should",
            "be",
            "called",
            "to",
            "ensure",
            "counter",
            "values",
            "are",
            "made",
            "visible",
            "across",
            "threads"
        ]
    },
    {
        "id": 1048,
        "code": "public void merge(DecoderCounters other) {\n  decoderInitCount += other.decoderInitCount;\n  decoderReleaseCount += other.decoderReleaseCount;\n  queuedInputBufferCount += other.queuedInputBufferCount;\n  skippedInputBufferCount += other.skippedInputBufferCount;\n  renderedOutputBufferCount += other.renderedOutputBufferCount;\n  skippedOutputBufferCount += other.skippedOutputBufferCount;\n  droppedBufferCount += other.droppedBufferCount;\n  droppedInputBufferCount += other.droppedInputBufferCount;\n  maxConsecutiveDroppedBufferCount =\n      max(maxConsecutiveDroppedBufferCount, other.maxConsecutiveDroppedBufferCount);\n  droppedToKeyframeCount += other.droppedToKeyframeCount;\n  addVideoFrameProcessingOffsets(\n      other.totalVideoFrameProcessingOffsetUs, other.videoFrameProcessingOffsetCount);\n}",
        "summary_tokens": [
            "merges",
            "the",
            "counts",
            "from",
            "other",
            "into",
            "this",
            "instance"
        ]
    },
    {
        "id": 1049,
        "code": "public void addVideoFrameProcessingOffset(long processingOffsetUs) {\n  addVideoFrameProcessingOffsets(processingOffsetUs,  1);\n}",
        "summary_tokens": [
            "adds",
            "a",
            "video",
            "frame",
            "processing",
            "offset",
            "to",
            "total",
            "video",
            "frame",
            "processing",
            "offset",
            "us",
            "and",
            "increases",
            "video",
            "frame",
            "processing",
            "offset",
            "count",
            "by",
            "one"
        ]
    },
    {
        "id": 1050,
        "code": "public static byte[] adjustRequestData(byte[] request) {\n  if (Util.SDK_INT >= 27) {\n    return request;\n  }\n    \n    \n    \n    \n  String requestString = Util.fromUtf8Bytes(request);\n  return Util.getUtf8Bytes(base64ToBase64Url(requestString));\n}",
        "summary_tokens": [
            "adjusts",
            "clear",
            "key",
            "request",
            "data",
            "obtained",
            "from",
            "the",
            "android",
            "clear",
            "key",
            "cdm",
            "to",
            "be",
            "spec",
            "compliant"
        ]
    },
    {
        "id": 1051,
        "code": "public static byte[] adjustResponseData(byte[] response) {\n  if (Util.SDK_INT >= 27) {\n    return response;\n  }\n    \n    \n    \n  try {\n    JSONObject responseJson = new JSONObject(Util.fromUtf8Bytes(response));\n    StringBuilder adjustedResponseBuilder = new StringBuilder(\"{\\\"keys\\\":[\");\n    JSONArray keysArray = responseJson.getJSONArray(\"keys\");\n    for (int i = 0; i < keysArray.length(); i++) {\n      if (i != 0) {\n        adjustedResponseBuilder.append(\",\");\n      }\n      JSONObject key = keysArray.getJSONObject(i);\n      adjustedResponseBuilder.append(\"{\\\"k\\\":\\\"\");\n      adjustedResponseBuilder.append(base64UrlToBase64(key.getString(\"k\")));\n      adjustedResponseBuilder.append(\"\\\",\\\"kid\\\":\\\"\");\n      adjustedResponseBuilder.append(base64UrlToBase64(key.getString(\"kid\")));\n      adjustedResponseBuilder.append(\"\\\",\\\"kty\\\":\\\"\");\n      adjustedResponseBuilder.append(key.getString(\"kty\"));\n      adjustedResponseBuilder.append(\"\\\"}\");\n    }\n    adjustedResponseBuilder.append(\"]}\");\n    return Util.getUtf8Bytes(adjustedResponseBuilder.toString());\n  } catch (JSONException e) {\n    Log.e(TAG, \"Failed to adjust response data: \" + Util.fromUtf8Bytes(response), e);\n    return response;\n  }\n}",
        "summary_tokens": [
            "adjusts",
            "clear",
            "key",
            "response",
            "data",
            "to",
            "be",
            "suitable",
            "for",
            "providing",
            "to",
            "the",
            "android",
            "clear",
            "key",
            "cdm"
        ]
    },
    {
        "id": 1052,
        "code": "public void setMode(@Mode int mode, @Nullable byte[] offlineLicenseKeySetId) {\n  checkState(sessions.isEmpty());\n  if (mode == MODE_QUERY || mode == MODE_RELEASE) {\n    checkNotNull(offlineLicenseKeySetId);\n  }\n  this.mode = mode;\n  this.offlineLicenseKeySetId = offlineLicenseKeySetId;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "mode",
            "which",
            "determines",
            "the",
            "role",
            "of",
            "sessions",
            "acquired",
            "from",
            "the",
            "instance"
        ]
    },
    {
        "id": 1053,
        "code": "private void undoAcquisition(\n    DrmSession session, @Nullable DrmSessionEventListener.EventDispatcher eventDispatcher) {\n  session.release(eventDispatcher);\n  if (sessionKeepaliveMs != C.TIME_UNSET) {\n    session.release( null);\n  }\n}",
        "summary_tokens": [
            "undoes",
            "the",
            "acquisitions",
            "from",
            "create",
            "and",
            "acquire",
            "session",
            "list",
            "boolean",
            "drm",
            "session",
            "event",
            "listener"
        ]
    },
    {
        "id": 1054,
        "code": "private DefaultDrmSession createAndAcquireSession(\n    @Nullable List<SchemeData> schemeDatas,\n    boolean isPlaceholderSession,\n    @Nullable DrmSessionEventListener.EventDispatcher eventDispatcher) {\n  checkNotNull(exoMediaDrm);\n    \n  boolean playClearSamplesWithoutKeys = this.playClearSamplesWithoutKeys | isPlaceholderSession;\n  DefaultDrmSession session =\n      new DefaultDrmSession(\n          uuid,\n          exoMediaDrm,\n           provisioningManagerImpl,\n          referenceCountListener,\n          schemeDatas,\n          mode,\n          playClearSamplesWithoutKeys,\n          isPlaceholderSession,\n          offlineLicenseKeySetId,\n          keyRequestParameters,\n          callback,\n          checkNotNull(playbackLooper),\n          loadErrorHandlingPolicy,\n          checkNotNull(playerId));\n    \n    \n    \n    \n  session.acquire(eventDispatcher);\n  if (sessionKeepaliveMs != C.TIME_UNSET) {\n      \n    session.acquire( null);\n  }\n  return session;\n}",
        "summary_tokens": [
            "creates",
            "a",
            "new",
            "default",
            "drm",
            "session",
            "and",
            "acquires",
            "it",
            "on",
            "behalf",
            "of",
            "the",
            "caller",
            "passing",
            "in",
            "event",
            "dispatcher"
        ]
    },
    {
        "id": 1055,
        "code": "private static List<SchemeData> getSchemeDatas(\n    DrmInitData drmInitData, UUID uuid, boolean allowMissingData) {\n    \n  List<SchemeData> matchingSchemeDatas = new ArrayList<>(drmInitData.schemeDataCount);\n  for (int i = 0; i < drmInitData.schemeDataCount; i++) {\n    SchemeData schemeData = drmInitData.get(i);\n    boolean uuidMatches =\n        schemeData.matches(uuid)\n            || (C.CLEARKEY_UUID.equals(uuid) && schemeData.matches(C.COMMON_PSSH_UUID));\n    if (uuidMatches && (schemeData.data != null || allowMissingData)) {\n      matchingSchemeDatas.add(schemeData);\n    }\n  }\n  return matchingSchemeDatas;\n}",
        "summary_tokens": [
            "extracts",
            "scheme",
            "data",
            "instances",
            "suitable",
            "for",
            "the",
            "given",
            "drm",
            "scheme",
            "uuid"
        ]
    },
    {
        "id": 1056,
        "code": "static void replaceSession(\n    @Nullable DrmSession previousSession, @Nullable DrmSession newSession) {\n  if (previousSession == newSession) {\n      \n    return;\n  }\n  if (newSession != null) {\n    newSession.acquire( null);\n  }\n  if (previousSession != null) {\n    previousSession.release( null);\n  }\n}",
        "summary_tokens": [
            "acquires",
            "new",
            "session",
            "then",
            "releases",
            "previous",
            "session"
        ]
    },
    {
        "id": 1057,
        "code": "default boolean playClearSamplesWithoutKeys() {\n  return false;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "this",
            "session",
            "allows",
            "playback",
            "of",
            "clear",
            "samples",
            "prior",
            "to",
            "keys",
            "being",
            "loaded"
        ]
    },
    {
        "id": 1058,
        "code": "default void onDrmSessionAcquired(\n    int windowIndex, @Nullable MediaPeriodId mediaPeriodId, @DrmSession.State int state) {}",
        "summary_tokens": [
            "called",
            "each",
            "time",
            "a",
            "drm",
            "session",
            "is",
            "acquired"
        ]
    },
    {
        "id": 1059,
        "code": "default void onDrmKeysLoaded(int windowIndex, @Nullable MediaPeriodId mediaPeriodId) {}",
        "summary_tokens": [
            "called",
            "each",
            "time",
            "keys",
            "are",
            "loaded"
        ]
    },
    {
        "id": 1060,
        "code": "default void onDrmSessionManagerError(\n    int windowIndex, @Nullable MediaPeriodId mediaPeriodId, Exception error) {}",
        "summary_tokens": [
            "called",
            "when",
            "a",
            "drm",
            "error",
            "occurs"
        ]
    },
    {
        "id": 1061,
        "code": "default void onDrmKeysRestored(int windowIndex, @Nullable MediaPeriodId mediaPeriodId) {}",
        "summary_tokens": [
            "called",
            "each",
            "time",
            "offline",
            "keys",
            "are",
            "restored"
        ]
    },
    {
        "id": 1062,
        "code": "default void onDrmKeysRemoved(int windowIndex, @Nullable MediaPeriodId mediaPeriodId) {}",
        "summary_tokens": [
            "called",
            "each",
            "time",
            "offline",
            "keys",
            "are",
            "removed"
        ]
    },
    {
        "id": 1063,
        "code": "default void onDrmSessionReleased(int windowIndex, @Nullable MediaPeriodId mediaPeriodId) {}",
        "summary_tokens": [
            "called",
            "each",
            "time",
            "a",
            "drm",
            "session",
            "is",
            "released"
        ]
    },
    {
        "id": 1064,
        "code": "default void prepare() {\n    \n}",
        "summary_tokens": [
            "acquires",
            "any",
            "required",
            "resources"
        ]
    },
    {
        "id": 1065,
        "code": "default void release() {\n    \n}",
        "summary_tokens": [
            "releases",
            "any",
            "acquired",
            "resources"
        ]
    },
    {
        "id": 1066,
        "code": "default DrmSessionReference preacquireSession(\n    @Nullable DrmSessionEventListener.EventDispatcher eventDispatcher, Format format) {\n  return DrmSessionReference.EMPTY;\n}",
        "summary_tokens": [
            "pre",
            "acquires",
            "a",
            "drm",
            "session",
            "for",
            "the",
            "specified",
            "format"
        ]
    },
    {
        "id": 1067,
        "code": "public static @PlaybackException.ErrorCode int getErrorCodeForMediaDrmException(\n    Exception exception, @ErrorSource int errorSource) {\n  if (Util.SDK_INT >= 21 && Api21.isMediaDrmStateException(exception)) {\n    return Api21.mediaDrmStateExceptionToErrorCode(exception);\n  } else if (Util.SDK_INT >= 23 && Api23.isMediaDrmResetException(exception)) {\n    return PlaybackException.ERROR_CODE_DRM_SYSTEM_ERROR;\n  } else if (Util.SDK_INT >= 18 && Api18.isNotProvisionedException(exception)) {\n    return PlaybackException.ERROR_CODE_DRM_PROVISIONING_FAILED;\n  } else if (Util.SDK_INT >= 18 && Api18.isDeniedByServerException(exception)) {\n    return PlaybackException.ERROR_CODE_DRM_DEVICE_REVOKED;\n  } else if (exception instanceof UnsupportedDrmException) {\n    return PlaybackException.ERROR_CODE_DRM_SCHEME_UNSUPPORTED;\n  } else if (exception instanceof DefaultDrmSessionManager.MissingSchemeDataException) {\n    return PlaybackException.ERROR_CODE_DRM_CONTENT_ERROR;\n  } else if (exception instanceof KeysExpiredException) {\n    return PlaybackException.ERROR_CODE_DRM_LICENSE_EXPIRED;\n  } else if (errorSource == ERROR_SOURCE_EXO_MEDIA_DRM) {\n      \n      \n    return PlaybackException.ERROR_CODE_DRM_SYSTEM_ERROR;\n  } else if (errorSource == ERROR_SOURCE_LICENSE_ACQUISITION) {\n    return PlaybackException.ERROR_CODE_DRM_LICENSE_ACQUISITION_FAILED;\n  } else if (errorSource == ERROR_SOURCE_PROVISIONING) {\n    return PlaybackException.ERROR_CODE_DRM_PROVISIONING_FAILED;\n  } else {\n      \n    throw new IllegalArgumentException();\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "playback",
            "exception"
        ]
    },
    {
        "id": 1068,
        "code": "public static DummyExoMediaDrm getInstance() {\n  return new DummyExoMediaDrm();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "instance"
        ]
    },
    {
        "id": 1069,
        "code": "default void setPlayerIdForSession(byte[] sessionId, PlayerId playerId) {}",
        "summary_tokens": [
            "sets",
            "the",
            "player",
            "id",
            "of",
            "the",
            "player",
            "using",
            "a",
            "session"
        ]
    },
    {
        "id": 1070,
        "code": "public static boolean isCryptoSchemeSupported(UUID uuid) {\n  return MediaDrm.isCryptoSchemeSupported(adjustUuid(uuid));\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "drm",
            "scheme",
            "with",
            "the",
            "given",
            "uuid",
            "is",
            "supported",
            "on",
            "this",
            "device"
        ]
    },
    {
        "id": 1071,
        "code": "public static FrameworkMediaDrm newInstance(UUID uuid) throws UnsupportedDrmException {\n  try {\n    return new FrameworkMediaDrm(uuid);\n  } catch (UnsupportedSchemeException e) {\n    throw new UnsupportedDrmException(UnsupportedDrmException.REASON_UNSUPPORTED_SCHEME, e);\n  } catch (Exception e) {\n    throw new UnsupportedDrmException(UnsupportedDrmException.REASON_INSTANTIATION_ERROR, e);\n  }\n}",
        "summary_tokens": [
            "creates",
            "an",
            "instance",
            "with",
            "an",
            "initial",
            "reference",
            "count",
            "of",
            "0"
        ]
    },
    {
        "id": 1072,
        "code": "private static boolean needsForceWidevineL3Workaround() {\n  return \"ASUS_Z00AD\".equals(Util.MODEL);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "device",
            "codec",
            "is",
            "known",
            "to",
            "fail",
            "if",
            "security",
            "level",
            "l",
            "0",
            "is",
            "used"
        ]
    },
    {
        "id": 1073,
        "code": "private static byte[] addLaUrlAttributeIfMissing(byte[] data) {\n  ParsableByteArray byteArray = new ParsableByteArray(data);\n    \n    \n  int length = byteArray.readLittleEndianInt();\n  int objectRecordCount = byteArray.readLittleEndianShort();\n  int recordType = byteArray.readLittleEndianShort();\n  if (objectRecordCount != 1 || recordType != 1) {\n    Log.i(TAG, \"Unexpected record count or type. Skipping LA_URL workaround.\");\n    return data;\n  }\n  int recordLength = byteArray.readLittleEndianShort();\n  String xml = byteArray.readString(recordLength, Charsets.UTF_16LE);\n  if (xml.contains(\"<LA_URL>\")) {\n      \n    return data;\n  }\n    \n  int endOfDataTagIndex = xml.indexOf(\"</DATA>\");\n  if (endOfDataTagIndex == -1) {\n    Log.w(TAG, \"Could not find the </DATA> tag. Skipping LA_URL workaround.\");\n  }\n  String xmlWithMockLaUrl =\n      xml.substring( 0,  endOfDataTagIndex)\n          + MOCK_LA_URL\n          + xml.substring( endOfDataTagIndex);\n  int extraBytes = MOCK_LA_URL.length() * UTF_16_BYTES_PER_CHARACTER;\n  ByteBuffer newData = ByteBuffer.allocate(length + extraBytes);\n  newData.order(ByteOrder.LITTLE_ENDIAN);\n  newData.putInt(length + extraBytes);\n  newData.putShort((short) objectRecordCount);\n  newData.putShort((short) recordType);\n  newData.putShort((short) (xmlWithMockLaUrl.length() * UTF_16_BYTES_PER_CHARACTER));\n  newData.put(xmlWithMockLaUrl.getBytes(Charsets.UTF_16LE));\n  return newData.array();\n}",
        "summary_tokens": [
            "if",
            "the",
            "la",
            "url",
            "tag",
            "is",
            "missing",
            "injects",
            "a",
            "mock",
            "la",
            "url",
            "value",
            "to",
            "avoid",
            "causing",
            "the",
            "cdm",
            "to",
            "throw",
            "when",
            "creating",
            "the",
            "key",
            "request"
        ]
    },
    {
        "id": 1074,
        "code": "public void setKeyRequestProperty(String name, String value) {\n  Assertions.checkNotNull(name);\n  Assertions.checkNotNull(value);\n  synchronized (keyRequestProperties) {\n    keyRequestProperties.put(name, value);\n  }\n}",
        "summary_tokens": [
            "sets",
            "a",
            "header",
            "for",
            "key",
            "requests",
            "made",
            "by",
            "the",
            "callback"
        ]
    },
    {
        "id": 1075,
        "code": "public void clearKeyRequestProperty(String name) {\n  Assertions.checkNotNull(name);\n  synchronized (keyRequestProperties) {\n    keyRequestProperties.remove(name);\n  }\n}",
        "summary_tokens": [
            "clears",
            "a",
            "header",
            "for",
            "key",
            "requests",
            "made",
            "by",
            "the",
            "callback"
        ]
    },
    {
        "id": 1076,
        "code": "public void clearAllKeyRequestProperties() {\n  synchronized (keyRequestProperties) {\n    keyRequestProperties.clear();\n  }\n}",
        "summary_tokens": [
            "clears",
            "all",
            "headers",
            "for",
            "key",
            "requests",
            "made",
            "by",
            "the",
            "callback"
        ]
    },
    {
        "id": 1077,
        "code": "public static OfflineLicenseHelper newWidevineInstance(\n    String defaultLicenseUrl,\n    boolean forceDefaultLicenseUrl,\n    DataSource.Factory dataSourceFactory,\n    @Nullable Map<String, String> optionalKeyRequestParameters,\n    DrmSessionEventListener.EventDispatcher eventDispatcher) {\n  return new OfflineLicenseHelper(\n      new DefaultDrmSessionManager.Builder()\n          .setKeyRequestParameters(optionalKeyRequestParameters)\n          .build(\n              new HttpMediaDrmCallback(\n                  defaultLicenseUrl, forceDefaultLicenseUrl, dataSourceFactory)),\n      eventDispatcher);\n}",
        "summary_tokens": [
            "instantiates",
            "a",
            "new",
            "instance",
            "which",
            "uses",
            "widevine",
            "cdm"
        ]
    },
    {
        "id": 1078,
        "code": "public synchronized byte[] downloadLicense(Format format) throws DrmSessionException {\n  Assertions.checkArgument(format.drmInitData != null);\n  return blockingKeyRequest(DefaultDrmSessionManager.MODE_DOWNLOAD, null, format);\n}",
        "summary_tokens": [
            "downloads",
            "an",
            "offline",
            "license"
        ]
    },
    {
        "id": 1079,
        "code": "public synchronized byte[] renewLicense(byte[] offlineLicenseKeySetId)\n    throws DrmSessionException {\n  Assertions.checkNotNull(offlineLicenseKeySetId);\n  return blockingKeyRequest(\n      DefaultDrmSessionManager.MODE_DOWNLOAD,\n      offlineLicenseKeySetId,\n      FORMAT_WITH_EMPTY_DRM_INIT_DATA);\n}",
        "summary_tokens": [
            "renews",
            "an",
            "offline",
            "license"
        ]
    },
    {
        "id": 1080,
        "code": "public synchronized void releaseLicense(byte[] offlineLicenseKeySetId)\n    throws DrmSessionException {\n  Assertions.checkNotNull(offlineLicenseKeySetId);\n  blockingKeyRequest(\n      DefaultDrmSessionManager.MODE_RELEASE,\n      offlineLicenseKeySetId,\n      FORMAT_WITH_EMPTY_DRM_INIT_DATA);\n}",
        "summary_tokens": [
            "releases",
            "an",
            "offline",
            "license"
        ]
    },
    {
        "id": 1081,
        "code": "public synchronized Pair<Long, Long> getLicenseDurationRemainingSec(byte[] offlineLicenseKeySetId)\n    throws DrmSessionException {\n  Assertions.checkNotNull(offlineLicenseKeySetId);\n  drmSessionManager.setPlayer(handlerThread.getLooper(), PlayerId.UNSET);\n  drmSessionManager.prepare();\n  DrmSession drmSession =\n      openBlockingKeyRequest(\n          DefaultDrmSessionManager.MODE_QUERY,\n          offlineLicenseKeySetId,\n          FORMAT_WITH_EMPTY_DRM_INIT_DATA);\n  DrmSessionException error = drmSession.getError();\n  Pair<Long, Long> licenseDurationRemainingSec =\n      WidevineUtil.getLicenseDurationRemainingSec(drmSession);\n  drmSession.release(eventDispatcher);\n  drmSessionManager.release();\n  if (error != null) {\n    if (error.getCause() instanceof KeysExpiredException) {\n      return Pair.create(0L, 0L);\n    }\n    throw error;\n  }\n  return Assertions.checkNotNull(licenseDurationRemainingSec);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "remaining",
            "license",
            "and",
            "playback",
            "durations",
            "in",
            "seconds",
            "for",
            "an",
            "offline",
            "license"
        ]
    },
    {
        "id": 1082,
        "code": "public static Pair<Long, Long> getLicenseDurationRemainingSec(DrmSession drmSession) {\n  Map<String, String> keyStatus = drmSession.queryKeyStatus();\n  if (keyStatus == null) {\n    return null;\n  }\n  return new Pair<>(\n      getDurationRemainingSec(keyStatus, PROPERTY_LICENSE_DURATION_REMAINING),\n      getDurationRemainingSec(keyStatus, PROPERTY_PLAYBACK_DURATION_REMAINING));\n}",
        "summary_tokens": [
            "returns",
            "license",
            "and",
            "playback",
            "durations",
            "remaining",
            "in",
            "seconds"
        ]
    },
    {
        "id": 1083,
        "code": "public void initialize(MediaCodec codec) {\n  checkState(handler == null);\n\n  callbackThread.start();\n  Handler handler = new Handler(callbackThread.getLooper());\n  codec.setCallback(this, handler);\n    \n    \n  this.handler = handler;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "callback",
            "on",
            "codec",
            "and",
            "starts",
            "the",
            "background",
            "callback",
            "thread"
        ]
    },
    {
        "id": 1084,
        "code": "public void shutdown() {\n  synchronized (lock) {\n    shutDown = true;\n    callbackThread.quit();\n    flushInternal();\n  }\n}",
        "summary_tokens": [
            "shuts",
            "down",
            "this",
            "instance"
        ]
    },
    {
        "id": 1085,
        "code": "public int dequeueInputBufferIndex() {\n  synchronized (lock) {\n    if (isFlushingOrShutdown()) {\n      return MediaCodec.INFO_TRY_AGAIN_LATER;\n    } else {\n      maybeThrowException();\n      return availableInputBuffers.isEmpty()\n          ? MediaCodec.INFO_TRY_AGAIN_LATER\n          : availableInputBuffers.remove();\n    }\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "next",
            "available",
            "input",
            "buffer",
            "index",
            "or",
            "media",
            "codec",
            "info",
            "try",
            "again",
            "later",
            "if",
            "no",
            "such",
            "buffer",
            "exists"
        ]
    },
    {
        "id": 1086,
        "code": "public int dequeueOutputBufferIndex(MediaCodec.BufferInfo bufferInfo) {\n  synchronized (lock) {\n    if (isFlushingOrShutdown()) {\n      return MediaCodec.INFO_TRY_AGAIN_LATER;\n    } else {\n      maybeThrowException();\n      if (availableOutputBuffers.isEmpty()) {\n        return MediaCodec.INFO_TRY_AGAIN_LATER;\n      } else {\n        int bufferIndex = availableOutputBuffers.remove();\n        if (bufferIndex >= 0) {\n          checkStateNotNull(currentFormat);\n          MediaCodec.BufferInfo nextBufferInfo = bufferInfos.remove();\n          bufferInfo.set(\n              nextBufferInfo.offset,\n              nextBufferInfo.size,\n              nextBufferInfo.presentationTimeUs,\n              nextBufferInfo.flags);\n        } else if (bufferIndex == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n          currentFormat = formats.remove();\n        }\n        return bufferIndex;\n      }\n    }\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "next",
            "available",
            "output",
            "buffer",
            "index"
        ]
    },
    {
        "id": 1087,
        "code": "public MediaFormat getOutputFormat() {\n  synchronized (lock) {\n    if (currentFormat == null) {\n      throw new IllegalStateException();\n    }\n    return currentFormat;\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "media",
            "format",
            "signalled",
            "by",
            "the",
            "underlying",
            "media",
            "codec"
        ]
    },
    {
        "id": 1088,
        "code": "public void flush() {\n  synchronized (lock) {\n    ++pendingFlushCount;\n    Util.castNonNull(handler).post(this::onFlushCompleted);\n  }\n}",
        "summary_tokens": [
            "initiates",
            "a",
            "flush",
            "asynchronously",
            "which",
            "will",
            "be",
            "completed",
            "on",
            "the",
            "callback",
            "thread"
        ]
    },
    {
        "id": 1089,
        "code": "private void flushInternal() {\n  if (!formats.isEmpty()) {\n    pendingOutputFormat = formats.getLast();\n  }\n    \n    \n\n  availableInputBuffers.clear();\n  availableOutputBuffers.clear();\n  bufferInfos.clear();\n  formats.clear();\n  mediaCodecException = null;\n}",
        "summary_tokens": [
            "flushes",
            "all",
            "available",
            "input",
            "and",
            "output",
            "buffers",
            "and",
            "any",
            "error",
            "that",
            "was",
            "previously",
            "set"
        ]
    },
    {
        "id": 1090,
        "code": "public void setMaxSampleCount(@IntRange(from = 1) int maxSampleCount) {\n  checkArgument(maxSampleCount > 0);\n  this.maxSampleCount = maxSampleCount;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "maximum",
            "number",
            "of",
            "samples",
            "that",
            "can",
            "be",
            "appended",
            "before",
            "the",
            "buffer",
            "is",
            "full"
        ]
    },
    {
        "id": 1091,
        "code": "public long getFirstSampleTimeUs() {\n  return timeUs;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "timestamp",
            "of",
            "the",
            "first",
            "sample",
            "in",
            "the",
            "buffer"
        ]
    },
    {
        "id": 1092,
        "code": "public long getLastSampleTimeUs() {\n  return lastSampleTimeUs;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "timestamp",
            "of",
            "the",
            "last",
            "sample",
            "in",
            "the",
            "buffer"
        ]
    },
    {
        "id": 1093,
        "code": "public int getSampleCount() {\n  return sampleCount;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "samples",
            "in",
            "the",
            "buffer"
        ]
    },
    {
        "id": 1094,
        "code": "public boolean hasSamples() {\n  return sampleCount > 0;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "buffer",
            "contains",
            "one",
            "or",
            "more",
            "samples"
        ]
    },
    {
        "id": 1095,
        "code": "public boolean append(DecoderInputBuffer buffer) {\n  checkArgument(!buffer.isEncrypted());\n  checkArgument(!buffer.hasSupplementalData());\n  checkArgument(!buffer.isEndOfStream());\n  if (!canAppendSampleBuffer(buffer)) {\n    return false;\n  }\n  if (sampleCount++ == 0) {\n    timeUs = buffer.timeUs;\n    if (buffer.isKeyFrame()) {\n      setFlags(C.BUFFER_FLAG_KEY_FRAME);\n    }\n  }\n  if (buffer.isDecodeOnly()) {\n    setFlags(C.BUFFER_FLAG_DECODE_ONLY);\n  }\n  @Nullable ByteBuffer bufferData = buffer.data;\n  if (bufferData != null) {\n    ensureSpaceForWrite(bufferData.remaining());\n    data.put(bufferData);\n  }\n  lastSampleTimeUs = buffer.timeUs;\n  return true;\n}",
        "summary_tokens": [
            "attempts",
            "to",
            "append",
            "the",
            "provided",
            "buffer"
        ]
    },
    {
        "id": 1096,
        "code": "public void reset() {\n  anchorTimestampUs = 0;\n  processedFrames = 0;\n  seenInvalidMpegAudioHeader = false;\n}",
        "summary_tokens": [
            "resets",
            "the",
            "timestamp",
            "tracker"
        ]
    },
    {
        "id": 1097,
        "code": "public long updateAndGetPresentationTimeUs(Format format, DecoderInputBuffer buffer) {\n  if (processedFrames == 0) {\n    anchorTimestampUs = buffer.timeUs;\n  }\n\n  if (seenInvalidMpegAudioHeader) {\n    return buffer.timeUs;\n  }\n\n  ByteBuffer data = Assertions.checkNotNull(buffer.data);\n  int sampleHeaderData = 0;\n  for (int i = 0; i < 4; i++) {\n    sampleHeaderData <<= 8;\n    sampleHeaderData |= data.get(i) & 0xFF;\n  }\n\n  int frameCount = MpegAudioUtil.parseMpegAudioFrameSampleCount(sampleHeaderData);\n  if (frameCount == C.LENGTH_UNSET) {\n    seenInvalidMpegAudioHeader = true;\n    processedFrames = 0;\n    anchorTimestampUs = buffer.timeUs;\n    Log.w(TAG, \"MPEG audio header is invalid.\");\n    return buffer.timeUs;\n  }\n  long currentBufferTimestampUs = getBufferTimestampUs(format.sampleRate);\n  processedFrames += frameCount;\n  return currentBufferTimestampUs;\n}",
        "summary_tokens": [
            "updates",
            "the",
            "tracker",
            "with",
            "the",
            "given",
            "input",
            "buffer",
            "and",
            "returns",
            "the",
            "expected",
            "output",
            "timestamp"
        ]
    },
    {
        "id": 1098,
        "code": "public long getLastOutputBufferPresentationTimeUs(Format format) {\n  return getBufferTimestampUs(format.sampleRate);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "timestamp",
            "of",
            "the",
            "last",
            "buffer",
            "that",
            "will",
            "be",
            "produced",
            "if",
            "the",
            "stream",
            "ends",
            "at",
            "the",
            "current",
            "position",
            "in",
            "microseconds"
        ]
    },
    {
        "id": 1099,
        "code": "public DefaultMediaCodecAdapterFactory forceEnableAsynchronous() {\n  asynchronousMode = MODE_ENABLED;\n  return this;\n}",
        "summary_tokens": [
            "forces",
            "this",
            "factory",
            "to",
            "always",
            "create",
            "asynchronous",
            "media",
            "codec",
            "adapter",
            "instances",
            "provided",
            "the",
            "device",
            "api",
            "level",
            "is",
            "gt",
            "0"
        ]
    },
    {
        "id": 1100,
        "code": "public DefaultMediaCodecAdapterFactory forceDisableAsynchronous() {\n  asynchronousMode = MODE_DISABLED;\n  return this;\n}",
        "summary_tokens": [
            "forces",
            "the",
            "factory",
            "to",
            "always",
            "create",
            "synchronous",
            "media",
            "codec",
            "adapter",
            "instances"
        ]
    },
    {
        "id": 1101,
        "code": "public void experimentalSetSynchronizeCodecInteractionsWithQueueingEnabled(boolean enabled) {\n  enableSynchronizeCodecInteractionsWithQueueing = enabled;\n}",
        "summary_tokens": [
            "enable",
            "synchronizing",
            "codec",
            "interactions",
            "with",
            "asynchronous",
            "buffer",
            "queueing"
        ]
    },
    {
        "id": 1102,
        "code": "public void add(int value) {\n  if (size == data.length) {\n    doubleArraySize();\n  }\n\n  tailIndex = (tailIndex + 1) & wrapAroundMask;\n  data[tailIndex] = value;\n  size++;\n}",
        "summary_tokens": [
            "add",
            "a",
            "new",
            "item",
            "to",
            "the",
            "queue"
        ]
    },
    {
        "id": 1103,
        "code": "public int remove() {\n  if (size == 0) {\n    throw new NoSuchElementException();\n  }\n\n  int value = data[headIndex];\n  headIndex = (headIndex + 1) & wrapAroundMask;\n  size--;\n\n  return value;\n}",
        "summary_tokens": [
            "remove",
            "an",
            "item",
            "from",
            "the",
            "queue"
        ]
    },
    {
        "id": 1104,
        "code": "public int size() {\n  return size;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "items",
            "in",
            "the",
            "queue"
        ]
    },
    {
        "id": 1105,
        "code": "public boolean isEmpty() {\n  return size == 0;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "queue",
            "is",
            "empty"
        ]
    },
    {
        "id": 1106,
        "code": "public int capacity() {\n  return data.length;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "length",
            "of",
            "the",
            "backing",
            "array"
        ]
    },
    {
        "id": 1107,
        "code": "public CodecProfileLevel[] getProfileLevels() {\n  return capabilities == null || capabilities.profileLevels == null\n      ? new CodecProfileLevel[0]\n      : capabilities.profileLevels;\n}",
        "summary_tokens": [
            "the",
            "profile",
            "levels",
            "supported",
            "by",
            "the",
            "decoder"
        ]
    },
    {
        "id": 1108,
        "code": "public int getMaxSupportedInstances() {\n  if (Util.SDK_INT < 23 || capabilities == null) {\n    return MAX_SUPPORTED_INSTANCES_UNKNOWN;\n  }\n  return getMaxSupportedInstancesV23(capabilities);\n}",
        "summary_tokens": [
            "returns",
            "an",
            "upper",
            "bound",
            "on",
            "the",
            "maximum",
            "number",
            "of",
            "supported",
            "instances",
            "or",
            "max",
            "supported",
            "instances",
            "unknown",
            "if",
            "unknown"
        ]
    },
    {
        "id": 1109,
        "code": "public boolean isFormatSupported(Format format) throws MediaCodecUtil.DecoderQueryException {\n  if (!isSampleMimeTypeSupported(format)) {\n    return false;\n  }\n\n  if (!isCodecProfileAndLevelSupported(format)) {\n    return false;\n  }\n\n  if (isVideo) {\n    if (format.width <= 0 || format.height <= 0) {\n      return true;\n    }\n    if (Util.SDK_INT >= 21) {\n      return isVideoSizeAndRateSupportedV21(format.width, format.height, format.frameRate);\n    } else {\n      boolean isFormatSupported =\n          format.width * format.height <= MediaCodecUtil.maxH264DecodableFrameSize();\n      if (!isFormatSupported) {\n        logNoSupport(\"legacyFrameSize, \" + format.width + \"x\" + format.height);\n      }\n      return isFormatSupported;\n    }\n  } else { \n    return Util.SDK_INT < 21\n        || ((format.sampleRate == Format.NO_VALUE\n                || isAudioSampleRateSupportedV21(format.sampleRate))\n            && (format.channelCount == Format.NO_VALUE\n                || isAudioChannelCountSupportedV21(format.channelCount)));\n  }\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "decoder",
            "may",
            "support",
            "decoding",
            "the",
            "given",
            "format"
        ]
    },
    {
        "id": 1110,
        "code": "public boolean isHdr10PlusOutOfBandMetadataSupported() {\n  if (Util.SDK_INT >= 29 && MimeTypes.VIDEO_VP9.equals(mimeType)) {\n    for (CodecProfileLevel capabilities : getProfileLevels()) {\n      if (capabilities.profile == CodecProfileLevel.VP9Profile2HDR10Plus) {\n        return true;\n      }\n    }\n  }\n  return false;\n}",
        "summary_tokens": [
            "whether",
            "the",
            "codec",
            "handles",
            "hdr",
            "0",
            "out",
            "of",
            "band",
            "metadata"
        ]
    },
    {
        "id": 1111,
        "code": "public boolean isSeamlessAdaptationSupported(\n    Format oldFormat, Format newFormat, boolean isNewFormatComplete) {\n  if (!isNewFormatComplete && oldFormat.colorInfo != null && newFormat.colorInfo == null) {\n    newFormat = newFormat.buildUpon().setColorInfo(oldFormat.colorInfo).build();\n  }\n  @DecoderReuseResult int reuseResult = canReuseCodec(oldFormat, newFormat).result;\n  return reuseResult == REUSE_RESULT_YES_WITH_RECONFIGURATION\n      || reuseResult == REUSE_RESULT_YES_WITHOUT_RECONFIGURATION;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "it",
            "is",
            "possible",
            "to",
            "adapt",
            "an",
            "instance",
            "of",
            "this",
            "decoder",
            "seamlessly",
            "from",
            "old",
            "format",
            "to",
            "new",
            "format"
        ]
    },
    {
        "id": 1112,
        "code": "public DecoderReuseEvaluation canReuseCodec(Format oldFormat, Format newFormat) {\n  @DecoderDiscardReasons int discardReasons = 0;\n  if (!Util.areEqual(oldFormat.sampleMimeType, newFormat.sampleMimeType)) {\n    discardReasons |= DISCARD_REASON_MIME_TYPE_CHANGED;\n  }\n\n  if (isVideo) {\n    if (oldFormat.rotationDegrees != newFormat.rotationDegrees) {\n      discardReasons |= DISCARD_REASON_VIDEO_ROTATION_CHANGED;\n    }\n    if (!adaptive\n        && (oldFormat.width != newFormat.width || oldFormat.height != newFormat.height)) {\n      discardReasons |= DISCARD_REASON_VIDEO_RESOLUTION_CHANGED;\n    }\n    if (!Util.areEqual(oldFormat.colorInfo, newFormat.colorInfo)) {\n      discardReasons |= DISCARD_REASON_VIDEO_COLOR_INFO_CHANGED;\n    }\n    if (needsAdaptationReconfigureWorkaround(name)\n        && !oldFormat.initializationDataEquals(newFormat)) {\n      discardReasons |= DISCARD_REASON_WORKAROUND;\n    }\n\n    if (discardReasons == 0) {\n      return new DecoderReuseEvaluation(\n          name,\n          oldFormat,\n          newFormat,\n          oldFormat.initializationDataEquals(newFormat)\n              ? REUSE_RESULT_YES_WITHOUT_RECONFIGURATION\n              : REUSE_RESULT_YES_WITH_RECONFIGURATION,\n           0);\n    }\n  } else {\n    if (oldFormat.channelCount != newFormat.channelCount) {\n      discardReasons |= DISCARD_REASON_AUDIO_CHANNEL_COUNT_CHANGED;\n    }\n    if (oldFormat.sampleRate != newFormat.sampleRate) {\n      discardReasons |= DISCARD_REASON_AUDIO_SAMPLE_RATE_CHANGED;\n    }\n    if (oldFormat.pcmEncoding != newFormat.pcmEncoding) {\n      discardReasons |= DISCARD_REASON_AUDIO_ENCODING_CHANGED;\n    }\n\n      \n      \n    if (discardReasons == 0 && MimeTypes.AUDIO_AAC.equals(mimeType)) {\n      @Nullable\n      Pair<Integer, Integer> oldCodecProfileLevel =\n          MediaCodecUtil.getCodecProfileAndLevel(oldFormat);\n      @Nullable\n      Pair<Integer, Integer> newCodecProfileLevel =\n          MediaCodecUtil.getCodecProfileAndLevel(newFormat);\n      if (oldCodecProfileLevel != null && newCodecProfileLevel != null) {\n        int oldProfile = oldCodecProfileLevel.first;\n        int newProfile = newCodecProfileLevel.first;\n        if (oldProfile == CodecProfileLevel.AACObjectXHE\n            && newProfile == CodecProfileLevel.AACObjectXHE) {\n          return new DecoderReuseEvaluation(\n              name,\n              oldFormat,\n              newFormat,\n              REUSE_RESULT_YES_WITHOUT_RECONFIGURATION,\n               0);\n        }\n      }\n    }\n\n    if (!oldFormat.initializationDataEquals(newFormat)) {\n      discardReasons |= DISCARD_REASON_INITIALIZATION_DATA_CHANGED;\n    }\n    if (needsAdaptationFlushWorkaround(mimeType)) {\n      discardReasons |= DISCARD_REASON_WORKAROUND;\n    }\n\n    if (discardReasons == 0) {\n      return new DecoderReuseEvaluation(\n          name, oldFormat, newFormat, REUSE_RESULT_YES_WITH_FLUSH,  0);\n    }\n  }\n\n  return new DecoderReuseEvaluation(name, oldFormat, newFormat, REUSE_RESULT_NO, discardReasons);\n}",
        "summary_tokens": [
            "evaluates",
            "whether",
            "it",
            "s",
            "possible",
            "to",
            "reuse",
            "an",
            "instance",
            "of",
            "this",
            "decoder",
            "that",
            "s",
            "currently",
            "decoding",
            "old",
            "format",
            "to",
            "decode",
            "new",
            "format",
            "instead"
        ]
    },
    {
        "id": 1113,
        "code": "public boolean isVideoSizeAndRateSupportedV21(int width, int height, double frameRate) {\n  if (capabilities == null) {\n    logNoSupport(\"sizeAndRate.caps\");\n    return false;\n  }\n  VideoCapabilities videoCapabilities = capabilities.getVideoCapabilities();\n  if (videoCapabilities == null) {\n    logNoSupport(\"sizeAndRate.vCaps\");\n    return false;\n  }\n  if (!areSizeAndRateSupportedV21(videoCapabilities, width, height, frameRate)) {\n    if (width >= height\n        || !needsRotatedVerticalResolutionWorkaround(name)\n        || !areSizeAndRateSupportedV21(videoCapabilities, height, width, frameRate)) {\n      logNoSupport(\"sizeAndRate.support, \" + width + \"x\" + height + \"x\" + frameRate);\n      return false;\n    }\n    logAssumedSupport(\"sizeAndRate.rotated, \" + width + \"x\" + height + \"x\" + frameRate);\n  }\n  return true;\n}",
        "summary_tokens": [
            "whether",
            "the",
            "decoder",
            "supports",
            "video",
            "with",
            "a",
            "given",
            "width",
            "height",
            "and",
            "frame",
            "rate"
        ]
    },
    {
        "id": 1114,
        "code": "public Point alignVideoSizeV21(int width, int height) {\n  if (capabilities == null) {\n    return null;\n  }\n  VideoCapabilities videoCapabilities = capabilities.getVideoCapabilities();\n  if (videoCapabilities == null) {\n    return null;\n  }\n  return alignVideoSizeV21(videoCapabilities, width, height);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "smallest",
            "video",
            "size",
            "greater",
            "than",
            "or",
            "equal",
            "to",
            "a",
            "specified",
            "size",
            "that",
            "also",
            "satisfies",
            "the",
            "media",
            "codec",
            "s",
            "width",
            "and",
            "height",
            "alignment",
            "requirements"
        ]
    },
    {
        "id": 1115,
        "code": "public boolean isAudioSampleRateSupportedV21(int sampleRate) {\n  if (capabilities == null) {\n    logNoSupport(\"sampleRate.caps\");\n    return false;\n  }\n  AudioCapabilities audioCapabilities = capabilities.getAudioCapabilities();\n  if (audioCapabilities == null) {\n    logNoSupport(\"sampleRate.aCaps\");\n    return false;\n  }\n  if (!audioCapabilities.isSampleRateSupported(sampleRate)) {\n    logNoSupport(\"sampleRate.support, \" + sampleRate);\n    return false;\n  }\n  return true;\n}",
        "summary_tokens": [
            "whether",
            "the",
            "decoder",
            "supports",
            "audio",
            "with",
            "a",
            "given",
            "sample",
            "rate"
        ]
    },
    {
        "id": 1116,
        "code": "public boolean isAudioChannelCountSupportedV21(int channelCount) {\n  if (capabilities == null) {\n    logNoSupport(\"channelCount.caps\");\n    return false;\n  }\n  AudioCapabilities audioCapabilities = capabilities.getAudioCapabilities();\n  if (audioCapabilities == null) {\n    logNoSupport(\"channelCount.aCaps\");\n    return false;\n  }\n  int maxInputChannelCount =\n      adjustMaxInputChannelCount(name, mimeType, audioCapabilities.getMaxInputChannelCount());\n  if (maxInputChannelCount < channelCount) {\n    logNoSupport(\"channelCount.support, \" + channelCount);\n    return false;\n  }\n  return true;\n}",
        "summary_tokens": [
            "whether",
            "the",
            "decoder",
            "supports",
            "audio",
            "with",
            "a",
            "given",
            "channel",
            "count"
        ]
    },
    {
        "id": 1117,
        "code": "private static CodecProfileLevel[] estimateLegacyVp9ProfileLevels(\n    @Nullable CodecCapabilities capabilities) {\n  int maxBitrate = 0;\n  if (capabilities != null) {\n    @Nullable VideoCapabilities videoCapabilities = capabilities.getVideoCapabilities();\n    if (videoCapabilities != null) {\n      maxBitrate = videoCapabilities.getBitrateRange().getUpper();\n    }\n  }\n\n    \n  int level;\n  if (maxBitrate >= 180_000_000) {\n    level = CodecProfileLevel.VP9Level52;\n  } else if (maxBitrate >= 120_000_000) {\n    level = CodecProfileLevel.VP9Level51;\n  } else if (maxBitrate >= 60_000_000) {\n    level = CodecProfileLevel.VP9Level5;\n  } else if (maxBitrate >= 30_000_000) {\n    level = CodecProfileLevel.VP9Level41;\n  } else if (maxBitrate >= 18_000_000) {\n    level = CodecProfileLevel.VP9Level4;\n  } else if (maxBitrate >= 12_000_000) {\n    level = CodecProfileLevel.VP9Level31;\n  } else if (maxBitrate >= 7_200_000) {\n    level = CodecProfileLevel.VP9Level3;\n  } else if (maxBitrate >= 3_600_000) {\n    level = CodecProfileLevel.VP9Level21;\n  } else if (maxBitrate >= 1_800_000) {\n    level = CodecProfileLevel.VP9Level2;\n  } else if (maxBitrate >= 800_000) {\n    level = CodecProfileLevel.VP9Level11;\n  } else { \n    level = CodecProfileLevel.VP9Level1;\n  }\n\n  CodecProfileLevel profileLevel = new CodecProfileLevel();\n    \n  profileLevel.profile = CodecProfileLevel.VP9Profile0;\n  profileLevel.level = level;\n\n  return new CodecProfileLevel[] {profileLevel};\n}",
        "summary_tokens": [
            "called",
            "on",
            "devices",
            "with",
            "util",
            "sdk",
            "int",
            "0",
            "and",
            "below",
            "for",
            "vp",
            "0",
            "decoders",
            "whose",
            "codec",
            "capabilities",
            "do",
            "not",
            "correctly",
            "report",
            "profile",
            "levels"
        ]
    },
    {
        "id": 1118,
        "code": "private static boolean needsDisableAdaptationWorkaround(String name) {\n  return Util.SDK_INT <= 22\n      && (\"ODROID-XU3\".equals(Util.MODEL) || \"Nexus 10\".equals(Util.MODEL))\n      && (\"OMX.Exynos.AVC.Decoder\".equals(name) || \"OMX.Exynos.AVC.Decoder.secure\".equals(name));\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "decoder",
            "is",
            "known",
            "to",
            "fail",
            "when",
            "adapting",
            "despite",
            "advertising",
            "itself",
            "as",
            "an",
            "adaptive",
            "decoder"
        ]
    },
    {
        "id": 1119,
        "code": "private static boolean needsAdaptationReconfigureWorkaround(String name) {\n  return Util.MODEL.startsWith(\"SM-T230\") && \"OMX.MARVELL.VIDEO.HW.CODA7542DECODER\".equals(name);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "decoder",
            "is",
            "known",
            "to",
            "fail",
            "when",
            "an",
            "attempt",
            "is",
            "made",
            "to",
            "reconfigure",
            "it",
            "with",
            "a",
            "new",
            "format",
            "s",
            "configuration",
            "data"
        ]
    },
    {
        "id": 1120,
        "code": "private static boolean needsAdaptationFlushWorkaround(String mimeType) {\n    \n    \n    \n    \n  return MimeTypes.AUDIO_OPUS.equals(mimeType);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "decoder",
            "is",
            "known",
            "to",
            "behave",
            "incorrectly",
            "if",
            "flushed",
            "to",
            "adapt",
            "to",
            "a",
            "new",
            "format"
        ]
    },
    {
        "id": 1121,
        "code": "private static final boolean needsRotatedVerticalResolutionWorkaround(String name) {\n  if (\"OMX.MTK.VIDEO.DECODER.HEVC\".equals(name) && \"mcv5a\".equals(Util.DEVICE)) {\n      \n    return false;\n  }\n  return true;\n}",
        "summary_tokens": [
            "capabilities",
            "are",
            "known",
            "to",
            "be",
            "inaccurately",
            "reported",
            "for",
            "vertical",
            "resolutions",
            "on",
            "some",
            "devices"
        ]
    },
    {
        "id": 1122,
        "code": "private static boolean needsProfileExcludedWorkaround(String mimeType, int profile) {\n    \n  return MimeTypes.VIDEO_H265.equals(mimeType)\n      && CodecProfileLevel.HEVCProfileMain10 == profile\n      && (\"sailfish\".equals(Util.DEVICE) || \"marlin\".equals(Util.DEVICE));\n}",
        "summary_tokens": [
            "whether",
            "a",
            "profile",
            "is",
            "excluded",
            "from",
            "the",
            "list",
            "of",
            "supported",
            "profiles"
        ]
    },
    {
        "id": 1123,
        "code": "public void setRenderTimeLimitMs(long renderTimeLimitMs) {\n  this.renderTimeLimitMs = renderTimeLimitMs;\n}",
        "summary_tokens": [
            "sets",
            "a",
            "limit",
            "on",
            "the",
            "time",
            "a",
            "single",
            "render",
            "long",
            "long",
            "call",
            "can",
            "spend",
            "draining",
            "and",
            "filling",
            "the",
            "decoder"
        ]
    },
    {
        "id": 1124,
        "code": "protected boolean shouldUseBypass(Format format) {\n  return false;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "buffers",
            "in",
            "the",
            "input",
            "format",
            "can",
            "be",
            "processed",
            "without",
            "a",
            "codec"
        ]
    },
    {
        "id": 1125,
        "code": "protected boolean shouldReinitCodec() {\n  return false;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "renderer",
            "needs",
            "to",
            "re",
            "initialize",
            "the",
            "codec",
            "possibly",
            "as",
            "a",
            "result",
            "of",
            "a",
            "change",
            "in",
            "device",
            "capabilities"
        ]
    },
    {
        "id": 1126,
        "code": "protected boolean getCodecNeedsEosPropagation() {\n  return false;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "codec",
            "needs",
            "the",
            "renderer",
            "to",
            "propagate",
            "the",
            "end",
            "of",
            "stream",
            "signal",
            "directly",
            "rather",
            "than",
            "by",
            "using",
            "an",
            "end",
            "of",
            "stream",
            "buffer",
            "queued",
            "to",
            "the",
            "codec"
        ]
    },
    {
        "id": 1127,
        "code": "protected final void setPendingPlaybackException(ExoPlaybackException exception) {\n  pendingPlaybackException = exception;\n}",
        "summary_tokens": [
            "sets",
            "an",
            "exception",
            "to",
            "be",
            "re",
            "thrown",
            "by",
            "render"
        ]
    },
    {
        "id": 1128,
        "code": "protected final void updateOutputFormatForTime(long presentationTimeUs)\n    throws ExoPlaybackException {\n  boolean outputFormatChanged = false;\n  @Nullable Format format = formatQueue.pollFloor(presentationTimeUs);\n  if (format == null && codecOutputMediaFormatChanged) {\n      \n      \n      \n      \n    format = formatQueue.pollFirst();\n  }\n  if (format != null) {\n    outputFormat = format;\n    outputFormatChanged = true;\n  }\n  if (outputFormatChanged || (codecOutputMediaFormatChanged && outputFormat != null)) {\n    onOutputFormatChanged(outputFormat, codecOutputMediaFormat);\n    codecOutputMediaFormatChanged = false;\n  }\n}",
        "summary_tokens": [
            "updates",
            "the",
            "output",
            "formats",
            "for",
            "the",
            "specified",
            "output",
            "buffer",
            "timestamp",
            "calling",
            "on",
            "output",
            "format",
            "changed",
            "if",
            "a",
            "change",
            "has",
            "occurred"
        ]
    },
    {
        "id": 1129,
        "code": "protected void resetCodecStateForFlush() {\n  resetInputBuffer();\n  resetOutputBuffer();\n  codecHotswapDeadlineMs = C.TIME_UNSET;\n  codecReceivedEos = false;\n  codecReceivedBuffers = false;\n  codecNeedsAdaptationWorkaroundBuffer = false;\n  shouldSkipAdaptationWorkaroundOutputBuffer = false;\n  isDecodeOnlyOutputBuffer = false;\n  isLastOutputBuffer = false;\n  decodeOnlyPresentationTimestamps.clear();\n  largestQueuedPresentationTimeUs = C.TIME_UNSET;\n  lastBufferInStreamPresentationTimeUs = C.TIME_UNSET;\n  if (c2Mp3TimestampTracker != null) {\n    c2Mp3TimestampTracker.reset();\n  }\n  codecDrainState = DRAIN_STATE_NONE;\n  codecDrainAction = DRAIN_ACTION_NONE;\n    \n    \n    \n  codecReconfigurationState =\n      codecReconfigured ? RECONFIGURATION_STATE_WRITE_PENDING : RECONFIGURATION_STATE_NONE;\n}",
        "summary_tokens": [
            "resets",
            "the",
            "renderer",
            "internal",
            "state",
            "after",
            "a",
            "codec",
            "flush"
        ]
    },
    {
        "id": 1130,
        "code": "protected void resetCodecStateForRelease() {\n  resetCodecStateForFlush();\n\n  pendingPlaybackException = null;\n  c2Mp3TimestampTracker = null;\n  availableCodecInfos = null;\n  codecInfo = null;\n  codecInputFormat = null;\n  codecOutputMediaFormat = null;\n  codecOutputMediaFormatChanged = false;\n  codecHasOutputMediaFormat = false;\n  codecOperatingRate = CODEC_OPERATING_RATE_UNSET;\n  codecAdaptationWorkaroundMode = ADAPTATION_WORKAROUND_MODE_NEVER;\n  codecNeedsDiscardToSpsWorkaround = false;\n  codecNeedsFlushWorkaround = false;\n  codecNeedsSosFlushWorkaround = false;\n  codecNeedsEosFlushWorkaround = false;\n  codecNeedsEosOutputExceptionWorkaround = false;\n  codecNeedsEosBufferTimestampWorkaround = false;\n  codecNeedsMonoChannelCountWorkaround = false;\n  codecNeedsEosPropagation = false;\n  codecReconfigured = false;\n  codecReconfigurationState = RECONFIGURATION_STATE_NONE;\n  mediaCryptoRequiresSecureDecoder = false;\n}",
        "summary_tokens": [
            "resets",
            "the",
            "renderer",
            "internal",
            "state",
            "after",
            "a",
            "codec",
            "release"
        ]
    },
    {
        "id": 1131,
        "code": "private boolean readSourceOmittingSampleData(@SampleStream.ReadFlags int readFlags)\n    throws ExoPlaybackException {\n  FormatHolder formatHolder = getFormatHolder();\n  noDataBuffer.clear();\n  @ReadDataResult\n  int result = readSource(formatHolder, noDataBuffer, readFlags | FLAG_OMIT_SAMPLE_DATA);\n  if (result == C.RESULT_FORMAT_READ) {\n    onInputFormatChanged(formatHolder);\n    return true;\n  } else if (result == C.RESULT_BUFFER_READ && noDataBuffer.isEndOfStream()) {\n    inputStreamEnded = true;\n    processEndOfStream();\n  }\n  return false;\n}",
        "summary_tokens": [
            "reads",
            "from",
            "the",
            "source",
            "when",
            "sample",
            "data",
            "is",
            "not",
            "required"
        ]
    },
    {
        "id": 1132,
        "code": "private void initBypass(Format format) {\n  disableBypass(); \n\n  String mimeType = format.sampleMimeType;\n  if (!MimeTypes.AUDIO_AAC.equals(mimeType)\n      && !MimeTypes.AUDIO_MPEG.equals(mimeType)\n      && !MimeTypes.AUDIO_OPUS.equals(mimeType)) {\n      \n    bypassBatchBuffer.setMaxSampleCount(1);\n  } else {\n    bypassBatchBuffer.setMaxSampleCount(BatchBuffer.DEFAULT_MAX_SAMPLE_COUNT);\n  }\n  bypassEnabled = true;\n}",
        "summary_tokens": [
            "configures",
            "rendering",
            "where",
            "no",
            "codec",
            "is",
            "used"
        ]
    },
    {
        "id": 1133,
        "code": "private boolean feedInputBuffer() throws ExoPlaybackException {\n  if (codec == null || codecDrainState == DRAIN_STATE_WAIT_END_OF_STREAM || inputStreamEnded) {\n    return false;\n  }\n  if (codecDrainState == DRAIN_STATE_NONE && shouldReinitCodec()) {\n    drainAndReinitializeCodec();\n  }\n\n  if (inputIndex < 0) {\n    inputIndex = codec.dequeueInputBufferIndex();\n    if (inputIndex < 0) {\n      return false;\n    }\n    buffer.data = codec.getInputBuffer(inputIndex);\n    buffer.clear();\n  }\n\n  if (codecDrainState == DRAIN_STATE_SIGNAL_END_OF_STREAM) {\n      \n      \n    if (codecNeedsEosPropagation) {\n        \n    } else {\n      codecReceivedEos = true;\n      codec.queueInputBuffer(inputIndex, 0, 0, 0, MediaCodec.BUFFER_FLAG_END_OF_STREAM);\n      resetInputBuffer();\n    }\n    codecDrainState = DRAIN_STATE_WAIT_END_OF_STREAM;\n    return false;\n  }\n\n  if (codecNeedsAdaptationWorkaroundBuffer) {\n    codecNeedsAdaptationWorkaroundBuffer = false;\n    buffer.data.put(ADAPTATION_WORKAROUND_BUFFER);\n    codec.queueInputBuffer(inputIndex, 0, ADAPTATION_WORKAROUND_BUFFER.length, 0, 0);\n    resetInputBuffer();\n    codecReceivedBuffers = true;\n    return true;\n  }\n\n    \n    \n  if (codecReconfigurationState == RECONFIGURATION_STATE_WRITE_PENDING) {\n    for (int i = 0; i < codecInputFormat.initializationData.size(); i++) {\n      byte[] data = codecInputFormat.initializationData.get(i);\n      buffer.data.put(data);\n    }\n    codecReconfigurationState = RECONFIGURATION_STATE_QUEUE_PENDING;\n  }\n  int adaptiveReconfigurationBytes = buffer.data.position();\n\n  FormatHolder formatHolder = getFormatHolder();\n\n  @SampleStream.ReadDataResult int result;\n  try {\n    result = readSource(formatHolder, buffer,  0);\n  } catch (InsufficientCapacityException e) {\n    onCodecError(e);\n      \n      \n    readSourceOmittingSampleData( 0);\n    flushCodec();\n    return true;\n  }\n\n  if (hasReadStreamToEnd()) {\n      \n    lastBufferInStreamPresentationTimeUs = largestQueuedPresentationTimeUs;\n  }\n\n  if (result == C.RESULT_NOTHING_READ) {\n    return false;\n  }\n  if (result == C.RESULT_FORMAT_READ) {\n    if (codecReconfigurationState == RECONFIGURATION_STATE_QUEUE_PENDING) {\n        \n        \n      buffer.clear();\n      codecReconfigurationState = RECONFIGURATION_STATE_WRITE_PENDING;\n    }\n    onInputFormatChanged(formatHolder);\n    return true;\n  }\n\n    \n  if (buffer.isEndOfStream()) {\n    if (codecReconfigurationState == RECONFIGURATION_STATE_QUEUE_PENDING) {\n        \n        \n        \n      buffer.clear();\n      codecReconfigurationState = RECONFIGURATION_STATE_WRITE_PENDING;\n    }\n    inputStreamEnded = true;\n    if (!codecReceivedBuffers) {\n      processEndOfStream();\n      return false;\n    }\n    try {\n      if (codecNeedsEosPropagation) {\n          \n      } else {\n        codecReceivedEos = true;\n        codec.queueInputBuffer(\n            inputIndex,\n             0,\n             0,\n             0,\n            MediaCodec.BUFFER_FLAG_END_OF_STREAM);\n        resetInputBuffer();\n      }\n    } catch (CryptoException e) {\n      throw createRendererException(\n          e, inputFormat, Util.getErrorCodeForMediaDrmErrorCode(e.getErrorCode()));\n    }\n    return false;\n  }\n\n    \n    \n    \n    \n    \n    \n  if (!codecReceivedBuffers && !buffer.isKeyFrame()) {\n    buffer.clear();\n    if (codecReconfigurationState == RECONFIGURATION_STATE_QUEUE_PENDING) {\n        \n        \n      codecReconfigurationState = RECONFIGURATION_STATE_WRITE_PENDING;\n    }\n    return true;\n  }\n\n  boolean bufferEncrypted = buffer.isEncrypted();\n  if (bufferEncrypted) {\n    buffer.cryptoInfo.increaseClearDataFirstSubSampleBy(adaptiveReconfigurationBytes);\n  }\n  if (codecNeedsDiscardToSpsWorkaround && !bufferEncrypted) {\n    NalUnitUtil.discardToSps(buffer.data);\n    if (buffer.data.position() == 0) {\n      return true;\n    }\n    codecNeedsDiscardToSpsWorkaround = false;\n  }\n\n  long presentationTimeUs = buffer.timeUs;\n\n  if (c2Mp3TimestampTracker != null) {\n    presentationTimeUs =\n        c2Mp3TimestampTracker.updateAndGetPresentationTimeUs(inputFormat, buffer);\n      \n      \n      \n      \n    largestQueuedPresentationTimeUs =\n        max(\n            largestQueuedPresentationTimeUs,\n            c2Mp3TimestampTracker.getLastOutputBufferPresentationTimeUs(inputFormat));\n  }\n\n  if (buffer.isDecodeOnly()) {\n    decodeOnlyPresentationTimestamps.add(presentationTimeUs);\n  }\n  if (waitingForFirstSampleInFormat) {\n    formatQueue.add(presentationTimeUs, inputFormat);\n    waitingForFirstSampleInFormat = false;\n  }\n  largestQueuedPresentationTimeUs = max(largestQueuedPresentationTimeUs, presentationTimeUs);\n  buffer.flip();\n  if (buffer.hasSupplementalData()) {\n    handleInputBufferSupplementalData(buffer);\n  }\n\n  onQueueInputBuffer(buffer);\n  try {\n    if (bufferEncrypted) {\n      codec.queueSecureInputBuffer(\n          inputIndex,  0, buffer.cryptoInfo, presentationTimeUs,  0);\n    } else {\n      codec.queueInputBuffer(\n          inputIndex,  0, buffer.data.limit(), presentationTimeUs,  0);\n    }\n  } catch (CryptoException e) {\n    throw createRendererException(\n        e, inputFormat, Util.getErrorCodeForMediaDrmErrorCode(e.getErrorCode()));\n  }\n\n  resetInputBuffer();\n  codecReceivedBuffers = true;\n  codecReconfigurationState = RECONFIGURATION_STATE_NONE;\n  decoderCounters.queuedInputBufferCount++;\n  return true;\n}",
        "summary_tokens": [
            "whether",
            "it",
            "may",
            "be",
            "possible",
            "to",
            "feed",
            "more",
            "input",
            "data"
        ]
    },
    {
        "id": 1134,
        "code": "protected void onCodecInitialized(\n    String name,\n    MediaCodecAdapter.Configuration configuration,\n    long initializedTimestampMs,\n    long initializationDurationMs) {\n    \n}",
        "summary_tokens": [
            "called",
            "when",
            "a",
            "media",
            "codec",
            "has",
            "been",
            "created",
            "and",
            "configured"
        ]
    },
    {
        "id": 1135,
        "code": "protected void onCodecReleased(String name) {\n    \n}",
        "summary_tokens": [
            "called",
            "when",
            "a",
            "media",
            "codec",
            "has",
            "been",
            "released"
        ]
    },
    {
        "id": 1136,
        "code": "protected void onCodecError(Exception codecError) {\n    \n}",
        "summary_tokens": [
            "called",
            "when",
            "a",
            "codec",
            "error",
            "has",
            "occurred"
        ]
    },
    {
        "id": 1137,
        "code": "protected DecoderReuseEvaluation onInputFormatChanged(FormatHolder formatHolder)\n    throws ExoPlaybackException {\n  waitingForFirstSampleInFormat = true;\n  Format newFormat = checkNotNull(formatHolder.format);\n  if (newFormat.sampleMimeType == null) {\n      \n      \n\n    throw createRendererException(\n        new IllegalArgumentException(),\n        newFormat,\n        PlaybackException.ERROR_CODE_DECODING_FORMAT_UNSUPPORTED);\n  }\n  setSourceDrmSession(formatHolder.drmSession);\n  inputFormat = newFormat;\n\n  if (bypassEnabled) {\n    bypassDrainAndReinitialize = true;\n    return null; \n  }\n\n  if (codec == null) {\n    availableCodecInfos = null;\n    maybeInitCodecOrBypass();\n    return null;\n  }\n\n    \n    \n    \n\n    \n    \n  MediaCodecAdapter codec = this.codec;\n  MediaCodecInfo codecInfo = this.codecInfo;\n\n  Format oldFormat = codecInputFormat;\n  if (drmNeedsCodecReinitialization(codecInfo, newFormat, codecDrmSession, sourceDrmSession)) {\n    drainAndReinitializeCodec();\n    return new DecoderReuseEvaluation(\n        codecInfo.name,\n        oldFormat,\n        newFormat,\n        REUSE_RESULT_NO,\n        DISCARD_REASON_DRM_SESSION_CHANGED);\n  }\n  boolean drainAndUpdateCodecDrmSession = sourceDrmSession != codecDrmSession;\n  Assertions.checkState(!drainAndUpdateCodecDrmSession || Util.SDK_INT >= 23);\n\n  DecoderReuseEvaluation evaluation = canReuseCodec(codecInfo, oldFormat, newFormat);\n  @DecoderDiscardReasons int overridingDiscardReasons = 0;\n  switch (evaluation.result) {\n    case REUSE_RESULT_NO:\n      drainAndReinitializeCodec();\n      break;\n    case REUSE_RESULT_YES_WITH_FLUSH:\n      if (!updateCodecOperatingRate(newFormat)) {\n        overridingDiscardReasons |= DISCARD_REASON_OPERATING_RATE_CHANGED;\n      } else {\n        codecInputFormat = newFormat;\n        if (drainAndUpdateCodecDrmSession) {\n          if (!drainAndUpdateCodecDrmSessionV23()) {\n            overridingDiscardReasons |= DISCARD_REASON_WORKAROUND;\n          }\n        } else if (!drainAndFlushCodec()) {\n          overridingDiscardReasons |= DISCARD_REASON_WORKAROUND;\n        }\n      }\n      break;\n    case REUSE_RESULT_YES_WITH_RECONFIGURATION:\n      if (!updateCodecOperatingRate(newFormat)) {\n        overridingDiscardReasons |= DISCARD_REASON_OPERATING_RATE_CHANGED;\n      } else {\n        codecReconfigured = true;\n        codecReconfigurationState = RECONFIGURATION_STATE_WRITE_PENDING;\n        codecNeedsAdaptationWorkaroundBuffer =\n            codecAdaptationWorkaroundMode == ADAPTATION_WORKAROUND_MODE_ALWAYS\n                || (codecAdaptationWorkaroundMode == ADAPTATION_WORKAROUND_MODE_SAME_RESOLUTION\n                    && newFormat.width == oldFormat.width\n                    && newFormat.height == oldFormat.height);\n        codecInputFormat = newFormat;\n        if (drainAndUpdateCodecDrmSession && !drainAndUpdateCodecDrmSessionV23()) {\n          overridingDiscardReasons |= DISCARD_REASON_WORKAROUND;\n        }\n      }\n      break;\n    case REUSE_RESULT_YES_WITHOUT_RECONFIGURATION:\n      if (!updateCodecOperatingRate(newFormat)) {\n        overridingDiscardReasons |= DISCARD_REASON_OPERATING_RATE_CHANGED;\n      } else {\n        codecInputFormat = newFormat;\n        if (drainAndUpdateCodecDrmSession && !drainAndUpdateCodecDrmSessionV23()) {\n          overridingDiscardReasons |= DISCARD_REASON_WORKAROUND;\n        }\n      }\n      break;\n    default:\n      throw new IllegalStateException(); \n  }\n\n  if (evaluation.result != REUSE_RESULT_NO\n      && (this.codec != codec || codecDrainAction == DRAIN_ACTION_REINITIALIZE)) {\n      \n      \n    return new DecoderReuseEvaluation(\n        codecInfo.name, oldFormat, newFormat, REUSE_RESULT_NO, overridingDiscardReasons);\n  }\n\n  return evaluation;\n}",
        "summary_tokens": [
            "called",
            "when",
            "a",
            "new",
            "format",
            "is",
            "read",
            "from",
            "the",
            "upstream",
            "media",
            "period"
        ]
    },
    {
        "id": 1138,
        "code": "protected void onOutputFormatChanged(Format format, @Nullable MediaFormat mediaFormat)",
        "summary_tokens": [
            "called",
            "when",
            "one",
            "of",
            "the",
            "output",
            "formats",
            "changes"
        ]
    },
    {
        "id": 1139,
        "code": "protected void handleInputBufferSupplementalData(DecoderInputBuffer buffer)",
        "summary_tokens": [
            "handles",
            "supplemental",
            "data",
            "associated",
            "with",
            "an",
            "input",
            "buffer"
        ]
    },
    {
        "id": 1140,
        "code": "protected void onQueueInputBuffer(DecoderInputBuffer buffer) throws ExoPlaybackException {\n    \n}",
        "summary_tokens": [
            "called",
            "immediately",
            "before",
            "an",
            "input",
            "buffer",
            "is",
            "queued",
            "into",
            "the",
            "codec"
        ]
    },
    {
        "id": 1141,
        "code": "protected void onProcessedOutputBuffer(long presentationTimeUs) {\n  while (pendingOutputStreamOffsetCount != 0\n      && presentationTimeUs >= pendingOutputStreamSwitchTimesUs[0]) {\n    outputStreamStartPositionUs = pendingOutputStreamStartPositionsUs[0];\n    outputStreamOffsetUs = pendingOutputStreamOffsetsUs[0];\n    pendingOutputStreamOffsetCount--;\n    System.arraycopy(\n        pendingOutputStreamStartPositionsUs,\n         1,\n        pendingOutputStreamStartPositionsUs,\n         0,\n        pendingOutputStreamOffsetCount);\n    System.arraycopy(\n        pendingOutputStreamOffsetsUs,\n         1,\n        pendingOutputStreamOffsetsUs,\n         0,\n        pendingOutputStreamOffsetCount);\n    System.arraycopy(\n        pendingOutputStreamSwitchTimesUs,\n         1,\n        pendingOutputStreamSwitchTimesUs,\n         0,\n        pendingOutputStreamOffsetCount);\n    onProcessedStreamChange();\n  }\n}",
        "summary_tokens": [
            "called",
            "when",
            "an",
            "output",
            "buffer",
            "is",
            "successfully",
            "processed"
        ]
    },
    {
        "id": 1142,
        "code": "protected void onProcessedStreamChange() {\n    \n}",
        "summary_tokens": [
            "called",
            "after",
            "the",
            "last",
            "output",
            "buffer",
            "before",
            "a",
            "stream",
            "change",
            "has",
            "been",
            "processed"
        ]
    },
    {
        "id": 1143,
        "code": "protected DecoderReuseEvaluation canReuseCodec(\n    MediaCodecInfo codecInfo, Format oldFormat, Format newFormat) {\n  return new DecoderReuseEvaluation(\n      codecInfo.name,\n      oldFormat,\n      newFormat,\n      REUSE_RESULT_NO,\n      DISCARD_REASON_REUSE_NOT_IMPLEMENTED);\n}",
        "summary_tokens": [
            "evaluates",
            "whether",
            "the",
            "existing",
            "media",
            "codec",
            "can",
            "be",
            "kept",
            "for",
            "a",
            "new",
            "format",
            "and",
            "if",
            "it",
            "can",
            "whether",
            "it",
            "requires",
            "reconfiguration"
        ]
    },
    {
        "id": 1144,
        "code": "protected float getPlaybackSpeed() {\n  return currentPlaybackSpeed;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "current",
            "playback",
            "speed",
            "as",
            "set",
            "by",
            "set",
            "playback",
            "speed"
        ]
    },
    {
        "id": 1145,
        "code": "protected float getCodecOperatingRate() {\n  return codecOperatingRate;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "operating",
            "rate",
            "used",
            "by",
            "the",
            "current",
            "codec"
        ]
    },
    {
        "id": 1146,
        "code": "protected float getCodecOperatingRateV23(\n    float targetPlaybackSpeed, Format format, Format[] streamFormats) {\n  return CODEC_OPERATING_RATE_UNSET;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "media",
            "format",
            "key",
            "operating",
            "rate",
            "value",
            "for",
            "a",
            "given",
            "playback",
            "speed",
            "current",
            "format",
            "and",
            "set",
            "of",
            "possible",
            "stream",
            "formats"
        ]
    },
    {
        "id": 1147,
        "code": "private boolean updateCodecOperatingRate(Format format) throws ExoPlaybackException {\n  if (Util.SDK_INT < 23) {\n    return true;\n  }\n\n  if (codec == null\n      || codecDrainAction == DRAIN_ACTION_REINITIALIZE\n      || getState() == STATE_DISABLED) {\n      \n    return true;\n  }\n\n  float newCodecOperatingRate =\n      getCodecOperatingRateV23(targetPlaybackSpeed, format, getStreamFormats());\n  if (codecOperatingRate == newCodecOperatingRate) {\n      \n    return true;\n  } else if (newCodecOperatingRate == CODEC_OPERATING_RATE_UNSET) {\n      \n      \n    drainAndReinitializeCodec();\n    return false;\n  } else if (codecOperatingRate != CODEC_OPERATING_RATE_UNSET\n      || newCodecOperatingRate > assumedMinimumCodecOperatingRate) {\n      \n      \n    Bundle codecParameters = new Bundle();\n    codecParameters.putFloat(MediaFormat.KEY_OPERATING_RATE, newCodecOperatingRate);\n    codec.setParameters(codecParameters);\n    codecOperatingRate = newCodecOperatingRate;\n    return true;\n  }\n\n  return true;\n}",
        "summary_tokens": [
            "updates",
            "the",
            "codec",
            "operating",
            "rate",
            "or",
            "triggers",
            "codec",
            "release",
            "and",
            "re",
            "initialization",
            "if",
            "a",
            "previously",
            "set",
            "operating",
            "rate",
            "needs",
            "to",
            "be",
            "cleared"
        ]
    },
    {
        "id": 1148,
        "code": "private boolean drainAndFlushCodec() {\n  if (codecReceivedBuffers) {\n    codecDrainState = DRAIN_STATE_SIGNAL_END_OF_STREAM;\n    if (codecNeedsFlushWorkaround || codecNeedsEosFlushWorkaround) {\n      codecDrainAction = DRAIN_ACTION_REINITIALIZE;\n      return false;\n    } else {\n      codecDrainAction = DRAIN_ACTION_FLUSH;\n    }\n  }\n  return true;\n}",
        "summary_tokens": [
            "starts",
            "draining",
            "the",
            "codec",
            "for",
            "a",
            "flush",
            "or",
            "to",
            "release",
            "and",
            "re",
            "initialize",
            "the",
            "codec",
            "if",
            "flushing",
            "will",
            "not",
            "be",
            "possible"
        ]
    },
    {
        "id": 1149,
        "code": "private boolean drainAndUpdateCodecDrmSessionV23() throws ExoPlaybackException {\n  if (codecReceivedBuffers) {\n    codecDrainState = DRAIN_STATE_SIGNAL_END_OF_STREAM;\n    if (codecNeedsFlushWorkaround || codecNeedsEosFlushWorkaround) {\n      codecDrainAction = DRAIN_ACTION_REINITIALIZE;\n      return false;\n    } else {\n      codecDrainAction = DRAIN_ACTION_FLUSH_AND_UPDATE_DRM_SESSION;\n    }\n  } else {\n      \n    updateDrmSessionV23();\n  }\n  return true;\n}",
        "summary_tokens": [
            "starts",
            "draining",
            "the",
            "codec",
            "to",
            "flush",
            "it",
            "and",
            "update",
            "its",
            "drm",
            "session",
            "or",
            "to",
            "release",
            "and",
            "re",
            "initialize",
            "the",
            "codec",
            "if",
            "flushing",
            "will",
            "not",
            "be",
            "possible"
        ]
    },
    {
        "id": 1150,
        "code": "private void drainAndReinitializeCodec() throws ExoPlaybackException {\n  if (codecReceivedBuffers) {\n    codecDrainState = DRAIN_STATE_SIGNAL_END_OF_STREAM;\n    codecDrainAction = DRAIN_ACTION_REINITIALIZE;\n  } else {\n      \n    reinitializeCodec();\n  }\n}",
        "summary_tokens": [
            "starts",
            "draining",
            "the",
            "codec",
            "for",
            "re",
            "initialization"
        ]
    },
    {
        "id": 1151,
        "code": "private boolean drainOutputBuffer(long positionUs, long elapsedRealtimeUs)\n    throws ExoPlaybackException {\n  if (!hasOutputBuffer()) {\n    int outputIndex;\n    if (codecNeedsEosOutputExceptionWorkaround && codecReceivedEos) {\n      try {\n        outputIndex = codec.dequeueOutputBufferIndex(outputBufferInfo);\n      } catch (IllegalStateException e) {\n        processEndOfStream();\n        if (outputStreamEnded) {\n            \n          releaseCodec();\n        }\n        return false;\n      }\n    } else {\n      outputIndex = codec.dequeueOutputBufferIndex(outputBufferInfo);\n    }\n\n    if (outputIndex < 0) {\n      if (outputIndex == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED ) {\n        processOutputMediaFormatChanged();\n        return true;\n      }\n        \n      if (codecNeedsEosPropagation\n          && (inputStreamEnded || codecDrainState == DRAIN_STATE_WAIT_END_OF_STREAM)) {\n        processEndOfStream();\n      }\n      return false;\n    }\n\n      \n    if (shouldSkipAdaptationWorkaroundOutputBuffer) {\n      shouldSkipAdaptationWorkaroundOutputBuffer = false;\n      codec.releaseOutputBuffer(outputIndex, false);\n      return true;\n    } else if (outputBufferInfo.size == 0\n        && (outputBufferInfo.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {\n        \n      processEndOfStream();\n      return false;\n    }\n\n    this.outputIndex = outputIndex;\n    outputBuffer = codec.getOutputBuffer(outputIndex);\n\n      \n      \n    if (outputBuffer != null) {\n      outputBuffer.position(outputBufferInfo.offset);\n      outputBuffer.limit(outputBufferInfo.offset + outputBufferInfo.size);\n    }\n    if (codecNeedsEosBufferTimestampWorkaround\n        && outputBufferInfo.presentationTimeUs == 0\n        && (outputBufferInfo.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0\n        && largestQueuedPresentationTimeUs != C.TIME_UNSET) {\n      outputBufferInfo.presentationTimeUs = largestQueuedPresentationTimeUs;\n    }\n    isDecodeOnlyOutputBuffer = isDecodeOnlyBuffer(outputBufferInfo.presentationTimeUs);\n    isLastOutputBuffer =\n        lastBufferInStreamPresentationTimeUs == outputBufferInfo.presentationTimeUs;\n    updateOutputFormatForTime(outputBufferInfo.presentationTimeUs);\n  }\n\n  boolean processedOutputBuffer;\n  if (codecNeedsEosOutputExceptionWorkaround && codecReceivedEos) {\n    try {\n      processedOutputBuffer =\n          processOutputBuffer(\n              positionUs,\n              elapsedRealtimeUs,\n              codec,\n              outputBuffer,\n              outputIndex,\n              outputBufferInfo.flags,\n               1,\n              outputBufferInfo.presentationTimeUs,\n              isDecodeOnlyOutputBuffer,\n              isLastOutputBuffer,\n              outputFormat);\n    } catch (IllegalStateException e) {\n      processEndOfStream();\n      if (outputStreamEnded) {\n          \n        releaseCodec();\n      }\n      return false;\n    }\n  } else {\n    processedOutputBuffer =\n        processOutputBuffer(\n            positionUs,\n            elapsedRealtimeUs,\n            codec,\n            outputBuffer,\n            outputIndex,\n            outputBufferInfo.flags,\n             1,\n            outputBufferInfo.presentationTimeUs,\n            isDecodeOnlyOutputBuffer,\n            isLastOutputBuffer,\n            outputFormat);\n  }\n\n  if (processedOutputBuffer) {\n    onProcessedOutputBuffer(outputBufferInfo.presentationTimeUs);\n    boolean isEndOfStream = (outputBufferInfo.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;\n    resetOutputBuffer();\n    if (!isEndOfStream) {\n      return true;\n    }\n    processEndOfStream();\n  }\n\n  return false;\n}",
        "summary_tokens": [
            "whether",
            "it",
            "may",
            "be",
            "possible",
            "to",
            "drain",
            "more",
            "output",
            "data"
        ]
    },
    {
        "id": 1152,
        "code": "private void processOutputMediaFormatChanged() {\n  codecHasOutputMediaFormat = true;\n  MediaFormat mediaFormat = codec.getOutputFormat();\n  if (codecAdaptationWorkaroundMode != ADAPTATION_WORKAROUND_MODE_NEVER\n      && mediaFormat.getInteger(MediaFormat.KEY_WIDTH) == ADAPTATION_WORKAROUND_SLICE_WIDTH_HEIGHT\n      && mediaFormat.getInteger(MediaFormat.KEY_HEIGHT)\n          == ADAPTATION_WORKAROUND_SLICE_WIDTH_HEIGHT) {\n      \n    shouldSkipAdaptationWorkaroundOutputBuffer = true;\n    return;\n  }\n  if (codecNeedsMonoChannelCountWorkaround) {\n    mediaFormat.setInteger(MediaFormat.KEY_CHANNEL_COUNT, 1);\n  }\n  codecOutputMediaFormat = mediaFormat;\n  codecOutputMediaFormatChanged = true;\n}",
        "summary_tokens": [
            "processes",
            "a",
            "change",
            "in",
            "the",
            "decoder",
            "output",
            "media",
            "format"
        ]
    },
    {
        "id": 1153,
        "code": "protected void renderToEndOfStream() throws ExoPlaybackException {\n    \n}",
        "summary_tokens": [
            "incrementally",
            "renders",
            "any",
            "remaining",
            "output"
        ]
    },
    {
        "id": 1154,
        "code": "private void processEndOfStream() throws ExoPlaybackException {\n  switch (codecDrainAction) {\n    case DRAIN_ACTION_REINITIALIZE:\n      reinitializeCodec();\n      break;\n    case DRAIN_ACTION_FLUSH_AND_UPDATE_DRM_SESSION:\n      flushCodec();\n      updateDrmSessionV23();\n      break;\n    case DRAIN_ACTION_FLUSH:\n      flushCodec();\n      break;\n    case DRAIN_ACTION_NONE:\n    default:\n      outputStreamEnded = true;\n      renderToEndOfStream();\n      break;\n  }\n}",
        "summary_tokens": [
            "processes",
            "an",
            "end",
            "of",
            "stream",
            "signal"
        ]
    },
    {
        "id": 1155,
        "code": "protected final void setPendingOutputEndOfStream() {\n  pendingOutputEndOfStream = true;\n}",
        "summary_tokens": [
            "notifies",
            "the",
            "renderer",
            "that",
            "output",
            "end",
            "of",
            "stream",
            "is",
            "pending",
            "and",
            "should",
            "be",
            "handled",
            "on",
            "the",
            "next",
            "render"
        ]
    },
    {
        "id": 1156,
        "code": "protected final long getOutputStreamOffsetUs() {\n  return outputStreamOffsetUs;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "offset",
            "that",
            "should",
            "be",
            "subtracted",
            "from",
            "buffer",
            "presentation",
            "time",
            "us",
            "in",
            "process",
            "output",
            "buffer",
            "long",
            "long",
            "media",
            "codec",
            "adapter",
            "byte",
            "buffer",
            "int",
            "int",
            "int",
            "long",
            "boolean",
            "boolean",
            "format",
            "to",
            "get",
            "the",
            "playback",
            "position",
            "with",
            "respect",
            "to",
            "the",
            "media"
        ]
    },
    {
        "id": 1157,
        "code": "protected static boolean supportsFormatDrm(Format format) {\n  return format.cryptoType == C.CRYPTO_TYPE_NONE || format.cryptoType == C.CRYPTO_TYPE_FRAMEWORK;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "this",
            "renderer",
            "supports",
            "the",
            "given",
            "format",
            "format",
            "s",
            "drm",
            "scheme"
        ]
    },
    {
        "id": 1158,
        "code": "private boolean drmNeedsCodecReinitialization(\n    MediaCodecInfo codecInfo,\n    Format newFormat,\n    @Nullable DrmSession oldSession,\n    @Nullable DrmSession newSession)\n    throws ExoPlaybackException {\n  if (oldSession == newSession) {\n      \n    return false;\n  }\n\n    \n\n  if (newSession == null || oldSession == null) {\n      \n    return true;\n  }\n\n    \n\n  if (Util.SDK_INT < 23) {\n      \n      \n    return true;\n  }\n  if (C.PLAYREADY_UUID.equals(oldSession.getSchemeUuid())\n      || C.PLAYREADY_UUID.equals(newSession.getSchemeUuid())) {\n      \n      \n      \n    return true;\n  }\n  @Nullable FrameworkCryptoConfig newCryptoConfig = getFrameworkCryptoConfig(newSession);\n  if (newCryptoConfig == null) {\n      \n      \n      \n      \n      \n      \n      \n    return true;\n  }\n\n  boolean requiresSecureDecoder;\n  if (newCryptoConfig.forceAllowInsecureDecoderComponents) {\n    requiresSecureDecoder = false;\n  } else {\n    requiresSecureDecoder = newSession.requiresSecureDecoder(newFormat.sampleMimeType);\n  }\n  if (!codecInfo.secure && requiresSecureDecoder) {\n      \n      \n    return true;\n  }\n\n  return false;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "it",
            "s",
            "necessary",
            "to",
            "re",
            "initialize",
            "the",
            "codec",
            "to",
            "handle",
            "a",
            "drm",
            "change"
        ]
    },
    {
        "id": 1159,
        "code": "private boolean bypassRender(long positionUs, long elapsedRealtimeUs)\n    throws ExoPlaybackException {\n\n    \n  checkState(!outputStreamEnded);\n  if (bypassBatchBuffer.hasSamples()) {\n    if (processOutputBuffer(\n        positionUs,\n        elapsedRealtimeUs,\n         null,\n        bypassBatchBuffer.data,\n        outputIndex,\n         0,\n        bypassBatchBuffer.getSampleCount(),\n        bypassBatchBuffer.getFirstSampleTimeUs(),\n        bypassBatchBuffer.isDecodeOnly(),\n        bypassBatchBuffer.isEndOfStream(),\n        outputFormat)) {\n        \n      onProcessedOutputBuffer(bypassBatchBuffer.getLastSampleTimeUs());\n      bypassBatchBuffer.clear();\n    } else {\n        \n      return false;\n    }\n  }\n\n    \n  if (inputStreamEnded) {\n    outputStreamEnded = true;\n    return false;\n  }\n\n  if (bypassSampleBufferPending) {\n    Assertions.checkState(bypassBatchBuffer.append(bypassSampleBuffer));\n    bypassSampleBufferPending = false;\n  }\n\n  if (bypassDrainAndReinitialize) {\n    if (bypassBatchBuffer.hasSamples()) {\n        \n        \n      return true;\n    }\n      \n    disableBypass();\n    bypassDrainAndReinitialize = false;\n    maybeInitCodecOrBypass();\n    if (!bypassEnabled) {\n        \n      return false;\n    }\n  }\n\n    \n  bypassRead();\n\n  if (bypassBatchBuffer.hasSamples()) {\n    bypassBatchBuffer.flip();\n  }\n\n    \n    \n  return bypassBatchBuffer.hasSamples() || inputStreamEnded || bypassDrainAndReinitialize;\n}",
        "summary_tokens": [
            "processes",
            "any",
            "pending",
            "batch",
            "of",
            "buffers",
            "without",
            "using",
            "a",
            "decoder",
            "and",
            "drains",
            "a",
            "new",
            "batch",
            "of",
            "buffers",
            "from",
            "the",
            "source"
        ]
    },
    {
        "id": 1160,
        "code": "private static boolean codecNeedsFlushWorkaround(String name) {\n  return Util.SDK_INT < 18\n      || (Util.SDK_INT == 18\n          && (\"OMX.SEC.avc.dec\".equals(name) || \"OMX.SEC.avc.dec.secure\".equals(name)))\n      || (Util.SDK_INT == 19\n          && Util.MODEL.startsWith(\"SM-G800\")\n          && (\"OMX.Exynos.avc.dec\".equals(name) || \"OMX.Exynos.avc.dec.secure\".equals(name)));\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "decoder",
            "is",
            "known",
            "to",
            "fail",
            "when",
            "flushed"
        ]
    },
    {
        "id": 1161,
        "code": "private @AdaptationWorkaroundMode int codecAdaptationWorkaroundMode(String name) {\n  if (Util.SDK_INT <= 25\n      && \"OMX.Exynos.avc.dec.secure\".equals(name)\n      && (Util.MODEL.startsWith(\"SM-T585\")\n          || Util.MODEL.startsWith(\"SM-A510\")\n          || Util.MODEL.startsWith(\"SM-A520\")\n          || Util.MODEL.startsWith(\"SM-J700\"))) {\n    return ADAPTATION_WORKAROUND_MODE_ALWAYS;\n  } else if (Util.SDK_INT < 24\n      && (\"OMX.Nvidia.h264.decode\".equals(name) || \"OMX.Nvidia.h264.decode.secure\".equals(name))\n      && (\"flounder\".equals(Util.DEVICE)\n          || \"flounder_lte\".equals(Util.DEVICE)\n          || \"grouper\".equals(Util.DEVICE)\n          || \"tilapia\".equals(Util.DEVICE))) {\n    return ADAPTATION_WORKAROUND_MODE_SAME_RESOLUTION;\n  } else {\n    return ADAPTATION_WORKAROUND_MODE_NEVER;\n  }\n}",
        "summary_tokens": [
            "returns",
            "a",
            "mode",
            "that",
            "specifies",
            "when",
            "the",
            "adaptation",
            "workaround",
            "should",
            "be",
            "enabled"
        ]
    },
    {
        "id": 1162,
        "code": "private static boolean codecNeedsDiscardToSpsWorkaround(String name, Format format) {\n  return Util.SDK_INT < 21\n      && format.initializationData.isEmpty()\n      && \"OMX.MTK.VIDEO.DECODER.AVC\".equals(name);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "decoder",
            "is",
            "an",
            "h"
        ]
    },
    {
        "id": 1163,
        "code": "private static boolean codecNeedsSosFlushWorkaround(String name) {\n  return Util.SDK_INT == 29 && \"c2.android.aac.decoder\".equals(name);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "decoder",
            "is",
            "known",
            "to",
            "behave",
            "incorrectly",
            "if",
            "flushed",
            "prior",
            "to",
            "having",
            "output",
            "a",
            "media",
            "format"
        ]
    },
    {
        "id": 1164,
        "code": "private static boolean codecNeedsEosPropagationWorkaround(MediaCodecInfo codecInfo) {\n  String name = codecInfo.name;\n  return (Util.SDK_INT <= 25 && \"OMX.rk.video_decoder.avc\".equals(name))\n      || (Util.SDK_INT <= 17 && \"OMX.allwinner.video.decoder.avc\".equals(name))\n      || (Util.SDK_INT <= 29\n          && (\"OMX.broadcom.video_decoder.tunnel\".equals(name)\n              || \"OMX.broadcom.video_decoder.tunnel.secure\".equals(name)))\n      || (\"Amazon\".equals(Util.MANUFACTURER) && \"AFTS\".equals(Util.MODEL) && codecInfo.secure);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "decoder",
            "is",
            "known",
            "to",
            "handle",
            "the",
            "propagation",
            "of",
            "the",
            "media",
            "codec",
            "buffer",
            "flag",
            "end",
            "of",
            "stream",
            "flag",
            "incorrectly",
            "on",
            "the",
            "host",
            "device"
        ]
    },
    {
        "id": 1165,
        "code": "private static boolean codecNeedsEosFlushWorkaround(String name) {\n  return (Util.SDK_INT <= 23 && \"OMX.google.vorbis.decoder\".equals(name))\n      || (Util.SDK_INT <= 19\n          && (\"hb2000\".equals(Util.DEVICE) || \"stvm8\".equals(Util.DEVICE))\n          && (\"OMX.amlogic.avc.decoder.awesome\".equals(name)\n              || \"OMX.amlogic.avc.decoder.awesome.secure\".equals(name)));\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "decoder",
            "is",
            "known",
            "to",
            "behave",
            "incorrectly",
            "if",
            "flushed",
            "after",
            "receiving",
            "an",
            "input",
            "buffer",
            "with",
            "media",
            "codec",
            "buffer",
            "flag",
            "end",
            "of",
            "stream",
            "set"
        ]
    },
    {
        "id": 1166,
        "code": "private static boolean codecNeedsEosBufferTimestampWorkaround(String codecName) {\n  return Util.SDK_INT < 21\n      && \"OMX.SEC.mp3.dec\".equals(codecName)\n      && \"samsung\".equals(Util.MANUFACTURER)\n      && (Util.DEVICE.startsWith(\"baffin\")\n          || Util.DEVICE.startsWith(\"grand\")\n          || Util.DEVICE.startsWith(\"fortuna\")\n          || Util.DEVICE.startsWith(\"gprimelte\")\n          || Util.DEVICE.startsWith(\"j2y18lte\")\n          || Util.DEVICE.startsWith(\"ms01\"));\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "decoder",
            "may",
            "output",
            "a",
            "non",
            "empty",
            "buffer",
            "with",
            "timestamp",
            "0",
            "as",
            "the",
            "end",
            "of",
            "stream",
            "buffer"
        ]
    },
    {
        "id": 1167,
        "code": "private static boolean codecNeedsEosOutputExceptionWorkaround(String name) {\n  return Util.SDK_INT == 21 && \"OMX.google.aac.decoder\".equals(name);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "decoder",
            "may",
            "throw",
            "an",
            "illegal",
            "state",
            "exception",
            "from",
            "media",
            "codec",
            "dequeue",
            "output",
            "buffer",
            "media",
            "codec"
        ]
    },
    {
        "id": 1168,
        "code": "private static boolean codecNeedsMonoChannelCountWorkaround(String name, Format format) {\n  return Util.SDK_INT <= 18\n      && format.channelCount == 1\n      && \"OMX.MTK.AUDIO.DECODER.MP3\".equals(name);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "decoder",
            "is",
            "known",
            "to",
            "set",
            "the",
            "number",
            "of",
            "audio",
            "channels",
            "in",
            "the",
            "output",
            "format",
            "to",
            "0",
            "for",
            "the",
            "given",
            "input",
            "format",
            "whilst",
            "only",
            "actually",
            "outputting",
            "a",
            "single",
            "channel"
        ]
    },
    {
        "id": 1169,
        "code": "public static void warmDecoderInfoCache(String mimeType, boolean secure, boolean tunneling) {\n  try {\n    getDecoderInfos(mimeType, secure, tunneling);\n  } catch (DecoderQueryException e) {\n      \n    Log.e(TAG, \"Codec warming failed\", e);\n  }\n}",
        "summary_tokens": [
            "optional",
            "call",
            "to",
            "warm",
            "the",
            "codec",
            "cache",
            "for",
            "a",
            "given",
            "mime",
            "type"
        ]
    },
    {
        "id": 1170,
        "code": "public static MediaCodecInfo getDecryptOnlyDecoderInfo() throws DecoderQueryException {\n  return getDecoderInfo(MimeTypes.AUDIO_RAW,  false,  false);\n}",
        "summary_tokens": [
            "returns",
            "information",
            "about",
            "a",
            "decoder",
            "that",
            "will",
            "only",
            "decrypt",
            "data",
            "without",
            "decoding",
            "it"
        ]
    },
    {
        "id": 1171,
        "code": "public static MediaCodecInfo getDecoderInfo(String mimeType, boolean secure, boolean tunneling)\n    throws DecoderQueryException {\n  List<MediaCodecInfo> decoderInfos = getDecoderInfos(mimeType, secure, tunneling);\n  return decoderInfos.isEmpty() ? null : decoderInfos.get(0);\n}",
        "summary_tokens": [
            "returns",
            "information",
            "about",
            "the",
            "preferred",
            "decoder",
            "for",
            "a",
            "given",
            "mime",
            "type"
        ]
    },
    {
        "id": 1172,
        "code": "public static synchronized List<MediaCodecInfo> getDecoderInfos(\n    String mimeType, boolean secure, boolean tunneling) throws DecoderQueryException {\n  CodecKey key = new CodecKey(mimeType, secure, tunneling);\n  @Nullable List<MediaCodecInfo> cachedDecoderInfos = decoderInfosCache.get(key);\n  if (cachedDecoderInfos != null) {\n    return cachedDecoderInfos;\n  }\n  MediaCodecListCompat mediaCodecList =\n      Util.SDK_INT >= 21\n          ? new MediaCodecListCompatV21(secure, tunneling)\n          : new MediaCodecListCompatV16();\n  ArrayList<MediaCodecInfo> decoderInfos = getDecoderInfosInternal(key, mediaCodecList);\n  if (secure && decoderInfos.isEmpty() && 21 <= Util.SDK_INT && Util.SDK_INT <= 23) {\n      \n      \n    mediaCodecList = new MediaCodecListCompatV16();\n    decoderInfos = getDecoderInfosInternal(key, mediaCodecList);\n    if (!decoderInfos.isEmpty()) {\n      Log.w(\n          TAG,\n          \"MediaCodecList API didn't list secure decoder for: \"\n              + mimeType\n              + \". Assuming: \"\n              + decoderInfos.get(0).name);\n    }\n  }\n  applyWorkarounds(mimeType, decoderInfos);\n  ImmutableList<MediaCodecInfo> immutableDecoderInfos = ImmutableList.copyOf(decoderInfos);\n  decoderInfosCache.put(key, immutableDecoderInfos);\n  return immutableDecoderInfos;\n}",
        "summary_tokens": [
            "returns",
            "all",
            "media",
            "codec",
            "info",
            "s",
            "for",
            "the",
            "given",
            "mime",
            "type",
            "in",
            "the",
            "order",
            "given",
            "by",
            "media",
            "codec",
            "list"
        ]
    },
    {
        "id": 1173,
        "code": "public static List<MediaCodecInfo> getDecoderInfosSortedByFormatSupport(\n    List<MediaCodecInfo> decoderInfos, Format format) {\n  decoderInfos = new ArrayList<>(decoderInfos);\n  sortByScore(\n      decoderInfos,\n      decoderInfo -> {\n        try {\n          return decoderInfo.isFormatSupported(format) ? 1 : 0;\n        } catch (DecoderQueryException e) {\n          return -1;\n        }\n      });\n  return decoderInfos;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "copy",
            "of",
            "the",
            "provided",
            "decoder",
            "list",
            "sorted",
            "such",
            "that",
            "decoders",
            "with",
            "format",
            "support",
            "are",
            "listed",
            "first"
        ]
    },
    {
        "id": 1174,
        "code": "public static int maxH264DecodableFrameSize() throws DecoderQueryException {\n  if (maxH264DecodableFrameSize == -1) {\n    int result = 0;\n    @Nullable\n    MediaCodecInfo decoderInfo =\n        getDecoderInfo(MimeTypes.VIDEO_H264,  false,  false);\n    if (decoderInfo != null) {\n      for (CodecProfileLevel profileLevel : decoderInfo.getProfileLevels()) {\n        result = max(avcLevelToMaxFrameSize(profileLevel.level), result);\n      }\n        \n        \n      result = max(result, Util.SDK_INT >= 21 ? (720 * 480) : (480 * 360));\n    }\n    maxH264DecodableFrameSize = result;\n  }\n  return maxH264DecodableFrameSize;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "maximum",
            "frame",
            "size",
            "supported",
            "by",
            "the",
            "default",
            "h",
            "0",
            "decoder"
        ]
    },
    {
        "id": 1175,
        "code": "public static Pair<Integer, Integer> getCodecProfileAndLevel(Format format) {\n  if (format.codecs == null) {\n    return null;\n  }\n  String[] parts = format.codecs.split(\"\\\\.\");\n    \n  if (MimeTypes.VIDEO_DOLBY_VISION.equals(format.sampleMimeType)) {\n    return getDolbyVisionProfileAndLevel(format.codecs, parts);\n  }\n  switch (parts[0]) {\n    case CODEC_ID_AVC1:\n    case CODEC_ID_AVC2:\n      return getAvcProfileAndLevel(format.codecs, parts);\n    case CODEC_ID_VP09:\n      return getVp9ProfileAndLevel(format.codecs, parts);\n    case CODEC_ID_HEV1:\n    case CODEC_ID_HVC1:\n      return getHevcProfileAndLevel(format.codecs, parts);\n    case CODEC_ID_AV01:\n      return getAv1ProfileAndLevel(format.codecs, parts, format.colorInfo);\n    case CODEC_ID_MP4A:\n      return getAacCodecProfileAndLevel(format.codecs, parts);\n    default:\n      return null;\n  }\n}",
        "summary_tokens": [
            "returns",
            "profile",
            "and",
            "level",
            "as",
            "defined",
            "by",
            "codec",
            "profile",
            "level",
            "corresponding",
            "to",
            "the",
            "codec",
            "description",
            "string",
            "as",
            "defined",
            "by",
            "rfc",
            "0",
            "of",
            "the",
            "given",
            "format"
        ]
    },
    {
        "id": 1176,
        "code": "public static String getAlternativeCodecMimeType(Format format) {\n  if (MimeTypes.AUDIO_E_AC3_JOC.equals(format.sampleMimeType)) {\n      \n    return MimeTypes.AUDIO_E_AC3;\n  }\n  if (MimeTypes.VIDEO_DOLBY_VISION.equals(format.sampleMimeType)) {\n      \n      \n      \n      \n    @Nullable\n    Pair<Integer, Integer> codecProfileAndLevel = MediaCodecUtil.getCodecProfileAndLevel(format);\n    if (codecProfileAndLevel != null) {\n      int profile = codecProfileAndLevel.first;\n      if (profile == CodecProfileLevel.DolbyVisionProfileDvheDtr\n          || profile == CodecProfileLevel.DolbyVisionProfileDvheSt) {\n        return MimeTypes.VIDEO_H265;\n      } else if (profile == CodecProfileLevel.DolbyVisionProfileDvavSe) {\n        return MimeTypes.VIDEO_H264;\n      }\n    }\n  }\n  return null;\n}",
        "summary_tokens": [
            "returns",
            "an",
            "alternative",
            "codec",
            "mime",
            "type",
            "besides",
            "the",
            "default",
            "format",
            "sample",
            "mime",
            "type",
            "that",
            "can",
            "be",
            "used",
            "to",
            "decode",
            "samples",
            "of",
            "the",
            "provided",
            "format"
        ]
    },
    {
        "id": 1177,
        "code": "private static ArrayList<MediaCodecInfo> getDecoderInfosInternal(\n    CodecKey key, MediaCodecListCompat mediaCodecList) throws DecoderQueryException {\n  try {\n    ArrayList<MediaCodecInfo> decoderInfos = new ArrayList<>();\n    String mimeType = key.mimeType;\n    int numberOfCodecs = mediaCodecList.getCodecCount();\n    boolean secureDecodersExplicit = mediaCodecList.secureDecodersExplicit();\n      \n    for (int i = 0; i < numberOfCodecs; i++) {\n      android.media.MediaCodecInfo codecInfo = mediaCodecList.getCodecInfoAt(i);\n      if (isAlias(codecInfo)) {\n          \n          \n        continue;\n      }\n      String name = codecInfo.getName();\n      if (!isCodecUsableDecoder(codecInfo, name, secureDecodersExplicit, mimeType)) {\n        continue;\n      }\n      @Nullable String codecMimeType = getCodecMimeType(codecInfo, name, mimeType);\n      if (codecMimeType == null) {\n        continue;\n      }\n      try {\n        CodecCapabilities capabilities = codecInfo.getCapabilitiesForType(codecMimeType);\n        boolean tunnelingSupported =\n            mediaCodecList.isFeatureSupported(\n                CodecCapabilities.FEATURE_TunneledPlayback, codecMimeType, capabilities);\n        boolean tunnelingRequired =\n            mediaCodecList.isFeatureRequired(\n                CodecCapabilities.FEATURE_TunneledPlayback, codecMimeType, capabilities);\n        if ((!key.tunneling && tunnelingRequired) || (key.tunneling && !tunnelingSupported)) {\n          continue;\n        }\n        boolean secureSupported =\n            mediaCodecList.isFeatureSupported(\n                CodecCapabilities.FEATURE_SecurePlayback, codecMimeType, capabilities);\n        boolean secureRequired =\n            mediaCodecList.isFeatureRequired(\n                CodecCapabilities.FEATURE_SecurePlayback, codecMimeType, capabilities);\n        if ((!key.secure && secureRequired) || (key.secure && !secureSupported)) {\n          continue;\n        }\n        boolean hardwareAccelerated = isHardwareAccelerated(codecInfo, mimeType);\n        boolean softwareOnly = isSoftwareOnly(codecInfo, mimeType);\n        boolean vendor = isVendor(codecInfo);\n        if ((secureDecodersExplicit && key.secure == secureSupported)\n            || (!secureDecodersExplicit && !key.secure)) {\n          decoderInfos.add(\n              MediaCodecInfo.newInstance(\n                  name,\n                  mimeType,\n                  codecMimeType,\n                  capabilities,\n                  hardwareAccelerated,\n                  softwareOnly,\n                  vendor,\n                   false,\n                   false));\n        } else if (!secureDecodersExplicit && secureSupported) {\n          decoderInfos.add(\n              MediaCodecInfo.newInstance(\n                  name + \".secure\",\n                  mimeType,\n                  codecMimeType,\n                  capabilities,\n                  hardwareAccelerated,\n                  softwareOnly,\n                  vendor,\n                   false,\n                   true));\n            \n          return decoderInfos;\n        }\n      } catch (Exception e) {\n        if (Util.SDK_INT <= 23 && !decoderInfos.isEmpty()) {\n            \n          Log.e(TAG, \"Skipping codec \" + name + \" (failed to query capabilities)\");\n        } else {\n            \n            \n          Log.e(TAG, \"Failed to query codec \" + name + \" (\" + codecMimeType + \")\");\n          throw e;\n        }\n      }\n    }\n    return decoderInfos;\n  } catch (Exception e) {\n      \n      \n    throw new DecoderQueryException(e);\n  }\n}",
        "summary_tokens": [
            "returns",
            "media",
            "codec",
            "info",
            "s",
            "for",
            "the",
            "given",
            "codec",
            "codec",
            "key",
            "in",
            "the",
            "order",
            "given",
            "by",
            "media",
            "codec",
            "list"
        ]
    },
    {
        "id": 1178,
        "code": "private static String getCodecMimeType(\n    android.media.MediaCodecInfo info, String name, String mimeType) {\n  String[] supportedTypes = info.getSupportedTypes();\n  for (String supportedType : supportedTypes) {\n    if (supportedType.equalsIgnoreCase(mimeType)) {\n      return supportedType;\n    }\n  }\n\n  if (mimeType.equals(MimeTypes.VIDEO_DOLBY_VISION)) {\n      \n      \n    if (\"OMX.MS.HEVCDV.Decoder\".equals(name)) {\n      return \"video/hevcdv\";\n    } else if (\"OMX.RTK.video.decoder\".equals(name)\n        || \"OMX.realtek.video.decoder.tunneled\".equals(name)) {\n      return \"video/dv_hevc\";\n    }\n  } else if (mimeType.equals(MimeTypes.AUDIO_ALAC) && \"OMX.lge.alac.decoder\".equals(name)) {\n    return \"audio/x-lg-alac\";\n  } else if (mimeType.equals(MimeTypes.AUDIO_FLAC) && \"OMX.lge.flac.decoder\".equals(name)) {\n    return \"audio/x-lg-flac\";\n  } else if (mimeType.equals(MimeTypes.AUDIO_AC3) && \"OMX.lge.ac3.decoder\".equals(name)) {\n    return \"audio/lg-ac3\";\n  }\n\n  return null;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "codec",
            "s",
            "supported",
            "mime",
            "type",
            "for",
            "media",
            "of",
            "type",
            "mime",
            "type",
            "or",
            "null",
            "if",
            "the",
            "codec",
            "can",
            "t",
            "be",
            "used"
        ]
    },
    {
        "id": 1179,
        "code": "private static boolean isCodecUsableDecoder(\n    android.media.MediaCodecInfo info,\n    String name,\n    boolean secureDecodersExplicit,\n    String mimeType) {\n  if (info.isEncoder() || (!secureDecodersExplicit && name.endsWith(\".secure\"))) {\n    return false;\n  }\n\n    \n  if (Util.SDK_INT < 21\n      && (\"CIPAACDecoder\".equals(name)\n          || \"CIPMP3Decoder\".equals(name)\n          || \"CIPVorbisDecoder\".equals(name)\n          || \"CIPAMRNBDecoder\".equals(name)\n          || \"AACDecoder\".equals(name)\n          || \"MP3Decoder\".equals(name))) {\n    return false;\n  }\n\n    \n    \n  if (Util.SDK_INT < 18\n      && \"OMX.MTK.AUDIO.DECODER.AAC\".equals(name)\n      && (\"a70\".equals(Util.DEVICE)\n          || (\"Xiaomi\".equals(Util.MANUFACTURER) && Util.DEVICE.startsWith(\"HM\")))) {\n    return false;\n  }\n\n    \n    \n  if (Util.SDK_INT == 16\n      && \"OMX.qcom.audio.decoder.mp3\".equals(name)\n      && (\"dlxu\".equals(Util.DEVICE) \n          || \"protou\".equals(Util.DEVICE) \n          || \"ville\".equals(Util.DEVICE) \n          || \"villeplus\".equals(Util.DEVICE)\n          || \"villec2\".equals(Util.DEVICE)\n          || Util.DEVICE.startsWith(\"gee\") \n          || \"C6602\".equals(Util.DEVICE) \n          || \"C6603\".equals(Util.DEVICE)\n          || \"C6606\".equals(Util.DEVICE)\n          || \"C6616\".equals(Util.DEVICE)\n          || \"L36h\".equals(Util.DEVICE)\n          || \"SO-02E\".equals(Util.DEVICE))) {\n    return false;\n  }\n\n    \n  if (Util.SDK_INT == 16\n      && \"OMX.qcom.audio.decoder.aac\".equals(name)\n      && (\"C1504\".equals(Util.DEVICE) \n          || \"C1505\".equals(Util.DEVICE)\n          || \"C1604\".equals(Util.DEVICE) \n          || \"C1605\".equals(Util.DEVICE))) {\n    return false;\n  }\n\n    \n  if (Util.SDK_INT < 24\n      && (\"OMX.SEC.aac.dec\".equals(name) || \"OMX.Exynos.AAC.Decoder\".equals(name))\n      && \"samsung\".equals(Util.MANUFACTURER)\n      && (Util.DEVICE.startsWith(\"zeroflte\") \n          || Util.DEVICE.startsWith(\"zerolte\") \n          || Util.DEVICE.startsWith(\"zenlte\") \n          || \"SC-05G\".equals(Util.DEVICE) \n          || \"marinelteatt\".equals(Util.DEVICE) \n          || \"404SC\".equals(Util.DEVICE) \n          || \"SC-04G\".equals(Util.DEVICE)\n          || \"SCV31\".equals(Util.DEVICE))) {\n    return false;\n  }\n\n    \n    \n  if (Util.SDK_INT <= 19\n      && \"OMX.SEC.vp8.dec\".equals(name)\n      && \"samsung\".equals(Util.MANUFACTURER)\n      && (Util.DEVICE.startsWith(\"d2\")\n          || Util.DEVICE.startsWith(\"serrano\")\n          || Util.DEVICE.startsWith(\"jflte\")\n          || Util.DEVICE.startsWith(\"santos\")\n          || Util.DEVICE.startsWith(\"t0\"))) {\n    return false;\n  }\n\n    \n  if (Util.SDK_INT <= 19\n      && Util.DEVICE.startsWith(\"jflte\")\n      && \"OMX.qcom.video.decoder.vp8\".equals(name)) {\n    return false;\n  }\n\n    \n  if (Util.SDK_INT <= 23\n      && MimeTypes.AUDIO_E_AC3_JOC.equals(mimeType)\n      && \"OMX.MTK.AUDIO.DECODER.DSPAC3\".equals(name)) {\n    return false;\n  }\n\n  return true;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "specified",
            "codec",
            "is",
            "usable",
            "for",
            "decoding",
            "on",
            "the",
            "current",
            "device"
        ]
    },
    {
        "id": 1180,
        "code": "private static void applyWorkarounds(String mimeType, List<MediaCodecInfo> decoderInfos) {\n  if (MimeTypes.AUDIO_RAW.equals(mimeType)) {\n    if (Util.SDK_INT < 26\n        && Util.DEVICE.equals(\"R9\")\n        && decoderInfos.size() == 1\n        && decoderInfos.get(0).name.equals(\"OMX.MTK.AUDIO.DECODER.RAW\")) {\n        \n        \n      decoderInfos.add(\n          MediaCodecInfo.newInstance(\n               \"OMX.google.raw.decoder\",\n               MimeTypes.AUDIO_RAW,\n               MimeTypes.AUDIO_RAW,\n               null,\n               false,\n               true,\n               false,\n               false,\n               false));\n    }\n      \n    sortByScore(\n        decoderInfos,\n        decoderInfo -> {\n          String name = decoderInfo.name;\n          if (name.startsWith(\"OMX.google\") || name.startsWith(\"c2.android\")) {\n              \n            return 1;\n          }\n          if (Util.SDK_INT < 26 && name.equals(\"OMX.MTK.AUDIO.DECODER.RAW\")) {\n              \n              \n            return -1;\n          }\n          return 0;\n        });\n  }\n\n  if (Util.SDK_INT < 21 && decoderInfos.size() > 1) {\n    String firstCodecName = decoderInfos.get(0).name;\n    if (\"OMX.SEC.mp3.dec\".equals(firstCodecName)\n        || \"OMX.SEC.MP3.Decoder\".equals(firstCodecName)\n        || \"OMX.brcm.audio.mp3.decoder\".equals(firstCodecName)) {\n        \n        \n        \n        \n      sortByScore(decoderInfos, decoderInfo -> decoderInfo.name.startsWith(\"OMX.google\") ? 1 : 0);\n    }\n  }\n\n  if (Util.SDK_INT < 32 && decoderInfos.size() > 1) {\n    String firstCodecName = decoderInfos.get(0).name;\n      \n      \n    if (\"OMX.qti.audio.decoder.flac\".equals(firstCodecName)) {\n      decoderInfos.add(decoderInfos.remove(0));\n    }\n  }\n}",
        "summary_tokens": [
            "modifies",
            "a",
            "list",
            "of",
            "media",
            "codec",
            "info",
            "s",
            "to",
            "apply",
            "workarounds",
            "where",
            "we",
            "know",
            "better",
            "than",
            "the",
            "platform"
        ]
    },
    {
        "id": 1181,
        "code": "private static boolean isHardwareAccelerated(\n    android.media.MediaCodecInfo codecInfo, String mimeType) {\n  if (Util.SDK_INT >= 29) {\n    return isHardwareAcceleratedV29(codecInfo);\n  }\n    \n    \n  return !isSoftwareOnly(codecInfo, mimeType);\n}",
        "summary_tokens": [
            "the",
            "result",
            "of",
            "android"
        ]
    },
    {
        "id": 1182,
        "code": "private static boolean isSoftwareOnly(android.media.MediaCodecInfo codecInfo, String mimeType) {\n  if (Util.SDK_INT >= 29) {\n    return isSoftwareOnlyV29(codecInfo);\n  }\n  if (MimeTypes.isAudio(mimeType)) {\n      \n    return true;\n  }\n  String codecName = Ascii.toLowerCase(codecInfo.getName());\n  if (codecName.startsWith(\"arc.\")) {\n      \n    return false;\n  }\n  return codecName.startsWith(\"omx.google.\")\n      || codecName.startsWith(\"omx.ffmpeg.\")\n      || (codecName.startsWith(\"omx.sec.\") && codecName.contains(\".sw.\"))\n      || codecName.equals(\"omx.qcom.video.decoder.hevcswvdec\")\n      || codecName.startsWith(\"c2.android.\")\n      || codecName.startsWith(\"c2.google.\")\n      || (!codecName.startsWith(\"omx.\") && !codecName.startsWith(\"c2.\"));\n}",
        "summary_tokens": [
            "the",
            "result",
            "of",
            "android"
        ]
    },
    {
        "id": 1183,
        "code": "private static boolean isVendor(android.media.MediaCodecInfo codecInfo) {\n  if (Util.SDK_INT >= 29) {\n    return isVendorV29(codecInfo);\n  }\n  String codecName = Ascii.toLowerCase(codecInfo.getName());\n  return !codecName.startsWith(\"omx.google.\")\n      && !codecName.startsWith(\"c2.android.\")\n      && !codecName.startsWith(\"c2.google.\");\n}",
        "summary_tokens": [
            "the",
            "result",
            "of",
            "android"
        ]
    },
    {
        "id": 1184,
        "code": "private static int avcLevelToMaxFrameSize(int avcLevel) {\n  switch (avcLevel) {\n    case CodecProfileLevel.AVCLevel1:\n    case CodecProfileLevel.AVCLevel1b:\n      return 99 * 16 * 16;\n    case CodecProfileLevel.AVCLevel12:\n    case CodecProfileLevel.AVCLevel13:\n    case CodecProfileLevel.AVCLevel2:\n      return 396 * 16 * 16;\n    case CodecProfileLevel.AVCLevel21:\n      return 792 * 16 * 16;\n    case CodecProfileLevel.AVCLevel22:\n    case CodecProfileLevel.AVCLevel3:\n      return 1620 * 16 * 16;\n    case CodecProfileLevel.AVCLevel31:\n      return 3600 * 16 * 16;\n    case CodecProfileLevel.AVCLevel32:\n      return 5120 * 16 * 16;\n    case CodecProfileLevel.AVCLevel4:\n    case CodecProfileLevel.AVCLevel41:\n      return 8192 * 16 * 16;\n    case CodecProfileLevel.AVCLevel42:\n      return 8704 * 16 * 16;\n    case CodecProfileLevel.AVCLevel5:\n      return 22080 * 16 * 16;\n    case CodecProfileLevel.AVCLevel51:\n    case CodecProfileLevel.AVCLevel52:\n      return 36864 * 16 * 16;\n    case CodecProfileLevel.AVCLevel6:\n    case CodecProfileLevel.AVCLevel61:\n    case CodecProfileLevel.AVCLevel62:\n      return 139264 * 16 * 16;\n    default:\n      return -1;\n  }\n}",
        "summary_tokens": [
            "conversion",
            "values",
            "taken",
            "from",
            "iso",
            "0",
            "0",
            "table",
            "a",
            "0"
        ]
    },
    {
        "id": 1185,
        "code": "private static <T> void sortByScore(List<T> list, ScoreProvider<T> scoreProvider) {\n  Collections.sort(list, (a, b) -> scoreProvider.getScore(b) - scoreProvider.getScore(a));\n}",
        "summary_tokens": [
            "stably",
            "sorts",
            "the",
            "provided",
            "list",
            "in",
            "place",
            "in",
            "order",
            "of",
            "decreasing",
            "score"
        ]
    },
    {
        "id": 1186,
        "code": "private static String inferMimeType(@Nullable String downloadType) {\n  if (\"dash\".equals(downloadType)) {\n    return MimeTypes.APPLICATION_MPD;\n  } else if (\"hls\".equals(downloadType)) {\n    return MimeTypes.APPLICATION_M3U8;\n  } else if (\"ss\".equals(downloadType)) {\n    return MimeTypes.APPLICATION_SS;\n  } else {\n    return MimeTypes.VIDEO_UNKNOWN;\n  }\n}",
        "summary_tokens": [
            "infers",
            "the",
            "mime",
            "type",
            "from",
            "a",
            "v",
            "0",
            "table",
            "row"
        ]
    },
    {
        "id": 1187,
        "code": "private static Download getDownloadForCurrentRowV2(Cursor cursor) {\n    \n  DownloadRequest request =\n      new DownloadRequest.Builder(\n               checkNotNull(cursor.getString(0)),\n               Uri.parse(checkNotNull(cursor.getString(2))))\n          .setMimeType(inferMimeType(cursor.getString(1)))\n          .setStreamKeys(decodeStreamKeys(cursor.getString(3)))\n          .setCustomCacheKey(cursor.getString(4))\n          .setData(cursor.getBlob(5))\n          .build();\n  DownloadProgress downloadProgress = new DownloadProgress();\n  downloadProgress.bytesDownloaded = cursor.getLong(13);\n  downloadProgress.percentDownloaded = cursor.getFloat(12);\n  @State int state = cursor.getInt(6);\n    \n    \n  @FailureReason\n  int failureReason =\n      state == Download.STATE_FAILED ? cursor.getInt(11) : Download.FAILURE_REASON_NONE;\n  return new Download(\n      request,\n      state,\n       cursor.getLong(7),\n       cursor.getLong(8),\n       cursor.getLong(9),\n       cursor.getInt(10),\n      failureReason,\n      downloadProgress);\n}",
        "summary_tokens": [
            "read",
            "a",
            "download",
            "from",
            "a",
            "table",
            "row",
            "of",
            "version",
            "0"
        ]
    },
    {
        "id": 1188,
        "code": "public boolean isTerminalState() {\n  return state == STATE_COMPLETED || state == STATE_FAILED;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "download",
            "is",
            "completed",
            "or",
            "failed"
        ]
    },
    {
        "id": 1189,
        "code": "public long getBytesDownloaded() {\n  return progress.bytesDownloaded;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "total",
            "number",
            "of",
            "downloaded",
            "bytes"
        ]
    },
    {
        "id": 1190,
        "code": "public float getPercentDownloaded() {\n  return progress.percentDownloaded;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "estimated",
            "download",
            "percentage",
            "or",
            "c",
            "percentage",
            "unset",
            "if",
            "no",
            "estimate",
            "is",
            "available"
        ]
    },
    {
        "id": 1191,
        "code": "default boolean moveToFirst() {\n  return moveToPosition(0);\n}",
        "summary_tokens": [
            "move",
            "the",
            "cursor",
            "to",
            "the",
            "first",
            "download"
        ]
    },
    {
        "id": 1192,
        "code": "default boolean moveToLast() {\n  return moveToPosition(getCount() - 1);\n}",
        "summary_tokens": [
            "move",
            "the",
            "cursor",
            "to",
            "the",
            "last",
            "download"
        ]
    },
    {
        "id": 1193,
        "code": "default boolean moveToNext() {\n  return moveToPosition(getPosition() + 1);\n}",
        "summary_tokens": [
            "move",
            "the",
            "cursor",
            "to",
            "the",
            "next",
            "download"
        ]
    },
    {
        "id": 1194,
        "code": "default boolean moveToPrevious() {\n  return moveToPosition(getPosition() - 1);\n}",
        "summary_tokens": [
            "move",
            "the",
            "cursor",
            "to",
            "the",
            "previous",
            "download"
        ]
    },
    {
        "id": 1195,
        "code": "default boolean isFirst() {\n  return getPosition() == 0 && getCount() != 0;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "cursor",
            "is",
            "pointing",
            "to",
            "the",
            "first",
            "download"
        ]
    },
    {
        "id": 1196,
        "code": "default boolean isLast() {\n  int count = getCount();\n  return getPosition() == (count - 1) && count != 0;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "cursor",
            "is",
            "pointing",
            "to",
            "the",
            "last",
            "download"
        ]
    },
    {
        "id": 1197,
        "code": "default boolean isBeforeFirst() {\n  if (getCount() == 0) {\n    return true;\n  }\n  return getPosition() == -1;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "cursor",
            "is",
            "pointing",
            "to",
            "the",
            "position",
            "before",
            "the",
            "first",
            "download"
        ]
    },
    {
        "id": 1198,
        "code": "default boolean isAfterLast() {\n  if (getCount() == 0) {\n    return true;\n  }\n  return getPosition() == getCount();\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "cursor",
            "is",
            "pointing",
            "to",
            "the",
            "position",
            "after",
            "the",
            "last",
            "download"
        ]
    },
    {
        "id": 1199,
        "code": "public Looper getApplicationLooper() {\n  return applicationHandler.getLooper();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "looper",
            "associated",
            "with",
            "the",
            "application",
            "thread",
            "that",
            "s",
            "used",
            "to",
            "access",
            "the",
            "manager",
            "and",
            "on",
            "which",
            "the",
            "manager",
            "will",
            "call",
            "its",
            "listener",
            "listeners"
        ]
    },
    {
        "id": 1200,
        "code": "public boolean isInitialized() {\n  return initialized;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "manager",
            "has",
            "completed",
            "initialization"
        ]
    },
    {
        "id": 1201,
        "code": "public boolean isIdle() {\n  return activeTaskCount == 0 && pendingMessages == 0;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "manager",
            "is",
            "currently",
            "idle"
        ]
    },
    {
        "id": 1202,
        "code": "public boolean isWaitingForRequirements() {\n  return waitingForRequirements;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "this",
            "manager",
            "has",
            "one",
            "or",
            "more",
            "downloads",
            "that",
            "are",
            "not",
            "progressing",
            "for",
            "the",
            "sole",
            "reason",
            "that",
            "the",
            "get",
            "requirements",
            "requirements",
            "are",
            "not",
            "met"
        ]
    },
    {
        "id": 1203,
        "code": "public Requirements getRequirements() {\n  return requirementsWatcher.getRequirements();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "requirements",
            "needed",
            "to",
            "be",
            "met",
            "to",
            "progress"
        ]
    },
    {
        "id": 1204,
        "code": "public @Requirements.RequirementFlags int getNotMetRequirements() {\n  return notMetRequirements;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "requirements",
            "needed",
            "for",
            "downloads",
            "to",
            "progress",
            "that",
            "are",
            "not",
            "currently",
            "met"
        ]
    },
    {
        "id": 1205,
        "code": "public void setRequirements(Requirements requirements) {\n  if (requirements.equals(requirementsWatcher.getRequirements())) {\n    return;\n  }\n  requirementsWatcher.stop();\n  requirementsWatcher = new RequirementsWatcher(context, requirementsListener, requirements);\n  int notMetRequirements = requirementsWatcher.start();\n  onRequirementsStateChanged(requirementsWatcher, notMetRequirements);\n}",
        "summary_tokens": [
            "sets",
            "the",
            "requirements",
            "that",
            "need",
            "to",
            "be",
            "met",
            "for",
            "downloads",
            "to",
            "progress"
        ]
    },
    {
        "id": 1206,
        "code": "public int getMaxParallelDownloads() {\n  return maxParallelDownloads;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "maximum",
            "number",
            "of",
            "parallel",
            "downloads"
        ]
    },
    {
        "id": 1207,
        "code": "public void setMaxParallelDownloads(@IntRange(from = 1) int maxParallelDownloads) {\n  Assertions.checkArgument(maxParallelDownloads > 0);\n  if (this.maxParallelDownloads == maxParallelDownloads) {\n    return;\n  }\n  this.maxParallelDownloads = maxParallelDownloads;\n  pendingMessages++;\n  internalHandler\n      .obtainMessage(MSG_SET_MAX_PARALLEL_DOWNLOADS, maxParallelDownloads,  0)\n      .sendToTarget();\n}",
        "summary_tokens": [
            "sets",
            "the",
            "maximum",
            "number",
            "of",
            "parallel",
            "downloads"
        ]
    },
    {
        "id": 1208,
        "code": "public int getMinRetryCount() {\n  return minRetryCount;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "minimum",
            "number",
            "of",
            "times",
            "that",
            "a",
            "download",
            "will",
            "be",
            "retried"
        ]
    },
    {
        "id": 1209,
        "code": "public void setMinRetryCount(int minRetryCount) {\n  Assertions.checkArgument(minRetryCount >= 0);\n  if (this.minRetryCount == minRetryCount) {\n    return;\n  }\n  this.minRetryCount = minRetryCount;\n  pendingMessages++;\n  internalHandler\n      .obtainMessage(MSG_SET_MIN_RETRY_COUNT, minRetryCount,  0)\n      .sendToTarget();\n}",
        "summary_tokens": [
            "sets",
            "the",
            "minimum",
            "number",
            "of",
            "times",
            "that",
            "a",
            "download",
            "will",
            "be",
            "retried"
        ]
    },
    {
        "id": 1210,
        "code": "public DownloadIndex getDownloadIndex() {\n  return downloadIndex;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "used",
            "download",
            "index"
        ]
    },
    {
        "id": 1211,
        "code": "public boolean getDownloadsPaused() {\n  return downloadsPaused;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "downloads",
            "are",
            "currently",
            "paused"
        ]
    },
    {
        "id": 1212,
        "code": "public void setStopReason(@Nullable String id, int stopReason) {\n  pendingMessages++;\n  internalHandler\n      .obtainMessage(MSG_SET_STOP_REASON, stopReason,  0, id)\n      .sendToTarget();\n}",
        "summary_tokens": [
            "sets",
            "the",
            "stop",
            "reason",
            "for",
            "one",
            "or",
            "all",
            "downloads"
        ]
    },
    {
        "id": 1213,
        "code": "public void addDownload(DownloadRequest request, int stopReason) {\n  pendingMessages++;\n  internalHandler\n      .obtainMessage(MSG_ADD_DOWNLOAD, stopReason,  0, request)\n      .sendToTarget();\n}",
        "summary_tokens": [
            "adds",
            "a",
            "download",
            "defined",
            "by",
            "the",
            "given",
            "request",
            "and",
            "with",
            "the",
            "specified",
            "stop",
            "reason"
        ]
    },
    {
        "id": 1214,
        "code": "public void removeDownload(String id) {\n  pendingMessages++;\n  internalHandler.obtainMessage(MSG_REMOVE_DOWNLOAD, id).sendToTarget();\n}",
        "summary_tokens": [
            "cancels",
            "the",
            "download",
            "with",
            "the",
            "id",
            "and",
            "removes",
            "all",
            "downloaded",
            "data"
        ]
    },
    {
        "id": 1215,
        "code": "public void removeAllDownloads() {\n  pendingMessages++;\n  internalHandler.obtainMessage(MSG_REMOVE_ALL_DOWNLOADS).sendToTarget();\n}",
        "summary_tokens": [
            "cancels",
            "all",
            "pending",
            "downloads",
            "and",
            "removes",
            "all",
            "downloaded",
            "data"
        ]
    },
    {
        "id": 1216,
        "code": "public void release() {\n  synchronized (internalHandler) {\n    if (internalHandler.released) {\n      return;\n    }\n    internalHandler.sendEmptyMessage(MSG_RELEASE);\n    boolean wasInterrupted = false;\n    while (!internalHandler.released) {\n      try {\n        internalHandler.wait();\n      } catch (InterruptedException e) {\n        wasInterrupted = true;\n      }\n    }\n    if (wasInterrupted) {\n        \n      Thread.currentThread().interrupt();\n    }\n    applicationHandler.removeCallbacksAndMessages( null);\n      \n    downloads = Collections.emptyList();\n    pendingMessages = 0;\n    activeTaskCount = 0;\n    initialized = false;\n    notMetRequirements = 0;\n    waitingForRequirements = false;\n  }\n}",
        "summary_tokens": [
            "stops",
            "the",
            "downloads",
            "and",
            "releases",
            "resources"
        ]
    },
    {
        "id": 1217,
        "code": "public DownloadRequest copyWithId(String id) {\n  return new DownloadRequest(id, uri, mimeType, streamKeys, keySetId, customCacheKey, data);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "copy",
            "with",
            "the",
            "specified",
            "id"
        ]
    },
    {
        "id": 1218,
        "code": "public DownloadRequest copyWithKeySetId(@Nullable byte[] keySetId) {\n  return new DownloadRequest(id, uri, mimeType, streamKeys, keySetId, customCacheKey, data);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "copy",
            "with",
            "the",
            "specified",
            "key",
            "set",
            "id"
        ]
    },
    {
        "id": 1219,
        "code": "public DownloadRequest copyWithMergedRequest(DownloadRequest newRequest) {\n  Assertions.checkArgument(id.equals(newRequest.id));\n  List<StreamKey> mergedKeys;\n  if (streamKeys.isEmpty() || newRequest.streamKeys.isEmpty()) {\n      \n    mergedKeys = Collections.emptyList();\n  } else {\n    mergedKeys = new ArrayList<>(streamKeys);\n    for (int i = 0; i < newRequest.streamKeys.size(); i++) {\n      StreamKey newKey = newRequest.streamKeys.get(i);\n      if (!mergedKeys.contains(newKey)) {\n        mergedKeys.add(newKey);\n      }\n    }\n  }\n  return new DownloadRequest(\n      id,\n      newRequest.uri,\n      newRequest.mimeType,\n      mergedKeys,\n      newRequest.keySetId,\n      newRequest.customCacheKey,\n      newRequest.data);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "result",
            "of",
            "merging",
            "new",
            "request",
            "into",
            "this",
            "request"
        ]
    },
    {
        "id": 1220,
        "code": "public MediaItem toMediaItem() {\n  return new MediaItem.Builder()\n      .setMediaId(id)\n      .setUri(uri)\n      .setCustomCacheKey(customCacheKey)\n      .setMimeType(mimeType)\n      .setStreamKeys(streamKeys)\n      .build();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "media",
            "item",
            "for",
            "the",
            "content",
            "defined",
            "by",
            "the",
            "request"
        ]
    },
    {
        "id": 1221,
        "code": "public static Intent buildAddDownloadIntent(\n    Context context,\n    Class<? extends DownloadService> clazz,\n    DownloadRequest downloadRequest,\n    int stopReason,\n    boolean foreground) {\n  return getIntent(context, clazz, ACTION_ADD_DOWNLOAD, foreground)\n      .putExtra(KEY_DOWNLOAD_REQUEST, downloadRequest)\n      .putExtra(KEY_STOP_REASON, stopReason);\n}",
        "summary_tokens": [
            "builds",
            "an",
            "intent",
            "for",
            "adding",
            "a",
            "new",
            "download"
        ]
    },
    {
        "id": 1222,
        "code": "public static Intent buildRemoveDownloadIntent(\n    Context context, Class<? extends DownloadService> clazz, String id, boolean foreground) {\n  return getIntent(context, clazz, ACTION_REMOVE_DOWNLOAD, foreground)\n      .putExtra(KEY_CONTENT_ID, id);\n}",
        "summary_tokens": [
            "builds",
            "an",
            "intent",
            "for",
            "removing",
            "the",
            "download",
            "with",
            "the",
            "id"
        ]
    },
    {
        "id": 1223,
        "code": "public static Intent buildRemoveAllDownloadsIntent(\n    Context context, Class<? extends DownloadService> clazz, boolean foreground) {\n  return getIntent(context, clazz, ACTION_REMOVE_ALL_DOWNLOADS, foreground);\n}",
        "summary_tokens": [
            "builds",
            "an",
            "intent",
            "for",
            "removing",
            "all",
            "downloads"
        ]
    },
    {
        "id": 1224,
        "code": "public static Intent buildResumeDownloadsIntent(\n    Context context, Class<? extends DownloadService> clazz, boolean foreground) {\n  return getIntent(context, clazz, ACTION_RESUME_DOWNLOADS, foreground);\n}",
        "summary_tokens": [
            "builds",
            "an",
            "intent",
            "for",
            "resuming",
            "all",
            "downloads"
        ]
    },
    {
        "id": 1225,
        "code": "public static Intent buildPauseDownloadsIntent(\n    Context context, Class<? extends DownloadService> clazz, boolean foreground) {\n  return getIntent(context, clazz, ACTION_PAUSE_DOWNLOADS, foreground);\n}",
        "summary_tokens": [
            "builds",
            "an",
            "intent",
            "to",
            "pause",
            "all",
            "downloads"
        ]
    },
    {
        "id": 1226,
        "code": "public static Intent buildSetStopReasonIntent(\n    Context context,\n    Class<? extends DownloadService> clazz,\n    @Nullable String id,\n    int stopReason,\n    boolean foreground) {\n  return getIntent(context, clazz, ACTION_SET_STOP_REASON, foreground)\n      .putExtra(KEY_CONTENT_ID, id)\n      .putExtra(KEY_STOP_REASON, stopReason);\n}",
        "summary_tokens": [
            "builds",
            "an",
            "intent",
            "for",
            "setting",
            "the",
            "stop",
            "reason",
            "for",
            "one",
            "or",
            "all",
            "downloads"
        ]
    },
    {
        "id": 1227,
        "code": "public static Intent buildSetRequirementsIntent(\n    Context context,\n    Class<? extends DownloadService> clazz,\n    Requirements requirements,\n    boolean foreground) {\n  return getIntent(context, clazz, ACTION_SET_REQUIREMENTS, foreground)\n      .putExtra(KEY_REQUIREMENTS, requirements);\n}",
        "summary_tokens": [
            "builds",
            "an",
            "intent",
            "for",
            "setting",
            "the",
            "requirements",
            "that",
            "need",
            "to",
            "be",
            "met",
            "for",
            "downloads",
            "to",
            "progress"
        ]
    },
    {
        "id": 1228,
        "code": "public static void sendAddDownload(\n    Context context,\n    Class<? extends DownloadService> clazz,\n    DownloadRequest downloadRequest,\n    int stopReason,\n    boolean foreground) {\n  Intent intent = buildAddDownloadIntent(context, clazz, downloadRequest, stopReason, foreground);\n  startService(context, intent, foreground);\n}",
        "summary_tokens": [
            "starts",
            "the",
            "service",
            "if",
            "not",
            "started",
            "already",
            "and",
            "adds",
            "a",
            "new",
            "download"
        ]
    },
    {
        "id": 1229,
        "code": "public static void sendRemoveDownload(\n    Context context, Class<? extends DownloadService> clazz, String id, boolean foreground) {\n  Intent intent = buildRemoveDownloadIntent(context, clazz, id, foreground);\n  startService(context, intent, foreground);\n}",
        "summary_tokens": [
            "starts",
            "the",
            "service",
            "if",
            "not",
            "started",
            "already",
            "and",
            "removes",
            "a",
            "download"
        ]
    },
    {
        "id": 1230,
        "code": "public static void sendRemoveAllDownloads(\n    Context context, Class<? extends DownloadService> clazz, boolean foreground) {\n  Intent intent = buildRemoveAllDownloadsIntent(context, clazz, foreground);\n  startService(context, intent, foreground);\n}",
        "summary_tokens": [
            "starts",
            "the",
            "service",
            "if",
            "not",
            "started",
            "already",
            "and",
            "removes",
            "all",
            "downloads"
        ]
    },
    {
        "id": 1231,
        "code": "public static void sendResumeDownloads(\n    Context context, Class<? extends DownloadService> clazz, boolean foreground) {\n  Intent intent = buildResumeDownloadsIntent(context, clazz, foreground);\n  startService(context, intent, foreground);\n}",
        "summary_tokens": [
            "starts",
            "the",
            "service",
            "if",
            "not",
            "started",
            "already",
            "and",
            "resumes",
            "all",
            "downloads"
        ]
    },
    {
        "id": 1232,
        "code": "public static void sendPauseDownloads(\n    Context context, Class<? extends DownloadService> clazz, boolean foreground) {\n  Intent intent = buildPauseDownloadsIntent(context, clazz, foreground);\n  startService(context, intent, foreground);\n}",
        "summary_tokens": [
            "starts",
            "the",
            "service",
            "if",
            "not",
            "started",
            "already",
            "and",
            "pauses",
            "all",
            "downloads"
        ]
    },
    {
        "id": 1233,
        "code": "public static void sendSetStopReason(\n    Context context,\n    Class<? extends DownloadService> clazz,\n    @Nullable String id,\n    int stopReason,\n    boolean foreground) {\n  Intent intent = buildSetStopReasonIntent(context, clazz, id, stopReason, foreground);\n  startService(context, intent, foreground);\n}",
        "summary_tokens": [
            "starts",
            "the",
            "service",
            "if",
            "not",
            "started",
            "already",
            "and",
            "sets",
            "the",
            "stop",
            "reason",
            "for",
            "one",
            "or",
            "all",
            "downloads"
        ]
    },
    {
        "id": 1234,
        "code": "public static void sendSetRequirements(\n    Context context,\n    Class<? extends DownloadService> clazz,\n    Requirements requirements,\n    boolean foreground) {\n  Intent intent = buildSetRequirementsIntent(context, clazz, requirements, foreground);\n  startService(context, intent, foreground);\n}",
        "summary_tokens": [
            "starts",
            "the",
            "service",
            "if",
            "not",
            "started",
            "already",
            "and",
            "sets",
            "the",
            "requirements",
            "that",
            "need",
            "to",
            "be",
            "met",
            "for",
            "downloads",
            "to",
            "progress"
        ]
    },
    {
        "id": 1235,
        "code": "public static void start(Context context, Class<? extends DownloadService> clazz) {\n  context.startService(getIntent(context, clazz, ACTION_INIT));\n}",
        "summary_tokens": [
            "starts",
            "a",
            "download",
            "service",
            "to",
            "resume",
            "any",
            "ongoing",
            "downloads"
        ]
    },
    {
        "id": 1236,
        "code": "public static void startForeground(Context context, Class<? extends DownloadService> clazz) {\n  Intent intent = getIntent(context, clazz, ACTION_INIT, true);\n  Util.startForegroundService(context, intent);\n}",
        "summary_tokens": [
            "starts",
            "the",
            "service",
            "in",
            "the",
            "foreground",
            "without",
            "adding",
            "a",
            "new",
            "download",
            "request"
        ]
    },
    {
        "id": 1237,
        "code": "public final IBinder onBind(Intent intent) {\n  throw new UnsupportedOperationException();\n}",
        "summary_tokens": [
            "throws",
            "unsupported",
            "operation",
            "exception",
            "because",
            "this",
            "service",
            "is",
            "not",
            "designed",
            "to",
            "be",
            "bound"
        ]
    },
    {
        "id": 1238,
        "code": "protected final void invalidateForegroundNotification() {\n  if (foregroundNotificationUpdater != null && !isDestroyed) {\n    foregroundNotificationUpdater.invalidate();\n  }\n}",
        "summary_tokens": [
            "invalidates",
            "the",
            "current",
            "foreground",
            "notification",
            "and",
            "causes",
            "get",
            "foreground",
            "notification",
            "list",
            "int",
            "to",
            "be",
            "invoked",
            "again",
            "if",
            "the",
            "service",
            "isn",
            "t",
            "stopped"
        ]
    },
    {
        "id": 1239,
        "code": "private void notifyDownloads(List<Download> downloads) {\n  if (foregroundNotificationUpdater != null) {\n    for (int i = 0; i < downloads.size(); i++) {\n      if (needsStartedService(downloads.get(i).state)) {\n        foregroundNotificationUpdater.startPeriodicUpdates();\n        break;\n      }\n    }\n  }\n}",
        "summary_tokens": [
            "called",
            "after",
            "the",
            "service",
            "is",
            "created",
            "once",
            "the",
            "downloads",
            "are",
            "known"
        ]
    },
    {
        "id": 1240,
        "code": "private void notifyDownloadChanged(Download download) {\n  if (foregroundNotificationUpdater != null) {\n    if (needsStartedService(download.state)) {\n      foregroundNotificationUpdater.startPeriodicUpdates();\n    } else {\n      foregroundNotificationUpdater.invalidate();\n    }\n  }\n}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "state",
            "of",
            "a",
            "download",
            "changes"
        ]
    },
    {
        "id": 1241,
        "code": "private void notifyDownloadRemoved() {\n  if (foregroundNotificationUpdater != null) {\n    foregroundNotificationUpdater.invalidate();\n  }\n}",
        "summary_tokens": [
            "called",
            "when",
            "a",
            "download",
            "is",
            "removed"
        ]
    },
    {
        "id": 1242,
        "code": "private boolean isStopped() {\n  return isStopped;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "service",
            "is",
            "stopped"
        ]
    },
    {
        "id": 1243,
        "code": "protected final M getManifest(DataSource dataSource, DataSpec dataSpec, boolean removing)\n    throws InterruptedException, IOException {\n  return execute(\n      new RunnableFutureTask<M, IOException>() {\n        @Override\n        protected M doWork() throws IOException {\n          return ParsingLoadable.load(dataSource, manifestParser, dataSpec, C.DATA_TYPE_MANIFEST);\n        }\n      },\n      removing);\n}",
        "summary_tokens": [
            "loads",
            "and",
            "parses",
            "a",
            "manifest"
        ]
    },
    {
        "id": 1244,
        "code": "protected final <T> T execute(RunnableFutureTask<T, ?> runnable, boolean removing)\n    throws InterruptedException, IOException {\n  if (removing) {\n    runnable.run();\n    try {\n      return runnable.get();\n    } catch (ExecutionException e) {\n      Throwable cause = Assertions.checkNotNull(e.getCause());\n      if (cause instanceof IOException) {\n        throw (IOException) cause;\n      } else {\n          \n        Util.sneakyThrow(e);\n      }\n    }\n  }\n  while (true) {\n    if (isCanceled) {\n      throw new InterruptedException();\n    }\n      \n    if (priorityTaskManager != null) {\n      priorityTaskManager.proceed(C.PRIORITY_DOWNLOAD);\n    }\n    addActiveRunnable(runnable);\n    executor.execute(runnable);\n    try {\n      return runnable.get();\n    } catch (ExecutionException e) {\n      Throwable cause = Assertions.checkNotNull(e.getCause());\n      if (cause instanceof PriorityTooLowException) {\n          \n      } else if (cause instanceof IOException) {\n        throw (IOException) cause;\n      } else {\n          \n        Util.sneakyThrow(e);\n      }\n    } finally {\n        \n      runnable.blockUntilFinished();\n      removeActiveRunnable(runnable);\n    }\n  }\n}",
        "summary_tokens": [
            "executes",
            "the",
            "provided",
            "runnable",
            "future",
            "task"
        ]
    },
    {
        "id": 1245,
        "code": "public Requirements filterRequirements(int requirementsFilter) {\n  int filteredRequirements = requirements & requirementsFilter;\n  return filteredRequirements == requirements ? this : new Requirements(filteredRequirements);\n}",
        "summary_tokens": [
            "filters",
            "the",
            "requirements",
            "returning",
            "the",
            "subset",
            "that",
            "are",
            "enabled",
            "by",
            "the",
            "provided",
            "filter"
        ]
    },
    {
        "id": 1246,
        "code": "public boolean isNetworkRequired() {\n  return (requirements & NETWORK) != 0;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "network",
            "connectivity",
            "is",
            "required"
        ]
    },
    {
        "id": 1247,
        "code": "public boolean isUnmeteredNetworkRequired() {\n  return (requirements & NETWORK_UNMETERED) != 0;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "un",
            "metered",
            "network",
            "connectivity",
            "is",
            "required"
        ]
    },
    {
        "id": 1248,
        "code": "public boolean isChargingRequired() {\n  return (requirements & DEVICE_CHARGING) != 0;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "device",
            "is",
            "required",
            "to",
            "be",
            "charging"
        ]
    },
    {
        "id": 1249,
        "code": "public boolean isIdleRequired() {\n  return (requirements & DEVICE_IDLE) != 0;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "device",
            "is",
            "required",
            "to",
            "be",
            "idle"
        ]
    },
    {
        "id": 1250,
        "code": "public boolean isStorageNotLowRequired() {\n  return (requirements & DEVICE_STORAGE_NOT_LOW) != 0;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "device",
            "is",
            "required",
            "to",
            "not",
            "be",
            "low",
            "on",
            "em",
            "internal",
            "em",
            "storage"
        ]
    },
    {
        "id": 1251,
        "code": "public boolean checkRequirements(Context context) {\n  return getNotMetRequirements(context) == 0;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "requirements",
            "are",
            "met"
        ]
    },
    {
        "id": 1252,
        "code": "public @RequirementFlags int getNotMetRequirements(Context context) {\n  @RequirementFlags int notMetRequirements = getNotMetNetworkRequirements(context);\n  if (isChargingRequired() && !isDeviceCharging(context)) {\n    notMetRequirements |= DEVICE_CHARGING;\n  }\n  if (isIdleRequired() && !isDeviceIdle(context)) {\n    notMetRequirements |= DEVICE_IDLE;\n  }\n  if (isStorageNotLowRequired() && !isStorageNotLow(context)) {\n    notMetRequirements |= DEVICE_STORAGE_NOT_LOW;\n  }\n  return notMetRequirements;\n}",
        "summary_tokens": [
            "returns",
            "requirements",
            "that",
            "are",
            "not",
            "met",
            "or",
            "0"
        ]
    },
    {
        "id": 1253,
        "code": "public @Requirements.RequirementFlags int start() {\n  notMetRequirements = requirements.getNotMetRequirements(context);\n\n  IntentFilter filter = new IntentFilter();\n  if (requirements.isNetworkRequired()) {\n    if (Util.SDK_INT >= 24) {\n      registerNetworkCallbackV24();\n    } else {\n      filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);\n    }\n  }\n  if (requirements.isChargingRequired()) {\n    filter.addAction(Intent.ACTION_POWER_CONNECTED);\n    filter.addAction(Intent.ACTION_POWER_DISCONNECTED);\n  }\n  if (requirements.isIdleRequired()) {\n    if (Util.SDK_INT >= 23) {\n      filter.addAction(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED);\n    } else {\n      filter.addAction(Intent.ACTION_SCREEN_ON);\n      filter.addAction(Intent.ACTION_SCREEN_OFF);\n    }\n  }\n  if (requirements.isStorageNotLowRequired()) {\n    filter.addAction(Intent.ACTION_DEVICE_STORAGE_LOW);\n    filter.addAction(Intent.ACTION_DEVICE_STORAGE_OK);\n  }\n  receiver = new DeviceStatusChangeReceiver();\n  context.registerReceiver(receiver, filter, null, handler);\n  return notMetRequirements;\n}",
        "summary_tokens": [
            "starts",
            "watching",
            "for",
            "changes"
        ]
    },
    {
        "id": 1254,
        "code": "public void stop() {\n  context.unregisterReceiver(checkNotNull(receiver));\n  receiver = null;\n  if (Util.SDK_INT >= 24 && networkCallback != null) {\n    unregisterNetworkCallbackV24();\n  }\n}",
        "summary_tokens": [
            "stops",
            "watching",
            "for",
            "changes"
        ]
    },
    {
        "id": 1255,
        "code": "private void recheckNotMetNetworkRequirements() {\n  if ((notMetRequirements & (Requirements.NETWORK | Requirements.NETWORK_UNMETERED)) == 0) {\n      \n    return;\n  }\n  checkRequirements();\n}",
        "summary_tokens": [
            "re",
            "checks",
            "the",
            "requirements",
            "if",
            "there",
            "are",
            "network",
            "requirements",
            "that",
            "are",
            "currently",
            "not",
            "met"
        ]
    },
    {
        "id": 1256,
        "code": "protected void enableInternal() {}",
        "summary_tokens": [
            "enables",
            "the",
            "source",
            "see",
            "enable",
            "media",
            "source",
            "caller"
        ]
    },
    {
        "id": 1257,
        "code": "protected void disableInternal() {}",
        "summary_tokens": [
            "disables",
            "the",
            "source",
            "see",
            "disable",
            "media",
            "source",
            "caller"
        ]
    },
    {
        "id": 1258,
        "code": "protected final void refreshSourceInfo(Timeline timeline) {\n  this.timeline = timeline;\n  for (MediaSourceCaller caller : mediaSourceCallers) {\n    caller.onSourceInfoRefreshed( this, timeline);\n  }\n}",
        "summary_tokens": [
            "updates",
            "timeline",
            "and",
            "manifest",
            "and",
            "notifies",
            "all",
            "listeners",
            "of",
            "the",
            "update"
        ]
    },
    {
        "id": 1259,
        "code": "protected final MediaSourceEventListener.EventDispatcher createEventDispatcher(\n    int windowIndex, @Nullable MediaPeriodId mediaPeriodId, long mediaTimeOffsetMs) {\n  return eventDispatcher.withParameters(windowIndex, mediaPeriodId, mediaTimeOffsetMs);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "media",
            "source",
            "event",
            "listener"
        ]
    },
    {
        "id": 1260,
        "code": "protected final DrmSessionEventListener.EventDispatcher createDrmEventDispatcher(\n    int windowIndex, @Nullable MediaPeriodId mediaPeriodId) {\n  return drmEventDispatcher.withParameters(windowIndex, mediaPeriodId);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "drm",
            "session",
            "event",
            "listener"
        ]
    },
    {
        "id": 1261,
        "code": "protected final boolean isEnabled() {\n  return !enabledMediaSourceCallers.isEmpty();\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "source",
            "is",
            "enabled"
        ]
    },
    {
        "id": 1262,
        "code": "protected final PlayerId getPlayerId() {\n  return checkStateNotNull(playerId);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "player",
            "id",
            "of",
            "the",
            "player",
            "using",
            "this",
            "media",
            "source"
        ]
    },
    {
        "id": 1263,
        "code": "public void updateClipping(long startUs, long endUs) {\n  this.startUs = startUs;\n  this.endUs = endUs;\n}",
        "summary_tokens": [
            "updates",
            "the",
            "clipping",
            "start",
            "end",
            "times",
            "for",
            "this",
            "period",
            "in",
            "microseconds"
        ]
    },
    {
        "id": 1264,
        "code": "public void setClippingError(IllegalClippingException clippingError) {\n  this.clippingError = clippingError;\n}",
        "summary_tokens": [
            "sets",
            "a",
            "clipping",
            "error",
            "detected",
            "by",
            "the",
            "media",
            "source",
            "so",
            "that",
            "it",
            "can",
            "be",
            "thrown",
            "as",
            "a",
            "period",
            "error",
            "at",
            "the",
            "next",
            "opportunity"
        ]
    },
    {
        "id": 1265,
        "code": "protected final void prepareChildSource(@UnknownNull T id, MediaSource mediaSource) {\n  Assertions.checkArgument(!childSources.containsKey(id));\n  MediaSourceCaller caller =\n      (source, timeline) -> onChildSourceInfoRefreshed(id, source, timeline);\n  ForwardingEventListener eventListener = new ForwardingEventListener(id);\n  childSources.put(id, new MediaSourceAndListener<>(mediaSource, caller, eventListener));\n  mediaSource.addEventListener(Assertions.checkNotNull(eventHandler), eventListener);\n  mediaSource.addDrmEventListener(Assertions.checkNotNull(eventHandler), eventListener);\n  mediaSource.prepareSource(caller, mediaTransferListener, getPlayerId());\n  if (!isEnabled()) {\n    mediaSource.disable(caller);\n  }\n}",
        "summary_tokens": [
            "prepares",
            "a",
            "child",
            "source"
        ]
    },
    {
        "id": 1266,
        "code": "protected final void enableChildSource(@UnknownNull T id) {\n  MediaSourceAndListener<T> enabledChild = Assertions.checkNotNull(childSources.get(id));\n  enabledChild.mediaSource.enable(enabledChild.caller);\n}",
        "summary_tokens": [
            "enables",
            "a",
            "child",
            "source"
        ]
    },
    {
        "id": 1267,
        "code": "protected final void disableChildSource(@UnknownNull T id) {\n  MediaSourceAndListener<T> disabledChild = Assertions.checkNotNull(childSources.get(id));\n  disabledChild.mediaSource.disable(disabledChild.caller);\n}",
        "summary_tokens": [
            "disables",
            "a",
            "child",
            "source"
        ]
    },
    {
        "id": 1268,
        "code": "protected final void releaseChildSource(@UnknownNull T id) {\n  MediaSourceAndListener<T> removedChild = Assertions.checkNotNull(childSources.remove(id));\n  removedChild.mediaSource.releaseSource(removedChild.caller);\n  removedChild.mediaSource.removeEventListener(removedChild.eventListener);\n  removedChild.mediaSource.removeDrmEventListener(removedChild.eventListener);\n}",
        "summary_tokens": [
            "releases",
            "a",
            "child",
            "source"
        ]
    },
    {
        "id": 1269,
        "code": "protected int getWindowIndexForChildWindowIndex(@UnknownNull T id, int windowIndex) {\n  return windowIndex;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "window",
            "index",
            "in",
            "the",
            "composite",
            "source",
            "corresponding",
            "to",
            "the",
            "specified",
            "window",
            "index",
            "in",
            "a",
            "child",
            "source"
        ]
    },
    {
        "id": 1270,
        "code": "protected MediaPeriodId getMediaPeriodIdForChildMediaPeriodId(\n    @UnknownNull T id, MediaPeriodId mediaPeriodId) {\n  return mediaPeriodId;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "media",
            "period",
            "id",
            "in",
            "the",
            "composite",
            "source",
            "corresponding",
            "to",
            "the",
            "specified",
            "media",
            "period",
            "id",
            "in",
            "a",
            "child",
            "source"
        ]
    },
    {
        "id": 1271,
        "code": "protected long getMediaTimeForChildMediaTime(@UnknownNull T id, long mediaTimeMs) {\n  return mediaTimeMs;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "media",
            "time",
            "in",
            "the",
            "media",
            "period",
            "of",
            "the",
            "composite",
            "source",
            "corresponding",
            "to",
            "the",
            "specified",
            "media",
            "time",
            "in",
            "the",
            "media",
            "period",
            "of",
            "the",
            "child",
            "source"
        ]
    },
    {
        "id": 1272,
        "code": "public synchronized void addMediaSource(\n    int index, MediaSource mediaSource, Handler handler, Runnable onCompletionAction) {\n  addPublicMediaSources(\n      index, Collections.singletonList(mediaSource), handler, onCompletionAction);\n}",
        "summary_tokens": [
            "adds",
            "a",
            "media",
            "source",
            "to",
            "the",
            "playlist",
            "and",
            "executes",
            "a",
            "custom",
            "action",
            "on",
            "completion"
        ]
    },
    {
        "id": 1273,
        "code": "public synchronized void addMediaSources(\n    int index,\n    Collection<MediaSource> mediaSources,\n    Handler handler,\n    Runnable onCompletionAction) {\n  addPublicMediaSources(index, mediaSources, handler, onCompletionAction);\n}",
        "summary_tokens": [
            "adds",
            "multiple",
            "media",
            "source",
            "s",
            "to",
            "the",
            "playlist",
            "and",
            "executes",
            "a",
            "custom",
            "action",
            "on",
            "completion"
        ]
    },
    {
        "id": 1274,
        "code": "public synchronized MediaSource removeMediaSource(\n    int index, Handler handler, Runnable onCompletionAction) {\n  MediaSource removedMediaSource = getMediaSource(index);\n  removePublicMediaSources(index, index + 1, handler, onCompletionAction);\n  return removedMediaSource;\n}",
        "summary_tokens": [
            "removes",
            "a",
            "media",
            "source",
            "from",
            "the",
            "playlist",
            "and",
            "executes",
            "a",
            "custom",
            "action",
            "on",
            "completion"
        ]
    },
    {
        "id": 1275,
        "code": "public synchronized void removeMediaSourceRange(\n    int fromIndex, int toIndex, Handler handler, Runnable onCompletionAction) {\n  removePublicMediaSources(fromIndex, toIndex, handler, onCompletionAction);\n}",
        "summary_tokens": [
            "removes",
            "a",
            "range",
            "of",
            "media",
            "source",
            "s",
            "from",
            "the",
            "playlist",
            "by",
            "specifying",
            "an",
            "initial",
            "index",
            "included",
            "and",
            "a",
            "final",
            "index",
            "excluded",
            "and",
            "executes",
            "a",
            "custom",
            "action",
            "on",
            "completion"
        ]
    },
    {
        "id": 1276,
        "code": "public synchronized void moveMediaSource(\n    int currentIndex, int newIndex, Handler handler, Runnable onCompletionAction) {\n  movePublicMediaSource(currentIndex, newIndex, handler, onCompletionAction);\n}",
        "summary_tokens": [
            "moves",
            "an",
            "existing",
            "media",
            "source",
            "within",
            "the",
            "playlist",
            "and",
            "executes",
            "a",
            "custom",
            "action",
            "on",
            "completion"
        ]
    },
    {
        "id": 1277,
        "code": "public synchronized void clear(Handler handler, Runnable onCompletionAction) {\n  removeMediaSourceRange(0, getSize(), handler, onCompletionAction);\n}",
        "summary_tokens": [
            "clears",
            "the",
            "playlist",
            "and",
            "executes",
            "a",
            "custom",
            "action",
            "on",
            "completion"
        ]
    },
    {
        "id": 1278,
        "code": "public synchronized int getSize() {\n  return mediaSourcesPublic.size();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "media",
            "sources",
            "in",
            "the",
            "playlist"
        ]
    },
    {
        "id": 1279,
        "code": "public synchronized MediaSource getMediaSource(int index) {\n  return mediaSourcesPublic.get(index).mediaSource;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "media",
            "source",
            "at",
            "a",
            "specified",
            "index"
        ]
    },
    {
        "id": 1280,
        "code": "public synchronized void setShuffleOrder(\n    ShuffleOrder shuffleOrder, Handler handler, Runnable onCompletionAction) {\n  setPublicShuffleOrder(shuffleOrder, handler, onCompletionAction);\n}",
        "summary_tokens": [
            "sets",
            "a",
            "new",
            "shuffle",
            "order",
            "to",
            "use",
            "when",
            "shuffling",
            "the",
            "child",
            "media",
            "sources"
        ]
    },
    {
        "id": 1281,
        "code": "private static Object getMediaSourceHolderUid(Object periodUid) {\n  return ConcatenatedTimeline.getChildTimelineUidFromConcatenatedUid(periodUid);\n}",
        "summary_tokens": [
            "return",
            "uid",
            "of",
            "media",
            "source",
            "holder",
            "from",
            "period",
            "uid",
            "of",
            "concatenated",
            "source"
        ]
    },
    {
        "id": 1282,
        "code": "private static Object getChildPeriodUid(Object periodUid) {\n  return ConcatenatedTimeline.getChildPeriodUidFromConcatenatedUid(periodUid);\n}",
        "summary_tokens": [
            "return",
            "uid",
            "of",
            "child",
            "period",
            "from",
            "period",
            "uid",
            "of",
            "concatenated",
            "source"
        ]
    },
    {
        "id": 1283,
        "code": "private boolean readMetadata() throws IOException {\n  int bytesRead = upstream.read(metadataLengthByteHolder, 0, 1);\n  if (bytesRead == C.RESULT_END_OF_INPUT) {\n    return false;\n  }\n  int metadataLength = (metadataLengthByteHolder[0] & 0xFF) << 4;\n  if (metadataLength == 0) {\n    return true;\n  }\n\n  int offset = 0;\n  int lengthRemaining = metadataLength;\n  byte[] metadata = new byte[metadataLength];\n  while (lengthRemaining > 0) {\n    bytesRead = upstream.read(metadata, offset, lengthRemaining);\n    if (bytesRead == C.RESULT_END_OF_INPUT) {\n      return false;\n    }\n    offset += bytesRead;\n    lengthRemaining -= bytesRead;\n  }\n\n    \n  while (metadataLength > 0 && metadata[metadataLength - 1] == 0) {\n    metadataLength--;\n  }\n\n  if (metadataLength > 0) {\n    listener.onIcyMetadata(new ParsableByteArray(metadata, metadataLength));\n  }\n  return true;\n}",
        "summary_tokens": [
            "reads",
            "an",
            "icy",
            "stream",
            "metadata",
            "block",
            "passing",
            "it",
            "to",
            "listener",
            "unless",
            "the",
            "block",
            "is",
            "empty"
        ]
    },
    {
        "id": 1284,
        "code": "public static long getNewId() {\n  return idSource.getAndIncrement();\n}",
        "summary_tokens": [
            "returns",
            "an",
            "non",
            "negative",
            "identifier",
            "which",
            "is",
            "unique",
            "to",
            "the",
            "jvm",
            "instance"
        ]
    },
    {
        "id": 1285,
        "code": "public void setPrepareListener(PrepareListener listener) {\n  this.listener = listener;\n}",
        "summary_tokens": [
            "sets",
            "a",
            "listener",
            "for",
            "preparation",
            "events"
        ]
    },
    {
        "id": 1286,
        "code": "public long getPreparePositionUs() {\n  return preparePositionUs;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "position",
            "at",
            "which",
            "the",
            "masking",
            "media",
            "period",
            "was",
            "prepared",
            "in",
            "microseconds"
        ]
    },
    {
        "id": 1287,
        "code": "public void overridePreparePositionUs(long preparePositionUs) {\n  preparePositionOverrideUs = preparePositionUs;\n}",
        "summary_tokens": [
            "overrides",
            "the",
            "default",
            "prepare",
            "position",
            "at",
            "which",
            "to",
            "prepare",
            "the",
            "media",
            "period"
        ]
    },
    {
        "id": 1288,
        "code": "public long getPreparePositionOverrideUs() {\n  return preparePositionOverrideUs;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "prepare",
            "position",
            "override",
            "set",
            "by",
            "override",
            "prepare",
            "position",
            "us",
            "long"
        ]
    },
    {
        "id": 1289,
        "code": "public void setMediaSource(MediaSource mediaSource) {\n  checkState(this.mediaSource == null);\n  this.mediaSource = mediaSource;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "media",
            "source",
            "that",
            "will",
            "create",
            "the",
            "underlying",
            "media",
            "period"
        ]
    },
    {
        "id": 1290,
        "code": "public void createPeriod(MediaPeriodId id) {\n  long preparePositionUs = getPreparePositionWithOverride(this.preparePositionUs);\n  mediaPeriod = checkNotNull(mediaSource).createPeriod(id, allocator, preparePositionUs);\n  if (callback != null) {\n    mediaPeriod.prepare( this, preparePositionUs);\n  }\n}",
        "summary_tokens": [
            "calls",
            "media",
            "source",
            "create",
            "period",
            "media",
            "period",
            "id",
            "allocator",
            "long",
            "on",
            "the",
            "wrapped",
            "source",
            "then",
            "prepares",
            "it",
            "if",
            "prepare",
            "callback",
            "long",
            "has",
            "been",
            "called"
        ]
    },
    {
        "id": 1291,
        "code": "default List<StreamKey> getStreamKeys(List<ExoTrackSelection> trackSelections) {\n  return Collections.emptyList();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "list",
            "of",
            "stream",
            "key",
            "stream",
            "keys",
            "which",
            "allow",
            "to",
            "filter",
            "the",
            "media",
            "in",
            "this",
            "period",
            "to",
            "load",
            "only",
            "the",
            "parts",
            "needed",
            "to",
            "play",
            "the",
            "provided",
            "exo",
            "track",
            "selection",
            "track",
            "selections"
        ]
    },
    {
        "id": 1292,
        "code": "default Timeline getInitialTimeline() {\n  return null;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "initial",
            "placeholder",
            "timeline",
            "that",
            "is",
            "returned",
            "immediately",
            "when",
            "the",
            "real",
            "timeline",
            "is",
            "not",
            "yet",
            "known",
            "or",
            "null",
            "to",
            "let",
            "the",
            "player",
            "create",
            "an",
            "initial",
            "timeline"
        ]
    },
    {
        "id": 1293,
        "code": "default boolean isSingleWindow() {\n  return true;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "the",
            "media",
            "source",
            "is",
            "guaranteed",
            "to",
            "never",
            "have",
            "zero",
            "or",
            "more",
            "than",
            "one",
            "window"
        ]
    },
    {
        "id": 1294,
        "code": "default void prepareSource(\n    MediaSourceCaller caller, @Nullable TransferListener mediaTransferListener) {\n  prepareSource(caller, mediaTransferListener, PlayerId.UNSET);\n}",
        "summary_tokens": [
            "implement",
            "prepare",
            "source",
            "media",
            "source",
            "caller",
            "transfer",
            "listener",
            "player",
            "id",
            "instead"
        ]
    },
    {
        "id": 1295,
        "code": "default void onLoadStarted(\n    int windowIndex,\n    @Nullable MediaPeriodId mediaPeriodId,\n    LoadEventInfo loadEventInfo,\n    MediaLoadData mediaLoadData) {}",
        "summary_tokens": [
            "called",
            "when",
            "a",
            "load",
            "begins"
        ]
    },
    {
        "id": 1296,
        "code": "default void onLoadCompleted(\n    int windowIndex,\n    @Nullable MediaPeriodId mediaPeriodId,\n    LoadEventInfo loadEventInfo,\n    MediaLoadData mediaLoadData) {}",
        "summary_tokens": [
            "called",
            "when",
            "a",
            "load",
            "ends"
        ]
    },
    {
        "id": 1297,
        "code": "default void onLoadCanceled(\n    int windowIndex,\n    @Nullable MediaPeriodId mediaPeriodId,\n    LoadEventInfo loadEventInfo,\n    MediaLoadData mediaLoadData) {}",
        "summary_tokens": [
            "called",
            "when",
            "a",
            "load",
            "is",
            "canceled"
        ]
    },
    {
        "id": 1298,
        "code": "default void onLoadError(\n    int windowIndex,\n    @Nullable MediaPeriodId mediaPeriodId,\n    LoadEventInfo loadEventInfo,\n    MediaLoadData mediaLoadData,\n    IOException error,\n    boolean wasCanceled) {}",
        "summary_tokens": [
            "called",
            "when",
            "a",
            "load",
            "error",
            "occurs"
        ]
    },
    {
        "id": 1299,
        "code": "default void onUpstreamDiscarded(\n    int windowIndex, MediaPeriodId mediaPeriodId, MediaLoadData mediaLoadData) {}",
        "summary_tokens": [
            "called",
            "when",
            "data",
            "is",
            "removed",
            "from",
            "the",
            "back",
            "of",
            "a",
            "media",
            "buffer",
            "typically",
            "so",
            "that",
            "it",
            "can",
            "be",
            "re",
            "buffered",
            "in",
            "a",
            "different",
            "format"
        ]
    },
    {
        "id": 1300,
        "code": "default void onDownstreamFormatChanged(\n    int windowIndex, @Nullable MediaPeriodId mediaPeriodId, MediaLoadData mediaLoadData) {}",
        "summary_tokens": [
            "called",
            "when",
            "a",
            "downstream",
            "format",
            "change",
            "occurs",
            "i"
        ]
    },
    {
        "id": 1301,
        "code": "public MediaPeriod getChildPeriod(int index) {\n  return periods[index] instanceof TimeOffsetMediaPeriod\n      ? ((TimeOffsetMediaPeriod) periods[index]).mediaPeriod\n      : periods[index];\n}",
        "summary_tokens": [
            "returns",
            "the",
            "child",
            "period",
            "passed",
            "to",
            "merging",
            "media",
            "period",
            "composite",
            "sequenceable",
            "loader",
            "factory",
            "long",
            "media",
            "period"
        ]
    },
    {
        "id": 1302,
        "code": "private boolean configureRetry(ExtractingLoadable loadable, int currentExtractedSampleCount) {\n  if (isLengthKnown || (seekMap != null && seekMap.getDurationUs() != C.TIME_UNSET)) {\n      \n      \n    extractedSamplesCountAtStartOfLoad = currentExtractedSampleCount;\n    return true;\n  } else if (prepared && !suppressRead()) {\n      \n      \n      \n      \n      \n      \n      \n      \n      \n    pendingDeferredRetry = true;\n    return false;\n  } else {\n      \n      \n      \n      \n    notifyDiscontinuity = prepared;\n    lastSeekPositionUs = 0;\n    extractedSamplesCountAtStartOfLoad = 0;\n    for (SampleQueue sampleQueue : sampleQueues) {\n      sampleQueue.reset();\n    }\n    loadable.setLoadPosition(0, 0);\n    return true;\n  }\n}",
        "summary_tokens": [
            "called",
            "to",
            "configure",
            "a",
            "retry",
            "when",
            "a",
            "load",
            "error",
            "occurs"
        ]
    },
    {
        "id": 1303,
        "code": "private boolean seekInsideBufferUs(boolean[] trackIsAudioVideoFlags, long positionUs) {\n  int trackCount = sampleQueues.length;\n  for (int i = 0; i < trackCount; i++) {\n    SampleQueue sampleQueue = sampleQueues[i];\n    boolean seekInsideQueue = sampleQueue.seekTo(positionUs,  false);\n      \n      \n      \n      \n    if (!seekInsideQueue && (trackIsAudioVideoFlags[i] || !haveAudioVideoTracks)) {\n      return false;\n    }\n  }\n  return true;\n}",
        "summary_tokens": [
            "attempts",
            "to",
            "seek",
            "to",
            "the",
            "specified",
            "position",
            "within",
            "the",
            "sample",
            "queues"
        ]
    },
    {
        "id": 1304,
        "code": "public void reset() {\n  clearAllocationNodes(firstAllocationNode);\n  firstAllocationNode.reset( 0, allocationLength);\n  readAllocationNode = firstAllocationNode;\n  writeAllocationNode = firstAllocationNode;\n  totalBytesWritten = 0;\n  allocator.trim();\n}",
        "summary_tokens": [
            "clears",
            "all",
            "sample",
            "data"
        ]
    },
    {
        "id": 1305,
        "code": "public void discardUpstreamSampleBytes(long totalBytesWritten) {\n  Assertions.checkArgument(totalBytesWritten <= this.totalBytesWritten);\n  this.totalBytesWritten = totalBytesWritten;\n  if (this.totalBytesWritten == 0\n      || this.totalBytesWritten == firstAllocationNode.startPosition) {\n    clearAllocationNodes(firstAllocationNode);\n    firstAllocationNode = new AllocationNode(this.totalBytesWritten, allocationLength);\n    readAllocationNode = firstAllocationNode;\n    writeAllocationNode = firstAllocationNode;\n  } else {\n      \n    AllocationNode lastNodeToKeep = firstAllocationNode;\n    while (this.totalBytesWritten > lastNodeToKeep.endPosition) {\n      lastNodeToKeep = lastNodeToKeep.next;\n    }\n      \n    AllocationNode firstNodeToDiscard = Assertions.checkNotNull(lastNodeToKeep.next);\n    clearAllocationNodes(firstNodeToDiscard);\n      \n    lastNodeToKeep.next = new AllocationNode(lastNodeToKeep.endPosition, allocationLength);\n      \n    writeAllocationNode =\n        this.totalBytesWritten == lastNodeToKeep.endPosition\n            ? lastNodeToKeep.next\n            : lastNodeToKeep;\n    if (readAllocationNode == firstNodeToDiscard) {\n      readAllocationNode = lastNodeToKeep.next;\n    }\n  }\n}",
        "summary_tokens": [
            "discards",
            "sample",
            "data",
            "bytes",
            "from",
            "the",
            "write",
            "side",
            "of",
            "the",
            "queue"
        ]
    },
    {
        "id": 1306,
        "code": "public void rewind() {\n  readAllocationNode = firstAllocationNode;\n}",
        "summary_tokens": [
            "rewinds",
            "the",
            "read",
            "position",
            "to",
            "the",
            "first",
            "sample",
            "in",
            "the",
            "queue"
        ]
    },
    {
        "id": 1307,
        "code": "public void readToBuffer(DecoderInputBuffer buffer, SampleExtrasHolder extrasHolder) {\n  readAllocationNode = readSampleData(readAllocationNode, buffer, extrasHolder, scratch);\n}",
        "summary_tokens": [
            "reads",
            "data",
            "from",
            "the",
            "rolling",
            "buffer",
            "to",
            "populate",
            "a",
            "decoder",
            "input",
            "buffer",
            "and",
            "advances",
            "the",
            "read",
            "position"
        ]
    },
    {
        "id": 1308,
        "code": "public void peekToBuffer(DecoderInputBuffer buffer, SampleExtrasHolder extrasHolder) {\n  readSampleData(readAllocationNode, buffer, extrasHolder, scratch);\n}",
        "summary_tokens": [
            "peeks",
            "data",
            "from",
            "the",
            "rolling",
            "buffer",
            "to",
            "populate",
            "a",
            "decoder",
            "input",
            "buffer",
            "without",
            "advancing",
            "the",
            "read",
            "position"
        ]
    },
    {
        "id": 1309,
        "code": "public void discardDownstreamTo(long absolutePosition) {\n  if (absolutePosition == C.POSITION_UNSET) {\n    return;\n  }\n  while (absolutePosition >= firstAllocationNode.endPosition) {\n      \n      \n    allocator.release(firstAllocationNode.allocation);\n    firstAllocationNode = firstAllocationNode.clear();\n  }\n  if (readAllocationNode.startPosition < firstAllocationNode.startPosition) {\n      \n      \n    readAllocationNode = firstAllocationNode;\n  }\n}",
        "summary_tokens": [
            "advances",
            "the",
            "read",
            "position",
            "to",
            "the",
            "specified",
            "absolute",
            "position"
        ]
    },
    {
        "id": 1310,
        "code": "private void clearAllocationNodes(AllocationNode fromNode) {\n  if (fromNode.allocation == null) {\n    return;\n  }\n    \n    \n    \n  allocator.release(fromNode);\n  fromNode.clear();\n}",
        "summary_tokens": [
            "clears",
            "allocation",
            "nodes",
            "starting",
            "from",
            "from",
            "node"
        ]
    },
    {
        "id": 1311,
        "code": "private int preAppend(int length) {\n  if (writeAllocationNode.allocation == null) {\n    writeAllocationNode.initialize(\n        allocator.allocate(),\n        new AllocationNode(writeAllocationNode.endPosition, allocationLength));\n  }\n  return min(length, (int) (writeAllocationNode.endPosition - totalBytesWritten));\n}",
        "summary_tokens": [
            "called",
            "before",
            "writing",
            "sample",
            "data",
            "to",
            "write",
            "allocation",
            "node"
        ]
    },
    {
        "id": 1312,
        "code": "private void postAppend(int length) {\n  totalBytesWritten += length;\n  if (totalBytesWritten == writeAllocationNode.endPosition) {\n    writeAllocationNode = writeAllocationNode.next;\n  }\n}",
        "summary_tokens": [
            "called",
            "after",
            "writing",
            "sample",
            "data"
        ]
    },
    {
        "id": 1313,
        "code": "private static AllocationNode readSampleData(\n    AllocationNode allocationNode,\n    DecoderInputBuffer buffer,\n    SampleExtrasHolder extrasHolder,\n    ParsableByteArray scratch) {\n  if (buffer.isEncrypted()) {\n    allocationNode = readEncryptionData(allocationNode, buffer, extrasHolder, scratch);\n  }\n    \n  if (buffer.hasSupplementalData()) {\n      \n    scratch.reset(4);\n    allocationNode = readData(allocationNode, extrasHolder.offset, scratch.getData(), 4);\n    int sampleSize = scratch.readUnsignedIntToInt();\n    extrasHolder.offset += 4;\n    extrasHolder.size -= 4;\n\n      \n    buffer.ensureSpaceForWrite(sampleSize);\n    allocationNode = readData(allocationNode, extrasHolder.offset, buffer.data, sampleSize);\n    extrasHolder.offset += sampleSize;\n    extrasHolder.size -= sampleSize;\n\n      \n    buffer.resetSupplementalData(extrasHolder.size);\n    allocationNode =\n        readData(allocationNode, extrasHolder.offset, buffer.supplementalData, extrasHolder.size);\n  } else {\n      \n    buffer.ensureSpaceForWrite(extrasHolder.size);\n    allocationNode =\n        readData(allocationNode, extrasHolder.offset, buffer.data, extrasHolder.size);\n  }\n  return allocationNode;\n}",
        "summary_tokens": [
            "reads",
            "data",
            "from",
            "the",
            "rolling",
            "buffer",
            "to",
            "populate",
            "a",
            "decoder",
            "input",
            "buffer"
        ]
    },
    {
        "id": 1314,
        "code": "private static AllocationNode readEncryptionData(\n    AllocationNode allocationNode,\n    DecoderInputBuffer buffer,\n    SampleExtrasHolder extrasHolder,\n    ParsableByteArray scratch) {\n  long offset = extrasHolder.offset;\n\n    \n  scratch.reset(1);\n  allocationNode = readData(allocationNode, offset, scratch.getData(), 1);\n  offset++;\n  byte signalByte = scratch.getData()[0];\n  boolean subsampleEncryption = (signalByte & 0x80) != 0;\n  int ivSize = signalByte & 0x7F;\n\n    \n  CryptoInfo cryptoInfo = buffer.cryptoInfo;\n  if (cryptoInfo.iv == null) {\n    cryptoInfo.iv = new byte[16];\n  } else {\n      \n    Arrays.fill(cryptoInfo.iv, (byte) 0);\n  }\n  allocationNode = readData(allocationNode, offset, cryptoInfo.iv, ivSize);\n  offset += ivSize;\n\n    \n  int subsampleCount;\n  if (subsampleEncryption) {\n    scratch.reset(2);\n    allocationNode = readData(allocationNode, offset, scratch.getData(), 2);\n    offset += 2;\n    subsampleCount = scratch.readUnsignedShort();\n  } else {\n    subsampleCount = 1;\n  }\n\n    \n  @Nullable int[] clearDataSizes = cryptoInfo.numBytesOfClearData;\n  if (clearDataSizes == null || clearDataSizes.length < subsampleCount) {\n    clearDataSizes = new int[subsampleCount];\n  }\n  @Nullable int[] encryptedDataSizes = cryptoInfo.numBytesOfEncryptedData;\n  if (encryptedDataSizes == null || encryptedDataSizes.length < subsampleCount) {\n    encryptedDataSizes = new int[subsampleCount];\n  }\n  if (subsampleEncryption) {\n    int subsampleDataLength = 6 * subsampleCount;\n    scratch.reset(subsampleDataLength);\n    allocationNode = readData(allocationNode, offset, scratch.getData(), subsampleDataLength);\n    offset += subsampleDataLength;\n    scratch.setPosition(0);\n    for (int i = 0; i < subsampleCount; i++) {\n      clearDataSizes[i] = scratch.readUnsignedShort();\n      encryptedDataSizes[i] = scratch.readUnsignedIntToInt();\n    }\n  } else {\n    clearDataSizes[0] = 0;\n    encryptedDataSizes[0] = extrasHolder.size - (int) (offset - extrasHolder.offset);\n  }\n\n    \n  CryptoData cryptoData = Util.castNonNull(extrasHolder.cryptoData);\n  cryptoInfo.set(\n      subsampleCount,\n      clearDataSizes,\n      encryptedDataSizes,\n      cryptoData.encryptionKey,\n      cryptoInfo.iv,\n      cryptoData.cryptoMode,\n      cryptoData.encryptedBlocks,\n      cryptoData.clearBlocks);\n\n    \n  int bytesRead = (int) (offset - extrasHolder.offset);\n  extrasHolder.offset += bytesRead;\n  extrasHolder.size -= bytesRead;\n  return allocationNode;\n}",
        "summary_tokens": [
            "reads",
            "encryption",
            "data",
            "for",
            "the",
            "sample",
            "described",
            "by",
            "extras",
            "holder"
        ]
    },
    {
        "id": 1315,
        "code": "private static AllocationNode readData(\n    AllocationNode allocationNode, long absolutePosition, byte[] target, int length) {\n  allocationNode = getNodeContainingPosition(allocationNode, absolutePosition);\n  int remaining = length;\n  while (remaining > 0) {\n    int toCopy = min(remaining, (int) (allocationNode.endPosition - absolutePosition));\n    Allocation allocation = allocationNode.allocation;\n    System.arraycopy(\n        allocation.data,\n        allocationNode.translateOffset(absolutePosition),\n        target,\n        length - remaining,\n        toCopy);\n    remaining -= toCopy;\n    absolutePosition += toCopy;\n    if (absolutePosition == allocationNode.endPosition) {\n      allocationNode = allocationNode.next;\n    }\n  }\n  return allocationNode;\n}",
        "summary_tokens": [
            "reads",
            "data",
            "from",
            "allocation",
            "node",
            "and",
            "its",
            "following",
            "nodes"
        ]
    },
    {
        "id": 1316,
        "code": "private static AllocationNode getNodeContainingPosition(\n    AllocationNode allocationNode, long absolutePosition) {\n  while (absolutePosition >= allocationNode.endPosition) {\n    allocationNode = allocationNode.next;\n  }\n  return allocationNode;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "allocation",
            "node",
            "in",
            "allocation",
            "node",
            "s",
            "chain",
            "which",
            "contains",
            "the",
            "given",
            "absolute",
            "position"
        ]
    },
    {
        "id": 1317,
        "code": "public static SampleQueue createWithoutDrm(Allocator allocator) {\n  return new SampleQueue(\n      allocator,  null,  null);\n}",
        "summary_tokens": [
            "creates",
            "a",
            "sample",
            "queue",
            "without",
            "drm",
            "resource",
            "management"
        ]
    },
    {
        "id": 1318,
        "code": "public static SampleQueue createWithDrm(\n    Allocator allocator,\n    Looper playbackLooper,\n    DrmSessionManager drmSessionManager,\n    DrmSessionEventListener.EventDispatcher drmEventDispatcher) {\n  drmSessionManager.setPlayer(playbackLooper, PlayerId.UNSET);\n  return new SampleQueue(\n      allocator,\n      Assertions.checkNotNull(drmSessionManager),\n      Assertions.checkNotNull(drmEventDispatcher));\n}",
        "summary_tokens": [
            "use",
            "create",
            "with",
            "drm",
            "allocator",
            "drm",
            "session",
            "manager",
            "event",
            "dispatcher",
            "instead"
        ]
    },
    {
        "id": 1319,
        "code": "public void release() {\n  reset( true);\n  releaseDrmSessionReferences();\n}",
        "summary_tokens": [
            "calls",
            "reset",
            "boolean",
            "reset",
            "true",
            "and",
            "releases",
            "any",
            "resources",
            "owned",
            "by",
            "the",
            "queue"
        ]
    },
    {
        "id": 1320,
        "code": "public void reset(boolean resetUpstreamFormat) {\n  sampleDataQueue.reset();\n  length = 0;\n  absoluteFirstIndex = 0;\n  relativeFirstIndex = 0;\n  readPosition = 0;\n  upstreamKeyframeRequired = true;\n  startTimeUs = Long.MIN_VALUE;\n  largestDiscardedTimestampUs = Long.MIN_VALUE;\n  largestQueuedTimestampUs = Long.MIN_VALUE;\n  isLastSampleQueued = false;\n  sharedSampleMetadata.clear();\n  if (resetUpstreamFormat) {\n    unadjustedUpstreamFormat = null;\n    upstreamFormat = null;\n    upstreamFormatRequired = true;\n  }\n}",
        "summary_tokens": [
            "clears",
            "all",
            "samples",
            "from",
            "the",
            "queue"
        ]
    },
    {
        "id": 1321,
        "code": "public final void setStartTimeUs(long startTimeUs) {\n  this.startTimeUs = startTimeUs;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "start",
            "time",
            "for",
            "the",
            "queue"
        ]
    },
    {
        "id": 1322,
        "code": "public final void sourceId(int sourceId) {\n  upstreamSourceId = sourceId;\n}",
        "summary_tokens": [
            "sets",
            "a",
            "source",
            "identifier",
            "for",
            "subsequent",
            "samples"
        ]
    },
    {
        "id": 1323,
        "code": "public final void splice() {\n  pendingSplice = true;\n}",
        "summary_tokens": [
            "indicates",
            "samples",
            "that",
            "are",
            "subsequently",
            "queued",
            "should",
            "be",
            "spliced",
            "into",
            "those",
            "already",
            "queued"
        ]
    },
    {
        "id": 1324,
        "code": "public final int getWriteIndex() {\n  return absoluteFirstIndex + length;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "current",
            "absolute",
            "write",
            "index"
        ]
    },
    {
        "id": 1325,
        "code": "public final void discardUpstreamSamples(int discardFromIndex) {\n  sampleDataQueue.discardUpstreamSampleBytes(discardUpstreamSampleMetadata(discardFromIndex));\n}",
        "summary_tokens": [
            "discards",
            "samples",
            "from",
            "the",
            "write",
            "side",
            "of",
            "the",
            "queue"
        ]
    },
    {
        "id": 1326,
        "code": "public final void discardUpstreamFrom(long timeUs) {\n  if (length == 0) {\n    return;\n  }\n  checkArgument(timeUs > getLargestReadTimestampUs());\n  int retainCount = countUnreadSamplesBefore(timeUs);\n  discardUpstreamSamples(absoluteFirstIndex + retainCount);\n}",
        "summary_tokens": [
            "discards",
            "samples",
            "from",
            "the",
            "write",
            "side",
            "of",
            "the",
            "queue"
        ]
    },
    {
        "id": 1327,
        "code": "public void preRelease() {\n  discardToEnd();\n  releaseDrmSessionReferences();\n}",
        "summary_tokens": [
            "calls",
            "discard",
            "to",
            "end",
            "and",
            "releases",
            "any",
            "resources",
            "owned",
            "by",
            "the",
            "queue"
        ]
    },
    {
        "id": 1328,
        "code": "public void maybeThrowError() throws IOException {\n    \n  if (currentDrmSession != null && currentDrmSession.getState() == DrmSession.STATE_ERROR) {\n    throw Assertions.checkNotNull(currentDrmSession.getError());\n  }\n}",
        "summary_tokens": [
            "throws",
            "an",
            "error",
            "that",
            "s",
            "preventing",
            "data",
            "from",
            "being",
            "read"
        ]
    },
    {
        "id": 1329,
        "code": "public final int getFirstIndex() {\n  return absoluteFirstIndex;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "current",
            "absolute",
            "start",
            "index"
        ]
    },
    {
        "id": 1330,
        "code": "public final int getReadIndex() {\n  return absoluteFirstIndex + readPosition;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "current",
            "absolute",
            "read",
            "index"
        ]
    },
    {
        "id": 1331,
        "code": "public final synchronized int peekSourceId() {\n  int relativeReadIndex = getRelativeIndex(readPosition);\n  return hasNextSample() ? sourceIds[relativeReadIndex] : upstreamSourceId;\n}",
        "summary_tokens": [
            "peeks",
            "the",
            "source",
            "id",
            "of",
            "the",
            "next",
            "sample",
            "to",
            "be",
            "read",
            "or",
            "the",
            "current",
            "upstream",
            "source",
            "id",
            "if",
            "the",
            "queue",
            "is",
            "empty",
            "or",
            "if",
            "the",
            "read",
            "position",
            "is",
            "at",
            "the",
            "end",
            "of",
            "the",
            "queue"
        ]
    },
    {
        "id": 1332,
        "code": "public final synchronized Format getUpstreamFormat() {\n  return upstreamFormatRequired ? null : upstreamFormat;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "upstream",
            "format",
            "in",
            "which",
            "samples",
            "are",
            "being",
            "queued"
        ]
    },
    {
        "id": 1333,
        "code": "public final synchronized long getLargestQueuedTimestampUs() {\n  return largestQueuedTimestampUs;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "largest",
            "sample",
            "timestamp",
            "that",
            "has",
            "been",
            "queued",
            "since",
            "the",
            "last",
            "reset"
        ]
    },
    {
        "id": 1334,
        "code": "public final synchronized long getLargestReadTimestampUs() {\n  return max(largestDiscardedTimestampUs, getLargestTimestamp(readPosition));\n}",
        "summary_tokens": [
            "returns",
            "the",
            "largest",
            "sample",
            "timestamp",
            "that",
            "has",
            "been",
            "read",
            "since",
            "the",
            "last",
            "reset"
        ]
    },
    {
        "id": 1335,
        "code": "public final synchronized boolean isLastSampleQueued() {\n  return isLastSampleQueued;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "last",
            "sample",
            "of",
            "the",
            "stream",
            "has",
            "knowingly",
            "been",
            "queued"
        ]
    },
    {
        "id": 1336,
        "code": "public final synchronized long getFirstTimestampUs() {\n  return length == 0 ? Long.MIN_VALUE : timesUs[relativeFirstIndex];\n}",
        "summary_tokens": [
            "returns",
            "the",
            "timestamp",
            "of",
            "the",
            "first",
            "sample",
            "or",
            "long",
            "min",
            "value",
            "if",
            "the",
            "queue",
            "is",
            "empty"
        ]
    },
    {
        "id": 1337,
        "code": "public synchronized boolean isReady(boolean loadingFinished) {\n  if (!hasNextSample()) {\n    return loadingFinished\n        || isLastSampleQueued\n        || (upstreamFormat != null && upstreamFormat != downstreamFormat);\n  }\n  if (sharedSampleMetadata.get(getReadIndex()).format != downstreamFormat) {\n      \n    return true;\n  }\n  return mayReadSample(getRelativeIndex(readPosition));\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "there",
            "is",
            "data",
            "available",
            "for",
            "reading"
        ]
    },
    {
        "id": 1338,
        "code": "public int read(\n    FormatHolder formatHolder,\n    DecoderInputBuffer buffer,\n    @ReadFlags int readFlags,\n    boolean loadingFinished) {\n  int result =\n      peekSampleMetadata(\n          formatHolder,\n          buffer,\n           (readFlags & FLAG_REQUIRE_FORMAT) != 0,\n          loadingFinished,\n          extrasHolder);\n  if (result == C.RESULT_BUFFER_READ && !buffer.isEndOfStream()) {\n    boolean peek = (readFlags & FLAG_PEEK) != 0;\n    if ((readFlags & FLAG_OMIT_SAMPLE_DATA) == 0) {\n      if (peek) {\n        sampleDataQueue.peekToBuffer(buffer, extrasHolder);\n      } else {\n        sampleDataQueue.readToBuffer(buffer, extrasHolder);\n      }\n    }\n    if (!peek) {\n      readPosition++;\n    }\n  }\n  return result;\n}",
        "summary_tokens": [
            "attempts",
            "to",
            "read",
            "from",
            "the",
            "queue"
        ]
    },
    {
        "id": 1339,
        "code": "public final synchronized boolean seekTo(long timeUs, boolean allowTimeBeyondBuffer) {\n  rewind();\n  int relativeReadIndex = getRelativeIndex(readPosition);\n  if (!hasNextSample()\n      || timeUs < timesUs[relativeReadIndex]\n      || (timeUs > largestQueuedTimestampUs && !allowTimeBeyondBuffer)) {\n    return false;\n  }\n  int offset =\n      findSampleBefore(relativeReadIndex, length - readPosition, timeUs,  true);\n  if (offset == -1) {\n    return false;\n  }\n  startTimeUs = timeUs;\n  readPosition += offset;\n  return true;\n}",
        "summary_tokens": [
            "attempts",
            "to",
            "seek",
            "the",
            "read",
            "position",
            "to",
            "the",
            "keyframe",
            "before",
            "or",
            "at",
            "the",
            "specified",
            "time"
        ]
    },
    {
        "id": 1340,
        "code": "public final synchronized int getSkipCount(long timeUs, boolean allowEndOfQueue) {\n  int relativeReadIndex = getRelativeIndex(readPosition);\n  if (!hasNextSample() || timeUs < timesUs[relativeReadIndex]) {\n    return 0;\n  }\n  if (timeUs > largestQueuedTimestampUs && allowEndOfQueue) {\n    return length - readPosition;\n  }\n  int offset =\n      findSampleBefore(relativeReadIndex, length - readPosition, timeUs,  true);\n  if (offset == -1) {\n    return 0;\n  }\n  return offset;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "samples",
            "that",
            "need",
            "to",
            "be",
            "skip",
            "int",
            "skipped",
            "to",
            "advance",
            "the",
            "read",
            "position",
            "to",
            "the",
            "keyframe",
            "before",
            "or",
            "at",
            "the",
            "specified",
            "time"
        ]
    },
    {
        "id": 1341,
        "code": "public final synchronized void skip(int count) {\n  checkArgument(count >= 0 && readPosition + count <= length);\n  readPosition += count;\n}",
        "summary_tokens": [
            "advances",
            "the",
            "read",
            "position",
            "by",
            "the",
            "specified",
            "number",
            "of",
            "samples"
        ]
    },
    {
        "id": 1342,
        "code": "public final void discardTo(long timeUs, boolean toKeyframe, boolean stopAtReadPosition) {\n  sampleDataQueue.discardDownstreamTo(\n      discardSampleMetadataTo(timeUs, toKeyframe, stopAtReadPosition));\n}",
        "summary_tokens": [
            "discards",
            "up",
            "to",
            "but",
            "not",
            "including",
            "the",
            "sample",
            "immediately",
            "before",
            "or",
            "at",
            "the",
            "specified",
            "time"
        ]
    },
    {
        "id": 1343,
        "code": "public final void discardToRead() {\n  sampleDataQueue.discardDownstreamTo(discardSampleMetadataToRead());\n}",
        "summary_tokens": [
            "discards",
            "up",
            "to",
            "but",
            "not",
            "including",
            "the",
            "read",
            "position"
        ]
    },
    {
        "id": 1344,
        "code": "public final void discardToEnd() {\n  sampleDataQueue.discardDownstreamTo(discardSampleMetadataToEnd());\n}",
        "summary_tokens": [
            "discards",
            "all",
            "samples",
            "in",
            "the",
            "queue",
            "and",
            "advances",
            "the",
            "read",
            "position"
        ]
    },
    {
        "id": 1345,
        "code": "public final void setSampleOffsetUs(long sampleOffsetUs) {\n  if (this.sampleOffsetUs != sampleOffsetUs) {\n    this.sampleOffsetUs = sampleOffsetUs;\n    invalidateUpstreamFormatAdjustment();\n  }\n}",
        "summary_tokens": [
            "sets",
            "an",
            "offset",
            "that",
            "will",
            "be",
            "added",
            "to",
            "the",
            "timestamps",
            "and",
            "sub",
            "sample",
            "timestamps",
            "of",
            "samples",
            "that",
            "are",
            "subsequently",
            "queued"
        ]
    },
    {
        "id": 1346,
        "code": "public final void setUpstreamFormatChangeListener(\n    @Nullable UpstreamFormatChangedListener listener) {\n  upstreamFormatChangeListener = listener;\n}",
        "summary_tokens": [
            "sets",
            "a",
            "listener",
            "to",
            "be",
            "notified",
            "of",
            "changes",
            "to",
            "the",
            "upstream",
            "format"
        ]
    },
    {
        "id": 1347,
        "code": "protected final void invalidateUpstreamFormatAdjustment() {\n  upstreamFormatAdjustmentRequired = true;\n}",
        "summary_tokens": [
            "invalidates",
            "the",
            "last",
            "upstream",
            "format",
            "adjustment"
        ]
    },
    {
        "id": 1348,
        "code": "protected Format getAdjustedUpstreamFormat(Format format) {\n  if (sampleOffsetUs != 0 && format.subsampleOffsetUs != Format.OFFSET_SAMPLE_RELATIVE) {\n    format =\n        format\n            .buildUpon()\n            .setSubsampleOffsetUs(format.subsampleOffsetUs + sampleOffsetUs)\n            .build();\n  }\n  return format;\n}",
        "summary_tokens": [
            "adjusts",
            "the",
            "upstream",
            "format",
            "i"
        ]
    },
    {
        "id": 1349,
        "code": "private synchronized void rewind() {\n  readPosition = 0;\n  sampleDataQueue.rewind();\n}",
        "summary_tokens": [
            "rewinds",
            "the",
            "read",
            "position",
            "to",
            "the",
            "first",
            "sample",
            "in",
            "the",
            "queue"
        ]
    },
    {
        "id": 1350,
        "code": "private synchronized boolean attemptSplice(long timeUs) {\n  if (length == 0) {\n    return timeUs > largestDiscardedTimestampUs;\n  }\n  if (getLargestReadTimestampUs() >= timeUs) {\n    return false;\n  }\n  int retainCount = countUnreadSamplesBefore(timeUs);\n  discardUpstreamSampleMetadata(absoluteFirstIndex + retainCount);\n  return true;\n}",
        "summary_tokens": [
            "attempts",
            "to",
            "discard",
            "samples",
            "from",
            "the",
            "end",
            "of",
            "the",
            "queue",
            "to",
            "allow",
            "samples",
            "starting",
            "from",
            "the",
            "specified",
            "timestamp",
            "to",
            "be",
            "spliced",
            "in"
        ]
    },
    {
        "id": 1351,
        "code": "private void onFormatResult(Format newFormat, FormatHolder outputFormatHolder) {\n  boolean isFirstFormat = downstreamFormat == null;\n  @Nullable DrmInitData oldDrmInitData = isFirstFormat ? null : downstreamFormat.drmInitData;\n  downstreamFormat = newFormat;\n  @Nullable DrmInitData newDrmInitData = newFormat.drmInitData;\n\n  outputFormatHolder.format =\n      drmSessionManager != null\n          ? newFormat.copyWithCryptoType(drmSessionManager.getCryptoType(newFormat))\n          : newFormat;\n  outputFormatHolder.drmSession = currentDrmSession;\n  if (drmSessionManager == null) {\n      \n    return;\n  }\n  if (!isFirstFormat && Util.areEqual(oldDrmInitData, newDrmInitData)) {\n      \n    return;\n  }\n    \n    \n  @Nullable DrmSession previousSession = currentDrmSession;\n  currentDrmSession = drmSessionManager.acquireSession(drmEventDispatcher, newFormat);\n  outputFormatHolder.drmSession = currentDrmSession;\n\n  if (previousSession != null) {\n    previousSession.release(drmEventDispatcher);\n  }\n}",
        "summary_tokens": [
            "sets",
            "the",
            "downstream",
            "format",
            "performs",
            "drm",
            "resource",
            "management",
            "and",
            "populates",
            "the",
            "output",
            "format",
            "holder"
        ]
    },
    {
        "id": 1352,
        "code": "private boolean mayReadSample(int relativeReadIndex) {\n  return currentDrmSession == null\n      || currentDrmSession.getState() == DrmSession.STATE_OPENED_WITH_KEYS\n      || ((flags[relativeReadIndex] & C.BUFFER_FLAG_ENCRYPTED) == 0\n          && currentDrmSession.playClearSamplesWithoutKeys());\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "it",
            "s",
            "possible",
            "to",
            "read",
            "the",
            "next",
            "sample"
        ]
    },
    {
        "id": 1353,
        "code": "private int findSampleBefore(int relativeStartIndex, int length, long timeUs, boolean keyframe) {\n    \n    \n    \n  int sampleCountToTarget = -1;\n  int searchIndex = relativeStartIndex;\n  for (int i = 0; i < length && timesUs[searchIndex] <= timeUs; i++) {\n    if (!keyframe || (flags[searchIndex] & C.BUFFER_FLAG_KEY_FRAME) != 0) {\n        \n      sampleCountToTarget = i;\n      if (timesUs[searchIndex] == timeUs) {\n          \n          \n        break;\n      }\n    }\n    searchIndex++;\n    if (searchIndex == capacity) {\n      searchIndex = 0;\n    }\n  }\n  return sampleCountToTarget;\n}",
        "summary_tokens": [
            "finds",
            "the",
            "sample",
            "in",
            "the",
            "specified",
            "range",
            "that",
            "s",
            "before",
            "or",
            "at",
            "the",
            "specified",
            "time"
        ]
    },
    {
        "id": 1354,
        "code": "private int countUnreadSamplesBefore(long timeUs) {\n  int count = length;\n  int relativeSampleIndex = getRelativeIndex(length - 1);\n  while (count > readPosition && timesUs[relativeSampleIndex] >= timeUs) {\n    count--;\n    relativeSampleIndex--;\n    if (relativeSampleIndex == -1) {\n      relativeSampleIndex = capacity - 1;\n    }\n  }\n  return count;\n}",
        "summary_tokens": [
            "counts",
            "the",
            "number",
            "of",
            "samples",
            "that",
            "haven",
            "t",
            "been",
            "read",
            "that",
            "have",
            "a",
            "timestamp",
            "smaller",
            "than",
            "time",
            "us"
        ]
    },
    {
        "id": 1355,
        "code": "private long discardSamples(int discardCount) {\n  largestDiscardedTimestampUs =\n      max(largestDiscardedTimestampUs, getLargestTimestamp(discardCount));\n  length -= discardCount;\n  absoluteFirstIndex += discardCount;\n  relativeFirstIndex += discardCount;\n  if (relativeFirstIndex >= capacity) {\n    relativeFirstIndex -= capacity;\n  }\n  readPosition -= discardCount;\n  if (readPosition < 0) {\n    readPosition = 0;\n  }\n  sharedSampleMetadata.discardTo(absoluteFirstIndex);\n\n  if (length == 0) {\n    int relativeLastDiscardIndex = (relativeFirstIndex == 0 ? capacity : relativeFirstIndex) - 1;\n    return offsets[relativeLastDiscardIndex] + sizes[relativeLastDiscardIndex];\n  } else {\n    return offsets[relativeFirstIndex];\n  }\n}",
        "summary_tokens": [
            "discards",
            "the",
            "specified",
            "number",
            "of",
            "samples"
        ]
    },
    {
        "id": 1356,
        "code": "private long getLargestTimestamp(int length) {\n  if (length == 0) {\n    return Long.MIN_VALUE;\n  }\n  long largestTimestampUs = Long.MIN_VALUE;\n  int relativeSampleIndex = getRelativeIndex(length - 1);\n  for (int i = 0; i < length; i++) {\n    largestTimestampUs = max(largestTimestampUs, timesUs[relativeSampleIndex]);\n    if ((flags[relativeSampleIndex] & C.BUFFER_FLAG_KEY_FRAME) != 0) {\n      break;\n    }\n    relativeSampleIndex--;\n    if (relativeSampleIndex == -1) {\n      relativeSampleIndex = capacity - 1;\n    }\n  }\n  return largestTimestampUs;\n}",
        "summary_tokens": [
            "finds",
            "the",
            "largest",
            "timestamp",
            "of",
            "any",
            "sample",
            "from",
            "the",
            "start",
            "of",
            "the",
            "queue",
            "up",
            "to",
            "the",
            "specified",
            "length",
            "assuming",
            "that",
            "the",
            "timestamps",
            "prior",
            "to",
            "a",
            "keyframe",
            "are",
            "always",
            "less",
            "than",
            "the",
            "timestamp",
            "of",
            "the",
            "keyframe",
            "itself",
            "and",
            "of",
            "subsequent",
            "frames"
        ]
    },
    {
        "id": 1357,
        "code": "private int getRelativeIndex(int offset) {\n  int relativeIndex = relativeFirstIndex + offset;\n  return relativeIndex < capacity ? relativeIndex : relativeIndex - capacity;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "relative",
            "index",
            "for",
            "a",
            "given",
            "offset",
            "from",
            "the",
            "start",
            "of",
            "the",
            "queue"
        ]
    },
    {
        "id": 1358,
        "code": "public V get(int key) {\n  if (memoizedReadIndex == C.INDEX_UNSET) {\n    memoizedReadIndex = 0;\n  }\n  while (memoizedReadIndex > 0 && key < spans.keyAt(memoizedReadIndex)) {\n    memoizedReadIndex--;\n  }\n  while (memoizedReadIndex < spans.size() - 1 && key >= spans.keyAt(memoizedReadIndex + 1)) {\n    memoizedReadIndex++;\n  }\n  return spans.valueAt(memoizedReadIndex);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "value",
            "associated",
            "with",
            "the",
            "span",
            "covering",
            "key"
        ]
    },
    {
        "id": 1359,
        "code": "public void appendSpan(int startKey, V value) {\n  if (memoizedReadIndex == C.INDEX_UNSET) {\n    checkState(spans.size() == 0);\n    memoizedReadIndex = 0;\n  }\n\n  if (spans.size() > 0) {\n    int lastStartKey = spans.keyAt(spans.size() - 1);\n    checkArgument(startKey >= lastStartKey);\n    if (lastStartKey == startKey) {\n      removeCallback.accept(spans.valueAt(spans.size() - 1));\n    }\n  }\n  spans.append(startKey, value);\n}",
        "summary_tokens": [
            "adds",
            "a",
            "new",
            "span",
            "to",
            "the",
            "end",
            "starting",
            "at",
            "start",
            "key",
            "and",
            "containing",
            "value"
        ]
    },
    {
        "id": 1360,
        "code": "public V getEndValue() {\n  return spans.valueAt(spans.size() - 1);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "value",
            "associated",
            "with",
            "the",
            "end",
            "span"
        ]
    },
    {
        "id": 1361,
        "code": "public void discardTo(int discardToKey) {\n  for (int i = 0; i < spans.size() - 1 && discardToKey >= spans.keyAt(i + 1); i++) {\n    removeCallback.accept(spans.valueAt(i));\n    spans.removeAt(i);\n    if (memoizedReadIndex > 0) {\n      memoizedReadIndex--;\n    }\n  }\n}",
        "summary_tokens": [
            "discard",
            "the",
            "spans",
            "from",
            "the",
            "start",
            "up",
            "to",
            "discard",
            "to",
            "key"
        ]
    },
    {
        "id": 1362,
        "code": "public void discardFrom(int discardFromKey) {\n  for (int i = spans.size() - 1; i >= 0 && discardFromKey < spans.keyAt(i); i--) {\n    removeCallback.accept(spans.valueAt(i));\n    spans.removeAt(i);\n  }\n  memoizedReadIndex = spans.size() > 0 ? min(memoizedReadIndex, spans.size() - 1) : C.INDEX_UNSET;\n}",
        "summary_tokens": [
            "discard",
            "the",
            "spans",
            "from",
            "the",
            "end",
            "back",
            "to",
            "discard",
            "from",
            "key"
        ]
    },
    {
        "id": 1363,
        "code": "public boolean isEmpty() {\n  return spans.size() == 0;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "the",
            "collection",
            "is",
            "empty"
        ]
    },
    {
        "id": 1364,
        "code": "public TrackGroup get(int index) {\n  return trackGroups.get(index);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "group",
            "at",
            "a",
            "given",
            "index"
        ]
    },
    {
        "id": 1365,
        "code": "public int indexOf(TrackGroup group) {\n  int index = trackGroups.indexOf(group);\n  return index >= 0 ? index : C.INDEX_UNSET;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "index",
            "of",
            "a",
            "group",
            "within",
            "the",
            "array"
        ]
    },
    {
        "id": 1366,
        "code": "public boolean isEmpty() {\n  return length == 0;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "this",
            "track",
            "group",
            "array",
            "is",
            "empty"
        ]
    },
    {
        "id": 1367,
        "code": "private void maybeUpdateAdMediaSources() {\n  @Nullable AdPlaybackState adPlaybackState = this.adPlaybackState;\n  if (adPlaybackState == null) {\n    return;\n  }\n  for (int adGroupIndex = 0; adGroupIndex < adMediaSourceHolders.length; adGroupIndex++) {\n    for (int adIndexInAdGroup = 0;\n        adIndexInAdGroup < this.adMediaSourceHolders[adGroupIndex].length;\n        adIndexInAdGroup++) {\n      @Nullable\n      AdMediaSourceHolder adMediaSourceHolder =\n          this.adMediaSourceHolders[adGroupIndex][adIndexInAdGroup];\n      AdPlaybackState.AdGroup adGroup = adPlaybackState.getAdGroup(adGroupIndex);\n      if (adMediaSourceHolder != null\n          && !adMediaSourceHolder.hasMediaSource()\n          && adIndexInAdGroup < adGroup.uris.length) {\n        @Nullable Uri adUri = adGroup.uris[adIndexInAdGroup];\n        if (adUri != null) {\n          MediaItem.Builder adMediaItem = new MediaItem.Builder().setUri(adUri);\n            \n          @Nullable\n          MediaItem.LocalConfiguration contentLocalConfiguration =\n              contentMediaSource.getMediaItem().localConfiguration;\n          if (contentLocalConfiguration != null) {\n            adMediaItem.setDrmConfiguration(contentLocalConfiguration.drmConfiguration);\n          }\n          MediaSource adMediaSource = adMediaSourceFactory.createMediaSource(adMediaItem.build());\n          adMediaSourceHolder.initializeWithMediaSource(adMediaSource, adUri);\n        }\n      }\n    }\n  }\n}",
        "summary_tokens": [
            "initializes",
            "any",
            "ad",
            "media",
            "source",
            "holder",
            "ad",
            "media",
            "source",
            "holders",
            "where",
            "the",
            "ad",
            "media",
            "uri",
            "is",
            "newly",
            "known"
        ]
    },
    {
        "id": 1368,
        "code": "public void setAdPlaybackStates(ImmutableMap<Object, AdPlaybackState> adPlaybackStates) {\n  checkArgument(!adPlaybackStates.isEmpty());\n  Object adsId = checkNotNull(adPlaybackStates.values().asList().get(0).adsId);\n  for (Map.Entry<Object, AdPlaybackState> entry : adPlaybackStates.entrySet()) {\n    Object periodUid = entry.getKey();\n    AdPlaybackState adPlaybackState = entry.getValue();\n    checkArgument(Util.areEqual(adsId, adPlaybackState.adsId));\n    @Nullable AdPlaybackState oldAdPlaybackState = this.adPlaybackStates.get(periodUid);\n    if (oldAdPlaybackState != null) {\n      for (int i = adPlaybackState.removedAdGroupCount; i < adPlaybackState.adGroupCount; i++) {\n        AdPlaybackState.AdGroup adGroup = adPlaybackState.getAdGroup(i);\n        checkArgument(adGroup.isServerSideInserted);\n        if (i < oldAdPlaybackState.adGroupCount) {\n          checkArgument(\n              getAdCountInGroup(adPlaybackState,  i)\n                  >= getAdCountInGroup(oldAdPlaybackState,  i));\n        }\n        if (adGroup.timeUs == C.TIME_END_OF_SOURCE) {\n          checkArgument(getAdCountInGroup(adPlaybackState,  i) == 0);\n        }\n      }\n    }\n  }\n  synchronized (this) {\n    if (playbackHandler == null) {\n      this.adPlaybackStates = adPlaybackStates;\n    } else {\n      playbackHandler.post(\n          () -> {\n            for (SharedMediaPeriod mediaPeriod : mediaPeriods.values()) {\n              @Nullable\n              AdPlaybackState adPlaybackState = adPlaybackStates.get(mediaPeriod.periodUid);\n              if (adPlaybackState != null) {\n                mediaPeriod.updateAdPlaybackState(adPlaybackState);\n              }\n            }\n            if (lastUsedMediaPeriod != null) {\n              @Nullable\n              AdPlaybackState adPlaybackState =\n                  adPlaybackStates.get(lastUsedMediaPeriod.periodUid);\n              if (adPlaybackState != null) {\n                lastUsedMediaPeriod.updateAdPlaybackState(adPlaybackState);\n              }\n            }\n            this.adPlaybackStates = adPlaybackStates;\n            if (contentTimeline != null) {\n              refreshSourceInfo(\n                  new ServerSideAdInsertionTimeline(contentTimeline, adPlaybackStates));\n            }\n          });\n    }\n  }\n}",
        "summary_tokens": [
            "sets",
            "the",
            "map",
            "of",
            "ad",
            "playback",
            "state",
            "ad",
            "playback",
            "states",
            "published",
            "by",
            "this",
            "source"
        ]
    },
    {
        "id": 1369,
        "code": "public static AdPlaybackState addAdGroupToAdPlaybackState(\n    AdPlaybackState adPlaybackState,\n    long fromPositionUs,\n    long contentResumeOffsetUs,\n    long... adDurationsUs) {\n  long adGroupInsertionPositionUs =\n      getMediaPeriodPositionUsForContent(\n          fromPositionUs,  C.INDEX_UNSET, adPlaybackState);\n  int insertionIndex = adPlaybackState.removedAdGroupCount;\n  while (insertionIndex < adPlaybackState.adGroupCount\n      && adPlaybackState.getAdGroup(insertionIndex).timeUs != C.TIME_END_OF_SOURCE\n      && adPlaybackState.getAdGroup(insertionIndex).timeUs <= adGroupInsertionPositionUs) {\n    insertionIndex++;\n  }\n  adPlaybackState =\n      adPlaybackState\n          .withNewAdGroup(insertionIndex, adGroupInsertionPositionUs)\n          .withIsServerSideInserted(insertionIndex,  true)\n          .withAdCount(insertionIndex,  adDurationsUs.length)\n          .withAdDurationsUs(insertionIndex, adDurationsUs)\n          .withContentResumeOffsetUs(insertionIndex, contentResumeOffsetUs);\n    \n  int adIndex = 0;\n  while (adIndex < adDurationsUs.length && adDurationsUs[adIndex] == 0) {\n    adPlaybackState =\n        adPlaybackState.withSkippedAd(insertionIndex,  adIndex++);\n  }\n  return correctFollowingAdGroupTimes(\n      adPlaybackState, insertionIndex, sum(adDurationsUs), contentResumeOffsetUs);\n}",
        "summary_tokens": [
            "adds",
            "a",
            "new",
            "server",
            "side",
            "inserted",
            "ad",
            "group",
            "to",
            "an",
            "ad",
            "playback",
            "state"
        ]
    },
    {
        "id": 1370,
        "code": "public static long getStreamPositionUs(\n    long positionUs, MediaPeriodId mediaPeriodId, AdPlaybackState adPlaybackState) {\n  return mediaPeriodId.isAd()\n      ? getStreamPositionUsForAd(\n          positionUs, mediaPeriodId.adGroupIndex, mediaPeriodId.adIndexInAdGroup, adPlaybackState)\n      : getStreamPositionUsForContent(\n          positionUs, mediaPeriodId.nextAdGroupIndex, adPlaybackState);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "position",
            "in",
            "the",
            "underlying",
            "server",
            "side",
            "inserted",
            "ads",
            "stream",
            "for",
            "a",
            "position",
            "in",
            "a",
            "media",
            "period"
        ]
    },
    {
        "id": 1371,
        "code": "public static long getMediaPeriodPositionUs(\n    long positionUs, MediaPeriodId mediaPeriodId, AdPlaybackState adPlaybackState) {\n  return mediaPeriodId.isAd()\n      ? getMediaPeriodPositionUsForAd(\n          positionUs, mediaPeriodId.adGroupIndex, mediaPeriodId.adIndexInAdGroup, adPlaybackState)\n      : getMediaPeriodPositionUsForContent(\n          positionUs, mediaPeriodId.nextAdGroupIndex, adPlaybackState);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "position",
            "in",
            "a",
            "media",
            "period",
            "for",
            "a",
            "position",
            "in",
            "the",
            "underlying",
            "server",
            "side",
            "inserted",
            "ads",
            "stream"
        ]
    },
    {
        "id": 1372,
        "code": "public static long getStreamPositionUsForAd(\n    long positionUs, int adGroupIndex, int adIndexInAdGroup, AdPlaybackState adPlaybackState) {\n  AdPlaybackState.AdGroup currentAdGroup = adPlaybackState.getAdGroup(adGroupIndex);\n  positionUs += currentAdGroup.timeUs;\n  for (int i = adPlaybackState.removedAdGroupCount; i < adGroupIndex; i++) {\n    AdPlaybackState.AdGroup adGroup = adPlaybackState.getAdGroup(i);\n    for (int j = 0; j < getAdCountInGroup(adPlaybackState,  i); j++) {\n      positionUs += adGroup.durationsUs[j];\n    }\n    positionUs -= adGroup.contentResumeOffsetUs;\n  }\n  if (adIndexInAdGroup < getAdCountInGroup(adPlaybackState, adGroupIndex)) {\n    for (int i = 0; i < adIndexInAdGroup; i++) {\n      positionUs += currentAdGroup.durationsUs[i];\n    }\n  }\n  return positionUs;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "position",
            "in",
            "the",
            "underlying",
            "server",
            "side",
            "inserted",
            "ads",
            "stream",
            "for",
            "a",
            "position",
            "in",
            "an",
            "ad",
            "media",
            "period"
        ]
    },
    {
        "id": 1373,
        "code": "public static long getMediaPeriodPositionUsForAd(\n    long positionUs, int adGroupIndex, int adIndexInAdGroup, AdPlaybackState adPlaybackState) {\n  AdPlaybackState.AdGroup currentAdGroup = adPlaybackState.getAdGroup(adGroupIndex);\n  positionUs -= currentAdGroup.timeUs;\n  for (int i = adPlaybackState.removedAdGroupCount; i < adGroupIndex; i++) {\n    AdPlaybackState.AdGroup adGroup = adPlaybackState.getAdGroup(i);\n    for (int j = 0; j < getAdCountInGroup(adPlaybackState,  i); j++) {\n      positionUs -= adGroup.durationsUs[j];\n    }\n    positionUs += adGroup.contentResumeOffsetUs;\n  }\n  if (adIndexInAdGroup < getAdCountInGroup(adPlaybackState, adGroupIndex)) {\n    for (int i = 0; i < adIndexInAdGroup; i++) {\n      positionUs -= currentAdGroup.durationsUs[i];\n    }\n  }\n  return positionUs;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "position",
            "in",
            "an",
            "ad",
            "media",
            "period",
            "for",
            "a",
            "position",
            "in",
            "the",
            "underlying",
            "server",
            "side",
            "inserted",
            "ads",
            "stream"
        ]
    },
    {
        "id": 1374,
        "code": "public static long getStreamPositionUsForContent(\n    long positionUs, int nextAdGroupIndex, AdPlaybackState adPlaybackState) {\n  long totalAdDurationBeforePositionUs = 0;\n  if (nextAdGroupIndex == C.INDEX_UNSET) {\n    nextAdGroupIndex = adPlaybackState.adGroupCount;\n  }\n  for (int i = adPlaybackState.removedAdGroupCount; i < nextAdGroupIndex; i++) {\n    AdPlaybackState.AdGroup adGroup = adPlaybackState.getAdGroup(i);\n    if (adGroup.timeUs == C.TIME_END_OF_SOURCE || adGroup.timeUs > positionUs) {\n      break;\n    }\n    long adGroupStreamStartPositionUs = adGroup.timeUs + totalAdDurationBeforePositionUs;\n    for (int j = 0; j < getAdCountInGroup(adPlaybackState,  i); j++) {\n      totalAdDurationBeforePositionUs += adGroup.durationsUs[j];\n    }\n    totalAdDurationBeforePositionUs -= adGroup.contentResumeOffsetUs;\n    long adGroupResumePositionUs = adGroup.timeUs + adGroup.contentResumeOffsetUs;\n    if (adGroupResumePositionUs > positionUs) {\n        \n      return max(adGroupStreamStartPositionUs, positionUs + totalAdDurationBeforePositionUs);\n    }\n  }\n  return positionUs + totalAdDurationBeforePositionUs;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "position",
            "in",
            "the",
            "underlying",
            "server",
            "side",
            "inserted",
            "ads",
            "stream",
            "for",
            "a",
            "position",
            "in",
            "a",
            "content",
            "media",
            "period"
        ]
    },
    {
        "id": 1375,
        "code": "public static long getMediaPeriodPositionUsForContent(\n    long positionUs, int nextAdGroupIndex, AdPlaybackState adPlaybackState) {\n  long totalAdDurationBeforePositionUs = 0;\n  if (nextAdGroupIndex == C.INDEX_UNSET) {\n    nextAdGroupIndex = adPlaybackState.adGroupCount;\n  }\n  for (int i = adPlaybackState.removedAdGroupCount; i < nextAdGroupIndex; i++) {\n    AdPlaybackState.AdGroup adGroup = adPlaybackState.getAdGroup(i);\n    if (adGroup.timeUs == C.TIME_END_OF_SOURCE\n        || adGroup.timeUs > positionUs - totalAdDurationBeforePositionUs) {\n      break;\n    }\n    for (int j = 0; j < getAdCountInGroup(adPlaybackState,  i); j++) {\n      totalAdDurationBeforePositionUs += adGroup.durationsUs[j];\n    }\n    totalAdDurationBeforePositionUs -= adGroup.contentResumeOffsetUs;\n    long adGroupResumePositionUs = adGroup.timeUs + adGroup.contentResumeOffsetUs;\n    if (adGroupResumePositionUs > positionUs - totalAdDurationBeforePositionUs) {\n        \n      return max(adGroup.timeUs, positionUs - totalAdDurationBeforePositionUs);\n    }\n  }\n  return positionUs - totalAdDurationBeforePositionUs;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "position",
            "in",
            "a",
            "content",
            "media",
            "period",
            "for",
            "a",
            "position",
            "in",
            "the",
            "underlying",
            "server",
            "side",
            "inserted",
            "ads",
            "stream"
        ]
    },
    {
        "id": 1376,
        "code": "public static int getAdCountInGroup(AdPlaybackState adPlaybackState, int adGroupIndex) {\n  AdPlaybackState.AdGroup adGroup = adPlaybackState.getAdGroup(adGroupIndex);\n  return adGroup.count == C.LENGTH_UNSET ? 0 : adGroup.count;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "ads",
            "in",
            "an",
            "ad",
            "group",
            "treating",
            "an",
            "unknown",
            "number",
            "as",
            "zero",
            "ads"
        ]
    },
    {
        "id": 1377,
        "code": "protected final void checkInBounds() {\n  if (currentIndex < fromIndex || currentIndex > toIndex) {\n    throw new NoSuchElementException();\n  }\n}",
        "summary_tokens": [
            "verifies",
            "that",
            "the",
            "iterator",
            "points",
            "to",
            "a",
            "valid",
            "element"
        ]
    },
    {
        "id": 1378,
        "code": "protected final long getCurrentIndex() {\n  return currentIndex;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "current",
            "index",
            "this",
            "iterator",
            "is",
            "pointing",
            "to"
        ]
    },
    {
        "id": 1379,
        "code": "public int[] getWriteIndices() {\n  int[] writeIndices = new int[sampleQueues.length];\n  for (int i = 0; i < sampleQueues.length; i++) {\n    writeIndices[i] = sampleQueues[i].getWriteIndex();\n  }\n  return writeIndices;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "current",
            "absolute",
            "write",
            "indices",
            "of",
            "the",
            "individual",
            "sample",
            "queues"
        ]
    },
    {
        "id": 1380,
        "code": "public void setSampleOffsetUs(long sampleOffsetUs) {\n  for (SampleQueue sampleQueue : sampleQueues) {\n    sampleQueue.setSampleOffsetUs(sampleOffsetUs);\n  }\n}",
        "summary_tokens": [
            "sets",
            "an",
            "offset",
            "that",
            "will",
            "be",
            "added",
            "to",
            "the",
            "timestamps",
            "and",
            "sub",
            "sample",
            "timestamps",
            "of",
            "samples",
            "subsequently",
            "written",
            "to",
            "the",
            "sample",
            "queues"
        ]
    },
    {
        "id": 1381,
        "code": "public final long getDurationUs() {\n  return endTimeUs - startTimeUs;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "duration",
            "of",
            "the",
            "chunk",
            "in",
            "microseconds"
        ]
    },
    {
        "id": 1382,
        "code": "public final long bytesLoaded() {\n  return dataSource.getBytesRead();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "bytes",
            "that",
            "have",
            "been",
            "loaded"
        ]
    },
    {
        "id": 1383,
        "code": "public final Uri getUri() {\n  return dataSource.getLastOpenedUri();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "uri",
            "associated",
            "with",
            "the",
            "last",
            "data",
            "source",
            "open",
            "call"
        ]
    },
    {
        "id": 1384,
        "code": "public final Map<String, List<String>> getResponseHeaders() {\n  return dataSource.getLastResponseHeaders();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "response",
            "headers",
            "associated",
            "with",
            "the",
            "last",
            "data",
            "source",
            "open",
            "call"
        ]
    },
    {
        "id": 1385,
        "code": "public void discardBuffer(long positionUs, boolean toKeyframe) {\n  if (isPendingReset()) {\n    return;\n  }\n  int oldFirstSampleIndex = primarySampleQueue.getFirstIndex();\n  primarySampleQueue.discardTo(positionUs, toKeyframe, true);\n  int newFirstSampleIndex = primarySampleQueue.getFirstIndex();\n  if (newFirstSampleIndex > oldFirstSampleIndex) {\n    long discardToUs = primarySampleQueue.getFirstTimestampUs();\n    for (int i = 0; i < embeddedSampleQueues.length; i++) {\n      embeddedSampleQueues[i].discardTo(discardToUs, toKeyframe, embeddedTracksSelected[i]);\n    }\n  }\n  discardDownstreamMediaChunks(newFirstSampleIndex);\n}",
        "summary_tokens": [
            "discards",
            "buffered",
            "media",
            "up",
            "to",
            "the",
            "specified",
            "position"
        ]
    },
    {
        "id": 1386,
        "code": "public EmbeddedSampleStream selectEmbeddedTrack(long positionUs, int trackType) {\n  for (int i = 0; i < embeddedSampleQueues.length; i++) {\n    if (embeddedTrackTypes[i] == trackType) {\n      Assertions.checkState(!embeddedTracksSelected[i]);\n      embeddedTracksSelected[i] = true;\n      embeddedSampleQueues[i].seekTo(positionUs,  true);\n      return new EmbeddedSampleStream(this, embeddedSampleQueues[i], i);\n    }\n  }\n    \n  throw new IllegalStateException();\n}",
        "summary_tokens": [
            "selects",
            "the",
            "embedded",
            "track",
            "returning",
            "a",
            "new",
            "embedded",
            "sample",
            "stream",
            "from",
            "which",
            "the",
            "track",
            "s",
            "samples",
            "can",
            "be",
            "consumed"
        ]
    },
    {
        "id": 1387,
        "code": "public T getChunkSource() {\n  return chunkSource;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "chunk",
            "source",
            "used",
            "by",
            "this",
            "stream"
        ]
    },
    {
        "id": 1388,
        "code": "public long getBufferedPositionUs() {\n  if (loadingFinished) {\n    return C.TIME_END_OF_SOURCE;\n  } else if (isPendingReset()) {\n    return pendingResetPositionUs;\n  } else {\n    long bufferedPositionUs = lastSeekPositionUs;\n    BaseMediaChunk lastMediaChunk = getLastMediaChunk();\n    BaseMediaChunk lastCompletedMediaChunk =\n        lastMediaChunk.isLoadCompleted()\n            ? lastMediaChunk\n            : mediaChunks.size() > 1 ? mediaChunks.get(mediaChunks.size() - 2) : null;\n    if (lastCompletedMediaChunk != null) {\n      bufferedPositionUs = max(bufferedPositionUs, lastCompletedMediaChunk.endTimeUs);\n    }\n    return max(bufferedPositionUs, primarySampleQueue.getLargestQueuedTimestampUs());\n  }\n}",
        "summary_tokens": [
            "returns",
            "an",
            "estimate",
            "of",
            "the",
            "position",
            "up",
            "to",
            "which",
            "data",
            "is",
            "buffered"
        ]
    },
    {
        "id": 1389,
        "code": "public long getAdjustedSeekPositionUs(long positionUs, SeekParameters seekParameters) {\n  return chunkSource.getAdjustedSeekPositionUs(positionUs, seekParameters);\n}",
        "summary_tokens": [
            "adjusts",
            "a",
            "seek",
            "position",
            "given",
            "the",
            "specified",
            "seek",
            "parameters"
        ]
    },
    {
        "id": 1390,
        "code": "public void seekToUs(long positionUs) {\n  lastSeekPositionUs = positionUs;\n  if (isPendingReset()) {\n      \n    pendingResetPositionUs = positionUs;\n    return;\n  }\n\n    \n  @Nullable BaseMediaChunk seekToMediaChunk = null;\n  for (int i = 0; i < mediaChunks.size(); i++) {\n    BaseMediaChunk mediaChunk = mediaChunks.get(i);\n    long mediaChunkStartTimeUs = mediaChunk.startTimeUs;\n    if (mediaChunkStartTimeUs == positionUs && mediaChunk.clippedStartTimeUs == C.TIME_UNSET) {\n      seekToMediaChunk = mediaChunk;\n      break;\n    } else if (mediaChunkStartTimeUs > positionUs) {\n        \n      break;\n    }\n  }\n\n    \n  boolean seekInsideBuffer;\n  if (seekToMediaChunk != null) {\n      \n      \n      \n    seekInsideBuffer = primarySampleQueue.seekTo(seekToMediaChunk.getFirstSampleIndex(0));\n  } else {\n    seekInsideBuffer =\n        primarySampleQueue.seekTo(\n            positionUs,  positionUs < getNextLoadPositionUs());\n  }\n\n  if (seekInsideBuffer) {\n      \n    nextNotifyPrimaryFormatMediaChunkIndex =\n        primarySampleIndexToMediaChunkIndex(\n            primarySampleQueue.getReadIndex(),  0);\n      \n    for (SampleQueue embeddedSampleQueue : embeddedSampleQueues) {\n      embeddedSampleQueue.seekTo(positionUs,  true);\n    }\n  } else {\n      \n    pendingResetPositionUs = positionUs;\n    loadingFinished = false;\n    mediaChunks.clear();\n    nextNotifyPrimaryFormatMediaChunkIndex = 0;\n    if (loader.isLoading()) {\n        \n      primarySampleQueue.discardToEnd();\n      for (SampleQueue embeddedSampleQueue : embeddedSampleQueues) {\n        embeddedSampleQueue.discardToEnd();\n      }\n      loader.cancelLoading();\n    } else {\n      loader.clearFatalError();\n      resetSampleQueues();\n    }\n  }\n}",
        "summary_tokens": [
            "seeks",
            "to",
            "the",
            "specified",
            "position",
            "in",
            "microseconds"
        ]
    },
    {
        "id": 1391,
        "code": "private boolean haveReadFromMediaChunk(int mediaChunkIndex) {\n  BaseMediaChunk mediaChunk = mediaChunks.get(mediaChunkIndex);\n  if (primarySampleQueue.getReadIndex() > mediaChunk.getFirstSampleIndex(0)) {\n    return true;\n  }\n  for (int i = 0; i < embeddedSampleQueues.length; i++) {\n    if (embeddedSampleQueues[i].getReadIndex() > mediaChunk.getFirstSampleIndex(i + 1)) {\n      return true;\n    }\n  }\n  return false;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "samples",
            "have",
            "been",
            "read",
            "from",
            "media",
            "chunk",
            "at",
            "given",
            "index"
        ]
    },
    {
        "id": 1392,
        "code": "private int primarySampleIndexToMediaChunkIndex(int primarySampleIndex, int minChunkIndex) {\n  for (int i = minChunkIndex + 1; i < mediaChunks.size(); i++) {\n    if (mediaChunks.get(i).getFirstSampleIndex(0) > primarySampleIndex) {\n      return i - 1;\n    }\n  }\n  return mediaChunks.size() - 1;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "media",
            "chunk",
            "index",
            "corresponding",
            "to",
            "a",
            "given",
            "primary",
            "sample",
            "index"
        ]
    },
    {
        "id": 1393,
        "code": "private BaseMediaChunk discardUpstreamMediaChunksFromIndex(int chunkIndex) {\n  BaseMediaChunk firstRemovedChunk = mediaChunks.get(chunkIndex);\n  Util.removeRange(mediaChunks,  chunkIndex,  mediaChunks.size());\n  nextNotifyPrimaryFormatMediaChunkIndex =\n      max(nextNotifyPrimaryFormatMediaChunkIndex, mediaChunks.size());\n  primarySampleQueue.discardUpstreamSamples(firstRemovedChunk.getFirstSampleIndex(0));\n  for (int i = 0; i < embeddedSampleQueues.length; i++) {\n    embeddedSampleQueues[i].discardUpstreamSamples(firstRemovedChunk.getFirstSampleIndex(i + 1));\n  }\n  return firstRemovedChunk;\n}",
        "summary_tokens": [
            "discard",
            "upstream",
            "media",
            "chunks",
            "from",
            "chunk",
            "index",
            "and",
            "corresponding",
            "samples",
            "from",
            "sample",
            "queues"
        ]
    },
    {
        "id": 1394,
        "code": "protected TrackOutputProvider getTrackOutputProvider(BaseMediaChunkOutput baseMediaChunkOutput) {\n  return baseMediaChunkOutput;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "track",
            "output",
            "provider",
            "to",
            "be",
            "used",
            "by",
            "the",
            "wrapped",
            "extractor"
        ]
    },
    {
        "id": 1395,
        "code": "public byte[] getDataHolder() {\n  return data;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "array",
            "in",
            "which",
            "the",
            "data",
            "is",
            "held"
        ]
    },
    {
        "id": 1396,
        "code": "public void init(TrackOutputProvider trackOutputProvider) {\n  this.trackOutputProvider = trackOutputProvider;\n}",
        "summary_tokens": [
            "initializes",
            "the",
            "chunk",
            "for",
            "loading",
            "setting",
            "a",
            "track",
            "output",
            "provider",
            "for",
            "track",
            "outputs",
            "to",
            "which",
            "formats",
            "will",
            "be",
            "written",
            "as",
            "they",
            "are",
            "loaded"
        ]
    },
    {
        "id": 1397,
        "code": "public long getNextChunkIndex() {\n  return chunkIndex != C.INDEX_UNSET ? chunkIndex + 1 : C.INDEX_UNSET;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "next",
            "chunk",
            "index",
            "or",
            "c",
            "index",
            "unset",
            "if",
            "it",
            "is",
            "not",
            "known"
        ]
    },
    {
        "id": 1398,
        "code": "public void setDataReader(DataReader dataReader, long length) {\n  this.dataReader = dataReader;\n  resourceLength = length;\n  lastSeekPosition = C.POSITION_UNSET;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "wrapped",
            "data",
            "reader"
        ]
    },
    {
        "id": 1399,
        "code": "public void setCurrentPosition(long position) {\n  currentPosition = position;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "absolute",
            "position",
            "in",
            "the",
            "resource",
            "from",
            "which",
            "the",
            "wrapped",
            "data",
            "reader",
            "reads"
        ]
    },
    {
        "id": 1400,
        "code": "public long getAndResetSeekPosition() {\n  long lastSeekPosition = this.lastSeekPosition;\n  this.lastSeekPosition = C.POSITION_UNSET;\n  return lastSeekPosition;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "last",
            "value",
            "passed",
            "to",
            "seek",
            "to",
            "position",
            "long",
            "and",
            "sets",
            "the",
            "stored",
            "value",
            "to",
            "c",
            "position",
            "unset"
        ]
    },
    {
        "id": 1401,
        "code": "public static MediaFormat toCaptionsMediaFormat(Format format) {\n  MediaFormat mediaFormat = new MediaFormat();\n  mediaFormat.setString(MediaFormat.KEY_MIME, format.sampleMimeType);\n  if (format.accessibilityChannel != Format.NO_VALUE) {\n    mediaFormat.setInteger(MediaFormat.KEY_CAPTION_SERVICE_NUMBER, format.accessibilityChannel);\n  }\n  return mediaFormat;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "media",
            "format",
            "with",
            "equivalent",
            "media",
            "format",
            "key",
            "mime",
            "and",
            "media",
            "format",
            "key",
            "caption",
            "service",
            "number",
            "to",
            "the",
            "given",
            "format"
        ]
    },
    {
        "id": 1402,
        "code": "public static void setLogSessionIdOnMediaParser(MediaParser mediaParser, PlayerId playerId) {\n  Api31.setLogSessionIdOnMediaParser(mediaParser, playerId);\n}",
        "summary_tokens": [
            "calls",
            "media",
            "parser",
            "set",
            "log",
            "session",
            "id",
            "log",
            "session",
            "id"
        ]
    },
    {
        "id": 1403,
        "code": "default void onCues(List<Cue> cues) {}",
        "summary_tokens": [
            "called",
            "when",
            "there",
            "is",
            "a",
            "change",
            "in",
            "the",
            "cue",
            "cues"
        ]
    },
    {
        "id": 1404,
        "code": "public void setFinalStreamEndPositionUs(long streamEndPositionUs) {\n  checkState(isCurrentStreamFinal());\n  this.finalStreamEndPositionUs = streamEndPositionUs;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "position",
            "at",
            "which",
            "to",
            "stop",
            "rendering",
            "the",
            "current",
            "stream"
        ]
    },
    {
        "id": 1405,
        "code": "private void handleDecoderError(SubtitleDecoderException e) {\n  Log.e(TAG, \"Subtitle decoding failed. streamFormat=\" + streamFormat, e);\n  clearOutput();\n  replaceDecoder();\n}",
        "summary_tokens": [
            "called",
            "when",
            "decoder",
            "throws",
            "an",
            "exception",
            "so",
            "it",
            "can",
            "be",
            "logged",
            "and",
            "playback",
            "can",
            "continue"
        ]
    },
    {
        "id": 1406,
        "code": "default void onDiscontinuity() {}",
        "summary_tokens": [
            "called",
            "to",
            "notify",
            "the",
            "selection",
            "of",
            "a",
            "position",
            "discontinuity"
        ]
    },
    {
        "id": 1407,
        "code": "default void onRebuffer() {}",
        "summary_tokens": [
            "called",
            "to",
            "notify",
            "when",
            "a",
            "rebuffer",
            "occurred"
        ]
    },
    {
        "id": 1408,
        "code": "default void onPlayWhenReadyChanged(boolean playWhenReady) {}",
        "summary_tokens": [
            "called",
            "to",
            "notify",
            "when",
            "the",
            "playback",
            "is",
            "paused",
            "or",
            "resumed"
        ]
    },
    {
        "id": 1409,
        "code": "default boolean shouldCancelChunkLoad(\n    long playbackPositionUs, Chunk loadingChunk, List<? extends MediaChunk> queue) {\n  return false;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "an",
            "ongoing",
            "load",
            "of",
            "a",
            "chunk",
            "should",
            "be",
            "canceled"
        ]
    },
    {
        "id": 1410,
        "code": "public TrackSelection get(int index) {\n  return trackSelections[index];\n}",
        "summary_tokens": [
            "returns",
            "the",
            "selection",
            "at",
            "a",
            "given",
            "index"
        ]
    },
    {
        "id": 1411,
        "code": "public @NullableType TrackSelection[] getAll() {\n  return trackSelections.clone();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "selections",
            "in",
            "a",
            "newly",
            "allocated",
            "array"
        ]
    },
    {
        "id": 1412,
        "code": "public static @NullableType ExoTrackSelection[] createTrackSelectionsForDefinitions(\n    @NullableType Definition[] definitions,\n    AdaptiveTrackSelectionFactory adaptiveTrackSelectionFactory) {\n  ExoTrackSelection[] selections = new ExoTrackSelection[definitions.length];\n  boolean createdAdaptiveTrackSelection = false;\n  for (int i = 0; i < definitions.length; i++) {\n    Definition definition = definitions[i];\n    if (definition == null) {\n      continue;\n    }\n    if (definition.tracks.length > 1 && !createdAdaptiveTrackSelection) {\n      createdAdaptiveTrackSelection = true;\n      selections[i] = adaptiveTrackSelectionFactory.createAdaptiveTrackSelection(definition);\n    } else {\n      selections[i] =\n          new FixedTrackSelection(\n              definition.group, definition.tracks[0],  definition.type);\n    }\n  }\n  return selections;\n}",
        "summary_tokens": [
            "creates",
            "track",
            "selections",
            "for",
            "an",
            "array",
            "of",
            "track",
            "selection",
            "definitions",
            "with",
            "at",
            "most",
            "one",
            "multi",
            "track",
            "adaptive",
            "selection"
        ]
    },
    {
        "id": 1413,
        "code": "public static DefaultTrackSelector.Parameters updateParametersWithOverride(\n    DefaultTrackSelector.Parameters parameters,\n    int rendererIndex,\n    TrackGroupArray trackGroupArray,\n    boolean isDisabled,\n    @Nullable SelectionOverride override) {\n  DefaultTrackSelector.Parameters.Builder builder =\n      parameters\n          .buildUpon()\n          .clearSelectionOverrides(rendererIndex)\n          .setRendererDisabled(rendererIndex, isDisabled);\n  if (override != null) {\n    builder.setSelectionOverride(rendererIndex, trackGroupArray, override);\n  }\n  return builder.build();\n}",
        "summary_tokens": [
            "updates",
            "default",
            "track",
            "selector"
        ]
    },
    {
        "id": 1414,
        "code": "public static LoadErrorHandlingPolicy.FallbackOptions createFallbackOptions(\n    ExoTrackSelection trackSelection) {\n  long nowMs = SystemClock.elapsedRealtime();\n  int numberOfTracks = trackSelection.length();\n  int numberOfExcludedTracks = 0;\n  for (int i = 0; i < numberOfTracks; i++) {\n    if (trackSelection.isBlacklisted(i, nowMs)) {\n      numberOfExcludedTracks++;\n    }\n  }\n  return new LoadErrorHandlingPolicy.FallbackOptions(\n       1,\n       0,\n      numberOfTracks,\n      numberOfExcludedTracks);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "load",
            "error",
            "handling",
            "policy"
        ]
    },
    {
        "id": 1415,
        "code": "public static Tracks buildTracks(\n    MappingTrackSelector.MappedTrackInfo mappedTrackInfo,\n    List<? extends TrackSelection>[] selections) {\n  ImmutableList.Builder<Tracks.Group> trackGroups = new ImmutableList.Builder<>();\n  for (int rendererIndex = 0;\n      rendererIndex < mappedTrackInfo.getRendererCount();\n      rendererIndex++) {\n    TrackGroupArray trackGroupArray = mappedTrackInfo.getTrackGroups(rendererIndex);\n    List<? extends TrackSelection> rendererTrackSelections = selections[rendererIndex];\n    for (int groupIndex = 0; groupIndex < trackGroupArray.length; groupIndex++) {\n      TrackGroup trackGroup = trackGroupArray.get(groupIndex);\n      boolean adaptiveSupported =\n          mappedTrackInfo.getAdaptiveSupport(\n                  rendererIndex, groupIndex,  false)\n              != RendererCapabilities.ADAPTIVE_NOT_SUPPORTED;\n      @C.FormatSupport int[] trackSupport = new int[trackGroup.length];\n      boolean[] selected = new boolean[trackGroup.length];\n      for (int trackIndex = 0; trackIndex < trackGroup.length; trackIndex++) {\n        trackSupport[trackIndex] =\n            mappedTrackInfo.getTrackSupport(rendererIndex, groupIndex, trackIndex);\n        boolean isTrackSelected = false;\n        for (int i = 0; i < rendererTrackSelections.size(); i++) {\n          TrackSelection trackSelection = rendererTrackSelections.get(i);\n          if (trackSelection.getTrackGroup().equals(trackGroup)\n              && trackSelection.indexOf(trackIndex) != C.INDEX_UNSET) {\n            isTrackSelected = true;\n            break;\n          }\n        }\n        selected[trackIndex] = isTrackSelected;\n      }\n      trackGroups.add(new Tracks.Group(trackGroup, adaptiveSupported, trackSupport, selected));\n    }\n  }\n  TrackGroupArray unmappedTrackGroups = mappedTrackInfo.getUnmappedTrackGroups();\n  for (int groupIndex = 0; groupIndex < unmappedTrackGroups.length; groupIndex++) {\n    TrackGroup trackGroup = unmappedTrackGroups.get(groupIndex);\n    @C.FormatSupport int[] trackSupport = new int[trackGroup.length];\n    Arrays.fill(trackSupport, C.FORMAT_UNSUPPORTED_TYPE);\n    boolean[] selected = new boolean[trackGroup.length];\n    trackGroups.add(\n        new Tracks.Group(trackGroup,  false, trackSupport, selected));\n  }\n  return new Tracks(trackGroups.build());\n}",
        "summary_tokens": [
            "returns",
            "tracks",
            "built",
            "from",
            "mapping",
            "track",
            "selector"
        ]
    },
    {
        "id": 1416,
        "code": "public void init(InvalidationListener listener, BandwidthMeter bandwidthMeter) {\n  this.listener = listener;\n  this.bandwidthMeter = bandwidthMeter;\n}",
        "summary_tokens": [
            "called",
            "by",
            "the",
            "player",
            "to",
            "initialize",
            "the",
            "selector"
        ]
    },
    {
        "id": 1417,
        "code": "public void release() {\n  listener = null;\n  bandwidthMeter = null;\n}",
        "summary_tokens": [
            "called",
            "by",
            "the",
            "player",
            "to",
            "release",
            "the",
            "selector"
        ]
    },
    {
        "id": 1418,
        "code": "public TrackSelectionParameters getParameters() {\n  return TrackSelectionParameters.DEFAULT_WITHOUT_CONTEXT;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "current",
            "parameters",
            "for",
            "track",
            "selection"
        ]
    },
    {
        "id": 1419,
        "code": "public void setParameters(TrackSelectionParameters parameters) {\n    \n}",
        "summary_tokens": [
            "called",
            "by",
            "the",
            "player",
            "to",
            "provide",
            "parameters",
            "for",
            "track",
            "selection"
        ]
    },
    {
        "id": 1420,
        "code": "public boolean isSetParametersSupported() {\n  return false;\n}",
        "summary_tokens": [
            "returns",
            "if",
            "this",
            "track",
            "selector",
            "supports",
            "set",
            "parameters",
            "track",
            "selection",
            "parameters"
        ]
    },
    {
        "id": 1421,
        "code": "public void setAudioAttributes(AudioAttributes audioAttributes) {\n    \n}",
        "summary_tokens": [
            "called",
            "by",
            "the",
            "player",
            "to",
            "set",
            "the",
            "audio",
            "attributes",
            "that",
            "will",
            "be",
            "used",
            "for",
            "playback"
        ]
    },
    {
        "id": 1422,
        "code": "protected final void invalidate() {\n  if (listener != null) {\n    listener.onTrackSelectionsInvalidated();\n  }\n}",
        "summary_tokens": [
            "calls",
            "invalidation",
            "listener",
            "on",
            "track",
            "selections",
            "invalidated",
            "to",
            "invalidate",
            "all",
            "previously",
            "generated",
            "track",
            "selections"
        ]
    },
    {
        "id": 1423,
        "code": "protected final BandwidthMeter getBandwidthMeter() {\n  return checkStateNotNull(bandwidthMeter);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "bandwidth",
            "meter",
            "which",
            "can",
            "be",
            "used",
            "by",
            "track",
            "selections",
            "to",
            "select",
            "tracks"
        ]
    },
    {
        "id": 1424,
        "code": "public boolean isRendererEnabled(int index) {\n  return rendererConfigurations[index] != null;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "renderer",
            "at",
            "the",
            "specified",
            "index",
            "is",
            "enabled"
        ]
    },
    {
        "id": 1425,
        "code": "public boolean isEquivalent(@Nullable TrackSelectorResult other, int index) {\n  if (other == null) {\n    return false;\n  }\n  return Util.areEqual(rendererConfigurations[index], other.rendererConfigurations[index])\n      && Util.areEqual(selections[index], other.selections[index]);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "this",
            "result",
            "is",
            "equivalent",
            "to",
            "other",
            "for",
            "the",
            "renderer",
            "at",
            "the",
            "given",
            "index"
        ]
    },
    {
        "id": 1426,
        "code": "public Notification buildProgressNotification(\n    Context context,\n    @DrawableRes int smallIcon,\n    @Nullable PendingIntent contentIntent,\n    @Nullable String message,\n    List<Download> downloads,\n    @Requirements.RequirementFlags int notMetRequirements) {\n  float totalPercentage = 0;\n  int downloadTaskCount = 0;\n  boolean allDownloadPercentagesUnknown = true;\n  boolean haveDownloadedBytes = false;\n  boolean haveDownloadingTasks = false;\n  boolean haveQueuedTasks = false;\n  boolean haveRemovingTasks = false;\n  for (int i = 0; i < downloads.size(); i++) {\n    Download download = downloads.get(i);\n    switch (download.state) {\n      case Download.STATE_REMOVING:\n        haveRemovingTasks = true;\n        break;\n      case Download.STATE_QUEUED:\n        haveQueuedTasks = true;\n        break;\n      case Download.STATE_RESTARTING:\n      case Download.STATE_DOWNLOADING:\n        haveDownloadingTasks = true;\n        float downloadPercentage = download.getPercentDownloaded();\n        if (downloadPercentage != C.PERCENTAGE_UNSET) {\n          allDownloadPercentagesUnknown = false;\n          totalPercentage += downloadPercentage;\n        }\n        haveDownloadedBytes |= download.getBytesDownloaded() > 0;\n        downloadTaskCount++;\n        break;\n          \n      case Download.STATE_STOPPED:\n      case Download.STATE_COMPLETED:\n      case Download.STATE_FAILED:\n      default:\n        break;\n    }\n  }\n\n  int titleStringId;\n  boolean showProgress = true;\n  if (haveDownloadingTasks) {\n    titleStringId = R.string.exo_download_downloading;\n  } else if (haveQueuedTasks && notMetRequirements != 0) {\n    showProgress = false;\n    if ((notMetRequirements & Requirements.NETWORK_UNMETERED) != 0) {\n        \n        \n      titleStringId = R.string.exo_download_paused_for_wifi;\n    } else if ((notMetRequirements & Requirements.NETWORK) != 0) {\n      titleStringId = R.string.exo_download_paused_for_network;\n    } else {\n      titleStringId = R.string.exo_download_paused;\n    }\n  } else if (haveRemovingTasks) {\n    titleStringId = R.string.exo_download_removing;\n  } else {\n      \n    titleStringId = NULL_STRING_ID;\n  }\n\n  int maxProgress = 0;\n  int currentProgress = 0;\n  boolean indeterminateProgress = false;\n  if (showProgress) {\n    maxProgress = 100;\n    if (haveDownloadingTasks) {\n      currentProgress = (int) (totalPercentage / downloadTaskCount);\n      indeterminateProgress = allDownloadPercentagesUnknown && haveDownloadedBytes;\n    } else {\n      indeterminateProgress = true;\n    }\n  }\n\n  return buildNotification(\n      context,\n      smallIcon,\n      contentIntent,\n      message,\n      titleStringId,\n      maxProgress,\n      currentProgress,\n      indeterminateProgress,\n       true,\n       false);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "progress",
            "notification",
            "for",
            "the",
            "given",
            "downloads"
        ]
    },
    {
        "id": 1427,
        "code": "public Notification buildDownloadCompletedNotification(\n    Context context,\n    @DrawableRes int smallIcon,\n    @Nullable PendingIntent contentIntent,\n    @Nullable String message) {\n  int titleStringId = R.string.exo_download_completed;\n  return buildEndStateNotification(context, smallIcon, contentIntent, message, titleStringId);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "notification",
            "for",
            "a",
            "completed",
            "download"
        ]
    },
    {
        "id": 1428,
        "code": "public Notification buildDownloadFailedNotification(\n    Context context,\n    @DrawableRes int smallIcon,\n    @Nullable PendingIntent contentIntent,\n    @Nullable String message) {\n  @StringRes int titleStringId = R.string.exo_download_failed;\n  return buildEndStateNotification(context, smallIcon, contentIntent, message, titleStringId);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "notification",
            "for",
            "a",
            "failed",
            "download"
        ]
    },
    {
        "id": 1429,
        "code": "default long getTimeToFirstByteEstimateUs() {\n  return C.TIME_UNSET;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "estimated",
            "time",
            "to",
            "first",
            "byte",
            "in",
            "microseconds",
            "or",
            "c",
            "time",
            "unset",
            "if",
            "no",
            "estimate",
            "is",
            "available"
        ]
    },
    {
        "id": 1430,
        "code": "public synchronized int getRegionEndTimeMs(long byteOffset) {\n  lookupRegion.startOffset = byteOffset;\n  @Nullable Region floorRegion = regions.floor(lookupRegion);\n  if (floorRegion == null\n      || byteOffset > floorRegion.endOffset\n      || floorRegion.endOffsetIndex == -1) {\n    return NOT_CACHED;\n  }\n  int index = floorRegion.endOffsetIndex;\n  if (index == chunkIndex.length - 1\n      && floorRegion.endOffset == (chunkIndex.offsets[index] + chunkIndex.sizes[index])) {\n    return CACHED_TO_END;\n  }\n  long segmentFractionUs =\n      (chunkIndex.durationsUs[index] * (floorRegion.endOffset - chunkIndex.offsets[index]))\n          / chunkIndex.sizes[index];\n  return (int) ((chunkIndex.timesUs[index] + segmentFractionUs) / 1000);\n}",
        "summary_tokens": [
            "when",
            "provided",
            "with",
            "a",
            "byte",
            "offset",
            "this",
            "method",
            "locates",
            "the",
            "cached",
            "region",
            "within",
            "which",
            "the",
            "offset",
            "falls",
            "and",
            "returns",
            "the",
            "approximate",
            "end",
            "position",
            "in",
            "milliseconds",
            "of",
            "that",
            "region"
        ]
    },
    {
        "id": 1431,
        "code": "public static synchronized DefaultBandwidthMeter getSingletonInstance(Context context) {\n  if (singletonInstance == null) {\n    singletonInstance = new DefaultBandwidthMeter.Builder(context).build();\n  }\n  return singletonInstance;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "singleton",
            "instance",
            "of",
            "a",
            "default",
            "bandwidth",
            "meter",
            "with",
            "default",
            "configuration"
        ]
    },
    {
        "id": 1432,
        "code": "public synchronized void setNetworkTypeOverride(@C.NetworkType int networkType) {\n  networkTypeOverride = networkType;\n  networkTypeOverrideSet = true;\n  onNetworkTypeChanged(networkType);\n}",
        "summary_tokens": [
            "overrides",
            "the",
            "network",
            "type"
        ]
    },
    {
        "id": 1433,
        "code": "private static int[] getInitialBitrateCountryGroupAssignment(String country) {\n  switch (country) {\n    case \"AE\":\n      return new int[] {1, 4, 4, 4, 4, 0};\n    case \"AG\":\n      return new int[] {2, 4, 1, 2, 2, 2};\n    case \"AI\":\n      return new int[] {0, 2, 0, 3, 2, 2};\n    case \"AM\":\n      return new int[] {2, 3, 2, 3, 2, 2};\n    case \"AO\":\n      return new int[] {4, 4, 3, 2, 2, 2};\n    case \"AS\":\n      return new int[] {2, 2, 3, 3, 2, 2};\n    case \"AT\":\n      return new int[] {1, 0, 1, 1, 0, 0};\n    case \"AU\":\n      return new int[] {0, 1, 1, 1, 2, 0};\n    case \"AW\":\n      return new int[] {1, 3, 4, 4, 2, 2};\n    case \"BA\":\n      return new int[] {1, 2, 1, 1, 2, 2};\n    case \"BD\":\n      return new int[] {2, 1, 3, 3, 2, 2};\n    case \"BE\":\n      return new int[] {0, 1, 4, 4, 3, 2};\n    case \"BF\":\n      return new int[] {4, 3, 4, 3, 2, 2};\n    case \"BH\":\n      return new int[] {1, 2, 1, 3, 4, 2};\n    case \"BJ\":\n      return new int[] {4, 4, 3, 3, 2, 2};\n    case \"BO\":\n      return new int[] {1, 2, 3, 2, 2, 2};\n    case \"BS\":\n      return new int[] {4, 4, 2, 2, 2, 2};\n    case \"BT\":\n      return new int[] {3, 1, 3, 2, 2, 2};\n    case \"BW\":\n      return new int[] {3, 2, 1, 0, 2, 2};\n    case \"BY\":\n      return new int[] {0, 1, 2, 3, 2, 2};\n    case \"BZ\":\n      return new int[] {2, 4, 2, 1, 2, 2};\n    case \"CA\":\n      return new int[] {0, 2, 2, 2, 3, 2};\n    case \"CD\":\n      return new int[] {4, 2, 3, 2, 2, 2};\n    case \"CH\":\n      return new int[] {0, 0, 0, 1, 0, 2};\n    case \"CM\":\n      return new int[] {3, 3, 3, 3, 2, 2};\n    case \"CN\":\n      return new int[] {2, 0, 1, 1, 3, 2};\n    case \"CO\":\n      return new int[] {2, 3, 4, 3, 2, 2};\n    case \"CR\":\n      return new int[] {2, 3, 4, 4, 2, 2};\n    case \"CV\":\n      return new int[] {2, 1, 0, 0, 2, 2};\n    case \"BN\":\n    case \"CW\":\n      return new int[] {2, 2, 0, 0, 2, 2};\n    case \"DE\":\n      return new int[] {0, 1, 2, 2, 2, 3};\n    case \"DK\":\n      return new int[] {0, 0, 3, 2, 0, 2};\n    case \"DO\":\n      return new int[] {3, 4, 4, 4, 4, 2};\n    case \"EC\":\n      return new int[] {2, 3, 2, 1, 2, 2};\n    case \"ET\":\n      return new int[] {4, 3, 3, 1, 2, 2};\n    case \"FI\":\n      return new int[] {0, 0, 0, 3, 0, 2};\n    case \"FJ\":\n      return new int[] {3, 1, 2, 2, 2, 2};\n    case \"FM\":\n      return new int[] {4, 2, 4, 1, 2, 2};\n    case \"FR\":\n      return new int[] {1, 2, 3, 1, 0, 2};\n    case \"GB\":\n      return new int[] {0, 0, 1, 1, 1, 1};\n    case \"GE\":\n      return new int[] {1, 1, 1, 2, 2, 2};\n    case \"BB\":\n    case \"DM\":\n    case \"FO\":\n    case \"GI\":\n      return new int[] {0, 2, 0, 0, 2, 2};\n    case \"AF\":\n    case \"GM\":\n      return new int[] {4, 3, 3, 4, 2, 2};\n    case \"GN\":\n      return new int[] {4, 3, 4, 2, 2, 2};\n    case \"GQ\":\n      return new int[] {4, 2, 1, 4, 2, 2};\n    case \"GT\":\n      return new int[] {2, 3, 2, 2, 2, 2};\n    case \"CG\":\n    case \"EG\":\n    case \"GW\":\n      return new int[] {3, 4, 3, 3, 2, 2};\n    case \"GY\":\n      return new int[] {3, 2, 2, 1, 2, 2};\n    case \"HK\":\n      return new int[] {0, 1, 2, 3, 2, 0};\n    case \"HU\":\n      return new int[] {0, 0, 0, 1, 3, 2};\n    case \"ID\":\n      return new int[] {3, 1, 2, 2, 3, 2};\n    case \"ES\":\n    case \"IE\":\n      return new int[] {0, 1, 1, 1, 2, 2};\n    case \"CL\":\n    case \"IL\":\n      return new int[] {1, 2, 2, 2, 3, 2};\n    case \"IN\":\n      return new int[] {1, 1, 3, 2, 3, 3};\n    case \"IQ\":\n      return new int[] {3, 2, 2, 3, 2, 2};\n    case \"IR\":\n      return new int[] {3, 0, 1, 1, 4, 1};\n    case \"IT\":\n      return new int[] {0, 0, 0, 1, 1, 2};\n    case \"JM\":\n      return new int[] {2, 4, 3, 2, 2, 2};\n    case \"JO\":\n      return new int[] {2, 1, 1, 2, 2, 2};\n    case \"JP\":\n      return new int[] {0, 1, 1, 2, 2, 4};\n    case \"KH\":\n      return new int[] {2, 1, 4, 2, 2, 2};\n    case \"CF\":\n    case \"KI\":\n      return new int[] {4, 2, 4, 2, 2, 2};\n    case \"FK\":\n    case \"KE\":\n    case \"KP\":\n      return new int[] {3, 2, 2, 2, 2, 2};\n    case \"KR\":\n      return new int[] {0, 1, 1, 3, 4, 4};\n    case \"CY\":\n    case \"KW\":\n      return new int[] {1, 0, 0, 0, 0, 2};\n    case \"KZ\":\n      return new int[] {2, 1, 2, 2, 2, 2};\n    case \"LA\":\n      return new int[] {1, 2, 1, 3, 2, 2};\n    case \"LB\":\n      return new int[] {3, 3, 2, 4, 2, 2};\n    case \"LK\":\n      return new int[] {3, 1, 3, 3, 4, 2};\n    case \"CI\":\n    case \"DZ\":\n    case \"LR\":\n      return new int[] {3, 4, 4, 4, 2, 2};\n    case \"LS\":\n      return new int[] {3, 3, 2, 2, 2, 2};\n    case \"LT\":\n      return new int[] {0, 0, 0, 0, 2, 2};\n    case \"LU\":\n      return new int[] {1, 0, 3, 2, 1, 4};\n    case \"MA\":\n      return new int[] {3, 3, 1, 1, 2, 2};\n    case \"MC\":\n      return new int[] {0, 2, 2, 0, 2, 2};\n    case \"ME\":\n      return new int[] {2, 0, 0, 1, 2, 2};\n    case \"MK\":\n      return new int[] {1, 0, 0, 1, 3, 2};\n    case \"MM\":\n      return new int[] {2, 4, 2, 3, 2, 2};\n    case \"MN\":\n      return new int[] {2, 0, 1, 2, 2, 2};\n    case \"MO\":\n    case \"MP\":\n      return new int[] {0, 2, 4, 4, 2, 2};\n    case \"GP\":\n    case \"MQ\":\n      return new int[] {2, 1, 2, 3, 2, 2};\n    case \"MU\":\n      return new int[] {3, 1, 1, 2, 2, 2};\n    case \"MV\":\n      return new int[] {3, 4, 1, 4, 2, 2};\n    case \"MW\":\n      return new int[] {4, 2, 3, 3, 2, 2};\n    case \"MX\":\n      return new int[] {2, 4, 3, 4, 2, 2};\n    case \"MY\":\n      return new int[] {1, 0, 3, 1, 3, 2};\n    case \"MZ\":\n      return new int[] {3, 1, 2, 1, 2, 2};\n    case \"NC\":\n      return new int[] {3, 3, 4, 4, 2, 2};\n    case \"NG\":\n      return new int[] {3, 4, 2, 1, 2, 2};\n    case \"NL\":\n      return new int[] {0, 2, 2, 3, 0, 3};\n    case \"CZ\":\n    case \"NO\":\n      return new int[] {0, 0, 2, 0, 1, 2};\n    case \"NP\":\n      return new int[] {2, 2, 4, 3, 2, 2};\n    case \"NR\":\n    case \"NU\":\n      return new int[] {4, 2, 2, 1, 2, 2};\n    case \"OM\":\n      return new int[] {2, 3, 1, 3, 4, 2};\n    case \"GU\":\n    case \"PE\":\n      return new int[] {1, 2, 4, 4, 4, 2};\n    case \"CK\":\n    case \"PF\":\n      return new int[] {2, 2, 2, 1, 2, 2};\n    case \"ML\":\n    case \"PG\":\n      return new int[] {4, 3, 3, 2, 2, 2};\n    case \"PH\":\n      return new int[] {2, 1, 3, 3, 3, 0};\n    case \"NZ\":\n    case \"PL\":\n      return new int[] {1, 1, 2, 2, 4, 2};\n    case \"PR\":\n      return new int[] {2, 0, 2, 1, 2, 1};\n    case \"PS\":\n      return new int[] {3, 4, 1, 2, 2, 2};\n    case \"PW\":\n      return new int[] {2, 2, 4, 1, 2, 2};\n    case \"QA\":\n      return new int[] {2, 4, 4, 4, 4, 2};\n    case \"MF\":\n    case \"RE\":\n      return new int[] {1, 2, 1, 2, 2, 2};\n    case \"RO\":\n      return new int[] {0, 0, 1, 2, 1, 2};\n    case \"MD\":\n    case \"RS\":\n      return new int[] {1, 0, 0, 0, 2, 2};\n    case \"RU\":\n      return new int[] {1, 0, 0, 0, 4, 3};\n    case \"RW\":\n      return new int[] {3, 4, 2, 0, 2, 2};\n    case \"SA\":\n      return new int[] {3, 1, 1, 1, 2, 2};\n    case \"SB\":\n      return new int[] {4, 2, 4, 3, 2, 2};\n    case \"SG\":\n      return new int[] {1, 1, 2, 2, 2, 1};\n    case \"AQ\":\n    case \"ER\":\n    case \"SH\":\n      return new int[] {4, 2, 2, 2, 2, 2};\n    case \"GR\":\n    case \"HR\":\n    case \"SI\":\n      return new int[] {1, 0, 0, 0, 1, 2};\n    case \"BG\":\n    case \"MT\":\n    case \"SK\":\n      return new int[] {0, 0, 0, 0, 1, 2};\n    case \"AX\":\n    case \"LI\":\n    case \"MS\":\n    case \"PM\":\n    case \"SM\":\n      return new int[] {0, 2, 2, 2, 2, 2};\n    case \"SN\":\n      return new int[] {4, 4, 4, 3, 2, 2};\n    case \"SR\":\n      return new int[] {2, 4, 3, 0, 2, 2};\n    case \"SS\":\n      return new int[] {4, 3, 2, 3, 2, 2};\n    case \"ST\":\n      return new int[] {2, 2, 1, 2, 2, 2};\n    case \"NI\":\n    case \"PA\":\n    case \"SV\":\n      return new int[] {2, 3, 3, 3, 2, 2};\n    case \"SZ\":\n      return new int[] {3, 3, 3, 4, 2, 2};\n    case \"SX\":\n    case \"TC\":\n      return new int[] {1, 2, 1, 0, 2, 2};\n    case \"GA\":\n    case \"TG\":\n      return new int[] {3, 4, 1, 0, 2, 2};\n    case \"TH\":\n      return new int[] {0, 2, 2, 3, 3, 4};\n    case \"TK\":\n      return new int[] {2, 2, 2, 4, 2, 2};\n    case \"CU\":\n    case \"DJ\":\n    case \"SY\":\n    case \"TJ\":\n    case \"TL\":\n      return new int[] {4, 3, 4, 4, 2, 2};\n    case \"SC\":\n    case \"TM\":\n      return new int[] {4, 2, 1, 1, 2, 2};\n    case \"AZ\":\n    case \"GF\":\n    case \"LY\":\n    case \"PK\":\n    case \"SO\":\n    case \"TO\":\n      return new int[] {3, 2, 3, 3, 2, 2};\n    case \"TR\":\n      return new int[] {1, 1, 0, 0, 2, 2};\n    case \"TT\":\n      return new int[] {1, 4, 1, 3, 2, 2};\n    case \"EE\":\n    case \"IS\":\n    case \"LV\":\n    case \"PT\":\n    case \"SE\":\n    case \"TW\":\n      return new int[] {0, 0, 0, 0, 0, 2};\n    case \"TZ\":\n      return new int[] {3, 4, 3, 2, 2, 2};\n    case \"IM\":\n    case \"UA\":\n      return new int[] {0, 2, 1, 1, 2, 2};\n    case \"SL\":\n    case \"UG\":\n      return new int[] {3, 3, 4, 3, 2, 2};\n    case \"US\":\n      return new int[] {1, 0, 2, 2, 3, 1};\n    case \"AR\":\n    case \"KG\":\n    case \"TN\":\n    case \"UY\":\n      return new int[] {2, 1, 1, 1, 2, 2};\n    case \"UZ\":\n      return new int[] {2, 2, 3, 4, 2, 2};\n    case \"BL\":\n    case \"CX\":\n    case \"VA\":\n      return new int[] {1, 2, 2, 2, 2, 2};\n    case \"AD\":\n    case \"BM\":\n    case \"BQ\":\n    case \"GD\":\n    case \"GL\":\n    case \"KN\":\n    case \"KY\":\n    case \"LC\":\n    case \"VC\":\n      return new int[] {1, 2, 0, 0, 2, 2};\n    case \"VG\":\n      return new int[] {2, 2, 1, 1, 2, 2};\n    case \"GG\":\n    case \"VI\":\n      return new int[] {0, 2, 0, 1, 2, 2};\n    case \"VN\":\n      return new int[] {0, 3, 3, 4, 2, 2};\n    case \"GH\":\n    case \"NA\":\n    case \"VU\":\n      return new int[] {3, 3, 3, 2, 2, 2};\n    case \"IO\":\n    case \"MH\":\n    case \"TV\":\n    case \"WF\":\n      return new int[] {4, 2, 2, 4, 2, 2};\n    case \"WS\":\n      return new int[] {3, 1, 3, 1, 2, 2};\n    case \"AL\":\n    case \"XK\":\n      return new int[] {1, 1, 1, 1, 2, 2};\n    case \"BI\":\n    case \"HT\":\n    case \"KM\":\n    case \"MG\":\n    case \"NE\":\n    case \"SD\":\n    case \"TD\":\n    case \"VE\":\n    case \"YE\":\n      return new int[] {4, 4, 4, 4, 2, 2};\n    case \"JE\":\n    case \"YT\":\n      return new int[] {4, 2, 2, 3, 2, 2};\n    case \"ZA\":\n      return new int[] {3, 2, 2, 1, 1, 2};\n    case \"ZM\":\n      return new int[] {3, 3, 4, 2, 2, 2};\n    case \"MR\":\n    case \"ZW\":\n      return new int[] {4, 2, 4, 4, 2, 2};\n    default:\n      return new int[] {2, 2, 2, 2, 2, 2};\n  }\n}",
        "summary_tokens": [
            "returns",
            "initial",
            "bitrate",
            "group",
            "assignments",
            "for",
            "a",
            "country"
        ]
    },
    {
        "id": 1434,
        "code": "public FallbackSelection getFallbackSelectionFor(\n    FallbackOptions fallbackOptions, LoadErrorInfo loadErrorInfo) {\n  if (!isEligibleForFallback(loadErrorInfo.exception)) {\n    return null;\n  }\n    \n  if (fallbackOptions.isFallbackAvailable(FALLBACK_TYPE_LOCATION)) {\n    return new FallbackSelection(FALLBACK_TYPE_LOCATION, DEFAULT_LOCATION_EXCLUSION_MS);\n  } else if (fallbackOptions.isFallbackAvailable(FALLBACK_TYPE_TRACK)) {\n    return new FallbackSelection(FALLBACK_TYPE_TRACK, DEFAULT_TRACK_EXCLUSION_MS);\n  }\n  return null;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "a",
            "loader",
            "should",
            "fall",
            "back",
            "to",
            "using",
            "another",
            "resource",
            "on",
            "encountering",
            "an",
            "error",
            "and",
            "if",
            "so",
            "the",
            "duration",
            "for",
            "which",
            "the",
            "failing",
            "resource",
            "should",
            "be",
            "excluded"
        ]
    },
    {
        "id": 1435,
        "code": "public long getRetryDelayMsFor(LoadErrorInfo loadErrorInfo) {\n  IOException exception = loadErrorInfo.exception;\n  return exception instanceof ParserException\n          || exception instanceof FileNotFoundException\n          || exception instanceof CleartextNotPermittedException\n          || exception instanceof UnexpectedLoaderException\n          || DataSourceException.isCausedByPositionOutOfRange(exception)\n      ? C.TIME_UNSET\n      : min((loadErrorInfo.errorCount - 1) * 1000, 5000);\n}",
        "summary_tokens": [
            "retries",
            "for",
            "any",
            "exception",
            "that",
            "is",
            "not",
            "a",
            "subclass",
            "of",
            "parser",
            "exception",
            "file",
            "not",
            "found",
            "exception",
            "cleartext",
            "not",
            "permitted",
            "exception",
            "or",
            "unexpected",
            "loader",
            "exception",
            "and",
            "for",
            "which",
            "data",
            "source",
            "exception",
            "is",
            "caused",
            "by",
            "position",
            "out",
            "of",
            "range",
            "returns",
            "false"
        ]
    },
    {
        "id": 1436,
        "code": "public int getMinimumLoadableRetryCount(int dataType) {\n  if (minimumLoadableRetryCount == DEFAULT_BEHAVIOR_MIN_LOADABLE_RETRY_COUNT) {\n    return dataType == C.DATA_TYPE_MEDIA_PROGRESSIVE_LIVE\n        ? DEFAULT_MIN_LOADABLE_RETRY_COUNT_PROGRESSIVE_LIVE\n        : DEFAULT_MIN_LOADABLE_RETRY_COUNT;\n  } else {\n    return minimumLoadableRetryCount;\n  }\n}",
        "summary_tokens": [
            "see",
            "default",
            "load",
            "error",
            "handling",
            "policy",
            "and",
            "default",
            "load",
            "error",
            "handling",
            "policy",
            "int",
            "for",
            "documentation",
            "about",
            "the",
            "behavior",
            "of",
            "this",
            "method"
        ]
    },
    {
        "id": 1437,
        "code": "protected boolean isEligibleForFallback(IOException exception) {\n  if (!(exception instanceof InvalidResponseCodeException)) {\n    return false;\n  }\n  InvalidResponseCodeException invalidResponseCodeException =\n      (InvalidResponseCodeException) exception;\n  return invalidResponseCodeException.responseCode == 403 \n      || invalidResponseCodeException.responseCode == 404 \n      || invalidResponseCodeException.responseCode == 410 \n      || invalidResponseCodeException.responseCode == 416 \n      || invalidResponseCodeException.responseCode == 500 \n      || invalidResponseCodeException.responseCode == 503; \n}",
        "summary_tokens": [
            "returns",
            "whether",
            "an",
            "error",
            "should",
            "trigger",
            "a",
            "fallback",
            "if",
            "possible"
        ]
    },
    {
        "id": 1438,
        "code": "default void onLoadTaskConcluded(long loadTaskId) {}",
        "summary_tokens": [
            "called",
            "once",
            "load",
            "task",
            "id",
            "will",
            "not",
            "be",
            "associated",
            "with",
            "any",
            "more",
            "load",
            "errors"
        ]
    },
    {
        "id": 1439,
        "code": "public static LoadErrorAction createRetryAction(boolean resetErrorCount, long retryDelayMillis) {\n  return new LoadErrorAction(\n      resetErrorCount ? ACTION_TYPE_RETRY_AND_RESET_ERROR_COUNT : ACTION_TYPE_RETRY,\n      retryDelayMillis);\n}",
        "summary_tokens": [
            "creates",
            "a",
            "load",
            "error",
            "action",
            "for",
            "retrying",
            "with",
            "the",
            "given",
            "parameters"
        ]
    },
    {
        "id": 1440,
        "code": "public boolean hasFatalError() {\n  return fatalError != null;\n}",
        "summary_tokens": [
            "whether",
            "the",
            "last",
            "call",
            "to",
            "start",
            "loading",
            "resulted",
            "in",
            "a",
            "fatal",
            "error"
        ]
    },
    {
        "id": 1441,
        "code": "public void clearFatalError() {\n  fatalError = null;\n}",
        "summary_tokens": [
            "clears",
            "any",
            "stored",
            "fatal",
            "error"
        ]
    },
    {
        "id": 1442,
        "code": "public <T extends Loadable> long startLoading(\n    T loadable, Callback<T> callback, int defaultMinRetryCount) {\n  Looper looper = Assertions.checkStateNotNull(Looper.myLooper());\n  fatalError = null;\n  long startTimeMs = SystemClock.elapsedRealtime();\n  new LoadTask<>(looper, loadable, callback, defaultMinRetryCount, startTimeMs).start(0);\n  return startTimeMs;\n}",
        "summary_tokens": [
            "starts",
            "loading",
            "a",
            "loadable"
        ]
    },
    {
        "id": 1443,
        "code": "public boolean isLoading() {\n  return currentTask != null;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "loader",
            "is",
            "currently",
            "loading"
        ]
    },
    {
        "id": 1444,
        "code": "public void cancelLoading() {\n  Assertions.checkStateNotNull(currentTask).cancel(false);\n}",
        "summary_tokens": [
            "cancels",
            "the",
            "current",
            "load"
        ]
    },
    {
        "id": 1445,
        "code": "public static <T> T load(\n    DataSource dataSource, Parser<? extends T> parser, DataSpec dataSpec, int type)\n    throws IOException {\n  ParsingLoadable<T> loadable = new ParsingLoadable<>(dataSource, dataSpec, type, parser);\n  loadable.load();\n  return Assertions.checkNotNull(loadable.getResult());\n}",
        "summary_tokens": [
            "loads",
            "a",
            "single",
            "parsable",
            "object"
        ]
    },
    {
        "id": 1446,
        "code": "public final T getResult() {\n  return result;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "loaded",
            "object",
            "or",
            "null",
            "if",
            "an",
            "object",
            "has",
            "not",
            "been",
            "loaded"
        ]
    },
    {
        "id": 1447,
        "code": "public long bytesLoaded() {\n  return dataSource.getBytesRead();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "bytes",
            "loaded"
        ]
    },
    {
        "id": 1448,
        "code": "public Uri getUri() {\n  return dataSource.getLastOpenedUri();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "uri",
            "from",
            "which",
            "data",
            "was",
            "read"
        ]
    },
    {
        "id": 1449,
        "code": "public Map<String, List<String>> getResponseHeaders() {\n  return dataSource.getLastResponseHeaders();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "response",
            "headers",
            "associated",
            "with",
            "the",
            "load"
        ]
    },
    {
        "id": 1450,
        "code": "public void reset() {\n  samples.clear();\n  currentSortOrder = SORT_ORDER_NONE;\n  nextSampleIndex = 0;\n  totalWeight = 0;\n}",
        "summary_tokens": [
            "resets",
            "the",
            "sliding",
            "percentile"
        ]
    },
    {
        "id": 1451,
        "code": "public void addSample(int weight, float value) {\n  ensureSortedByIndex();\n\n  Sample newSample =\n      recycledSampleCount > 0 ? recycledSamples[--recycledSampleCount] : new Sample();\n  newSample.index = nextSampleIndex++;\n  newSample.weight = weight;\n  newSample.value = value;\n  samples.add(newSample);\n  totalWeight += weight;\n\n  while (totalWeight > maxWeight) {\n    int excessWeight = totalWeight - maxWeight;\n    Sample oldestSample = samples.get(0);\n    if (oldestSample.weight <= excessWeight) {\n      totalWeight -= oldestSample.weight;\n      samples.remove(0);\n      if (recycledSampleCount < MAX_RECYCLED_SAMPLES) {\n        recycledSamples[recycledSampleCount++] = oldestSample;\n      }\n    } else {\n      oldestSample.weight -= excessWeight;\n      totalWeight -= excessWeight;\n    }\n  }\n}",
        "summary_tokens": [
            "adds",
            "a",
            "new",
            "weighted",
            "value"
        ]
    },
    {
        "id": 1452,
        "code": "public float getPercentile(float percentile) {\n  ensureSortedByValue();\n  float desiredWeight = percentile * totalWeight;\n  int accumulatedWeight = 0;\n  for (int i = 0; i < samples.size(); i++) {\n    Sample currentSample = samples.get(i);\n    accumulatedWeight += currentSample.weight;\n    if (accumulatedWeight >= desiredWeight) {\n      return currentSample.value;\n    }\n  }\n    \n  return samples.isEmpty() ? Float.NaN : samples.get(samples.size() - 1).value;\n}",
        "summary_tokens": [
            "computes",
            "a",
            "percentile",
            "by",
            "integration"
        ]
    },
    {
        "id": 1453,
        "code": "private void ensureSortedByIndex() {\n  if (currentSortOrder != SORT_ORDER_BY_INDEX) {\n    Collections.sort(samples, INDEX_COMPARATOR);\n    currentSortOrder = SORT_ORDER_BY_INDEX;\n  }\n}",
        "summary_tokens": [
            "sorts",
            "the",
            "samples",
            "by",
            "index"
        ]
    },
    {
        "id": 1454,
        "code": "private void ensureSortedByValue() {\n  if (currentSortOrder != SORT_ORDER_BY_VALUE) {\n    Collections.sort(samples, VALUE_COMPARATOR);\n    currentSortOrder = SORT_ORDER_BY_VALUE;\n  }\n}",
        "summary_tokens": [
            "sorts",
            "the",
            "samples",
            "by",
            "value"
        ]
    },
    {
        "id": 1455,
        "code": "public final void start() {\n  if (started) {\n    return;\n  }\n  started = true;\n  player.addListener(updater);\n  updateAndPost();\n}",
        "summary_tokens": [
            "starts",
            "periodic",
            "updates",
            "of",
            "the",
            "text",
            "view"
        ]
    },
    {
        "id": 1456,
        "code": "public final void stop() {\n  if (!started) {\n    return;\n  }\n  started = false;\n  player.removeListener(updater);\n  textView.removeCallbacks(updater);\n}",
        "summary_tokens": [
            "stops",
            "periodic",
            "updates",
            "of",
            "the",
            "text",
            "view"
        ]
    },
    {
        "id": 1457,
        "code": "protected String getDebugString() {\n  return getPlayerStateString() + getVideoString() + getAudioString();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "debugging",
            "information",
            "string",
            "to",
            "be",
            "shown",
            "by",
            "the",
            "target",
            "text",
            "view"
        ]
    },
    {
        "id": 1458,
        "code": "protected String getPlayerStateString() {\n  String playbackStateString;\n  switch (player.getPlaybackState()) {\n    case Player.STATE_BUFFERING:\n      playbackStateString = \"buffering\";\n      break;\n    case Player.STATE_ENDED:\n      playbackStateString = \"ended\";\n      break;\n    case Player.STATE_IDLE:\n      playbackStateString = \"idle\";\n      break;\n    case Player.STATE_READY:\n      playbackStateString = \"ready\";\n      break;\n    default:\n      playbackStateString = \"unknown\";\n      break;\n  }\n  return String.format(\n      \"playWhenReady:%s playbackState:%s item:%s\",\n      player.getPlayWhenReady(), playbackStateString, player.getCurrentMediaItemIndex());\n}",
        "summary_tokens": [
            "returns",
            "a",
            "string",
            "containing",
            "player",
            "state",
            "debugging",
            "information"
        ]
    },
    {
        "id": 1459,
        "code": "protected String getVideoString() {\n  Format format = player.getVideoFormat();\n  DecoderCounters decoderCounters = player.getVideoDecoderCounters();\n  if (format == null || decoderCounters == null) {\n    return \"\";\n  }\n  return \"\\n\"\n      + format.sampleMimeType\n      + \"(id:\"\n      + format.id\n      + \" r:\"\n      + format.width\n      + \"x\"\n      + format.height\n      + getPixelAspectRatioString(format.pixelWidthHeightRatio)\n      + getDecoderCountersBufferCountString(decoderCounters)\n      + \" vfpo: \"\n      + getVideoFrameProcessingOffsetAverageString(\n          decoderCounters.totalVideoFrameProcessingOffsetUs,\n          decoderCounters.videoFrameProcessingOffsetCount)\n      + \")\";\n}",
        "summary_tokens": [
            "returns",
            "a",
            "string",
            "containing",
            "video",
            "debugging",
            "information"
        ]
    },
    {
        "id": 1460,
        "code": "protected String getAudioString() {\n  Format format = player.getAudioFormat();\n  DecoderCounters decoderCounters = player.getAudioDecoderCounters();\n  if (format == null || decoderCounters == null) {\n    return \"\";\n  }\n  return \"\\n\"\n      + format.sampleMimeType\n      + \"(id:\"\n      + format.id\n      + \" hz:\"\n      + format.sampleRate\n      + \" ch:\"\n      + format.channelCount\n      + getDecoderCountersBufferCountString(decoderCounters)\n      + \")\";\n}",
        "summary_tokens": [
            "returns",
            "a",
            "string",
            "containing",
            "audio",
            "debugging",
            "information"
        ]
    },
    {
        "id": 1461,
        "code": "protected void logd(String msg) {\n  Log.d(tag, msg);\n}",
        "summary_tokens": [
            "logs",
            "a",
            "debug",
            "message"
        ]
    },
    {
        "id": 1462,
        "code": "protected void loge(String msg) {\n  Log.e(tag, msg);\n}",
        "summary_tokens": [
            "logs",
            "an",
            "error",
            "message"
        ]
    },
    {
        "id": 1463,
        "code": "public static String getNtpHost() {\n  synchronized (valueLock) {\n    return ntpHost;\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "ntp",
            "host",
            "address",
            "used",
            "to",
            "retrieve",
            "get",
            "elapsed",
            "realtime",
            "offset",
            "ms"
        ]
    },
    {
        "id": 1464,
        "code": "public static void setNtpHost(String ntpHost) {\n  synchronized (valueLock) {\n    if (!SntpClient.ntpHost.equals(ntpHost)) {\n      SntpClient.ntpHost = ntpHost;\n      isInitialized = false;\n    }\n  }\n}",
        "summary_tokens": [
            "sets",
            "the",
            "ntp",
            "host",
            "address",
            "used",
            "to",
            "retrieve",
            "get",
            "elapsed",
            "realtime",
            "offset",
            "ms"
        ]
    },
    {
        "id": 1465,
        "code": "public static boolean isInitialized() {\n  synchronized (valueLock) {\n    return isInitialized;\n  }\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "device",
            "time",
            "offset",
            "has",
            "already",
            "been",
            "loaded"
        ]
    },
    {
        "id": 1466,
        "code": "public static long getElapsedRealtimeOffsetMs() {\n  synchronized (valueLock) {\n    return isInitialized ? elapsedRealtimeOffsetMs : C.TIME_UNSET;\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "offset",
            "between",
            "system",
            "clock",
            "elapsed",
            "realtime",
            "and",
            "the",
            "ntp",
            "server",
            "time",
            "in",
            "milliseconds",
            "or",
            "c",
            "time",
            "unset",
            "if",
            "is",
            "initialized",
            "returns",
            "false"
        ]
    },
    {
        "id": 1467,
        "code": "public static void initialize(\n    @Nullable Loader loader, @Nullable InitializationCallback callback) {\n  if (isInitialized()) {\n    if (callback != null) {\n      callback.onInitialized();\n    }\n    return;\n  }\n  if (loader == null) {\n    loader = new Loader(\"SntpClient\");\n  }\n  loader.startLoading(\n      new NtpTimeLoadable(), new NtpTimeCallback(callback),  1);\n}",
        "summary_tokens": [
            "starts",
            "loading",
            "the",
            "device",
            "time",
            "offset"
        ]
    },
    {
        "id": 1468,
        "code": "public void resetPosition(long positionUs) {\n  baseUs = positionUs;\n  if (started) {\n    baseElapsedMs = clock.elapsedRealtime();\n  }\n}",
        "summary_tokens": [
            "resets",
            "the",
            "clock",
            "s",
            "position"
        ]
    },
    {
        "id": 1469,
        "code": "protected void onInputFormatChanged(FormatHolder formatHolder) throws ExoPlaybackException {\n  waitingForFirstSampleInFormat = true;\n  Format newFormat = Assertions.checkNotNull(formatHolder.format);\n  setSourceDrmSession(formatHolder.drmSession);\n  Format oldFormat = inputFormat;\n  inputFormat = newFormat;\n\n  if (decoder == null) {\n    maybeInitDecoder();\n    eventDispatcher.inputFormatChanged(inputFormat,  null);\n    return;\n  }\n\n  DecoderReuseEvaluation evaluation;\n  if (sourceDrmSession != decoderDrmSession) {\n    evaluation =\n        new DecoderReuseEvaluation(\n            decoder.getName(),\n            oldFormat,\n            newFormat,\n            REUSE_RESULT_NO,\n            DISCARD_REASON_DRM_SESSION_CHANGED);\n  } else {\n    evaluation = canReuseDecoder(decoder.getName(), oldFormat, newFormat);\n  }\n\n  if (evaluation.result == REUSE_RESULT_NO) {\n    if (decoderReceivedBuffers) {\n        \n      decoderReinitializationState = REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM;\n    } else {\n        \n      releaseDecoder();\n      maybeInitDecoder();\n    }\n  }\n  eventDispatcher.inputFormatChanged(inputFormat, evaluation);\n}",
        "summary_tokens": [
            "called",
            "when",
            "a",
            "new",
            "format",
            "is",
            "read",
            "from",
            "the",
            "upstream",
            "source"
        ]
    },
    {
        "id": 1470,
        "code": "protected void onQueueInputBuffer(DecoderInputBuffer buffer) {\n    \n}",
        "summary_tokens": [
            "called",
            "immediately",
            "before",
            "an",
            "input",
            "buffer",
            "is",
            "queued",
            "into",
            "the",
            "decoder"
        ]
    },
    {
        "id": 1471,
        "code": "protected void onProcessedOutputBuffer(long presentationTimeUs) {\n  buffersInCodecCount--;\n}",
        "summary_tokens": [
            "called",
            "when",
            "an",
            "output",
            "buffer",
            "is",
            "successfully",
            "processed"
        ]
    },
    {
        "id": 1472,
        "code": "protected boolean shouldDropOutputBuffer(long earlyUs, long elapsedRealtimeUs) {\n  return isBufferLate(earlyUs);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "buffer",
            "being",
            "processed",
            "should",
            "be",
            "dropped"
        ]
    },
    {
        "id": 1473,
        "code": "protected boolean shouldDropBuffersToKeyframe(long earlyUs, long elapsedRealtimeUs) {\n  return isBufferVeryLate(earlyUs);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "to",
            "drop",
            "all",
            "buffers",
            "from",
            "the",
            "buffer",
            "being",
            "processed",
            "to",
            "the",
            "keyframe",
            "at",
            "or",
            "after",
            "the",
            "current",
            "playback",
            "position",
            "if",
            "possible"
        ]
    },
    {
        "id": 1474,
        "code": "protected boolean shouldForceRenderOutputBuffer(long earlyUs, long elapsedSinceLastRenderUs) {\n  return isBufferLate(earlyUs) && elapsedSinceLastRenderUs > 100000;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "to",
            "force",
            "rendering",
            "an",
            "output",
            "buffer"
        ]
    },
    {
        "id": 1475,
        "code": "protected void skipOutputBuffer(VideoDecoderOutputBuffer outputBuffer) {\n  decoderCounters.skippedOutputBufferCount++;\n  outputBuffer.release();\n}",
        "summary_tokens": [
            "skips",
            "the",
            "specified",
            "output",
            "buffer",
            "and",
            "releases",
            "it"
        ]
    },
    {
        "id": 1476,
        "code": "protected void dropOutputBuffer(VideoDecoderOutputBuffer outputBuffer) {\n  updateDroppedBufferCounters(\n       0,  1);\n  outputBuffer.release();\n}",
        "summary_tokens": [
            "drops",
            "the",
            "specified",
            "output",
            "buffer",
            "and",
            "releases",
            "it"
        ]
    },
    {
        "id": 1477,
        "code": "protected boolean maybeDropBuffersToKeyframe(long positionUs) throws ExoPlaybackException {\n  int droppedSourceBufferCount = skipSource(positionUs);\n  if (droppedSourceBufferCount == 0) {\n    return false;\n  }\n  decoderCounters.droppedToKeyframeCount++;\n    \n    \n  updateDroppedBufferCounters(\n      droppedSourceBufferCount,  buffersInCodecCount);\n  flushDecoder();\n  return true;\n}",
        "summary_tokens": [
            "drops",
            "frames",
            "from",
            "the",
            "current",
            "output",
            "buffer",
            "to",
            "the",
            "next",
            "keyframe",
            "at",
            "or",
            "before",
            "the",
            "playback",
            "position"
        ]
    },
    {
        "id": 1478,
        "code": "protected void updateDroppedBufferCounters(\n    int droppedInputBufferCount, int droppedDecoderBufferCount) {\n  decoderCounters.droppedInputBufferCount += droppedInputBufferCount;\n  int totalDroppedBufferCount = droppedInputBufferCount + droppedDecoderBufferCount;\n  decoderCounters.droppedBufferCount += totalDroppedBufferCount;\n  droppedFrames += totalDroppedBufferCount;\n  consecutiveDroppedFrameCount += totalDroppedBufferCount;\n  decoderCounters.maxConsecutiveDroppedBufferCount =\n      max(consecutiveDroppedFrameCount, decoderCounters.maxConsecutiveDroppedBufferCount);\n  if (maxDroppedFramesToNotify > 0 && droppedFrames >= maxDroppedFramesToNotify) {\n    maybeNotifyDroppedFrames();\n  }\n}",
        "summary_tokens": [
            "updates",
            "local",
            "counters",
            "and",
            "decoder",
            "counters",
            "to",
            "reflect",
            "that",
            "buffers",
            "were",
            "dropped"
        ]
    },
    {
        "id": 1479,
        "code": "protected void renderOutputBuffer(\n    VideoDecoderOutputBuffer outputBuffer, long presentationTimeUs, Format outputFormat)\n    throws DecoderException {\n  if (frameMetadataListener != null) {\n    frameMetadataListener.onVideoFrameAboutToBeRendered(\n        presentationTimeUs, System.nanoTime(), outputFormat,  null);\n  }\n  lastRenderTimeUs = Util.msToUs(SystemClock.elapsedRealtime() * 1000);\n  int bufferMode = outputBuffer.mode;\n  boolean renderSurface = bufferMode == C.VIDEO_OUTPUT_MODE_SURFACE_YUV && outputSurface != null;\n  boolean renderYuv = bufferMode == C.VIDEO_OUTPUT_MODE_YUV && outputBufferRenderer != null;\n  if (!renderYuv && !renderSurface) {\n    dropOutputBuffer(outputBuffer);\n  } else {\n    maybeNotifyVideoSizeChanged(outputBuffer.width, outputBuffer.height);\n    if (renderYuv) {\n      outputBufferRenderer.setOutputBuffer(outputBuffer);\n    } else {\n      renderOutputBufferToSurface(outputBuffer, outputSurface);\n    }\n    consecutiveDroppedFrameCount = 0;\n    decoderCounters.renderedOutputBufferCount++;\n    maybeNotifyRenderedFirstFrame();\n  }\n}",
        "summary_tokens": [
            "renders",
            "the",
            "specified",
            "output",
            "buffer"
        ]
    },
    {
        "id": 1480,
        "code": "protected final void setOutput(@Nullable Object output) {\n  if (output instanceof Surface) {\n    outputSurface = (Surface) output;\n    outputBufferRenderer = null;\n    outputMode = C.VIDEO_OUTPUT_MODE_SURFACE_YUV;\n  } else if (output instanceof VideoDecoderOutputBufferRenderer) {\n    outputSurface = null;\n    outputBufferRenderer = (VideoDecoderOutputBufferRenderer) output;\n    outputMode = C.VIDEO_OUTPUT_MODE_YUV;\n  } else {\n      \n    output = null;\n    outputSurface = null;\n    outputBufferRenderer = null;\n    outputMode = C.VIDEO_OUTPUT_MODE_NONE;\n  }\n  if (this.output != output) {\n    this.output = output;\n    if (output != null) {\n      if (decoder != null) {\n        setDecoderOutputMode(outputMode);\n      }\n      onOutputChanged();\n    } else {\n        \n        \n      onOutputRemoved();\n    }\n  } else if (output != null) {\n      \n    onOutputReset();\n  }\n}",
        "summary_tokens": [
            "sets",
            "the",
            "video",
            "output"
        ]
    },
    {
        "id": 1481,
        "code": "protected DecoderReuseEvaluation canReuseDecoder(\n    String decoderName, Format oldFormat, Format newFormat) {\n  return new DecoderReuseEvaluation(\n      decoderName, oldFormat, newFormat, REUSE_RESULT_NO, DISCARD_REASON_REUSE_NOT_IMPLEMENTED);\n}",
        "summary_tokens": [
            "evaluates",
            "whether",
            "the",
            "existing",
            "decoder",
            "can",
            "be",
            "reused",
            "for",
            "a",
            "new",
            "format"
        ]
    },
    {
        "id": 1482,
        "code": "private boolean drainOutputBuffer(long positionUs, long elapsedRealtimeUs)\n    throws ExoPlaybackException, DecoderException {\n  if (outputBuffer == null) {\n    outputBuffer = decoder.dequeueOutputBuffer();\n    if (outputBuffer == null) {\n      return false;\n    }\n    decoderCounters.skippedOutputBufferCount += outputBuffer.skippedOutputBufferCount;\n    buffersInCodecCount -= outputBuffer.skippedOutputBufferCount;\n  }\n\n  if (outputBuffer.isEndOfStream()) {\n    if (decoderReinitializationState == REINITIALIZATION_STATE_WAIT_END_OF_STREAM) {\n        \n      releaseDecoder();\n      maybeInitDecoder();\n    } else {\n      outputBuffer.release();\n      outputBuffer = null;\n      outputStreamEnded = true;\n    }\n    return false;\n  }\n\n  boolean processedOutputBuffer = processOutputBuffer(positionUs, elapsedRealtimeUs);\n  if (processedOutputBuffer) {\n    onProcessedOutputBuffer(outputBuffer.timeUs);\n    outputBuffer = null;\n  }\n  return processedOutputBuffer;\n}",
        "summary_tokens": [
            "attempts",
            "to",
            "dequeue",
            "an",
            "output",
            "buffer",
            "from",
            "the",
            "decoder",
            "and",
            "if",
            "successful",
            "passes",
            "it",
            "to",
            "process",
            "output",
            "buffer",
            "long",
            "long"
        ]
    },
    {
        "id": 1483,
        "code": "private boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs)\n    throws ExoPlaybackException, DecoderException {\n  if (initialPositionUs == C.TIME_UNSET) {\n    initialPositionUs = positionUs;\n  }\n\n  long earlyUs = outputBuffer.timeUs - positionUs;\n  if (!hasOutput()) {\n      \n    if (isBufferLate(earlyUs)) {\n      skipOutputBuffer(outputBuffer);\n      return true;\n    }\n    return false;\n  }\n\n  long presentationTimeUs = outputBuffer.timeUs - outputStreamOffsetUs;\n  Format format = formatQueue.pollFloor(presentationTimeUs);\n  if (format != null) {\n    outputFormat = format;\n  }\n\n  long elapsedRealtimeNowUs = SystemClock.elapsedRealtime() * 1000;\n  long elapsedSinceLastRenderUs = elapsedRealtimeNowUs - lastRenderTimeUs;\n  boolean isStarted = getState() == STATE_STARTED;\n  boolean shouldRenderFirstFrame =\n      !renderedFirstFrameAfterEnable\n          ? (isStarted || mayRenderFirstFrameAfterEnableIfNotStarted)\n          : !renderedFirstFrameAfterReset;\n    \n  if (shouldRenderFirstFrame\n      || (isStarted && shouldForceRenderOutputBuffer(earlyUs, elapsedSinceLastRenderUs))) {\n    renderOutputBuffer(outputBuffer, presentationTimeUs, outputFormat);\n    return true;\n  }\n\n  if (!isStarted || positionUs == initialPositionUs) {\n    return false;\n  }\n\n    \n  if (shouldDropBuffersToKeyframe(earlyUs, elapsedRealtimeUs)\n      && maybeDropBuffersToKeyframe(positionUs)) {\n    return false;\n  } else if (shouldDropOutputBuffer(earlyUs, elapsedRealtimeUs)) {\n    dropOutputBuffer(outputBuffer);\n    return true;\n  }\n\n  if (earlyUs < 30000) {\n    renderOutputBuffer(outputBuffer, presentationTimeUs, outputFormat);\n    return true;\n  }\n\n  return false;\n}",
        "summary_tokens": [
            "processes",
            "output",
            "buffer",
            "by",
            "rendering",
            "it",
            "skipping",
            "it",
            "or",
            "doing",
            "nothing",
            "and",
            "returns",
            "whether",
            "it",
            "may",
            "be",
            "possible",
            "to",
            "process",
            "another",
            "output",
            "buffer"
        ]
    },
    {
        "id": 1484,
        "code": "public void onNextFrame(long framePresentationTimeNs) {\n  currentMatcher.onNextFrame(framePresentationTimeNs);\n  if (currentMatcher.isSynced() && !switchToCandidateMatcherWhenSynced) {\n    candidateMatcherActive = false;\n  } else if (lastFramePresentationTimeNs != C.TIME_UNSET) {\n    if (!candidateMatcherActive || candidateMatcher.isLastFrameOutlier()) {\n        \n        \n      candidateMatcher.reset();\n      candidateMatcher.onNextFrame(lastFramePresentationTimeNs);\n    }\n    candidateMatcherActive = true;\n    candidateMatcher.onNextFrame(framePresentationTimeNs);\n  }\n  if (candidateMatcherActive && candidateMatcher.isSynced()) {\n      \n      \n    Matcher previousMatcher = currentMatcher;\n    currentMatcher = candidateMatcher;\n    candidateMatcher = previousMatcher;\n    candidateMatcherActive = false;\n    switchToCandidateMatcherWhenSynced = false;\n  }\n  lastFramePresentationTimeNs = framePresentationTimeNs;\n  framesWithoutSyncCount = currentMatcher.isSynced() ? 0 : framesWithoutSyncCount + 1;\n}",
        "summary_tokens": [
            "called",
            "with",
            "each",
            "frame",
            "presentation",
            "timestamp"
        ]
    },
    {
        "id": 1485,
        "code": "public boolean isSynced() {\n  return currentMatcher.isSynced();\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "estimator",
            "has",
            "detected",
            "a",
            "fixed",
            "frame",
            "rate"
        ]
    },
    {
        "id": 1486,
        "code": "public int getFramesWithoutSyncCount() {\n  return framesWithoutSyncCount;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "frames",
            "since",
            "the",
            "estimator",
            "last",
            "detected",
            "a",
            "fixed",
            "frame",
            "rate"
        ]
    },
    {
        "id": 1487,
        "code": "public long getMatchingFrameDurationSumNs() {\n  return isSynced() ? currentMatcher.getMatchingFrameDurationSumNs() : C.TIME_UNSET;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "sum",
            "of",
            "all",
            "frame",
            "durations",
            "used",
            "to",
            "calculate",
            "the",
            "current",
            "fixed",
            "frame",
            "rate",
            "estimate",
            "or",
            "c",
            "time",
            "unset",
            "if",
            "is",
            "synced",
            "is",
            "false"
        ]
    },
    {
        "id": 1488,
        "code": "public long getFrameDurationNs() {\n  return isSynced() ? currentMatcher.getFrameDurationNs() : C.TIME_UNSET;\n}",
        "summary_tokens": [
            "the",
            "currently",
            "detected",
            "fixed",
            "frame",
            "duration",
            "estimate",
            "in",
            "nanoseconds",
            "or",
            "c",
            "time",
            "unset",
            "if",
            "is",
            "synced",
            "is",
            "false"
        ]
    },
    {
        "id": 1489,
        "code": "public float getFrameRate() {\n  return isSynced()\n      ? (float) ((double) C.NANOS_PER_SECOND / currentMatcher.getFrameDurationNs())\n      : Format.NO_VALUE;\n}",
        "summary_tokens": [
            "the",
            "currently",
            "detected",
            "fixed",
            "frame",
            "rate",
            "estimate",
            "or",
            "format",
            "no",
            "value",
            "if",
            "is",
            "synced",
            "is",
            "false"
        ]
    },
    {
        "id": 1490,
        "code": "private static List<MediaCodecInfo> getDecoderInfos(\n    MediaCodecSelector mediaCodecSelector,\n    Format format,\n    boolean requiresSecureDecoder,\n    boolean requiresTunnelingDecoder)\n    throws DecoderQueryException {\n  @Nullable String mimeType = format.sampleMimeType;\n  if (mimeType == null) {\n    return ImmutableList.of();\n  }\n  List<MediaCodecInfo> decoderInfos =\n      mediaCodecSelector.getDecoderInfos(\n          mimeType, requiresSecureDecoder, requiresTunnelingDecoder);\n  @Nullable String alternativeMimeType = MediaCodecUtil.getAlternativeCodecMimeType(format);\n  if (alternativeMimeType == null) {\n    return ImmutableList.copyOf(decoderInfos);\n  }\n  List<MediaCodecInfo> alternativeDecoderInfos =\n      mediaCodecSelector.getDecoderInfos(\n          alternativeMimeType, requiresSecureDecoder, requiresTunnelingDecoder);\n  return ImmutableList.<MediaCodecInfo>builder()\n      .addAll(decoderInfos)\n      .addAll(alternativeDecoderInfos)\n      .build();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "list",
            "of",
            "decoders",
            "that",
            "can",
            "decode",
            "media",
            "in",
            "the",
            "specified",
            "format",
            "in",
            "the",
            "priority",
            "order",
            "specified",
            "by",
            "the",
            "media",
            "codec",
            "selector"
        ]
    },
    {
        "id": 1491,
        "code": "public static int getCodecMaxInputSize(MediaCodecInfo codecInfo, Format format) {\n  int width = format.width;\n  int height = format.height;\n  if (width == Format.NO_VALUE || height == Format.NO_VALUE) {\n      \n    return Format.NO_VALUE;\n  }\n\n  String sampleMimeType = format.sampleMimeType;\n  if (MimeTypes.VIDEO_DOLBY_VISION.equals(sampleMimeType)) {\n      \n      \n      \n      \n      \n    sampleMimeType = MimeTypes.VIDEO_H265;\n    @Nullable\n    Pair<Integer, Integer> codecProfileAndLevel = MediaCodecUtil.getCodecProfileAndLevel(format);\n    if (codecProfileAndLevel != null) {\n      int profile = codecProfileAndLevel.first;\n      if (profile == CodecProfileLevel.DolbyVisionProfileDvavSe\n          || profile == CodecProfileLevel.DolbyVisionProfileDvavPer\n          || profile == CodecProfileLevel.DolbyVisionProfileDvavPen) {\n        sampleMimeType = MimeTypes.VIDEO_H264;\n      }\n    }\n  }\n\n    \n  int maxPixels;\n  int minCompressionRatio;\n  switch (sampleMimeType) {\n    case MimeTypes.VIDEO_H263:\n    case MimeTypes.VIDEO_MP4V:\n      maxPixels = width * height;\n      minCompressionRatio = 2;\n      break;\n    case MimeTypes.VIDEO_H264:\n      if (\"BRAVIA 4K 2015\".equals(Util.MODEL) \n          || (\"Amazon\".equals(Util.MANUFACTURER)\n              && (\"KFSOWI\".equals(Util.MODEL) \n                  || (\"AFTS\".equals(Util.MODEL) && codecInfo.secure)))) { \n          \n          \n        return Format.NO_VALUE;\n      }\n        \n      maxPixels = Util.ceilDivide(width, 16) * Util.ceilDivide(height, 16) * 16 * 16;\n      minCompressionRatio = 2;\n      break;\n    case MimeTypes.VIDEO_AV1:\n        \n    case MimeTypes.VIDEO_VP8:\n        \n      maxPixels = width * height;\n      minCompressionRatio = 2;\n      break;\n    case MimeTypes.VIDEO_H265:\n    case MimeTypes.VIDEO_VP9:\n      maxPixels = width * height;\n      minCompressionRatio = 4;\n      break;\n    default:\n        \n      return Format.NO_VALUE;\n  }\n    \n  return (maxPixels * 3) / (2 * minCompressionRatio);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "maximum",
            "input",
            "size",
            "for",
            "a",
            "given",
            "codec",
            "and",
            "format"
        ]
    },
    {
        "id": 1492,
        "code": "protected void onQueueInputBuffer(DecoderInputBuffer buffer) throws ExoPlaybackException {\n    \n    \n  if (!tunneling) {\n    buffersInCodecCount++;\n  }\n  if (Util.SDK_INT < 23 && tunneling) {\n      \n      \n    onProcessedTunneledBuffer(buffer.timeUs);\n  }\n}",
        "summary_tokens": [
            "called",
            "immediately",
            "before",
            "an",
            "input",
            "buffer",
            "is",
            "queued",
            "into",
            "the",
            "codec"
        ]
    },
    {
        "id": 1493,
        "code": "protected void onProcessedTunneledBuffer(long presentationTimeUs) throws ExoPlaybackException {\n  updateOutputFormatForTime(presentationTimeUs);\n  maybeNotifyVideoSizeChanged();\n  decoderCounters.renderedOutputBufferCount++;\n  maybeNotifyRenderedFirstFrame();\n  onProcessedOutputBuffer(presentationTimeUs);\n}",
        "summary_tokens": [
            "called",
            "when",
            "a",
            "buffer",
            "was",
            "processed",
            "in",
            "tunneling",
            "mode"
        ]
    },
    {
        "id": 1494,
        "code": "private void onProcessedTunneledEndOfStream() {\n  setPendingOutputEndOfStream();\n}",
        "summary_tokens": [
            "called",
            "when",
            "a",
            "output",
            "eos",
            "was",
            "received",
            "in",
            "tunneling",
            "mode"
        ]
    },
    {
        "id": 1495,
        "code": "protected boolean shouldDropOutputBuffer(\n    long earlyUs, long elapsedRealtimeUs, boolean isLastBuffer) {\n  return isBufferLate(earlyUs) && !isLastBuffer;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "buffer",
            "being",
            "processed",
            "should",
            "be",
            "dropped"
        ]
    },
    {
        "id": 1496,
        "code": "protected boolean shouldDropBuffersToKeyframe(\n    long earlyUs, long elapsedRealtimeUs, boolean isLastBuffer) {\n  return isBufferVeryLate(earlyUs) && !isLastBuffer;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "to",
            "drop",
            "all",
            "buffers",
            "from",
            "the",
            "buffer",
            "being",
            "processed",
            "to",
            "the",
            "keyframe",
            "at",
            "or",
            "after",
            "the",
            "current",
            "playback",
            "position",
            "if",
            "possible"
        ]
    },
    {
        "id": 1497,
        "code": "protected boolean shouldForceRenderOutputBuffer(long earlyUs, long elapsedSinceLastRenderUs) {\n    \n  return isBufferLate(earlyUs) && elapsedSinceLastRenderUs > 100000;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "to",
            "force",
            "rendering",
            "an",
            "output",
            "buffer"
        ]
    },
    {
        "id": 1498,
        "code": "protected void skipOutputBuffer(MediaCodecAdapter codec, int index, long presentationTimeUs) {\n  TraceUtil.beginSection(\"skipVideoBuffer\");\n  codec.releaseOutputBuffer(index, false);\n  TraceUtil.endSection();\n  decoderCounters.skippedOutputBufferCount++;\n}",
        "summary_tokens": [
            "skips",
            "the",
            "output",
            "buffer",
            "with",
            "the",
            "specified",
            "index"
        ]
    },
    {
        "id": 1499,
        "code": "protected void dropOutputBuffer(MediaCodecAdapter codec, int index, long presentationTimeUs) {\n  TraceUtil.beginSection(\"dropVideoBuffer\");\n  codec.releaseOutputBuffer(index, false);\n  TraceUtil.endSection();\n  updateDroppedBufferCounters(\n       0,  1);\n}",
        "summary_tokens": [
            "drops",
            "the",
            "output",
            "buffer",
            "with",
            "the",
            "specified",
            "index"
        ]
    },
    {
        "id": 1500,
        "code": "protected boolean maybeDropBuffersToKeyframe(\n    long positionUs, boolean treatDroppedBuffersAsSkipped) throws ExoPlaybackException {\n  int droppedSourceBufferCount = skipSource(positionUs);\n  if (droppedSourceBufferCount == 0) {\n    return false;\n  }\n    \n    \n  if (treatDroppedBuffersAsSkipped) {\n    decoderCounters.skippedInputBufferCount += droppedSourceBufferCount;\n    decoderCounters.skippedOutputBufferCount += buffersInCodecCount;\n  } else {\n    decoderCounters.droppedToKeyframeCount++;\n    updateDroppedBufferCounters(\n        droppedSourceBufferCount,  buffersInCodecCount);\n  }\n  flushOrReinitializeCodec();\n  return true;\n}",
        "summary_tokens": [
            "drops",
            "frames",
            "from",
            "the",
            "current",
            "output",
            "buffer",
            "to",
            "the",
            "next",
            "keyframe",
            "at",
            "or",
            "before",
            "the",
            "playback",
            "position"
        ]
    },
    {
        "id": 1501,
        "code": "protected void updateDroppedBufferCounters(\n    int droppedInputBufferCount, int droppedDecoderBufferCount) {\n  decoderCounters.droppedInputBufferCount += droppedInputBufferCount;\n  int totalDroppedBufferCount = droppedInputBufferCount + droppedDecoderBufferCount;\n  decoderCounters.droppedBufferCount += totalDroppedBufferCount;\n  droppedFrames += totalDroppedBufferCount;\n  consecutiveDroppedFrameCount += totalDroppedBufferCount;\n  decoderCounters.maxConsecutiveDroppedBufferCount =\n      max(consecutiveDroppedFrameCount, decoderCounters.maxConsecutiveDroppedBufferCount);\n  if (maxDroppedFramesToNotify > 0 && droppedFrames >= maxDroppedFramesToNotify) {\n    maybeNotifyDroppedFrames();\n  }\n}",
        "summary_tokens": [
            "updates",
            "local",
            "counters",
            "and",
            "decoder",
            "counters",
            "to",
            "reflect",
            "that",
            "buffers",
            "were",
            "dropped"
        ]
    },
    {
        "id": 1502,
        "code": "protected void updateVideoFrameProcessingOffsetCounters(long processingOffsetUs) {\n  decoderCounters.addVideoFrameProcessingOffset(processingOffsetUs);\n  totalVideoFrameProcessingOffsetUs += processingOffsetUs;\n  videoFrameProcessingOffsetCount++;\n}",
        "summary_tokens": [
            "updates",
            "local",
            "counters",
            "and",
            "decoder",
            "counters",
            "with",
            "a",
            "new",
            "video",
            "frame",
            "processing",
            "offset"
        ]
    },
    {
        "id": 1503,
        "code": "protected void renderOutputBuffer(MediaCodecAdapter codec, int index, long presentationTimeUs) {\n  maybeNotifyVideoSizeChanged();\n  TraceUtil.beginSection(\"releaseOutputBuffer\");\n  codec.releaseOutputBuffer(index, true);\n  TraceUtil.endSection();\n  lastRenderRealtimeUs = SystemClock.elapsedRealtime() * 1000;\n  decoderCounters.renderedOutputBufferCount++;\n  consecutiveDroppedFrameCount = 0;\n  maybeNotifyRenderedFirstFrame();\n}",
        "summary_tokens": [
            "renders",
            "the",
            "output",
            "buffer",
            "with",
            "the",
            "specified",
            "index"
        ]
    },
    {
        "id": 1504,
        "code": "protected void renderOutputBufferV21(\n    MediaCodecAdapter codec, int index, long presentationTimeUs, long releaseTimeNs) {\n  maybeNotifyVideoSizeChanged();\n  TraceUtil.beginSection(\"releaseOutputBuffer\");\n  codec.releaseOutputBuffer(index, releaseTimeNs);\n  TraceUtil.endSection();\n  lastRenderRealtimeUs = SystemClock.elapsedRealtime() * 1000;\n  decoderCounters.renderedOutputBufferCount++;\n  consecutiveDroppedFrameCount = 0;\n  maybeNotifyRenderedFirstFrame();\n}",
        "summary_tokens": [
            "renders",
            "the",
            "output",
            "buffer",
            "with",
            "the",
            "specified",
            "index"
        ]
    },
    {
        "id": 1505,
        "code": "protected MediaFormat getMediaFormat(\n    Format format,\n    String codecMimeType,\n    CodecMaxValues codecMaxValues,\n    float codecOperatingRate,\n    boolean deviceNeedsNoPostProcessWorkaround,\n    int tunnelingAudioSessionId) {\n  MediaFormat mediaFormat = new MediaFormat();\n    \n  mediaFormat.setString(MediaFormat.KEY_MIME, codecMimeType);\n  mediaFormat.setInteger(MediaFormat.KEY_WIDTH, format.width);\n  mediaFormat.setInteger(MediaFormat.KEY_HEIGHT, format.height);\n  MediaFormatUtil.setCsdBuffers(mediaFormat, format.initializationData);\n    \n  MediaFormatUtil.maybeSetFloat(mediaFormat, MediaFormat.KEY_FRAME_RATE, format.frameRate);\n  MediaFormatUtil.maybeSetInteger(mediaFormat, MediaFormat.KEY_ROTATION, format.rotationDegrees);\n  MediaFormatUtil.maybeSetColorInfo(mediaFormat, format.colorInfo);\n  if (MimeTypes.VIDEO_DOLBY_VISION.equals(format.sampleMimeType)) {\n      \n      \n    Pair<Integer, Integer> codecProfileAndLevel = MediaCodecUtil.getCodecProfileAndLevel(format);\n    if (codecProfileAndLevel != null) {\n      MediaFormatUtil.maybeSetInteger(\n          mediaFormat, MediaFormat.KEY_PROFILE, codecProfileAndLevel.first);\n    }\n  }\n    \n  mediaFormat.setInteger(MediaFormat.KEY_MAX_WIDTH, codecMaxValues.width);\n  mediaFormat.setInteger(MediaFormat.KEY_MAX_HEIGHT, codecMaxValues.height);\n  MediaFormatUtil.maybeSetInteger(\n      mediaFormat, MediaFormat.KEY_MAX_INPUT_SIZE, codecMaxValues.inputSize);\n    \n  if (Util.SDK_INT >= 23) {\n    mediaFormat.setInteger(MediaFormat.KEY_PRIORITY, 0 );\n    if (codecOperatingRate != CODEC_OPERATING_RATE_UNSET) {\n      mediaFormat.setFloat(MediaFormat.KEY_OPERATING_RATE, codecOperatingRate);\n    }\n  }\n  if (deviceNeedsNoPostProcessWorkaround) {\n    mediaFormat.setInteger(\"no-post-process\", 1);\n    mediaFormat.setInteger(\"auto-frc\", 0);\n  }\n  if (tunnelingAudioSessionId != C.AUDIO_SESSION_ID_UNSET) {\n    configureTunnelingV21(mediaFormat, tunnelingAudioSessionId);\n  }\n  return mediaFormat;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "framework",
            "media",
            "format",
            "that",
            "should",
            "be",
            "used",
            "to",
            "configure",
            "the",
            "decoder"
        ]
    },
    {
        "id": 1506,
        "code": "protected CodecMaxValues getCodecMaxValues(\n    MediaCodecInfo codecInfo, Format format, Format[] streamFormats) {\n  int maxWidth = format.width;\n  int maxHeight = format.height;\n  int maxInputSize = getMaxInputSize(codecInfo, format);\n  if (streamFormats.length == 1) {\n      \n      \n    if (maxInputSize != Format.NO_VALUE) {\n      int codecMaxInputSize = getCodecMaxInputSize(codecInfo, format);\n      if (codecMaxInputSize != Format.NO_VALUE) {\n          \n          \n          \n        int scaledMaxInputSize =\n            (int) (maxInputSize * INITIAL_FORMAT_MAX_INPUT_SIZE_SCALE_FACTOR);\n          \n        maxInputSize = min(scaledMaxInputSize, codecMaxInputSize);\n      }\n    }\n    return new CodecMaxValues(maxWidth, maxHeight, maxInputSize);\n  }\n  boolean haveUnknownDimensions = false;\n  for (Format streamFormat : streamFormats) {\n    if (format.colorInfo != null && streamFormat.colorInfo == null) {\n        \n        \n      streamFormat = streamFormat.buildUpon().setColorInfo(format.colorInfo).build();\n    }\n    if (codecInfo.canReuseCodec(format, streamFormat).result != REUSE_RESULT_NO) {\n      haveUnknownDimensions |=\n          (streamFormat.width == Format.NO_VALUE || streamFormat.height == Format.NO_VALUE);\n      maxWidth = max(maxWidth, streamFormat.width);\n      maxHeight = max(maxHeight, streamFormat.height);\n      maxInputSize = max(maxInputSize, getMaxInputSize(codecInfo, streamFormat));\n    }\n  }\n  if (haveUnknownDimensions) {\n    Log.w(TAG, \"Resolutions unknown. Codec max resolution: \" + maxWidth + \"x\" + maxHeight);\n    @Nullable Point codecMaxSize = getCodecMaxSize(codecInfo, format);\n    if (codecMaxSize != null) {\n      maxWidth = max(maxWidth, codecMaxSize.x);\n      maxHeight = max(maxHeight, codecMaxSize.y);\n      maxInputSize =\n          max(\n              maxInputSize,\n              getCodecMaxInputSize(\n                  codecInfo, format.buildUpon().setWidth(maxWidth).setHeight(maxHeight).build()));\n      Log.w(TAG, \"Codec max resolution adjusted to: \" + maxWidth + \"x\" + maxHeight);\n    }\n  }\n  return new CodecMaxValues(maxWidth, maxHeight, maxInputSize);\n}",
        "summary_tokens": [
            "returns",
            "codec",
            "max",
            "values",
            "suitable",
            "for",
            "configuring",
            "a",
            "codec",
            "for",
            "format",
            "in",
            "a",
            "way",
            "that",
            "will",
            "allow",
            "possible",
            "adaptation",
            "to",
            "other",
            "compatible",
            "formats",
            "in",
            "stream",
            "formats"
        ]
    },
    {
        "id": 1507,
        "code": "private static Point getCodecMaxSize(MediaCodecInfo codecInfo, Format format) {\n  boolean isVerticalVideo = format.height > format.width;\n  int formatLongEdgePx = isVerticalVideo ? format.height : format.width;\n  int formatShortEdgePx = isVerticalVideo ? format.width : format.height;\n  float aspectRatio = (float) formatShortEdgePx / formatLongEdgePx;\n  for (int longEdgePx : STANDARD_LONG_EDGE_VIDEO_PX) {\n    int shortEdgePx = (int) (longEdgePx * aspectRatio);\n    if (longEdgePx <= formatLongEdgePx || shortEdgePx <= formatShortEdgePx) {\n        \n      return null;\n    } else if (Util.SDK_INT >= 21) {\n      Point alignedSize =\n          codecInfo.alignVideoSizeV21(\n              isVerticalVideo ? shortEdgePx : longEdgePx,\n              isVerticalVideo ? longEdgePx : shortEdgePx);\n      float frameRate = format.frameRate;\n      if (codecInfo.isVideoSizeAndRateSupportedV21(alignedSize.x, alignedSize.y, frameRate)) {\n        return alignedSize;\n      }\n    } else {\n      try {\n          \n        longEdgePx = Util.ceilDivide(longEdgePx, 16) * 16;\n        shortEdgePx = Util.ceilDivide(shortEdgePx, 16) * 16;\n        if (longEdgePx * shortEdgePx <= MediaCodecUtil.maxH264DecodableFrameSize()) {\n          return new Point(\n              isVerticalVideo ? shortEdgePx : longEdgePx,\n              isVerticalVideo ? longEdgePx : shortEdgePx);\n        }\n      } catch (DecoderQueryException e) {\n          \n        return null;\n      }\n    }\n  }\n  return null;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "maximum",
            "video",
            "size",
            "to",
            "use",
            "when",
            "configuring",
            "a",
            "codec",
            "for",
            "format",
            "in",
            "a",
            "way",
            "that",
            "will",
            "allow",
            "possible",
            "adaptation",
            "to",
            "other",
            "compatible",
            "formats",
            "that",
            "are",
            "expected",
            "to",
            "have",
            "the",
            "same",
            "aspect",
            "ratio",
            "but",
            "whose",
            "sizes",
            "are",
            "unknown"
        ]
    },
    {
        "id": 1508,
        "code": "protected static int getMaxInputSize(MediaCodecInfo codecInfo, Format format) {\n  if (format.maxInputSize != Format.NO_VALUE) {\n      \n      \n    int totalInitializationDataSize = 0;\n    int initializationDataCount = format.initializationData.size();\n    for (int i = 0; i < initializationDataCount; i++) {\n      totalInitializationDataSize += format.initializationData.get(i).length;\n    }\n    return format.maxInputSize + totalInitializationDataSize;\n  } else {\n    return getCodecMaxInputSize(codecInfo, format);\n  }\n}",
        "summary_tokens": [
            "returns",
            "a",
            "maximum",
            "input",
            "buffer",
            "size",
            "for",
            "a",
            "given",
            "media",
            "codec",
            "and",
            "format"
        ]
    },
    {
        "id": 1509,
        "code": "private static boolean deviceNeedsNoPostProcessWorkaround() {\n    \n    \n    \n    \n    \n    \n    \n  return \"NVIDIA\".equals(Util.MANUFACTURER);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "device",
            "is",
            "known",
            "to",
            "do",
            "post",
            "processing",
            "by",
            "default",
            "that",
            "isn",
            "t",
            "compatible",
            "with",
            "exo",
            "player"
        ]
    },
    {
        "id": 1510,
        "code": "protected boolean codecNeedsSetOutputSurfaceWorkaround(String name) {\n  if (name.startsWith(\"OMX.google\")) {\n      \n    return false;\n  }\n  synchronized (MediaCodecVideoRenderer.class) {\n    if (!evaluatedDeviceNeedsSetOutputSurfaceWorkaround) {\n      deviceNeedsSetOutputSurfaceWorkaround = evaluateDeviceNeedsSetOutputSurfaceWorkaround();\n      evaluatedDeviceNeedsSetOutputSurfaceWorkaround = true;\n    }\n  }\n  return deviceNeedsSetOutputSurfaceWorkaround;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "codec",
            "is",
            "known",
            "to",
            "implement",
            "media",
            "codec",
            "set",
            "output",
            "surface",
            "surface",
            "incorrectly"
        ]
    },
    {
        "id": 1511,
        "code": "public static synchronized boolean isSecureSupported(Context context) {\n  if (!secureModeInitialized) {\n    secureMode = getSecureMode(context);\n    secureModeInitialized = true;\n  }\n  return secureMode != SECURE_MODE_NONE;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "device",
            "supports",
            "secure",
            "placeholder",
            "surfaces"
        ]
    },
    {
        "id": 1512,
        "code": "public static PlaceholderSurface newInstanceV17(Context context, boolean secure) {\n  Assertions.checkState(!secure || isSecureSupported(context));\n  PlaceholderSurfaceThread thread = new PlaceholderSurfaceThread();\n  return thread.init(secure ? secureMode : SECURE_MODE_NONE);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "newly",
            "created",
            "placeholder",
            "surface"
        ]
    },
    {
        "id": 1513,
        "code": "public void onStarted() {\n  started = true;\n  resetAdjustment();\n  if (displayHelper != null) {\n    checkNotNull(vsyncSampler).addObserver();\n    displayHelper.register(this::updateDefaultDisplayRefreshRateParams);\n  }\n  updateSurfacePlaybackFrameRate( false);\n}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "renderer",
            "is",
            "started"
        ]
    },
    {
        "id": 1514,
        "code": "public void onSurfaceChanged(@Nullable Surface surface) {\n  if (surface instanceof PlaceholderSurface) {\n      \n    surface = null;\n  }\n  if (this.surface == surface) {\n    return;\n  }\n  clearSurfaceFrameRate();\n  this.surface = surface;\n  updateSurfacePlaybackFrameRate( true);\n}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "renderer",
            "changes",
            "which",
            "surface",
            "it",
            "s",
            "rendering",
            "to",
            "renders",
            "to"
        ]
    },
    {
        "id": 1515,
        "code": "public void onPositionReset() {\n  resetAdjustment();\n}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "renderer",
            "s",
            "position",
            "is",
            "reset"
        ]
    },
    {
        "id": 1516,
        "code": "public void onPlaybackSpeed(float playbackSpeed) {\n  this.playbackSpeed = playbackSpeed;\n  resetAdjustment();\n  updateSurfacePlaybackFrameRate( false);\n}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "renderer",
            "s",
            "playback",
            "speed",
            "changes"
        ]
    },
    {
        "id": 1517,
        "code": "public void onFormatChanged(float formatFrameRate) {\n  this.formatFrameRate = formatFrameRate;\n  frameRateEstimator.reset();\n  updateSurfaceMediaFrameRate();\n}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "renderer",
            "s",
            "output",
            "format",
            "changes"
        ]
    },
    {
        "id": 1518,
        "code": "public void onNextFrame(long framePresentationTimeUs) {\n  if (pendingLastAdjustedFrameIndex != C.INDEX_UNSET) {\n    lastAdjustedFrameIndex = pendingLastAdjustedFrameIndex;\n    lastAdjustedReleaseTimeNs = pendingLastAdjustedReleaseTimeNs;\n  }\n  frameIndex++;\n  frameRateEstimator.onNextFrame(framePresentationTimeUs * 1000);\n  updateSurfaceMediaFrameRate();\n}",
        "summary_tokens": [
            "called",
            "by",
            "the",
            "renderer",
            "for",
            "each",
            "frame",
            "prior",
            "to",
            "it",
            "being",
            "skipped",
            "dropped",
            "or",
            "rendered"
        ]
    },
    {
        "id": 1519,
        "code": "public void onStopped() {\n  started = false;\n  if (displayHelper != null) {\n    displayHelper.unregister();\n    checkNotNull(vsyncSampler).removeObserver();\n  }\n  clearSurfaceFrameRate();\n}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "renderer",
            "is",
            "stopped"
        ]
    },
    {
        "id": 1520,
        "code": "public long adjustReleaseTime(long releaseTimeNs) {\n    \n  long adjustedReleaseTimeNs = releaseTimeNs;\n\n  if (lastAdjustedFrameIndex != C.INDEX_UNSET && frameRateEstimator.isSynced()) {\n    long frameDurationNs = frameRateEstimator.getFrameDurationNs();\n    long candidateAdjustedReleaseTimeNs =\n        lastAdjustedReleaseTimeNs\n            + (long) ((frameDurationNs * (frameIndex - lastAdjustedFrameIndex)) / playbackSpeed);\n    if (adjustmentAllowed(releaseTimeNs, candidateAdjustedReleaseTimeNs)) {\n      adjustedReleaseTimeNs = candidateAdjustedReleaseTimeNs;\n    } else {\n      resetAdjustment();\n    }\n  }\n  pendingLastAdjustedFrameIndex = frameIndex;\n  pendingLastAdjustedReleaseTimeNs = adjustedReleaseTimeNs;\n\n  if (vsyncSampler == null || vsyncDurationNs == C.TIME_UNSET) {\n    return adjustedReleaseTimeNs;\n  }\n  long sampledVsyncTimeNs = vsyncSampler.sampledVsyncTimeNs;\n  if (sampledVsyncTimeNs == C.TIME_UNSET) {\n    return adjustedReleaseTimeNs;\n  }\n    \n  long snappedTimeNs = closestVsync(adjustedReleaseTimeNs, sampledVsyncTimeNs, vsyncDurationNs);\n    \n  return snappedTimeNs - vsyncOffsetNs;\n}",
        "summary_tokens": [
            "adjusts",
            "the",
            "release",
            "timestamp",
            "for",
            "the",
            "next",
            "frame"
        ]
    },
    {
        "id": 1521,
        "code": "private void updateSurfaceMediaFrameRate() {\n  if (Util.SDK_INT < 30 || surface == null) {\n    return;\n  }\n\n  float candidateFrameRate =\n      frameRateEstimator.isSynced() ? frameRateEstimator.getFrameRate() : formatFrameRate;\n  if (candidateFrameRate == surfaceMediaFrameRate) {\n    return;\n  }\n\n    \n    \n  boolean shouldUpdate;\n  if (candidateFrameRate != Format.NO_VALUE && surfaceMediaFrameRate != Format.NO_VALUE) {\n    boolean candidateIsHighConfidence =\n        frameRateEstimator.isSynced()\n            && frameRateEstimator.getMatchingFrameDurationSumNs()\n                >= MINIMUM_MATCHING_FRAME_DURATION_FOR_HIGH_CONFIDENCE_NS;\n    float minimumChangeForUpdate =\n        candidateIsHighConfidence\n            ? MINIMUM_MEDIA_FRAME_RATE_CHANGE_FOR_UPDATE_HIGH_CONFIDENCE\n            : MINIMUM_MEDIA_FRAME_RATE_CHANGE_FOR_UPDATE_LOW_CONFIDENCE;\n    shouldUpdate = Math.abs(candidateFrameRate - surfaceMediaFrameRate) >= minimumChangeForUpdate;\n  } else if (candidateFrameRate != Format.NO_VALUE) {\n    shouldUpdate = true;\n  } else {\n    shouldUpdate =\n        frameRateEstimator.getFramesWithoutSyncCount()\n            >= MINIMUM_FRAMES_WITHOUT_SYNC_TO_CLEAR_SURFACE_FRAME_RATE;\n  }\n\n  if (shouldUpdate) {\n    surfaceMediaFrameRate = candidateFrameRate;\n    updateSurfacePlaybackFrameRate( false);\n  }\n}",
        "summary_tokens": [
            "updates",
            "the",
            "media",
            "frame",
            "rate",
            "that",
            "s",
            "used",
            "to",
            "calculate",
            "the",
            "playback",
            "frame",
            "rate",
            "of",
            "the",
            "current",
            "surface"
        ]
    },
    {
        "id": 1522,
        "code": "private void updateSurfacePlaybackFrameRate(boolean forceUpdate) {\n  if (Util.SDK_INT < 30\n      || surface == null\n      || changeFrameRateStrategy == C.VIDEO_CHANGE_FRAME_RATE_STRATEGY_OFF) {\n    return;\n  }\n\n  float surfacePlaybackFrameRate = 0;\n  if (started && surfaceMediaFrameRate != Format.NO_VALUE) {\n    surfacePlaybackFrameRate = surfaceMediaFrameRate * playbackSpeed;\n  }\n    \n    \n  if (!forceUpdate && this.surfacePlaybackFrameRate == surfacePlaybackFrameRate) {\n    return;\n  }\n  this.surfacePlaybackFrameRate = surfacePlaybackFrameRate;\n  Api30.setSurfaceFrameRate(surface, surfacePlaybackFrameRate);\n}",
        "summary_tokens": [
            "updates",
            "the",
            "playback",
            "frame",
            "rate",
            "of",
            "the",
            "current",
            "surface",
            "based",
            "on",
            "the",
            "playback",
            "speed",
            "frame",
            "rate",
            "of",
            "the",
            "content",
            "and",
            "whether",
            "the",
            "renderer",
            "is",
            "started"
        ]
    },
    {
        "id": 1523,
        "code": "private void clearSurfaceFrameRate() {\n  if (Util.SDK_INT < 30\n      || surface == null\n      || changeFrameRateStrategy == C.VIDEO_CHANGE_FRAME_RATE_STRATEGY_OFF\n      || surfacePlaybackFrameRate == 0) {\n    return;\n  }\n  surfacePlaybackFrameRate = 0;\n  Api30.setSurfaceFrameRate(surface,  0);\n}",
        "summary_tokens": [
            "clears",
            "the",
            "frame",
            "rate",
            "of",
            "the",
            "current",
            "surface"
        ]
    },
    {
        "id": 1524,
        "code": "default void onVideoEnabled(DecoderCounters counters) {}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "renderer",
            "is",
            "enabled"
        ]
    },
    {
        "id": 1525,
        "code": "default void onVideoDecoderInitialized(\n    String decoderName, long initializedTimestampMs, long initializationDurationMs) {}",
        "summary_tokens": [
            "called",
            "when",
            "a",
            "decoder",
            "is",
            "created"
        ]
    },
    {
        "id": 1526,
        "code": "default void onVideoInputFormatChanged(\n    Format format, @Nullable DecoderReuseEvaluation decoderReuseEvaluation) {}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "format",
            "of",
            "the",
            "media",
            "being",
            "consumed",
            "by",
            "the",
            "renderer",
            "changes"
        ]
    },
    {
        "id": 1527,
        "code": "default void onDroppedFrames(int count, long elapsedMs) {}",
        "summary_tokens": [
            "called",
            "to",
            "report",
            "the",
            "number",
            "of",
            "frames",
            "dropped",
            "by",
            "the",
            "renderer"
        ]
    },
    {
        "id": 1528,
        "code": "default void onVideoFrameProcessingOffset(long totalProcessingOffsetUs, int frameCount) {}",
        "summary_tokens": [
            "called",
            "to",
            "report",
            "the",
            "video",
            "processing",
            "offset",
            "of",
            "video",
            "frames",
            "processed",
            "by",
            "the",
            "video",
            "renderer"
        ]
    },
    {
        "id": 1529,
        "code": "default void onVideoSizeChanged(VideoSize videoSize) {}",
        "summary_tokens": [
            "called",
            "before",
            "a",
            "frame",
            "is",
            "rendered",
            "for",
            "the",
            "first",
            "time",
            "since",
            "setting",
            "the",
            "surface",
            "and",
            "each",
            "time",
            "there",
            "s",
            "a",
            "change",
            "in",
            "the",
            "size",
            "rotation",
            "or",
            "pixel",
            "aspect",
            "ratio",
            "of",
            "the",
            "video",
            "being",
            "rendered"
        ]
    },
    {
        "id": 1530,
        "code": "default void onRenderedFirstFrame(Object output, long renderTimeMs) {}",
        "summary_tokens": [
            "called",
            "when",
            "a",
            "frame",
            "is",
            "rendered",
            "for",
            "the",
            "first",
            "time",
            "since",
            "setting",
            "the",
            "output",
            "or",
            "since",
            "the",
            "renderer",
            "was",
            "reset",
            "or",
            "since",
            "the",
            "stream",
            "being",
            "rendered",
            "was",
            "changed"
        ]
    },
    {
        "id": 1531,
        "code": "default void onVideoDecoderReleased(String decoderName) {}",
        "summary_tokens": [
            "called",
            "when",
            "a",
            "decoder",
            "is",
            "released"
        ]
    },
    {
        "id": 1532,
        "code": "default void onVideoDisabled(DecoderCounters counters) {}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "renderer",
            "is",
            "disabled"
        ]
    },
    {
        "id": 1533,
        "code": "default void onVideoCodecError(Exception videoCodecError) {}",
        "summary_tokens": [
            "called",
            "when",
            "a",
            "video",
            "decoder",
            "encounters",
            "an",
            "error"
        ]
    },
    {
        "id": 1534,
        "code": "public void setRotation(long timestampUs, float[] angleAxis) {\n  rotations.add(timestampUs, angleAxis);\n}",
        "summary_tokens": [
            "sets",
            "a",
            "rotation",
            "for",
            "a",
            "given",
            "timestamp"
        ]
    },
    {
        "id": 1535,
        "code": "public void reset() {\n  rotations.clear();\n  recenterMatrixComputed = false;\n}",
        "summary_tokens": [
            "removes",
            "all",
            "of",
            "the",
            "rotations",
            "and",
            "forces",
            "rotations",
            "to",
            "be",
            "recentered"
        ]
    },
    {
        "id": 1536,
        "code": "public boolean pollRotationMatrix(float[] matrix, long timestampUs) {\n  float[] rotation = rotations.pollFloor(timestampUs);\n  if (rotation == null) {\n    return false;\n  }\n    \n  getRotationMatrixFromAngleAxis(rotationMatrix, rotation);\n  if (!recenterMatrixComputed) {\n    computeRecenterMatrix(recenterMatrix, rotationMatrix);\n    recenterMatrixComputed = true;\n  }\n  Matrix.multiplyMM(matrix, 0, recenterMatrix, 0, rotationMatrix, 0);\n  return true;\n}",
        "summary_tokens": [
            "copies",
            "the",
            "rotation",
            "matrix",
            "with",
            "the",
            "greatest",
            "timestamp",
            "which",
            "is",
            "less",
            "than",
            "or",
            "equal",
            "to",
            "the",
            "given",
            "timestamp",
            "to",
            "matrix"
        ]
    },
    {
        "id": 1537,
        "code": "public static void computeRecenterMatrix(float[] recenterMatrix, float[] rotationMatrix) {\n    \n    \n    \n    \n    \n    \n    \n    \n  Matrix.setIdentityM(recenterMatrix, 0);\n  float normRowSqr =\n      rotationMatrix[10] * rotationMatrix[10] + rotationMatrix[8] * rotationMatrix[8];\n  float normRow = (float) Math.sqrt(normRowSqr);\n  recenterMatrix[0] = rotationMatrix[10] / normRow;\n  recenterMatrix[2] = rotationMatrix[8] / normRow;\n  recenterMatrix[8] = -rotationMatrix[8] / normRow;\n  recenterMatrix[10] = rotationMatrix[10] / normRow;\n}",
        "summary_tokens": [
            "computes",
            "a",
            "recentering",
            "matrix",
            "from",
            "the",
            "given",
            "angle",
            "axis",
            "rotation",
            "only",
            "accounting",
            "for",
            "yaw"
        ]
    },
    {
        "id": 1538,
        "code": "public static Projection createEquirectangular(\n    float radius,\n    int latitudes,\n    int longitudes,\n    float verticalFovDegrees,\n    float horizontalFovDegrees,\n    @C.StereoMode int stereoMode) {\n  Assertions.checkArgument(radius > 0);\n  Assertions.checkArgument(latitudes >= 1);\n  Assertions.checkArgument(longitudes >= 1);\n  Assertions.checkArgument(verticalFovDegrees > 0 && verticalFovDegrees <= 180);\n  Assertions.checkArgument(horizontalFovDegrees > 0 && horizontalFovDegrees <= 360);\n\n    \n  float verticalFovRads = (float) Math.toRadians(verticalFovDegrees);\n  float horizontalFovRads = (float) Math.toRadians(horizontalFovDegrees);\n  float quadHeightRads = verticalFovRads / latitudes;\n  float quadWidthRads = horizontalFovRads / longitudes;\n\n    \n  int vertexCount = (2 * (longitudes + 1) + 2) * latitudes;\n    \n  float[] vertexData = new float[vertexCount * POSITION_COORDS_PER_VERTEX];\n  float[] textureData = new float[vertexCount * TEXTURE_COORDS_PER_VERTEX];\n\n    \n    \n  int vOffset = 0; \n  int tOffset = 0; \n    \n  for (int j = 0; j < latitudes; ++j) { \n      \n      \n    float phiLow = quadHeightRads * j - verticalFovRads / 2;\n    float phiHigh = quadHeightRads * (j + 1) - verticalFovRads / 2;\n\n    for (int i = 0; i < longitudes + 1; ++i) { \n      for (int k = 0; k < 2; ++k) { \n          \n        float phi = k == 0 ? phiLow : phiHigh;\n        float theta = quadWidthRads * i + (float) Math.PI - horizontalFovRads / 2;\n\n          \n        vertexData[vOffset++] = -(float) (radius * Math.sin(theta) * Math.cos(phi));\n        vertexData[vOffset++] = (float) (radius * Math.sin(phi));\n        vertexData[vOffset++] = (float) (radius * Math.cos(theta) * Math.cos(phi));\n\n        textureData[tOffset++] = i * quadWidthRads / horizontalFovRads;\n        textureData[tOffset++] = (j + k) * quadHeightRads / verticalFovRads;\n\n          \n        if ((i == 0 && k == 0) || (i == longitudes && k == 1)) {\n          System.arraycopy(\n              vertexData,\n              vOffset - POSITION_COORDS_PER_VERTEX,\n              vertexData,\n              vOffset,\n              POSITION_COORDS_PER_VERTEX);\n          vOffset += POSITION_COORDS_PER_VERTEX;\n          System.arraycopy(\n              textureData,\n              tOffset - TEXTURE_COORDS_PER_VERTEX,\n              textureData,\n              tOffset,\n              TEXTURE_COORDS_PER_VERTEX);\n          tOffset += TEXTURE_COORDS_PER_VERTEX;\n        }\n      }\n        \n    }\n      \n  }\n  SubMesh subMesh =\n      new SubMesh(SubMesh.VIDEO_TEXTURE_ID, vertexData, textureData, DRAW_MODE_TRIANGLES_STRIP);\n  return new Projection(new Mesh(subMesh), stereoMode);\n}",
        "summary_tokens": [
            "generates",
            "an",
            "equirectangular",
            "projection"
        ]
    },
    {
        "id": 1539,
        "code": "private static boolean isProj(ParsableByteArray input) {\n  input.skipBytes(4); \n  int type = input.readInt();\n  input.setPosition(0);\n  return type == TYPE_PROJ;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "the",
            "input",
            "contains",
            "a",
            "proj",
            "box"
        ]
    },
    {
        "id": 1540,
        "code": "private static ArrayList<Mesh> parseRawMshpData(ParsableByteArray input) {\n  ArrayList<Mesh> meshes = new ArrayList<>();\n  int position = input.getPosition();\n  int limit = input.limit();\n  while (position < limit) {\n    int childEnd = position + input.readInt();\n    if (childEnd <= position || childEnd > limit) {\n      return null;\n    }\n    int childAtomType = input.readInt();\n    if (childAtomType == TYPE_MESH) {\n      Mesh mesh = parseMesh(input);\n      if (mesh == null) {\n        return null;\n      }\n      meshes.add(mesh);\n    }\n    position = childEnd;\n    input.setPosition(position);\n  }\n  return meshes;\n}",
        "summary_tokens": [
            "parses",
            "mshp",
            "data",
            "after",
            "the",
            "encoding",
            "four",
            "cc",
            "field"
        ]
    },
    {
        "id": 1541,
        "code": "private static int decodeZigZag(int n) {\n  return (n >> 1) ^ -(n & 1);\n}",
        "summary_tokens": [
            "decodes",
            "zigzag",
            "encoding",
            "as",
            "described",
            "in",
            "https",
            "developers"
        ]
    },
    {
        "id": 1542,
        "code": "public static boolean isSupported(Projection projection) {\n  Projection.Mesh leftMesh = projection.leftMesh;\n  Projection.Mesh rightMesh = projection.rightMesh;\n  return leftMesh.getSubMeshCount() == 1\n      && leftMesh.getSubMesh(0).textureId == Projection.SubMesh.VIDEO_TEXTURE_ID\n      && rightMesh.getSubMeshCount() == 1\n      && rightMesh.getSubMesh(0).textureId == Projection.SubMesh.VIDEO_TEXTURE_ID;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "projection",
            "is",
            "supported"
        ]
    },
    {
        "id": 1543,
        "code": "public void setProjection(Projection projection) {\n  if (!isSupported(projection)) {\n    return;\n  }\n  stereoMode = projection.stereoMode;\n  leftMeshData = new MeshData(projection.leftMesh.getSubMesh(0));\n  rightMeshData =\n      projection.singleMesh ? leftMeshData : new MeshData(projection.rightMesh.getSubMesh(0));\n}",
        "summary_tokens": [
            "sets",
            "a",
            "projection",
            "to",
            "be",
            "used"
        ]
    },
    {
        "id": 1544,
        "code": "public void init() {\n  program = new GlProgram(VERTEX_SHADER, FRAGMENT_SHADER);\n  mvpMatrixHandle = program.getUniformLocation(\"uMvpMatrix\");\n  uTexMatrixHandle = program.getUniformLocation(\"uTexMatrix\");\n  positionHandle = program.getAttributeArrayLocationAndEnable(\"aPosition\");\n  texCoordsHandle = program.getAttributeArrayLocationAndEnable(\"aTexCoords\");\n  textureHandle = program.getUniformLocation(\"uTexture\");\n}",
        "summary_tokens": [
            "initializes",
            "of",
            "the",
            "gl",
            "components"
        ]
    },
    {
        "id": 1545,
        "code": "public void shutdown() {\n  if (program != null) {\n    program.delete();\n  }\n}",
        "summary_tokens": [
            "cleans",
            "up",
            "gl",
            "resources"
        ]
    },
    {
        "id": 1546,
        "code": "public void setDefaultStereoMode(@C.StereoMode int stereoMode) {\n  defaultStereoMode = stereoMode;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "default",
            "stereo",
            "mode"
        ]
    },
    {
        "id": 1547,
        "code": "public void drawFrame(float[] viewProjectionMatrix, boolean rightEye) {\n    \n    \n  GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT);\n  checkGlError();\n\n  if (frameAvailable.compareAndSet(true, false)) {\n    Assertions.checkNotNull(surfaceTexture).updateTexImage();\n    checkGlError();\n    if (resetRotationAtNextFrame.compareAndSet(true, false)) {\n      Matrix.setIdentityM(rotationMatrix, 0);\n    }\n    long lastFrameTimestampNs = surfaceTexture.getTimestamp();\n    Long sampleTimestampUs = sampleTimestampQueue.poll(lastFrameTimestampNs);\n    if (sampleTimestampUs != null) {\n      frameRotationQueue.pollRotationMatrix(rotationMatrix, sampleTimestampUs);\n    }\n    Projection projection = projectionQueue.pollFloor(lastFrameTimestampNs);\n    if (projection != null) {\n      projectionRenderer.setProjection(projection);\n    }\n  }\n  Matrix.multiplyMM(tempMatrix, 0, viewProjectionMatrix, 0, rotationMatrix, 0);\n  projectionRenderer.draw(textureId, tempMatrix, rightEye);\n}",
        "summary_tokens": [
            "draws",
            "the",
            "scene",
            "with",
            "a",
            "given",
            "eye",
            "pose",
            "and",
            "type"
        ]
    },
    {
        "id": 1548,
        "code": "public void shutdown() {\n  projectionRenderer.shutdown();\n}",
        "summary_tokens": [
            "cleans",
            "up",
            "gl",
            "resources"
        ]
    },
    {
        "id": 1549,
        "code": "private void setProjection(\n    @Nullable byte[] projectionData, @C.StereoMode int stereoMode, long timeNs) {\n  byte[] oldProjectionData = lastProjectionData;\n  int oldStereoMode = lastStereoMode;\n  lastProjectionData = projectionData;\n  lastStereoMode = stereoMode == Format.NO_VALUE ? defaultStereoMode : stereoMode;\n  if (oldStereoMode == lastStereoMode && Arrays.equals(oldProjectionData, lastProjectionData)) {\n    return;\n  }\n\n  Projection projectionFromData = null;\n  if (lastProjectionData != null) {\n    projectionFromData = ProjectionDecoder.decode(lastProjectionData, lastStereoMode);\n  }\n  Projection projection =\n      projectionFromData != null && ProjectionRenderer.isSupported(projectionFromData)\n          ? projectionFromData\n          : Projection.createEquirectangular(lastStereoMode);\n  projectionQueue.add(timeNs, projection);\n}",
        "summary_tokens": [
            "sets",
            "projection",
            "data",
            "and",
            "stereo",
            "mode",
            "of",
            "the",
            "media",
            "to",
            "be",
            "played"
        ]
    },
    {
        "id": 1550,
        "code": "public void addVideoSurfaceListener(VideoSurfaceListener listener) {\n  videoSurfaceListeners.add(listener);\n}",
        "summary_tokens": [
            "adds",
            "a",
            "video",
            "surface",
            "listener"
        ]
    },
    {
        "id": 1551,
        "code": "public void removeVideoSurfaceListener(VideoSurfaceListener listener) {\n  videoSurfaceListeners.remove(listener);\n}",
        "summary_tokens": [
            "removes",
            "a",
            "video",
            "surface",
            "listener"
        ]
    },
    {
        "id": 1552,
        "code": "public Surface getVideoSurface() {\n  return surface;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "surface",
            "to",
            "which",
            "video",
            "frames",
            "should",
            "be",
            "rendered",
            "or",
            "null",
            "if",
            "it",
            "has",
            "not",
            "been",
            "created"
        ]
    },
    {
        "id": 1553,
        "code": "public VideoFrameMetadataListener getVideoFrameMetadataListener() {\n  return scene;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "video",
            "frame",
            "metadata",
            "listener",
            "that",
            "should",
            "be",
            "registered",
            "during",
            "playback"
        ]
    },
    {
        "id": 1554,
        "code": "public CameraMotionListener getCameraMotionListener() {\n  return scene;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "camera",
            "motion",
            "listener",
            "that",
            "should",
            "be",
            "registered",
            "during",
            "playback"
        ]
    },
    {
        "id": 1555,
        "code": "public void setDefaultStereoMode(@C.StereoMode int stereoMode) {\n  scene.setDefaultStereoMode(stereoMode);\n}",
        "summary_tokens": [
            "sets",
            "the",
            "default",
            "stereo",
            "mode"
        ]
    },
    {
        "id": 1556,
        "code": "public void setUseSensorRotation(boolean useSensorRotation) {\n  this.useSensorRotation = useSensorRotation;\n  updateOrientationListenerRegistration();\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "to",
            "use",
            "the",
            "orientation",
            "sensor",
            "for",
            "rotation",
            "if",
            "available"
        ]
    },
    {
        "id": 1557,
        "code": "public boolean onTouch(View v, MotionEvent event) {\n  return gestureDetector.onTouchEvent(event);\n}",
        "summary_tokens": [
            "converts",
            "action",
            "move",
            "events",
            "to",
            "pitch",
            "yaw",
            "events",
            "while",
            "compensating",
            "for",
            "device",
            "roll"
        ]
    },
    {
        "id": 1558,
        "code": "public void playEmptyTimeline() throws Exception {\n  Timeline timeline = Timeline.EMPTY;\n  Timeline expectedMaskingTimeline =\n      new MaskingMediaSource.PlaceholderTimeline(FakeMediaSource.FAKE_MEDIA_ITEM);\n  FakeRenderer renderer = new FakeRenderer(C.TRACK_TYPE_UNKNOWN);\n\n  ExoPlayer player = new TestExoPlayerBuilder(context).setRenderers(renderer).build();\n  Player.Listener mockListener = mock(Player.Listener.class);\n  player.addListener(mockListener);\n\n  player.setMediaSource(new FakeMediaSource(timeline, ExoPlayerTestRunner.VIDEO_FORMAT));\n  player.prepare();\n  player.play();\n  runUntilPlaybackState(player, Player.STATE_ENDED);\n\n  InOrder inOrder = inOrder(mockListener);\n  inOrder\n      .verify(mockListener)\n      .onTimelineChanged(\n          argThat(noUid(expectedMaskingTimeline)),\n          eq(Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED));\n  inOrder\n      .verify(mockListener)\n      .onTimelineChanged(\n          argThat(noUid(timeline)), eq(Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE));\n  inOrder.verify(mockListener, never()).onPositionDiscontinuity(anyInt());\n  inOrder.verify(mockListener, never()).onPositionDiscontinuity(any(), any(), anyInt());\n  assertThat(renderer.getFormatsRead()).isEmpty();\n  assertThat(renderer.sampleBufferReadCount).isEqualTo(0);\n  assertThat(renderer.isEnded).isFalse();\n}",
        "summary_tokens": [
            "tests",
            "playback",
            "of",
            "a",
            "source",
            "that",
            "exposes",
            "an",
            "empty",
            "timeline"
        ]
    },
    {
        "id": 1559,
        "code": "public void playSinglePeriodTimeline() throws Exception {\n  Timeline timeline = new FakeTimeline();\n  FakeRenderer renderer = new FakeRenderer(C.TRACK_TYPE_VIDEO);\n  ExoPlayer player = new TestExoPlayerBuilder(context).setRenderers(renderer).build();\n  Player.Listener mockListener = mock(Player.Listener.class);\n  player.addListener(mockListener);\n\n  player.setMediaSource(new FakeMediaSource(timeline, ExoPlayerTestRunner.VIDEO_FORMAT));\n  player.prepare();\n  player.play();\n  runUntilPlaybackState(player, Player.STATE_ENDED);\n\n  InOrder inOrder = Mockito.inOrder(mockListener);\n  inOrder\n      .verify(mockListener)\n      .onTimelineChanged(\n          argThat(noUid(placeholderTimeline)),\n          eq(Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED));\n  inOrder\n      .verify(mockListener)\n      .onTimelineChanged(\n          argThat(noUid(timeline)), eq(Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE));\n  inOrder\n      .verify(mockListener)\n      .onTracksChanged(\n          eq(\n              new Tracks(\n                  ImmutableList.of(\n                      new Tracks.Group(\n                          new TrackGroup(ExoPlayerTestRunner.VIDEO_FORMAT),\n                           false,\n                          new int[] {C.FORMAT_HANDLED},\n                           new boolean[] {true})))));\n  inOrder.verify(mockListener, never()).onPositionDiscontinuity(anyInt());\n  inOrder.verify(mockListener, never()).onPositionDiscontinuity(any(), any(), anyInt());\n  assertThat(renderer.getFormatsRead()).containsExactly(ExoPlayerTestRunner.VIDEO_FORMAT);\n  assertThat(renderer.sampleBufferReadCount).isEqualTo(1);\n  assertThat(renderer.isEnded).isTrue();\n}",
        "summary_tokens": [
            "tests",
            "playback",
            "of",
            "a",
            "source",
            "that",
            "exposes",
            "a",
            "single",
            "period"
        ]
    },
    {
        "id": 1560,
        "code": "public void playMultiPeriodTimeline() throws Exception {\n  Timeline timeline = new FakeTimeline( 3);\n  FakeRenderer renderer = new FakeRenderer(C.TRACK_TYPE_VIDEO);\n  ExoPlayer player = new TestExoPlayerBuilder(context).setRenderers(renderer).build();\n  Player.Listener mockPlayerListener = mock(Player.Listener.class);\n  player.addListener(mockPlayerListener);\n\n  player.setMediaSource(new FakeMediaSource(timeline, ExoPlayerTestRunner.VIDEO_FORMAT));\n  player.prepare();\n  player.play();\n  runUntilPlaybackState(player, Player.STATE_ENDED);\n\n  InOrder inOrder = Mockito.inOrder(mockPlayerListener);\n  inOrder\n      .verify(mockPlayerListener)\n      .onTimelineChanged(\n          argThat(noUid(new FakeMediaSource.InitialTimeline(timeline))),\n          eq(Player.DISCONTINUITY_REASON_AUTO_TRANSITION));\n  inOrder\n      .verify(mockPlayerListener)\n      .onTimelineChanged(\n          argThat(noUid(timeline)), eq(Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE));\n  inOrder\n      .verify(mockPlayerListener, times(2))\n      .onPositionDiscontinuity(any(), any(), eq(Player.DISCONTINUITY_REASON_AUTO_TRANSITION));\n  assertThat(renderer.getFormatsRead())\n      .containsExactly(\n          ExoPlayerTestRunner.VIDEO_FORMAT,\n          ExoPlayerTestRunner.VIDEO_FORMAT,\n          ExoPlayerTestRunner.VIDEO_FORMAT);\n  assertThat(renderer.sampleBufferReadCount).isEqualTo(3);\n  assertThat(renderer.isEnded).isTrue();\n}",
        "summary_tokens": [
            "tests",
            "playback",
            "of",
            "a",
            "source",
            "that",
            "exposes",
            "three",
            "periods"
        ]
    },
    {
        "id": 1561,
        "code": "public void playShortDurationPeriods() throws Exception {\n    \n  Timeline timeline =\n      new FakeTimeline(new TimelineWindowDefinition( 100,  0));\n  FakeRenderer renderer = new FakeRenderer(C.TRACK_TYPE_VIDEO);\n  ExoPlayer player = new TestExoPlayerBuilder(context).setRenderers(renderer).build();\n  Player.Listener mockPlayerListener = mock(Player.Listener.class);\n  player.addListener(mockPlayerListener);\n\n  player.setMediaSource(new FakeMediaSource(timeline, ExoPlayerTestRunner.VIDEO_FORMAT));\n  player.prepare();\n  player.play();\n  runUntilPlaybackState(player, Player.STATE_ENDED);\n\n  InOrder inOrder = inOrder(mockPlayerListener);\n  inOrder\n      .verify(mockPlayerListener)\n      .onTimelineChanged(\n          argThat(noUid(placeholderTimeline)),\n          eq(Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED));\n  inOrder\n      .verify(mockPlayerListener)\n      .onTimelineChanged(\n          argThat(noUid(timeline)), eq(Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE));\n  inOrder\n      .verify(mockPlayerListener, times(99))\n      .onPositionDiscontinuity(any(), any(), eq(Player.DISCONTINUITY_REASON_AUTO_TRANSITION));\n  assertThat(renderer.getFormatsRead()).hasSize(100);\n  assertThat(renderer.sampleBufferReadCount).isEqualTo(100);\n  assertThat(renderer.isEnded).isTrue();\n}",
        "summary_tokens": [
            "tests",
            "playback",
            "of",
            "periods",
            "with",
            "very",
            "short",
            "duration"
        ]
    },
    {
        "id": 1562,
        "code": "public void readAheadToEndDoesNotResetRenderer() throws Exception {\n    \n  TimelineWindowDefinition windowDefinition0 =\n      new TimelineWindowDefinition(\n           1,\n           0,\n           false,\n           false,\n           100_000);\n  TimelineWindowDefinition windowDefinition1 =\n      new TimelineWindowDefinition(\n           1,\n           1,\n           false,\n           false,\n           100_000);\n  TimelineWindowDefinition windowDefinition2 =\n      new TimelineWindowDefinition(\n           1,\n           2,\n           false,\n           false,\n           100_000);\n  Timeline timeline = new FakeTimeline(windowDefinition0, windowDefinition1, windowDefinition2);\n  final FakeRenderer videoRenderer = new FakeRenderer(C.TRACK_TYPE_VIDEO);\n  FakeMediaClockRenderer audioRenderer =\n      new FakeMediaClockRenderer(C.TRACK_TYPE_AUDIO) {\n        @Override\n        public long getPositionUs() {\n            \n            \n            \n            \n          return isCurrentStreamFinal() ? 30 : 0;\n        }\n\n        @Override\n        public void setPlaybackParameters(PlaybackParameters playbackParameters) {}\n\n        @Override\n        public PlaybackParameters getPlaybackParameters() {\n          return PlaybackParameters.DEFAULT;\n        }\n\n        @Override\n        public boolean isEnded() {\n          return videoRenderer.isEnded();\n        }\n      };\n  ExoPlayer player =\n      new TestExoPlayerBuilder(context).setRenderers(videoRenderer, audioRenderer).build();\n  Player.Listener mockPlayerListener = mock(Player.Listener.class);\n  player.addListener(mockPlayerListener);\n\n  player.setMediaSource(\n      new FakeMediaSource(\n          timeline, ExoPlayerTestRunner.VIDEO_FORMAT, ExoPlayerTestRunner.AUDIO_FORMAT));\n  player.prepare();\n  player.play();\n  runUntilPlaybackState(player, Player.STATE_ENDED);\n\n  InOrder inOrder = inOrder(mockPlayerListener);\n  inOrder\n      .verify(mockPlayerListener)\n      .onTimelineChanged(\n          argThat(noUid(new FakeMediaSource.InitialTimeline(timeline))),\n          eq(Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED));\n  inOrder\n      .verify(mockPlayerListener)\n      .onTimelineChanged(\n          argThat(noUid(timeline)), eq(Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE));\n  inOrder\n      .verify(mockPlayerListener, times(2))\n      .onPositionDiscontinuity(any(), any(), eq(Player.DISCONTINUITY_REASON_AUTO_TRANSITION));\n  assertThat(audioRenderer.positionResetCount).isEqualTo(1);\n  assertThat(videoRenderer.isEnded).isTrue();\n  assertThat(audioRenderer.isEnded).isTrue();\n}",
        "summary_tokens": [
            "tests",
            "that",
            "the",
            "player",
            "does",
            "not",
            "unnecessarily",
            "reset",
            "renderers",
            "when",
            "playing",
            "a",
            "multi",
            "period",
            "source"
        ]
    },
    {
        "id": 1563,
        "code": "public void\n    playlistWithMediaWithStartOffsets_andStartOffsetChangesDuringPreparation_appliesCorrectRenderingOffsetToAllPeriods()\n        throws Exception {\n  List<Long> rendererStreamOffsetsUs = new ArrayList<>();\n  List<Long> firstBufferTimesUsWithOffset = new ArrayList<>();\n  FakeRenderer renderer =\n      new FakeRenderer(C.TRACK_TYPE_VIDEO) {\n        boolean pendingFirstBufferTime = false;\n\n        @Override\n        protected void onStreamChanged(Format[] formats, long startPositionUs, long offsetUs) {\n          rendererStreamOffsetsUs.add(offsetUs);\n          pendingFirstBufferTime = true;\n        }\n\n        @Override\n        protected boolean shouldProcessBuffer(long bufferTimeUs, long playbackPositionUs) {\n          if (pendingFirstBufferTime) {\n            firstBufferTimesUsWithOffset.add(bufferTimeUs);\n            pendingFirstBufferTime = false;\n          }\n          return super.shouldProcessBuffer(bufferTimeUs, playbackPositionUs);\n        }\n      };\n  Timeline timelineWithOffsets =\n      new FakeTimeline(\n          new TimelineWindowDefinition(\n               1,\n               new Object(),\n               true,\n               false,\n               false,\n               false,\n              TimelineWindowDefinition.DEFAULT_WINDOW_DURATION_US,\n               4_567_890,\n               1_234_567,\n              AdPlaybackState.NONE));\n  ExoPlayer player = new TestExoPlayerBuilder(context).setRenderers(renderer).build();\n  long firstSampleTimeUs = 4_567_890 + 1_234_567;\n  FakeMediaSource firstMediaSource =\n      new FakeMediaSource(\n           null,\n          DrmSessionManager.DRM_UNSUPPORTED,\n          (unusedFormat, unusedMediaPeriodId) ->\n              ImmutableList.of(\n                  oneByteSample(firstSampleTimeUs, C.BUFFER_FLAG_KEY_FRAME), END_OF_STREAM_ITEM),\n          ExoPlayerTestRunner.VIDEO_FORMAT);\n  FakeMediaSource secondMediaSource =\n      new FakeMediaSource(\n          timelineWithOffsets,\n          DrmSessionManager.DRM_UNSUPPORTED,\n          (unusedFormat, unusedMediaPeriodId) ->\n              ImmutableList.of(\n                  oneByteSample(firstSampleTimeUs, C.BUFFER_FLAG_KEY_FRAME), END_OF_STREAM_ITEM),\n          ExoPlayerTestRunner.VIDEO_FORMAT);\n  player.setMediaSources(ImmutableList.of(firstMediaSource, secondMediaSource));\n\n    \n  player.prepare();\n  player.play();\n  runUntilPendingCommandsAreFullyHandled(player);\n    \n  firstMediaSource.setNewSourceInfo(timelineWithOffsets);\n    \n  runUntilPositionDiscontinuity(player, Player.DISCONTINUITY_REASON_AUTO_TRANSITION);\n  assertThat(player.getCurrentMediaItemIndex()).isEqualTo(1);\n  player.release();\n\n  assertThat(rendererStreamOffsetsUs).hasSize(2);\n  assertThat(firstBufferTimesUsWithOffset).hasSize(2);\n    \n  assertThat(firstBufferTimesUsWithOffset.get(0))\n      .isEqualTo(rendererStreamOffsetsUs.get(0) + firstSampleTimeUs);\n  assertThat(firstBufferTimesUsWithOffset.get(1))\n      .isEqualTo(rendererStreamOffsetsUs.get(1) + firstSampleTimeUs);\n    \n    \n  long periodDurationUs =\n      timelineWithOffsets.getPeriod( 0, new Timeline.Period()).durationUs;\n  assertThat(firstBufferTimesUsWithOffset.get(1))\n      .isEqualTo(rendererStreamOffsetsUs.get(0) + periodDurationUs);\n}",
        "summary_tokens": [
            "this",
            "tests",
            "that",
            "renderer",
            "offsets",
            "and",
            "buffer",
            "times",
            "in",
            "the",
            "renderer",
            "are",
            "set",
            "correctly",
            "even",
            "when",
            "the",
            "sources",
            "have",
            "a",
            "window",
            "to",
            "period",
            "offset",
            "and",
            "a",
            "non",
            "zero",
            "default",
            "start",
            "position"
        ]
    },
    {
        "id": 1564,
        "code": "private static ArgumentMatcher<Timeline> noUid(Timeline timeline) {\n  return argument -> timelinesAreSame(argument, timeline);\n}",
        "summary_tokens": [
            "returns",
            "an",
            "argument",
            "matcher",
            "for",
            "timeline",
            "instances",
            "that",
            "ignores",
            "period",
            "and",
            "window",
            "uids"
        ]
    },
    {
        "id": 1565,
        "code": "public void defaultAnalyticsCollector_overridesAllPlayerListenerMethods() throws Exception {\n  for (Method method : Player.Listener.class.getDeclaredMethods()) {\n    if (method.isSynthetic()) {\n        \n        \n      continue;\n    }\n    assertThat(\n            DefaultAnalyticsCollector.class\n                .getMethod(method.getName(), method.getParameterTypes())\n                .getDeclaringClass())\n        .isEqualTo(DefaultAnalyticsCollector.class);\n  }\n}",
        "summary_tokens": [
            "verify",
            "that",
            "default",
            "analytics",
            "collector",
            "explicitly",
            "overrides",
            "all",
            "player"
        ]
    },
    {
        "id": 1566,
        "code": "private static ByteBuffer createDefaultSilenceBuffer() {\n  return ByteBuffer.allocateDirect(\n          SAMPLE_RATE_44_1 * CHANNEL_COUNT_STEREO * BYTES_PER_FRAME_16_BIT)\n      .order(ByteOrder.nativeOrder());\n}",
        "summary_tokens": [
            "creates",
            "a",
            "one",
            "second",
            "silence",
            "buffer",
            "for",
            "0"
        ]
    },
    {
        "id": 1567,
        "code": "private static long process(\n    SilenceSkippingAudioProcessor processor,\n    InputBufferProvider inputBufferProvider,\n    int inputBufferSize) {\n  int bytesPerFrame = AUDIO_FORMAT.bytesPerFrame;\n  processor.flush();\n  long totalOutputFrames = 0;\n  while (inputBufferProvider.hasRemaining()) {\n    ByteBuffer inputBuffer = inputBufferProvider.getNextInputBuffer(inputBufferSize);\n    while (inputBuffer.hasRemaining()) {\n      processor.queueInput(inputBuffer);\n      ByteBuffer outputBuffer = processor.getOutput();\n      totalOutputFrames += outputBuffer.remaining() / bytesPerFrame;\n      outputBuffer.clear();\n    }\n  }\n  processor.queueEndOfStream();\n  while (!processor.isEnded()) {\n    ByteBuffer outputBuffer = processor.getOutput();\n    totalOutputFrames += outputBuffer.remaining() / bytesPerFrame;\n    outputBuffer.clear();\n  }\n  return totalOutputFrames;\n}",
        "summary_tokens": [
            "processes",
            "the",
            "entire",
            "stream",
            "provided",
            "by",
            "input",
            "buffer",
            "provider",
            "in",
            "chunks",
            "of",
            "input",
            "buffer",
            "size",
            "and",
            "returns",
            "the",
            "total",
            "number",
            "of",
            "output",
            "frames"
        ]
    },
    {
        "id": 1568,
        "code": "private static InputBufferProvider getInputBufferProviderForAlternatingSilenceAndNoise(\n    int silenceDurationMs, int noiseDurationMs, int totalFrameCount) {\n  int sampleRate = AUDIO_FORMAT.sampleRate;\n  int channelCount = AUDIO_FORMAT.channelCount;\n  Pcm16BitAudioBuilder audioBuilder = new Pcm16BitAudioBuilder(channelCount, totalFrameCount);\n  while (!audioBuilder.isFull()) {\n    int silenceDurationFrames = (silenceDurationMs * sampleRate) / 1000;\n    audioBuilder.appendFrames(\n         silenceDurationFrames,  (short) 0);\n    int noiseDurationFrames = (noiseDurationMs * sampleRate) / 1000;\n    audioBuilder.appendFrames(\n         noiseDurationFrames,  Short.MAX_VALUE);\n  }\n  return new InputBufferProvider(audioBuilder.build());\n}",
        "summary_tokens": [
            "returns",
            "an",
            "input",
            "buffer",
            "provider",
            "that",
            "provides",
            "input",
            "buffers",
            "for",
            "a",
            "stream",
            "that",
            "alternates",
            "between",
            "silence",
            "noise",
            "of",
            "the",
            "specified",
            "durations",
            "to",
            "fill",
            "total",
            "frame",
            "count"
        ]
    },
    {
        "id": 1569,
        "code": "private int feedAndDrainAudioProcessorToEndOfTrackOne() throws Exception {\n    \n  ByteBuffer inputBuffer = ByteBuffer.allocate(TRACK_ONE_BUFFER_SIZE_BYTES);\n  int outputSize = 0;\n  while (!trimmingAudioProcessor.isEnded()) {\n    if (inputBuffer.hasRemaining()) {\n      trimmingAudioProcessor.queueInput(inputBuffer);\n      if (!inputBuffer.hasRemaining()) {\n          \n        trimmingAudioProcessor.setTrimFrameCount(\n            TRACK_TWO_TRIM_START_FRAME_COUNT, TRACK_TWO_TRIM_END_FRAME_COUNT);\n        trimmingAudioProcessor.configure(AUDIO_FORMAT);\n        trimmingAudioProcessor.queueEndOfStream();\n      }\n    }\n    ByteBuffer outputBuffer = trimmingAudioProcessor.getOutput();\n    outputSize += outputBuffer.remaining();\n    outputBuffer.clear();\n  }\n  trimmingAudioProcessor.reset();\n  return outputSize;\n}",
        "summary_tokens": [
            "feeds",
            "and",
            "drains",
            "the",
            "audio",
            "processor",
            "up",
            "to",
            "the",
            "end",
            "of",
            "track",
            "one",
            "returning",
            "the",
            "total",
            "output",
            "size",
            "in",
            "bytes"
        ]
    },
    {
        "id": 1570,
        "code": "private static MediaCodec.CodecException createCodecException() throws Exception {\n  Constructor<MediaCodec.CodecException> constructor =\n      MediaCodec.CodecException.class.getDeclaredConstructor(\n          Integer.TYPE, Integer.TYPE, String.class);\n  return constructor.newInstance(\n       0,  0,  \"error from codec\");\n}",
        "summary_tokens": [
            "reflectively",
            "create",
            "a",
            "media",
            "codec"
        ]
    },
    {
        "id": 1571,
        "code": "private static MediaCodec.CodecException createCodecException() throws Exception {\n  Constructor<MediaCodec.CodecException> constructor =\n      MediaCodec.CodecException.class.getDeclaredConstructor(\n          Integer.TYPE, Integer.TYPE, String.class);\n  return constructor.newInstance(\n       0,  0,  \"error from codec\");\n}",
        "summary_tokens": [
            "reflectively",
            "create",
            "a",
            "media",
            "codec"
        ]
    },
    {
        "id": 1572,
        "code": "private static byte[] encodeTxxxId3Frame(String description, String value) {\n  byte[] id3FrameData =\n      Bytes.concat(\n          \"TXXX\".getBytes(ISO_8859_1), \n          TestUtil.createByteArray(0, 0, 0, 0), \n          TestUtil.createByteArray(0, 0), \n          TestUtil.createByteArray(0), \n          description.getBytes(ISO_8859_1),\n          TestUtil.createByteArray(0), \n          value.getBytes(ISO_8859_1),\n          TestUtil.createByteArray(0)); \n  int frameSizeIndex = 7;\n  int frameSize = id3FrameData.length - 10;\n  Assertions.checkArgument(\n      frameSize < 128, \"frameSize must fit in 7 bits to avoid synch-safe encoding: \" + frameSize);\n  id3FrameData[frameSizeIndex] = (byte) frameSize;\n\n  byte[] id3Bytes =\n      Bytes.concat(\n          \"ID3\".getBytes(ISO_8859_1), \n          TestUtil.createByteArray(0x04, 0x00), \n          TestUtil.createByteArray(0), \n          TestUtil.createByteArray(0, 0, 0, 0), \n          id3FrameData);\n  int tagSizeIndex = 9;\n  int tagSize = id3Bytes.length - 10;\n  Assertions.checkArgument(\n      tagSize < 128, \"tagSize must fit in 7 bits to avoid synch-safe encoding: \" + tagSize);\n  id3Bytes[tagSizeIndex] = (byte) tagSize;\n  return id3Bytes;\n}",
        "summary_tokens": [
            "builds",
            "an",
            "id",
            "0",
            "v",
            "0",
            "tag",
            "containing",
            "a",
            "single",
            "user",
            "defined",
            "text",
            "information",
            "frame",
            "id",
            "txxx",
            "with",
            "description",
            "and",
            "value"
        ]
    },
    {
        "id": 1573,
        "code": "public void addDownloadWithStopReason_whilstRemoving_addsStoppedDownload() throws Throwable {\n  postDownloadRequest(ID1);\n  getDownloaderAt(0).finish();\n  assertCompleted(ID1);\n\n  postRemoveRequest(ID1);\n  FakeDownloader downloadRemover = getDownloaderAt(1);\n  downloadRemover.assertRemoveStarted();\n\n    \n  runOnMainThread(\n      () -> downloadManager.addDownload(createDownloadRequest(ID1),  1234));\n\n  downloadRemover.finish();\n  downloadManagerListener.blockUntilIdle();\n\n  assertDownloadIndexSize(1);\n    \n    \n  assertDownloaderCount(2);\n    \n  assertCurrentDownloadCount(1);\n\n  List<Download> downloads = postGetCurrentDownloads();\n  Download download = downloads.get(0);\n  assertThat(download.request.id).isEqualTo(ID1);\n  assertThat(download.state).isEqualTo(Download.STATE_STOPPED);\n  assertThat(download.stopReason).isEqualTo(1234);\n}",
        "summary_tokens": [
            "test",
            "for",
            "https",
            "github"
        ]
    },
    {
        "id": 1574,
        "code": "private static Timeline getClippedTimeline(Timeline timeline, long durationUs)\n    throws IOException {\n  FakeMediaSource fakeMediaSource = new FakeMediaSource(timeline);\n  ClippingMediaSource mediaSource = new ClippingMediaSource(fakeMediaSource, durationUs);\n  return getClippedTimelines(fakeMediaSource, mediaSource)[0];\n}",
        "summary_tokens": [
            "wraps",
            "the",
            "specified",
            "timeline",
            "in",
            "a",
            "clipping",
            "media",
            "source",
            "and",
            "returns",
            "the",
            "clipped",
            "timeline"
        ]
    },
    {
        "id": 1575,
        "code": "private static Timeline[] getClippedTimelines(\n    long startUs,\n    long endUs,\n    boolean allowDynamicUpdates,\n    boolean fromDefaultPosition,\n    Timeline firstTimeline,\n    Timeline... additionalTimelines)\n    throws IOException {\n  FakeMediaSource fakeMediaSource = new FakeMediaSource(firstTimeline);\n  ClippingMediaSource mediaSource =\n      new ClippingMediaSource(\n          fakeMediaSource,\n          startUs,\n          endUs,\n           true,\n          allowDynamicUpdates,\n          fromDefaultPosition);\n  return getClippedTimelines(fakeMediaSource, mediaSource, additionalTimelines);\n}",
        "summary_tokens": [
            "wraps",
            "the",
            "specified",
            "timelines",
            "in",
            "a",
            "clipping",
            "media",
            "source",
            "and",
            "returns",
            "the",
            "clipped",
            "timeline",
            "for",
            "each",
            "timeline",
            "update"
        ]
    },
    {
        "id": 1576,
        "code": "public void getBufferedPositionUsReturnsMinimumLoaderBufferedPosition() {\n  FakeSequenceableLoader loader1 =\n      new FakeSequenceableLoader( 1000,  2000);\n  FakeSequenceableLoader loader2 =\n      new FakeSequenceableLoader( 1001,  2001);\n  CompositeSequenceableLoader compositeSequenceableLoader =\n      new CompositeSequenceableLoader(new SequenceableLoader[] {loader1, loader2});\n  assertThat(compositeSequenceableLoader.getBufferedPositionUs()).isEqualTo(1000);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "composite",
            "sequenceable",
            "loader",
            "get",
            "buffered",
            "position",
            "us",
            "returns",
            "minimum",
            "buffered",
            "position",
            "among",
            "all",
            "sub",
            "loaders"
        ]
    },
    {
        "id": 1577,
        "code": "public void getBufferedPositionUsReturnsMinimumNonEndOfSourceLoaderBufferedPosition() {\n  FakeSequenceableLoader loader1 =\n      new FakeSequenceableLoader( 1000,  2000);\n  FakeSequenceableLoader loader2 =\n      new FakeSequenceableLoader( 1001,  2000);\n  FakeSequenceableLoader loader3 =\n      new FakeSequenceableLoader(\n           C.TIME_END_OF_SOURCE,\n           C.TIME_END_OF_SOURCE);\n  CompositeSequenceableLoader compositeSequenceableLoader =\n      new CompositeSequenceableLoader(new SequenceableLoader[] {loader1, loader2, loader3});\n  assertThat(compositeSequenceableLoader.getBufferedPositionUs()).isEqualTo(1000);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "composite",
            "sequenceable",
            "loader",
            "get",
            "buffered",
            "position",
            "us",
            "returns",
            "minimum",
            "buffered",
            "position",
            "that",
            "is",
            "not",
            "c",
            "time",
            "end",
            "of",
            "source",
            "among",
            "all",
            "sub",
            "loaders"
        ]
    },
    {
        "id": 1578,
        "code": "public void getBufferedPositionUsReturnsEndOfSourceWhenAllLoaderBufferedTillEndOfSource() {\n  FakeSequenceableLoader loader1 =\n      new FakeSequenceableLoader(\n           C.TIME_END_OF_SOURCE,\n           C.TIME_END_OF_SOURCE);\n  FakeSequenceableLoader loader2 =\n      new FakeSequenceableLoader(\n           C.TIME_END_OF_SOURCE,\n           C.TIME_END_OF_SOURCE);\n  CompositeSequenceableLoader compositeSequenceableLoader =\n      new CompositeSequenceableLoader(new SequenceableLoader[] {loader1, loader2});\n  assertThat(compositeSequenceableLoader.getBufferedPositionUs()).isEqualTo(C.TIME_END_OF_SOURCE);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "composite",
            "sequenceable",
            "loader",
            "get",
            "buffered",
            "position",
            "us",
            "returns",
            "c",
            "time",
            "end",
            "of",
            "source",
            "when",
            "all",
            "sub",
            "loaders",
            "have",
            "buffered",
            "till",
            "end",
            "of",
            "source"
        ]
    },
    {
        "id": 1579,
        "code": "public void getNextLoadPositionUsReturnMinimumLoaderNextLoadPositionUs() {\n  FakeSequenceableLoader loader1 =\n      new FakeSequenceableLoader( 1000,  2001);\n  FakeSequenceableLoader loader2 =\n      new FakeSequenceableLoader( 1001,  2000);\n  CompositeSequenceableLoader compositeSequenceableLoader =\n      new CompositeSequenceableLoader(new SequenceableLoader[] {loader1, loader2});\n  assertThat(compositeSequenceableLoader.getNextLoadPositionUs()).isEqualTo(2000);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "composite",
            "sequenceable",
            "loader",
            "get",
            "next",
            "load",
            "position",
            "us",
            "returns",
            "minimum",
            "next",
            "load",
            "position",
            "among",
            "all",
            "sub",
            "loaders"
        ]
    },
    {
        "id": 1580,
        "code": "public void getNextLoadPositionUsReturnMinimumNonEndOfSourceLoaderNextLoadPositionUs() {\n  FakeSequenceableLoader loader1 =\n      new FakeSequenceableLoader( 1000,  2000);\n  FakeSequenceableLoader loader2 =\n      new FakeSequenceableLoader( 1001,  2001);\n  FakeSequenceableLoader loader3 =\n      new FakeSequenceableLoader(\n           1001,  C.TIME_END_OF_SOURCE);\n  CompositeSequenceableLoader compositeSequenceableLoader =\n      new CompositeSequenceableLoader(new SequenceableLoader[] {loader1, loader2, loader3});\n  assertThat(compositeSequenceableLoader.getNextLoadPositionUs()).isEqualTo(2000);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "composite",
            "sequenceable",
            "loader",
            "get",
            "next",
            "load",
            "position",
            "us",
            "returns",
            "minimum",
            "next",
            "load",
            "position",
            "that",
            "is",
            "not",
            "c",
            "time",
            "end",
            "of",
            "source",
            "among",
            "all",
            "sub",
            "loaders"
        ]
    },
    {
        "id": 1581,
        "code": "public void getNextLoadPositionUsReturnsEndOfSourceWhenAllLoaderLoadingLastChunk() {\n  FakeSequenceableLoader loader1 =\n      new FakeSequenceableLoader(\n           1000,  C.TIME_END_OF_SOURCE);\n  FakeSequenceableLoader loader2 =\n      new FakeSequenceableLoader(\n           1001,  C.TIME_END_OF_SOURCE);\n  CompositeSequenceableLoader compositeSequenceableLoader =\n      new CompositeSequenceableLoader(new SequenceableLoader[] {loader1, loader2});\n  assertThat(compositeSequenceableLoader.getNextLoadPositionUs()).isEqualTo(C.TIME_END_OF_SOURCE);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "composite",
            "sequenceable",
            "loader",
            "get",
            "next",
            "load",
            "position",
            "us",
            "returns",
            "c",
            "time",
            "end",
            "of",
            "source",
            "when",
            "all",
            "sub",
            "loaders",
            "have",
            "next",
            "load",
            "position",
            "at",
            "end",
            "of",
            "source"
        ]
    },
    {
        "id": 1582,
        "code": "public void continueLoadingOnlyAllowFurthestBehindLoaderToLoadIfNotBehindPlaybackPosition() {\n  FakeSequenceableLoader loader1 =\n      new FakeSequenceableLoader( 1000,  2000);\n  FakeSequenceableLoader loader2 =\n      new FakeSequenceableLoader( 1001,  2001);\n  CompositeSequenceableLoader compositeSequenceableLoader =\n      new CompositeSequenceableLoader(new SequenceableLoader[] {loader1, loader2});\n  compositeSequenceableLoader.continueLoading(100);\n\n  assertThat(loader1.numInvocations).isEqualTo(1);\n  assertThat(loader2.numInvocations).isEqualTo(0);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "composite",
            "sequenceable",
            "loader",
            "continue",
            "loading",
            "long",
            "only",
            "allows",
            "the",
            "loader",
            "with",
            "minimum",
            "next",
            "load",
            "position",
            "to",
            "continue",
            "loading",
            "if",
            "next",
            "load",
            "positions",
            "are",
            "not",
            "behind",
            "current",
            "playback",
            "position"
        ]
    },
    {
        "id": 1583,
        "code": "public void continueLoadingReturnAllowAllLoadersBehindPlaybackPositionToLoad() {\n  FakeSequenceableLoader loader1 =\n      new FakeSequenceableLoader( 1000,  2000);\n  FakeSequenceableLoader loader2 =\n      new FakeSequenceableLoader( 1001,  2001);\n  FakeSequenceableLoader loader3 =\n      new FakeSequenceableLoader( 1002,  2002);\n  CompositeSequenceableLoader compositeSequenceableLoader =\n      new CompositeSequenceableLoader(new SequenceableLoader[] {loader1, loader2, loader3});\n  compositeSequenceableLoader.continueLoading(3000);\n\n  assertThat(loader1.numInvocations).isEqualTo(1);\n  assertThat(loader2.numInvocations).isEqualTo(1);\n  assertThat(loader3.numInvocations).isEqualTo(1);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "composite",
            "sequenceable",
            "loader",
            "continue",
            "loading",
            "long",
            "allows",
            "all",
            "loaders",
            "with",
            "next",
            "load",
            "position",
            "behind",
            "current",
            "playback",
            "position",
            "to",
            "continue",
            "loading"
        ]
    },
    {
        "id": 1584,
        "code": "public void continueLoadingOnlyNotAllowEndOfSourceLoaderToLoad() {\n  FakeSequenceableLoader loader1 =\n      new FakeSequenceableLoader(\n           1000,  C.TIME_END_OF_SOURCE);\n  FakeSequenceableLoader loader2 =\n      new FakeSequenceableLoader(\n           1001,  C.TIME_END_OF_SOURCE);\n  CompositeSequenceableLoader compositeSequenceableLoader =\n      new CompositeSequenceableLoader(new SequenceableLoader[] {loader1, loader2});\n  compositeSequenceableLoader.continueLoading(3000);\n\n  assertThat(loader1.numInvocations).isEqualTo(0);\n  assertThat(loader2.numInvocations).isEqualTo(0);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "composite",
            "sequenceable",
            "loader",
            "continue",
            "loading",
            "long",
            "does",
            "not",
            "allow",
            "loader",
            "with",
            "next",
            "load",
            "position",
            "at",
            "end",
            "of",
            "source",
            "to",
            "continue",
            "loading"
        ]
    },
    {
        "id": 1585,
        "code": "public void continueLoadingReturnTrueIfFurthestBehindLoaderCanMakeProgress() {\n  FakeSequenceableLoader loader1 =\n      new FakeSequenceableLoader( 1000,  2000);\n  FakeSequenceableLoader loader2 =\n      new FakeSequenceableLoader( 1001,  2001);\n  loader1.setNextChunkDurationUs(1000);\n\n  CompositeSequenceableLoader compositeSequenceableLoader =\n      new CompositeSequenceableLoader(new SequenceableLoader[] {loader1, loader2});\n\n  assertThat(compositeSequenceableLoader.continueLoading(100)).isTrue();\n}",
        "summary_tokens": [
            "tests",
            "that",
            "composite",
            "sequenceable",
            "loader",
            "continue",
            "loading",
            "long",
            "returns",
            "true",
            "if",
            "the",
            "loader",
            "with",
            "minimum",
            "next",
            "load",
            "position",
            "can",
            "make",
            "progress",
            "if",
            "next",
            "load",
            "positions",
            "are",
            "not",
            "behind",
            "current",
            "playback",
            "position"
        ]
    },
    {
        "id": 1586,
        "code": "public void continueLoadingReturnTrueIfLoaderBehindPlaybackPositionCanMakeProgress() {\n  FakeSequenceableLoader loader1 =\n      new FakeSequenceableLoader( 1000,  2000);\n  FakeSequenceableLoader loader2 =\n      new FakeSequenceableLoader( 1001,  2001);\n    \n  loader2.setNextChunkDurationUs(1000);\n\n  CompositeSequenceableLoader compositeSequenceableLoader =\n      new CompositeSequenceableLoader(new SequenceableLoader[] {loader1, loader2});\n\n  assertThat(compositeSequenceableLoader.continueLoading(3000)).isTrue();\n}",
        "summary_tokens": [
            "tests",
            "that",
            "composite",
            "sequenceable",
            "loader",
            "continue",
            "loading",
            "long",
            "returns",
            "true",
            "if",
            "any",
            "loader",
            "that",
            "are",
            "behind",
            "current",
            "playback",
            "position",
            "can",
            "make",
            "progress",
            "even",
            "if",
            "it",
            "is",
            "not",
            "the",
            "one",
            "with",
            "minimum",
            "next",
            "load",
            "position"
        ]
    },
    {
        "id": 1587,
        "code": "private static Timeline getLoopingTimeline(Timeline timeline, int loopCount) throws IOException {\n  FakeMediaSource fakeMediaSource = new FakeMediaSource(timeline);\n  LoopingMediaSource mediaSource = new LoopingMediaSource(fakeMediaSource, loopCount);\n  MediaSourceTestRunner testRunner = new MediaSourceTestRunner(mediaSource, null);\n  try {\n    Timeline loopingTimeline = testRunner.prepareSource();\n    testRunner.releaseSource();\n    fakeMediaSource.assertReleased();\n    return loopingTimeline;\n  } finally {\n    testRunner.release();\n  }\n}",
        "summary_tokens": [
            "wraps",
            "the",
            "specified",
            "timeline",
            "in",
            "a",
            "looping",
            "media",
            "source",
            "and",
            "returns",
            "the",
            "looping",
            "timeline"
        ]
    },
    {
        "id": 1588,
        "code": "private static void testMediaPeriodCreation(Timeline timeline, int loopCount) throws Exception {\n  FakeMediaSource fakeMediaSource = new FakeMediaSource(timeline);\n  LoopingMediaSource mediaSource = new LoopingMediaSource(fakeMediaSource, loopCount);\n  MediaSourceTestRunner testRunner = new MediaSourceTestRunner(mediaSource, null);\n  try {\n    testRunner.prepareSource();\n    testRunner.assertPrepareAndReleaseAllPeriods();\n    testRunner.releaseSource();\n  } finally {\n    testRunner.release();\n  }\n}",
        "summary_tokens": [
            "wraps",
            "the",
            "specified",
            "timeline",
            "in",
            "a",
            "looping",
            "media",
            "source",
            "and",
            "asserts",
            "that",
            "all",
            "periods",
            "of",
            "the",
            "looping",
            "timeline",
            "can",
            "be",
            "created",
            "and",
            "prepared"
        ]
    },
    {
        "id": 1589,
        "code": "private static Timeline prepareMergingMediaSource(boolean clipDurations, Timeline... timelines)\n    throws IOException {\n  FakeMediaSource[] mediaSources = new FakeMediaSource[timelines.length];\n  for (int i = 0; i < timelines.length; i++) {\n    mediaSources[i] = new FakeMediaSource(timelines[i]);\n  }\n  MergingMediaSource mergingMediaSource =\n      new MergingMediaSource( false, clipDurations, mediaSources);\n  MediaSourceTestRunner testRunner =\n      new MediaSourceTestRunner(mergingMediaSource,  null);\n  try {\n    Timeline timeline = testRunner.prepareSource();\n    testRunner.releaseSource();\n    for (FakeMediaSource mediaSource : mediaSources) {\n      mediaSource.assertReleased();\n    }\n    return timeline;\n  } finally {\n    testRunner.release();\n  }\n}",
        "summary_tokens": [
            "wraps",
            "the",
            "specified",
            "timelines",
            "in",
            "a",
            "merging",
            "media",
            "source",
            "prepares",
            "it",
            "and",
            "returns",
            "the",
            "merged",
            "timeline"
        ]
    },
    {
        "id": 1590,
        "code": "private void writeTestData(\n    byte[] data,\n    int[] sampleSizes,\n    int[] sampleOffsets,\n    long[] sampleTimestamps,\n    Format[] sampleFormats,\n    int[] sampleFlags) {\n  sampleQueue.sampleData(new ParsableByteArray(data), data.length);\n  Format format = null;\n  for (int i = 0; i < sampleTimestamps.length; i++) {\n    if (sampleFormats[i] != format) {\n      sampleQueue.format(sampleFormats[i]);\n      format = sampleFormats[i];\n    }\n    sampleQueue.sampleMetadata(\n        sampleTimestamps[i],\n        sampleFlags[i],\n        sampleSizes[i],\n        sampleOffsets[i],\n        (sampleFlags[i] & C.BUFFER_FLAG_ENCRYPTED) != 0 ? CRYPTO_DATA : null);\n  }\n}",
        "summary_tokens": [
            "writes",
            "the",
            "specified",
            "test",
            "data",
            "to",
            "sample",
            "queue"
        ]
    },
    {
        "id": 1591,
        "code": "private void writeFormat(Format format) {\n  sampleQueue.format(format);\n}",
        "summary_tokens": [
            "writes",
            "a",
            "format",
            "to",
            "the",
            "sample",
            "queue"
        ]
    },
    {
        "id": 1592,
        "code": "private void writeSample(byte[] data, long timestampUs, int sampleFlags) {\n  sampleQueue.sampleData(new ParsableByteArray(data), data.length);\n  sampleQueue.sampleMetadata(\n      timestampUs,\n      sampleFlags,\n      data.length,\n       0,\n      (sampleFlags & C.BUFFER_FLAG_ENCRYPTED) != 0 ? CRYPTO_DATA : null);\n}",
        "summary_tokens": [
            "writes",
            "a",
            "single",
            "sample",
            "to",
            "sample",
            "queue"
        ]
    },
    {
        "id": 1593,
        "code": "private void assertReadTestData(\n    Format startFormat,\n    int firstSampleIndex,\n    int sampleCount,\n    long sampleOffsetUs,\n    long decodeOnlyUntilUs) {\n  Format format = adjustFormat(startFormat, sampleOffsetUs);\n  for (int i = firstSampleIndex; i < firstSampleIndex + sampleCount; i++) {\n      \n      \n    Format testSampleFormat = adjustFormat(SAMPLE_FORMATS[i], sampleOffsetUs);\n    if (!testSampleFormat.equals(format)) {\n        \n      assertReadFormat(false, testSampleFormat);\n      format = testSampleFormat;\n    }\n      \n    assertReadFormat(true, testSampleFormat);\n      \n    long expectedTimeUs = SAMPLE_TIMESTAMPS[i] + sampleOffsetUs;\n    assertReadSample(\n        expectedTimeUs,\n        (SAMPLE_FLAGS[i] & C.BUFFER_FLAG_KEY_FRAME) != 0,\n         expectedTimeUs < decodeOnlyUntilUs,\n         false,\n        DATA,\n        DATA.length - SAMPLE_OFFSETS[i] - SAMPLE_SIZES[i],\n        SAMPLE_SIZES[i]);\n  }\n}",
        "summary_tokens": [
            "asserts",
            "correct",
            "reading",
            "of",
            "standard",
            "test",
            "data",
            "from",
            "sample",
            "queue"
        ]
    },
    {
        "id": 1594,
        "code": "private void assertNoSamplesToRead(Format endFormat) {\n    \n  assertReadNothing(false);\n    \n  if (endFormat == null) {\n    assertReadNothing(true);\n  } else {\n    assertReadFormat(true, endFormat);\n  }\n    \n  assertReadEndOfStream(false);\n  assertReadEndOfStream(true);\n    \n  assertReadNothing(false);\n  if (endFormat == null) {\n    assertReadNothing(true);\n  } else {\n    assertReadFormat(true, endFormat);\n  }\n}",
        "summary_tokens": [
            "asserts",
            "sample",
            "queue",
            "read",
            "is",
            "behaving",
            "correctly",
            "given",
            "there",
            "are",
            "no",
            "samples",
            "to",
            "read",
            "and",
            "the",
            "last",
            "format",
            "to",
            "be",
            "written",
            "to",
            "the",
            "sample",
            "queue",
            "is",
            "end",
            "format"
        ]
    },
    {
        "id": 1595,
        "code": "private void assertReadNothing(boolean formatRequired) {\n  clearFormatHolderAndInputBuffer();\n  int result =\n      sampleQueue.read(\n          formatHolder,\n          inputBuffer,\n          formatRequired ? SampleStream.FLAG_REQUIRE_FORMAT : 0,\n           false);\n  assertThat(result).isEqualTo(RESULT_NOTHING_READ);\n    \n  assertThat(formatHolder.format).isNull();\n    \n  assertInputBufferContainsNoSampleData();\n  assertInputBufferHasNoDefaultFlagsSet();\n}",
        "summary_tokens": [
            "asserts",
            "sample",
            "queue",
            "read",
            "returns",
            "c",
            "result",
            "nothing",
            "read"
        ]
    },
    {
        "id": 1596,
        "code": "private void assertReadEndOfStream(boolean formatRequired) {\n  clearFormatHolderAndInputBuffer();\n  int result =\n      sampleQueue.read(\n          formatHolder,\n          inputBuffer,\n          formatRequired ? SampleStream.FLAG_REQUIRE_FORMAT : 0,\n           true);\n  assertThat(result).isEqualTo(RESULT_BUFFER_READ);\n    \n  assertThat(formatHolder.format).isNull();\n    \n  assertInputBufferContainsNoSampleData();\n  assertThat(inputBuffer.isEndOfStream()).isTrue();\n  assertThat(inputBuffer.isDecodeOnly()).isFalse();\n  assertThat(inputBuffer.isEncrypted()).isFalse();\n}",
        "summary_tokens": [
            "asserts",
            "sample",
            "queue",
            "read",
            "returns",
            "c",
            "result",
            "buffer",
            "read",
            "and",
            "that",
            "the",
            "decoder",
            "input",
            "buffer",
            "is",
            "end",
            "of",
            "stream",
            "is",
            "set"
        ]
    },
    {
        "id": 1597,
        "code": "private void assertReadFormat(boolean formatRequired, Format format) {\n  clearFormatHolderAndInputBuffer();\n  int result =\n      sampleQueue.read(\n          formatHolder,\n          inputBuffer,\n          formatRequired ? SampleStream.FLAG_REQUIRE_FORMAT : 0,\n           false);\n  assertThat(result).isEqualTo(RESULT_FORMAT_READ);\n    \n  assertThat(formatHolder.format).isEqualTo(format);\n    \n  assertInputBufferContainsNoSampleData();\n  assertInputBufferHasNoDefaultFlagsSet();\n}",
        "summary_tokens": [
            "asserts",
            "sample",
            "queue",
            "read",
            "returns",
            "c",
            "result",
            "format",
            "read",
            "and",
            "that",
            "the",
            "format",
            "holder",
            "is",
            "filled",
            "with",
            "a",
            "format",
            "that",
            "equals",
            "format"
        ]
    },
    {
        "id": 1598,
        "code": "private void assertReadSample(\n    long timeUs,\n    boolean isKeyFrame,\n    boolean isDecodeOnly,\n    boolean isEncrypted,\n    byte[] sampleData,\n    int offset,\n    int length) {\n    \n  formatHolder.format = null;\n  DecoderInputBuffer flagsOnlyBuffer = DecoderInputBuffer.newNoDataInstance();\n  int result =\n      sampleQueue.read(\n          formatHolder,\n          flagsOnlyBuffer,\n          FLAG_OMIT_SAMPLE_DATA | FLAG_PEEK,\n           false);\n  assertSampleBufferReadResult(\n      flagsOnlyBuffer, result, timeUs, isKeyFrame, isDecodeOnly, isEncrypted);\n\n    \n  clearFormatHolderAndInputBuffer();\n  result = sampleQueue.read(formatHolder, inputBuffer, FLAG_PEEK,  false);\n  assertSampleBufferReadResult(\n      result, timeUs, isKeyFrame, isDecodeOnly, isEncrypted, sampleData, offset, length);\n\n    \n  clearFormatHolderAndInputBuffer();\n  result =\n      sampleQueue.read(\n          formatHolder, inputBuffer,  0,  false);\n  assertSampleBufferReadResult(\n      result, timeUs, isKeyFrame, isDecodeOnly, isEncrypted, sampleData, offset, length);\n}",
        "summary_tokens": [
            "asserts",
            "sample",
            "queue",
            "read",
            "returns",
            "c",
            "result",
            "buffer",
            "read",
            "and",
            "that",
            "the",
            "buffer",
            "is",
            "filled",
            "with",
            "the",
            "specified",
            "sample",
            "data"
        ]
    },
    {
        "id": 1599,
        "code": "private void assertAllocationCount(int count) {\n  assertThat(allocator.getTotalBytesAllocated()).isEqualTo(ALLOCATION_SIZE * count);\n}",
        "summary_tokens": [
            "asserts",
            "the",
            "number",
            "of",
            "allocations",
            "currently",
            "in",
            "use",
            "by",
            "sample",
            "queue"
        ]
    },
    {
        "id": 1600,
        "code": "private void assertInputBufferContainsNoSampleData() {\n  if (inputBuffer.data == null) {\n    return;\n  }\n  inputBuffer.flip();\n  assertThat(inputBuffer.data.limit()).isEqualTo(0);\n}",
        "summary_tokens": [
            "asserts",
            "input",
            "buffer",
            "does",
            "not",
            "contain",
            "any",
            "sample",
            "data"
        ]
    },
    {
        "id": 1601,
        "code": "public void roundTripViaBundle_ofParameters_yieldsEqualInstance() {\n  Parameters parametersToBundle = buildParametersForEqualsTest();\n\n  Parameters parametersFromBundle = Parameters.CREATOR.fromBundle(parametersToBundle.toBundle());\n\n  assertThat(parametersFromBundle).isEqualTo(parametersToBundle);\n}",
        "summary_tokens": [
            "tests",
            "parameters",
            "bundleable",
            "implementation"
        ]
    },
    {
        "id": 1602,
        "code": "public void selectTracks_withOverrideWithoutTracks_clearsTrackSelection()\n    throws ExoPlaybackException {\n  trackSelector.setParameters(\n      trackSelector\n          .buildUponParameters()\n          .addOverride(new TrackSelectionOverride(VIDEO_TRACK_GROUP, ImmutableList.of()))\n          .build());\n\n  TrackSelectorResult result =\n      trackSelector.selectTracks(RENDERER_CAPABILITIES, TRACK_GROUPS, periodId, TIMELINE);\n\n  assertSelections(result, new TrackSelection[] {null, TRACK_SELECTIONS[1]});\n  assertThat(result.rendererConfigurations)\n      .isEqualTo(new RendererConfiguration[] {null, DEFAULT});\n}",
        "summary_tokens": [
            "tests",
            "that",
            "an",
            "empty",
            "override",
            "clears",
            "a",
            "track",
            "selection"
        ]
    },
    {
        "id": 1603,
        "code": "public void selectTracksWithNullOverride() throws ExoPlaybackException {\n  trackSelector.setParameters(\n      trackSelector\n          .buildUponParameters()\n          .setSelectionOverride(0, new TrackGroupArray(VIDEO_TRACK_GROUP), null));\n  TrackSelectorResult result =\n      trackSelector.selectTracks(RENDERER_CAPABILITIES, TRACK_GROUPS, periodId, TIMELINE);\n  assertSelections(result, new TrackSelection[] {null, TRACK_SELECTIONS[1]});\n  assertThat(result.rendererConfigurations)\n      .isEqualTo(new RendererConfiguration[] {null, DEFAULT});\n}",
        "summary_tokens": [
            "tests",
            "that",
            "a",
            "null",
            "override",
            "clears",
            "a",
            "track",
            "selection"
        ]
    },
    {
        "id": 1604,
        "code": "public void selectTracksWithClearedNullOverride() throws ExoPlaybackException {\n  trackSelector.setParameters(\n      trackSelector\n          .buildUponParameters()\n          .setSelectionOverride(0, new TrackGroupArray(VIDEO_TRACK_GROUP), null)\n          .clearSelectionOverride(0, new TrackGroupArray(VIDEO_TRACK_GROUP)));\n  TrackSelectorResult result =\n      trackSelector.selectTracks(RENDERER_CAPABILITIES, TRACK_GROUPS, periodId, TIMELINE);\n  assertSelections(result, TRACK_SELECTIONS);\n  assertThat(result.rendererConfigurations)\n      .isEqualTo(new RendererConfiguration[] {DEFAULT, DEFAULT});\n}",
        "summary_tokens": [
            "tests",
            "that",
            "a",
            "null",
            "override",
            "can",
            "be",
            "cleared"
        ]
    },
    {
        "id": 1605,
        "code": "public void selectTracks_withEmptyTrackOverrideForDifferentTracks_hasNoEffect()\n    throws ExoPlaybackException {\n  TrackGroup videoGroup0 = VIDEO_TRACK_GROUP.copyWithId(\"0\");\n  TrackGroup videoGroup1 = VIDEO_TRACK_GROUP.copyWithId(\"1\");\n  trackSelector.setParameters(\n      trackSelector\n          .buildUponParameters()\n          .setOverrideForType(\n              new TrackSelectionOverride(\n                  new TrackGroup(VIDEO_FORMAT, VIDEO_FORMAT), ImmutableList.of()))\n          .build());\n\n  TrackSelectorResult result =\n      trackSelector.selectTracks(\n          RENDERER_CAPABILITIES,\n          new TrackGroupArray(videoGroup0, AUDIO_TRACK_GROUP, videoGroup1),\n          periodId,\n          TIMELINE);\n\n  assertThat(result.selections)\n      .asList()\n      .containsExactly(\n          new FixedTrackSelection(videoGroup0,  0),\n          new FixedTrackSelection(AUDIO_TRACK_GROUP,  0))\n      .inOrder();\n  assertThat(result.rendererConfigurations)\n      .isEqualTo(new RendererConfiguration[] {DEFAULT, DEFAULT});\n}",
        "summary_tokens": [
            "tests",
            "that",
            "an",
            "empty",
            "override",
            "is",
            "not",
            "applied",
            "for",
            "a",
            "different",
            "set",
            "of",
            "available",
            "track",
            "groups"
        ]
    },
    {
        "id": 1606,
        "code": "public void selectTracksWithNullOverrideForDifferentTracks() throws ExoPlaybackException {\n  TrackGroup videoGroup0 = VIDEO_TRACK_GROUP.copyWithId(\"0\");\n  TrackGroup videoGroup1 = VIDEO_TRACK_GROUP.copyWithId(\"1\");\n  trackSelector.setParameters(\n      trackSelector\n          .buildUponParameters()\n          .setSelectionOverride(0, new TrackGroupArray(VIDEO_TRACK_GROUP.copyWithId(\"2\")), null));\n  TrackSelectorResult result =\n      trackSelector.selectTracks(\n          RENDERER_CAPABILITIES,\n          new TrackGroupArray(videoGroup0, AUDIO_TRACK_GROUP, videoGroup1),\n          periodId,\n          TIMELINE);\n  assertThat(result.selections)\n      .asList()\n      .containsExactly(\n          new FixedTrackSelection(videoGroup0,  0),\n          new FixedTrackSelection(AUDIO_TRACK_GROUP,  0))\n      .inOrder();\n  assertThat(result.rendererConfigurations)\n      .isEqualTo(new RendererConfiguration[] {DEFAULT, DEFAULT});\n}",
        "summary_tokens": [
            "tests",
            "that",
            "an",
            "override",
            "is",
            "not",
            "applied",
            "for",
            "a",
            "different",
            "set",
            "of",
            "available",
            "track",
            "groups"
        ]
    },
    {
        "id": 1607,
        "code": "public void selectVideoAudioTracks_withDisabledAudioType_onlyVideoIsSelected()\n    throws ExoPlaybackException {\n  trackSelector.setParameters(\n      defaultParameters\n          .buildUpon()\n          .setTrackTypeDisabled(C.TRACK_TYPE_AUDIO,  true));\n\n  TrackSelectorResult result =\n      trackSelector.selectTracks(\n          RENDERER_CAPABILITIES,\n          new TrackGroupArray(VIDEO_TRACK_GROUP, AUDIO_TRACK_GROUP),\n          periodId,\n          TIMELINE);\n\n  assertThat(result.selections).asList().containsExactly(VIDEO_TRACK_SELECTION, null).inOrder();\n  assertThat(result.rendererConfigurations).asList().containsExactly(DEFAULT, null);\n}",
        "summary_tokens": [
            "tests",
            "disabling",
            "a",
            "track",
            "type"
        ]
    },
    {
        "id": 1608,
        "code": "public void selectTracks_withClearedDisabledTrackType_selectsAll() throws ExoPlaybackException {\n  trackSelector.setParameters(\n      trackSelector\n          .buildUponParameters()\n          .setTrackTypeDisabled(C.TRACK_TYPE_AUDIO,  true)\n          .setDisabledTrackTypes(ImmutableSet.of()));\n\n  TrackSelectorResult result =\n      trackSelector.selectTracks(RENDERER_CAPABILITIES, TRACK_GROUPS, periodId, TIMELINE);\n\n  assertThat(result.selections).asList().containsExactlyElementsIn(TRACK_SELECTIONS).inOrder();\n  assertThat(result.rendererConfigurations).asList().containsExactly(DEFAULT, DEFAULT).inOrder();\n}",
        "summary_tokens": [
            "tests",
            "that",
            "a",
            "disabled",
            "track",
            "type",
            "can",
            "be",
            "enabled",
            "again"
        ]
    },
    {
        "id": 1609,
        "code": "public void selectTracks_withDisabledNoneTracksAndNoSampleRenderer_disablesNoSampleRenderer()\n    throws ExoPlaybackException {\n  trackSelector.setParameters(\n      defaultParameters\n          .buildUpon()\n          .setTrackTypeDisabled(C.TRACK_TYPE_NONE,  true));\n\n  TrackSelectorResult result =\n      trackSelector.selectTracks(\n          new RendererCapabilities[] {VIDEO_CAPABILITIES, NO_SAMPLE_CAPABILITIES},\n          TRACK_GROUPS,\n          periodId,\n          TIMELINE);\n\n  assertThat(result.selections).asList().containsExactly(VIDEO_TRACK_SELECTION, null).inOrder();\n  assertThat(result.rendererConfigurations).asList().containsExactly(DEFAULT, null).inOrder();\n}",
        "summary_tokens": [
            "tests",
            "disabling",
            "none",
            "track",
            "type",
            "rendering"
        ]
    },
    {
        "id": 1610,
        "code": "public void selectTracksWithDisabledRenderer() throws ExoPlaybackException {\n  trackSelector.setParameters(defaultParameters.buildUpon().setRendererDisabled(1, true));\n  TrackSelectorResult result =\n      trackSelector.selectTracks(RENDERER_CAPABILITIES, TRACK_GROUPS, periodId, TIMELINE);\n  assertSelections(result, new TrackSelection[] {TRACK_SELECTIONS[0], null});\n  assertThat(new RendererConfiguration[] {DEFAULT, null})\n      .isEqualTo(result.rendererConfigurations);\n}",
        "summary_tokens": [
            "tests",
            "disabling",
            "a",
            "renderer"
        ]
    },
    {
        "id": 1611,
        "code": "public void selectTracksWithClearedDisabledRenderer() throws ExoPlaybackException {\n  trackSelector.setParameters(\n      trackSelector\n          .buildUponParameters()\n          .setRendererDisabled(1, true)\n          .setRendererDisabled(1, false));\n  TrackSelectorResult result =\n      trackSelector.selectTracks(RENDERER_CAPABILITIES, TRACK_GROUPS, periodId, TIMELINE);\n  assertSelections(result, TRACK_SELECTIONS);\n  assertThat(new RendererConfiguration[] {DEFAULT, DEFAULT})\n      .isEqualTo(result.rendererConfigurations);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "a",
            "disabled",
            "renderer",
            "can",
            "be",
            "enabled",
            "again"
        ]
    },
    {
        "id": 1612,
        "code": "public void selectTracksWithNoSampleRenderer() throws ExoPlaybackException {\n  TrackSelectorResult result =\n      trackSelector.selectTracks(\n          RENDERER_CAPABILITIES_WITH_NO_SAMPLE_RENDERER, TRACK_GROUPS, periodId, TIMELINE);\n  assertSelections(result, TRACK_SELECTIONS_WITH_NO_SAMPLE_RENDERER);\n  assertThat(new RendererConfiguration[] {DEFAULT, DEFAULT})\n      .isEqualTo(result.rendererConfigurations);\n}",
        "summary_tokens": [
            "tests",
            "a",
            "no",
            "sample",
            "renderer",
            "is",
            "enabled",
            "without",
            "a",
            "track",
            "selection",
            "by",
            "default"
        ]
    },
    {
        "id": 1613,
        "code": "public void selectTracksWithDisabledNoSampleRenderer() throws ExoPlaybackException {\n  trackSelector.setParameters(defaultParameters.buildUpon().setRendererDisabled(1, true));\n  TrackSelectorResult result =\n      trackSelector.selectTracks(\n          RENDERER_CAPABILITIES_WITH_NO_SAMPLE_RENDERER, TRACK_GROUPS, periodId, TIMELINE);\n  assertSelections(result, TRACK_SELECTIONS_WITH_NO_SAMPLE_RENDERER);\n  assertThat(new RendererConfiguration[] {DEFAULT, null})\n      .isEqualTo(result.rendererConfigurations);\n}",
        "summary_tokens": [
            "tests",
            "disabling",
            "a",
            "no",
            "sample",
            "renderer"
        ]
    },
    {
        "id": 1614,
        "code": "public void setParameterWithDefaultParametersDoesNotNotifyInvalidationListener() {\n  trackSelector.setParameters(defaultParameters);\n  verify(invalidationListener, never()).onTrackSelectionsInvalidated();\n}",
        "summary_tokens": [
            "tests",
            "that",
            "track",
            "selector",
            "will",
            "not",
            "call",
            "invalidation",
            "listener",
            "on",
            "track",
            "selections",
            "invalidated",
            "when",
            "it",
            "s",
            "set",
            "with",
            "default",
            "values",
            "of",
            "parameters"
        ]
    },
    {
        "id": 1615,
        "code": "public void setParameterWithNonDefaultParameterNotifyInvalidationListener() {\n  Parameters.Builder builder = defaultParameters.buildUpon().setPreferredAudioLanguage(\"eng\");\n  trackSelector.setParameters(builder);\n  verify(invalidationListener).onTrackSelectionsInvalidated();\n}",
        "summary_tokens": [
            "tests",
            "that",
            "track",
            "selector",
            "will",
            "call",
            "invalidation",
            "listener",
            "on",
            "track",
            "selections",
            "invalidated",
            "when",
            "it",
            "s",
            "set",
            "with",
            "non",
            "default",
            "values",
            "of",
            "parameters"
        ]
    },
    {
        "id": 1616,
        "code": "public void setParameterWithSameParametersDoesNotNotifyInvalidationListenerAgain() {\n  Parameters.Builder builder = defaultParameters.buildUpon().setPreferredAudioLanguage(\"eng\");\n  trackSelector.setParameters(builder);\n  trackSelector.setParameters(builder);\n  verify(invalidationListener, times(1)).onTrackSelectionsInvalidated();\n}",
        "summary_tokens": [
            "tests",
            "that",
            "track",
            "selector",
            "will",
            "not",
            "call",
            "invalidation",
            "listener",
            "on",
            "track",
            "selections",
            "invalidated",
            "again",
            "when",
            "it",
            "s",
            "set",
            "with",
            "the",
            "same",
            "values",
            "of",
            "parameters"
        ]
    },
    {
        "id": 1617,
        "code": "public void selectTracksSelectTrackWithSelectionFlag() throws Exception {\n  Format.Builder formatBuilder = AUDIO_FORMAT.buildUpon();\n  Format audioFormat = formatBuilder.setSelectionFlags(0).build();\n  Format formatWithSelectionFlag =\n      formatBuilder.setSelectionFlags(C.SELECTION_FLAG_DEFAULT).build();\n  TrackGroupArray trackGroups = wrapFormats(audioFormat, formatWithSelectionFlag);\n\n  TrackSelectorResult result =\n      trackSelector.selectTracks(\n          new RendererCapabilities[] {ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES},\n          trackGroups,\n          periodId,\n          TIMELINE);\n  assertFixedSelection(result.selections[0], trackGroups, formatWithSelectionFlag);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "track",
            "selector",
            "will",
            "select",
            "audio",
            "track",
            "with",
            "c",
            "selection",
            "flag",
            "default",
            "given",
            "default",
            "values",
            "of",
            "parameters"
        ]
    },
    {
        "id": 1618,
        "code": "public void selectAdaptiveAudioTrackGroupWithMaxBitrate() throws ExoPlaybackException {\n  Format.Builder formatBuilder = AUDIO_FORMAT.buildUpon();\n  Format format128k = formatBuilder.setAverageBitrate(128 * 1024).build();\n  Format format192k = formatBuilder.setAverageBitrate(192 * 1024).build();\n  Format format256k = formatBuilder.setAverageBitrate(256 * 1024).build();\n  RendererCapabilities[] rendererCapabilities = {\n    ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES\n  };\n  TrackGroupArray trackGroups =\n      new TrackGroupArray(new TrackGroup(format192k, format128k, format256k));\n\n  TrackSelectorResult result =\n      trackSelector.selectTracks(rendererCapabilities, trackGroups, periodId, TIMELINE);\n  assertAdaptiveSelection(result.selections[0], trackGroups.get(0), 2, 0, 1);\n\n  trackSelector.setParameters(\n      trackSelector.buildUponParameters().setMaxAudioBitrate(256 * 1024 - 1));\n  result = trackSelector.selectTracks(rendererCapabilities, trackGroups, periodId, TIMELINE);\n  assertAdaptiveSelection(result.selections[0], trackGroups.get(0), 0, 1);\n\n  trackSelector.setParameters(trackSelector.buildUponParameters().setMaxAudioBitrate(192 * 1024));\n  result = trackSelector.selectTracks(rendererCapabilities, trackGroups, periodId, TIMELINE);\n  assertAdaptiveSelection(result.selections[0], trackGroups.get(0), 0, 1);\n\n  trackSelector.setParameters(\n      trackSelector.buildUponParameters().setMaxAudioBitrate(192 * 1024 - 1));\n  result = trackSelector.selectTracks(rendererCapabilities, trackGroups, periodId, TIMELINE);\n  assertFixedSelection(result.selections[0], trackGroups.get(0), 1);\n\n  trackSelector.setParameters(trackSelector.buildUponParameters().setMaxAudioBitrate(10));\n  result = trackSelector.selectTracks(rendererCapabilities, trackGroups, periodId, TIMELINE);\n  assertFixedSelection(result.selections[0], trackGroups.get(0), 1);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "adaptive",
            "audio",
            "track",
            "selections",
            "respect",
            "the",
            "maximum",
            "audio",
            "bitrate"
        ]
    },
    {
        "id": 1619,
        "code": "public void selectTracksSelectPreferredAudioLanguage() throws Exception {\n  Format.Builder formatBuilder = AUDIO_FORMAT.buildUpon();\n  Format frAudioFormat = formatBuilder.setLanguage(\"fra\").build();\n  Format enAudioFormat = formatBuilder.setLanguage(\"eng\").build();\n  TrackGroupArray trackGroups = wrapFormats(frAudioFormat, enAudioFormat);\n\n  trackSelector.setParameters(defaultParameters.buildUpon().setPreferredAudioLanguage(\"eng\"));\n  TrackSelectorResult result =\n      trackSelector.selectTracks(\n          new RendererCapabilities[] {ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES},\n          wrapFormats(frAudioFormat, enAudioFormat),\n          periodId,\n          TIMELINE);\n  assertFixedSelection(result.selections[0], trackGroups, enAudioFormat);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "track",
            "selector",
            "will",
            "select",
            "audio",
            "track",
            "with",
            "language",
            "that",
            "match",
            "preferred",
            "language",
            "given",
            "by",
            "parameters"
        ]
    },
    {
        "id": 1620,
        "code": "public void selectTracks_withPreferredAudioRoleFlags_selectPreferredTrack() throws Exception {\n  Format.Builder formatBuilder = AUDIO_FORMAT.buildUpon();\n  Format noRoleFlags = formatBuilder.build();\n  Format lessRoleFlags = formatBuilder.setRoleFlags(C.ROLE_FLAG_CAPTION).build();\n  Format moreRoleFlags =\n      formatBuilder\n          .setRoleFlags(C.ROLE_FLAG_CAPTION | C.ROLE_FLAG_COMMENTARY | C.ROLE_FLAG_DUB)\n          .build();\n  TrackGroupArray trackGroups = wrapFormats(noRoleFlags, moreRoleFlags, lessRoleFlags);\n\n  trackSelector.setParameters(\n      defaultParameters\n          .buildUpon()\n          .setPreferredAudioRoleFlags(C.ROLE_FLAG_CAPTION | C.ROLE_FLAG_COMMENTARY));\n  TrackSelectorResult result =\n      trackSelector.selectTracks(\n          new RendererCapabilities[] {ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES},\n          trackGroups,\n          periodId,\n          TIMELINE);\n  assertFixedSelection(result.selections[0], trackGroups, moreRoleFlags);\n\n    \n  trackSelector.setParameters(\n      defaultParameters.buildUpon().setPreferredAudioRoleFlags(C.ROLE_FLAG_CAPTION));\n  result =\n      trackSelector.selectTracks(\n          new RendererCapabilities[] {ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES},\n          trackGroups,\n          periodId,\n          TIMELINE);\n  assertFixedSelection(result.selections[0], trackGroups, lessRoleFlags);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "track",
            "selector",
            "will",
            "select",
            "the",
            "audio",
            "track",
            "with",
            "the",
            "highest",
            "number",
            "of",
            "matching",
            "role",
            "flags",
            "given",
            "by",
            "parameters"
        ]
    },
    {
        "id": 1621,
        "code": "public void selectTracks_withoutPreferredAudioRoleFlags_selectsDefaultTrack() throws Exception {\n  Format firstFormat = AUDIO_FORMAT;\n  Format defaultFormat =\n      AUDIO_FORMAT.buildUpon().setSelectionFlags(C.SELECTION_FLAG_DEFAULT).build();\n  Format roleFlagFormat = AUDIO_FORMAT.buildUpon().setRoleFlags(C.ROLE_FLAG_CAPTION).build();\n  TrackGroupArray trackGroups = wrapFormats(firstFormat, defaultFormat, roleFlagFormat);\n\n  TrackSelectorResult result =\n      trackSelector.selectTracks(\n          new RendererCapabilities[] {ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES},\n          trackGroups,\n          periodId,\n          TIMELINE);\n  assertFixedSelection(result.selections[0], trackGroups, defaultFormat);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "track",
            "selector",
            "with",
            "select",
            "default",
            "audio",
            "track",
            "if",
            "no",
            "role",
            "flag",
            "preference",
            "is",
            "specified",
            "by",
            "parameters"
        ]
    },
    {
        "id": 1622,
        "code": "public void selectTracks_withoutPreferredAudioRoleFlagsOrDefaultTrack_selectsFirstTrack()\n    throws Exception {\n  Format firstFormat = AUDIO_FORMAT;\n  Format roleFlagFormat = AUDIO_FORMAT.buildUpon().setRoleFlags(C.ROLE_FLAG_CAPTION).build();\n  TrackGroupArray trackGroups = wrapFormats(firstFormat, roleFlagFormat);\n\n  TrackSelectorResult result =\n      trackSelector.selectTracks(\n          new RendererCapabilities[] {ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES},\n          trackGroups,\n          periodId,\n          TIMELINE);\n  assertFixedSelection(result.selections[0], trackGroups, firstFormat);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "track",
            "selector",
            "with",
            "select",
            "the",
            "first",
            "audio",
            "track",
            "if",
            "no",
            "role",
            "flag",
            "preference",
            "is",
            "specified",
            "by",
            "parameters",
            "and",
            "no",
            "default",
            "track",
            "exists"
        ]
    },
    {
        "id": 1623,
        "code": "public void selectTracksSelectPreferredAudioLanguageOverSelectionFlag() throws Exception {\n  Format.Builder formatBuilder = AUDIO_FORMAT.buildUpon();\n  Format frDefaultFormat =\n      formatBuilder.setLanguage(\"fra\").setSelectionFlags(C.SELECTION_FLAG_DEFAULT).build();\n  Format enNonDefaultFormat = formatBuilder.setLanguage(\"eng\").setSelectionFlags(0).build();\n  TrackGroupArray trackGroups = wrapFormats(frDefaultFormat, enNonDefaultFormat);\n\n  trackSelector.setParameters(defaultParameters.buildUpon().setPreferredAudioLanguage(\"eng\"));\n  TrackSelectorResult result =\n      trackSelector.selectTracks(\n          new RendererCapabilities[] {ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES},\n          trackGroups,\n          periodId,\n          TIMELINE);\n  assertFixedSelection(result.selections[0], trackGroups, enNonDefaultFormat);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "track",
            "selector",
            "will",
            "prefer",
            "selecting",
            "audio",
            "track",
            "with",
            "language",
            "that",
            "match",
            "preferred",
            "language",
            "given",
            "by",
            "parameters",
            "over",
            "track",
            "with",
            "c",
            "selection",
            "flag",
            "default"
        ]
    },
    {
        "id": 1624,
        "code": "public void selectTracksPreferTrackWithinCapabilities() throws Exception {\n  Format.Builder formatBuilder = AUDIO_FORMAT.buildUpon();\n  Format supportedFormat = formatBuilder.setId(\"supportedFormat\").build();\n  Format exceededFormat = formatBuilder.setId(\"exceededFormat\").build();\n  TrackGroupArray trackGroups = wrapFormats(exceededFormat, supportedFormat);\n\n  Map<String, Integer> mappedCapabilities = new HashMap<>();\n  mappedCapabilities.put(supportedFormat.id, FORMAT_HANDLED);\n  mappedCapabilities.put(exceededFormat.id, FORMAT_EXCEEDS_CAPABILITIES);\n  RendererCapabilities mappedAudioRendererCapabilities =\n      new FakeMappedRendererCapabilities(C.TRACK_TYPE_AUDIO, mappedCapabilities);\n\n  TrackSelectorResult result =\n      trackSelector.selectTracks(\n          new RendererCapabilities[] {mappedAudioRendererCapabilities},\n          trackGroups,\n          periodId,\n          TIMELINE);\n  assertFixedSelection(result.selections[0], trackGroups, supportedFormat);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "track",
            "selector",
            "will",
            "prefer",
            "tracks",
            "that",
            "are",
            "within",
            "renderer",
            "s",
            "capabilities",
            "over",
            "track",
            "that",
            "exceed",
            "renderer",
            "s",
            "capabilities"
        ]
    },
    {
        "id": 1625,
        "code": "public void selectTracksWithNoTrackWithinCapabilitiesSelectExceededCapabilityTrack()\n    throws Exception {\n  TrackGroupArray trackGroups = singleTrackGroup(AUDIO_FORMAT);\n\n  TrackSelectorResult result =\n      trackSelector.selectTracks(\n          new RendererCapabilities[] {ALL_AUDIO_FORMAT_EXCEEDED_RENDERER_CAPABILITIES},\n          trackGroups,\n          periodId,\n          TIMELINE);\n  assertFixedSelection(result.selections[0], trackGroups, AUDIO_FORMAT);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "track",
            "selector",
            "will",
            "select",
            "a",
            "track",
            "that",
            "exceeds",
            "the",
            "renderer",
            "s",
            "capabilities",
            "when",
            "there",
            "are",
            "no",
            "other",
            "choice",
            "given",
            "the",
            "default",
            "parameters"
        ]
    },
    {
        "id": 1626,
        "code": "public void selectTracksWithNoTrackWithinCapabilitiesAndSetByParamsReturnNoSelection()\n    throws Exception {\n  TrackGroupArray trackGroups = singleTrackGroup(AUDIO_FORMAT);\n\n  trackSelector.setParameters(\n      defaultParameters.buildUpon().setExceedRendererCapabilitiesIfNecessary(false));\n  TrackSelectorResult result =\n      trackSelector.selectTracks(\n          new RendererCapabilities[] {ALL_AUDIO_FORMAT_EXCEEDED_RENDERER_CAPABILITIES},\n          trackGroups,\n          periodId,\n          TIMELINE);\n  assertNoSelection(result.selections[0]);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "track",
            "selector",
            "will",
            "return",
            "a",
            "null",
            "track",
            "selection",
            "for",
            "a",
            "renderer",
            "when",
            "all",
            "tracks",
            "exceed",
            "that",
            "renderer",
            "s",
            "capabilities",
            "when",
            "parameters",
            "does",
            "not",
            "allow",
            "exceeding",
            "capabilities",
            "tracks"
        ]
    },
    {
        "id": 1627,
        "code": "public void selectTracksPreferTrackWithinCapabilitiesOverSelectionFlag() throws Exception {\n  Format.Builder formatBuilder = AUDIO_FORMAT.buildUpon();\n  Format exceededWithSelectionFlagFormat =\n      formatBuilder.setId(\"exceededFormat\").setSelectionFlags(C.SELECTION_FLAG_DEFAULT).build();\n  Format supportedFormat = formatBuilder.setId(\"supportedFormat\").setSelectionFlags(0).build();\n  TrackGroupArray trackGroups = wrapFormats(exceededWithSelectionFlagFormat, supportedFormat);\n\n  Map<String, Integer> mappedCapabilities = new HashMap<>();\n  mappedCapabilities.put(supportedFormat.id, FORMAT_HANDLED);\n  mappedCapabilities.put(exceededWithSelectionFlagFormat.id, FORMAT_EXCEEDS_CAPABILITIES);\n  RendererCapabilities mappedAudioRendererCapabilities =\n      new FakeMappedRendererCapabilities(C.TRACK_TYPE_AUDIO, mappedCapabilities);\n\n  TrackSelectorResult result =\n      trackSelector.selectTracks(\n          new RendererCapabilities[] {mappedAudioRendererCapabilities},\n          trackGroups,\n          periodId,\n          TIMELINE);\n  assertFixedSelection(result.selections[0], trackGroups, supportedFormat);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "track",
            "selector",
            "will",
            "prefer",
            "tracks",
            "that",
            "are",
            "within",
            "renderer",
            "s",
            "capabilities",
            "over",
            "tracks",
            "that",
            "have",
            "c",
            "selection",
            "flag",
            "default",
            "but",
            "exceed",
            "renderer",
            "s",
            "capabilities"
        ]
    },
    {
        "id": 1628,
        "code": "public void selectTracksPreferTrackWithinCapabilitiesOverPreferredLanguage() throws Exception {\n  Format.Builder formatBuilder = AUDIO_FORMAT.buildUpon();\n  Format exceededEnFormat = formatBuilder.setId(\"exceededFormat\").setLanguage(\"eng\").build();\n  Format supportedFrFormat = formatBuilder.setId(\"supportedFormat\").setLanguage(\"fra\").build();\n  TrackGroupArray trackGroups = wrapFormats(exceededEnFormat, supportedFrFormat);\n\n  Map<String, Integer> mappedCapabilities = new HashMap<>();\n  mappedCapabilities.put(exceededEnFormat.id, FORMAT_EXCEEDS_CAPABILITIES);\n  mappedCapabilities.put(supportedFrFormat.id, FORMAT_HANDLED);\n  RendererCapabilities mappedAudioRendererCapabilities =\n      new FakeMappedRendererCapabilities(C.TRACK_TYPE_AUDIO, mappedCapabilities);\n\n  trackSelector.setParameters(defaultParameters.buildUpon().setPreferredAudioLanguage(\"eng\"));\n  TrackSelectorResult result =\n      trackSelector.selectTracks(\n          new RendererCapabilities[] {mappedAudioRendererCapabilities},\n          trackGroups,\n          periodId,\n          TIMELINE);\n  assertFixedSelection(result.selections[0], trackGroups, supportedFrFormat);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "track",
            "selector",
            "will",
            "prefer",
            "tracks",
            "that",
            "are",
            "within",
            "renderer",
            "s",
            "capabilities",
            "over",
            "track",
            "that",
            "have",
            "language",
            "matching",
            "preferred",
            "audio",
            "given",
            "by",
            "parameters",
            "but",
            "exceed",
            "renderer",
            "s",
            "capabilities"
        ]
    },
    {
        "id": 1629,
        "code": "public void selectTracksPreferTrackWithinCapabilitiesOverSelectionFlagAndPreferredLanguage()\n    throws Exception {\n  Format.Builder formatBuilder = AUDIO_FORMAT.buildUpon();\n  Format exceededDefaultSelectionEnFormat =\n      formatBuilder\n          .setId(\"exceededFormat\")\n          .setSelectionFlags(C.SELECTION_FLAG_DEFAULT)\n          .setLanguage(\"eng\")\n          .build();\n  Format supportedFrFormat =\n      formatBuilder.setId(\"supportedFormat\").setSelectionFlags(0).setLanguage(\"fra\").build();\n  TrackGroupArray trackGroups = wrapFormats(exceededDefaultSelectionEnFormat, supportedFrFormat);\n\n  Map<String, Integer> mappedCapabilities = new HashMap<>();\n  mappedCapabilities.put(exceededDefaultSelectionEnFormat.id, FORMAT_EXCEEDS_CAPABILITIES);\n  mappedCapabilities.put(supportedFrFormat.id, FORMAT_HANDLED);\n  RendererCapabilities mappedAudioRendererCapabilities =\n      new FakeMappedRendererCapabilities(C.TRACK_TYPE_AUDIO, mappedCapabilities);\n\n  trackSelector.setParameters(defaultParameters.buildUpon().setPreferredAudioLanguage(\"eng\"));\n  TrackSelectorResult result =\n      trackSelector.selectTracks(\n          new RendererCapabilities[] {mappedAudioRendererCapabilities},\n          trackGroups,\n          periodId,\n          TIMELINE);\n  assertFixedSelection(result.selections[0], trackGroups, supportedFrFormat);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "track",
            "selector",
            "will",
            "prefer",
            "tracks",
            "that",
            "are",
            "within",
            "renderer",
            "s",
            "capabilities",
            "over",
            "track",
            "that",
            "have",
            "both",
            "language",
            "matching",
            "preferred",
            "audio",
            "given",
            "by",
            "parameters",
            "and",
            "c",
            "selection",
            "flag",
            "default",
            "but",
            "exceed",
            "renderer",
            "s",
            "capabilities"
        ]
    },
    {
        "id": 1630,
        "code": "public void\n    selectTracks_audioChannelCountConstraintsDisabledAndTracksWithinCapabilities_selectHigherNumChannel()\n        throws Exception {\n  Format.Builder formatBuilder = AUDIO_FORMAT.buildUpon();\n  Format higherChannelFormat = formatBuilder.setChannelCount(6).build();\n  Format lowerChannelFormat = formatBuilder.setChannelCount(2).build();\n  TrackGroupArray trackGroups = wrapFormats(higherChannelFormat, lowerChannelFormat);\n  trackSelector.setParameters(\n      trackSelector\n          .buildUponParameters()\n          .setConstrainAudioChannelCountToDeviceCapabilities(false)\n          .build());\n\n  TrackSelectorResult result =\n      trackSelector.selectTracks(\n          new RendererCapabilities[] {ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES},\n          trackGroups,\n          periodId,\n          TIMELINE);\n  assertFixedSelection(result.selections[0], trackGroups, higherChannelFormat);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "track",
            "selector",
            "will",
            "select",
            "audio",
            "tracks",
            "with",
            "higher",
            "num",
            "channel",
            "when",
            "other",
            "factors",
            "are",
            "the",
            "same",
            "and",
            "tracks",
            "are",
            "within",
            "renderer",
            "s",
            "capabilities"
        ]
    },
    {
        "id": 1631,
        "code": "public void selectTracksWithinCapabilitiesSelectHigherSampleRate() throws Exception {\n  Format.Builder formatBuilder = AUDIO_FORMAT.buildUpon();\n  Format higherSampleRateFormat = formatBuilder.setSampleRate(44100).build();\n  Format lowerSampleRateFormat = formatBuilder.setSampleRate(22050).build();\n  TrackGroupArray trackGroups = wrapFormats(higherSampleRateFormat, lowerSampleRateFormat);\n\n  TrackSelectorResult result =\n      trackSelector.selectTracks(\n          new RendererCapabilities[] {ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES},\n          trackGroups,\n          periodId,\n          TIMELINE);\n  assertFixedSelection(result.selections[0], trackGroups, higherSampleRateFormat);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "track",
            "selector",
            "will",
            "select",
            "audio",
            "tracks",
            "with",
            "higher",
            "sample",
            "rate",
            "when",
            "other",
            "factors",
            "are",
            "the",
            "same",
            "and",
            "tracks",
            "are",
            "within",
            "renderer",
            "s",
            "capabilities"
        ]
    },
    {
        "id": 1632,
        "code": "public void selectAudioTracks_withinCapabilities_andSameLanguage_selectsHigherBitrate()\n    throws Exception {\n  Format.Builder formatBuilder = AUDIO_FORMAT.buildUpon().setLanguage(\"en\");\n  Format lowerBitrateFormat = formatBuilder.setAverageBitrate(15000).build();\n  Format higherBitrateFormat = formatBuilder.setAverageBitrate(30000).build();\n  TrackGroupArray trackGroups = wrapFormats(lowerBitrateFormat, higherBitrateFormat);\n\n  TrackSelectorResult result =\n      trackSelector.selectTracks(\n          new RendererCapabilities[] {ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES},\n          trackGroups,\n          periodId,\n          TIMELINE);\n  assertFixedSelection(result.selections[0], trackGroups, higherBitrateFormat);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "track",
            "selector",
            "will",
            "select",
            "audio",
            "tracks",
            "with",
            "higher",
            "bit",
            "rate",
            "when",
            "other",
            "factors",
            "are",
            "the",
            "same",
            "and",
            "tracks",
            "are",
            "within",
            "renderer",
            "s",
            "capabilities",
            "and",
            "have",
            "the",
            "same",
            "language"
        ]
    },
    {
        "id": 1633,
        "code": "public void selectAudioTracks_withinCapabilities_andDifferentLanguage_selectsFirstTrack()\n    throws Exception {\n  Format.Builder formatBuilder = AUDIO_FORMAT.buildUpon();\n  Format firstLanguageFormat = formatBuilder.setAverageBitrate(15000).setLanguage(\"hi\").build();\n  Format higherBitrateFormat = formatBuilder.setAverageBitrate(30000).setLanguage(\"te\").build();\n  TrackGroupArray trackGroups = wrapFormats(firstLanguageFormat, higherBitrateFormat);\n\n  TrackSelectorResult result =\n      trackSelector.selectTracks(\n          new RendererCapabilities[] {ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES},\n          trackGroups,\n          periodId,\n          TIMELINE);\n  assertFixedSelection(result.selections[0], trackGroups, firstLanguageFormat);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "track",
            "selector",
            "will",
            "select",
            "the",
            "first",
            "audio",
            "track",
            "even",
            "if",
            "other",
            "tracks",
            "with",
            "a",
            "different",
            "language",
            "have",
            "higher",
            "bit",
            "rates",
            "all",
            "other",
            "factors",
            "are",
            "the",
            "same",
            "and",
            "tracks",
            "are",
            "within",
            "renderer",
            "s",
            "capabilities"
        ]
    },
    {
        "id": 1634,
        "code": "public void\n    selectTracks_audioChannelCountConstraintsDisabled_preferHigherNumChannelBeforeSampleRate()\n        throws Exception {\n  Format.Builder formatBuilder = AUDIO_FORMAT.buildUpon();\n  Format higherChannelLowerSampleRateFormat =\n      formatBuilder.setChannelCount(6).setSampleRate(22050).build();\n  Format lowerChannelHigherSampleRateFormat =\n      formatBuilder.setChannelCount(2).setSampleRate(44100).build();\n  TrackGroupArray trackGroups =\n      wrapFormats(higherChannelLowerSampleRateFormat, lowerChannelHigherSampleRateFormat);\n  trackSelector.setParameters(\n      trackSelector\n          .buildUponParameters()\n          .setConstrainAudioChannelCountToDeviceCapabilities(false)\n          .build());\n\n  TrackSelectorResult result =\n      trackSelector.selectTracks(\n          new RendererCapabilities[] {ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES},\n          trackGroups,\n          periodId,\n          TIMELINE);\n  assertFixedSelection(result.selections[0], trackGroups, higherChannelLowerSampleRateFormat);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "track",
            "selector",
            "will",
            "prefer",
            "audio",
            "tracks",
            "with",
            "higher",
            "channel",
            "count",
            "over",
            "tracks",
            "with",
            "higher",
            "sample",
            "rate",
            "when",
            "audio",
            "channel",
            "count",
            "constraints",
            "are",
            "disabled",
            "other",
            "factors",
            "are",
            "the",
            "same",
            "and",
            "tracks",
            "are",
            "within",
            "renderer",
            "s",
            "capabilities"
        ]
    },
    {
        "id": 1635,
        "code": "public void selectTracksPreferHigherSampleRateBeforeBitrate() throws Exception {\n  Format.Builder formatBuilder = AUDIO_FORMAT.buildUpon();\n  Format higherSampleRateLowerBitrateFormat =\n      formatBuilder.setAverageBitrate(15000).setSampleRate(44100).build();\n  Format lowerSampleRateHigherBitrateFormat =\n      formatBuilder.setAverageBitrate(30000).setSampleRate(22050).build();\n  TrackGroupArray trackGroups =\n      wrapFormats(higherSampleRateLowerBitrateFormat, lowerSampleRateHigherBitrateFormat);\n\n  TrackSelectorResult result =\n      trackSelector.selectTracks(\n          new RendererCapabilities[] {ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES},\n          trackGroups,\n          periodId,\n          TIMELINE);\n  assertFixedSelection(result.selections[0], trackGroups, higherSampleRateLowerBitrateFormat);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "track",
            "selector",
            "will",
            "prefer",
            "audio",
            "tracks",
            "with",
            "higher",
            "sample",
            "rate",
            "over",
            "tracks",
            "with",
            "higher",
            "bitrate",
            "when",
            "other",
            "factors",
            "are",
            "the",
            "same",
            "and",
            "tracks",
            "are",
            "within",
            "renderer",
            "s",
            "capabilities"
        ]
    },
    {
        "id": 1636,
        "code": "public void selectTracksExceedingCapabilitiesSelectLowerNumChannel() throws Exception {\n  Format.Builder formatBuilder = AUDIO_FORMAT.buildUpon();\n  Format higherChannelFormat = formatBuilder.setChannelCount(6).build();\n  Format lowerChannelFormat = formatBuilder.setChannelCount(2).build();\n  TrackGroupArray trackGroups = wrapFormats(higherChannelFormat, lowerChannelFormat);\n\n  TrackSelectorResult result =\n      trackSelector.selectTracks(\n          new RendererCapabilities[] {ALL_AUDIO_FORMAT_EXCEEDED_RENDERER_CAPABILITIES},\n          trackGroups,\n          periodId,\n          TIMELINE);\n  assertFixedSelection(result.selections[0], trackGroups, lowerChannelFormat);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "track",
            "selector",
            "will",
            "select",
            "audio",
            "tracks",
            "with",
            "lower",
            "num",
            "channel",
            "when",
            "other",
            "factors",
            "are",
            "the",
            "same",
            "and",
            "tracks",
            "exceed",
            "renderer",
            "s",
            "capabilities"
        ]
    },
    {
        "id": 1637,
        "code": "public void selectTracksExceedingCapabilitiesSelectLowerSampleRate() throws Exception {\n  Format.Builder formatBuilder = AUDIO_FORMAT.buildUpon();\n  Format lowerSampleRateFormat = formatBuilder.setSampleRate(22050).build();\n  Format higherSampleRateFormat = formatBuilder.setSampleRate(44100).build();\n  TrackGroupArray trackGroups = wrapFormats(higherSampleRateFormat, lowerSampleRateFormat);\n\n  TrackSelectorResult result =\n      trackSelector.selectTracks(\n          new RendererCapabilities[] {ALL_AUDIO_FORMAT_EXCEEDED_RENDERER_CAPABILITIES},\n          trackGroups,\n          periodId,\n          TIMELINE);\n  assertFixedSelection(result.selections[0], trackGroups, lowerSampleRateFormat);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "track",
            "selector",
            "will",
            "select",
            "audio",
            "tracks",
            "with",
            "lower",
            "sample",
            "rate",
            "when",
            "other",
            "factors",
            "are",
            "the",
            "same",
            "and",
            "tracks",
            "exceed",
            "renderer",
            "s",
            "capabilities"
        ]
    },
    {
        "id": 1638,
        "code": "public void selectTracksExceedingCapabilitiesSelectLowerBitrate() throws Exception {\n  Format.Builder formatBuilder = AUDIO_FORMAT.buildUpon();\n  Format lowerBitrateFormat = formatBuilder.setAverageBitrate(15000).build();\n  Format higherBitrateFormat = formatBuilder.setAverageBitrate(30000).build();\n  TrackGroupArray trackGroups = wrapFormats(lowerBitrateFormat, higherBitrateFormat);\n\n  TrackSelectorResult result =\n      trackSelector.selectTracks(\n          new RendererCapabilities[] {ALL_AUDIO_FORMAT_EXCEEDED_RENDERER_CAPABILITIES},\n          trackGroups,\n          periodId,\n          TIMELINE);\n  assertFixedSelection(result.selections[0], trackGroups, lowerBitrateFormat);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "track",
            "selector",
            "will",
            "select",
            "audio",
            "tracks",
            "with",
            "lower",
            "bit",
            "rate",
            "when",
            "other",
            "factors",
            "are",
            "the",
            "same",
            "and",
            "tracks",
            "exceed",
            "renderer",
            "s",
            "capabilities"
        ]
    },
    {
        "id": 1639,
        "code": "public void selectTracksExceedingCapabilitiesPreferLowerNumChannelBeforeSampleRate()\n    throws Exception {\n  Format.Builder formatBuilder = AUDIO_FORMAT.buildUpon();\n  Format lowerChannelHigherSampleRateFormat =\n      formatBuilder.setChannelCount(2).setSampleRate(44100).build();\n  Format higherChannelLowerSampleRateFormat =\n      formatBuilder.setChannelCount(6).setSampleRate(22050).build();\n  TrackGroupArray trackGroups =\n      wrapFormats(higherChannelLowerSampleRateFormat, lowerChannelHigherSampleRateFormat);\n\n  TrackSelectorResult result =\n      trackSelector.selectTracks(\n          new RendererCapabilities[] {ALL_AUDIO_FORMAT_EXCEEDED_RENDERER_CAPABILITIES},\n          trackGroups,\n          periodId,\n          TIMELINE);\n  assertFixedSelection(result.selections[0], trackGroups, lowerChannelHigherSampleRateFormat);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "track",
            "selector",
            "will",
            "prefer",
            "audio",
            "tracks",
            "with",
            "lower",
            "channel",
            "count",
            "over",
            "tracks",
            "with",
            "lower",
            "sample",
            "rate",
            "when",
            "other",
            "factors",
            "are",
            "the",
            "same",
            "and",
            "tracks",
            "are",
            "within",
            "renderer",
            "s",
            "capabilities"
        ]
    },
    {
        "id": 1640,
        "code": "public void selectTracksExceedingCapabilitiesPreferLowerSampleRateBeforeBitrate()\n    throws Exception {\n  Format.Builder formatBuilder = AUDIO_FORMAT.buildUpon();\n  Format higherSampleRateLowerBitrateFormat =\n      formatBuilder.setAverageBitrate(15000).setSampleRate(44100).build();\n  Format lowerSampleRateHigherBitrateFormat =\n      formatBuilder.setAverageBitrate(30000).setSampleRate(22050).build();\n  TrackGroupArray trackGroups =\n      wrapFormats(higherSampleRateLowerBitrateFormat, lowerSampleRateHigherBitrateFormat);\n\n  TrackSelectorResult result =\n      trackSelector.selectTracks(\n          new RendererCapabilities[] {ALL_AUDIO_FORMAT_EXCEEDED_RENDERER_CAPABILITIES},\n          trackGroups,\n          periodId,\n          TIMELINE);\n  assertFixedSelection(result.selections[0], trackGroups, lowerSampleRateHigherBitrateFormat);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "track",
            "selector",
            "will",
            "prefer",
            "audio",
            "tracks",
            "with",
            "lower",
            "sample",
            "rate",
            "over",
            "tracks",
            "with",
            "lower",
            "bitrate",
            "when",
            "other",
            "factors",
            "are",
            "the",
            "same",
            "and",
            "tracks",
            "are",
            "within",
            "renderer",
            "s",
            "capabilities"
        ]
    },
    {
        "id": 1641,
        "code": "public void textTrackSelectionFlags() throws ExoPlaybackException {\n  Format.Builder formatBuilder = TEXT_FORMAT.buildUpon().setLanguage(\"eng\");\n  Format forcedOnly = formatBuilder.setSelectionFlags(C.SELECTION_FLAG_FORCED).build();\n  Format forcedDefault =\n      formatBuilder.setSelectionFlags(C.SELECTION_FLAG_FORCED | C.SELECTION_FLAG_DEFAULT).build();\n  Format defaultOnly = formatBuilder.setSelectionFlags(C.SELECTION_FLAG_DEFAULT).build();\n  Format noFlag = formatBuilder.setSelectionFlags(0).build();\n\n  RendererCapabilities[] textRendererCapabilities =\n      new RendererCapabilities[] {ALL_TEXT_FORMAT_SUPPORTED_RENDERER_CAPABILITIES};\n\n    \n  TrackGroupArray trackGroups = wrapFormats(forcedOnly, forcedDefault, defaultOnly, noFlag);\n  TrackSelectorResult result =\n      trackSelector.selectTracks(textRendererCapabilities, trackGroups, periodId, TIMELINE);\n  assertFixedSelection(result.selections[0], trackGroups, forcedDefault);\n\n    \n  trackGroups = wrapFormats(forcedOnly, noFlag, defaultOnly);\n  result = trackSelector.selectTracks(textRendererCapabilities, trackGroups, periodId, TIMELINE);\n  assertFixedSelection(result.selections[0], trackGroups, defaultOnly);\n\n    \n    \n  trackGroups = wrapFormats(defaultOnly, noFlag, forcedOnly, forcedDefault);\n  trackSelector.setParameters(\n      defaultParameters.buildUpon().setIgnoredTextSelectionFlags(C.SELECTION_FLAG_DEFAULT));\n  result = trackSelector.selectTracks(textRendererCapabilities, trackGroups, periodId, TIMELINE);\n  assertNoSelection(result.selections[0]);\n\n    \n    \n  trackGroups = wrapFormats(forcedOnly, forcedDefault, defaultOnly, noFlag);\n  trackSelector.setParameters(\n      trackSelector\n          .getParameters()\n          .buildUpon()\n          .setIgnoredTextSelectionFlags(C.SELECTION_FLAG_DEFAULT | C.SELECTION_FLAG_FORCED));\n  result = trackSelector.selectTracks(textRendererCapabilities, trackGroups, periodId, TIMELINE);\n  assertNoSelection(result.selections[0]);\n\n    \n    \n  trackSelector.setParameters(defaultParameters.buildUpon().setPreferredTextLanguage(\"eng\"));\n  result = trackSelector.selectTracks(textRendererCapabilities, trackGroups, periodId, TIMELINE);\n  assertFixedSelection(result.selections[0], trackGroups, defaultOnly);\n\n    \n    \n    \n  trackGroups = wrapFormats(noFlag, forcedOnly, forcedDefault, defaultOnly);\n  trackSelector.setParameters(\n      trackSelector\n          .getParameters()\n          .buildUpon()\n          .setIgnoredTextSelectionFlags(C.SELECTION_FLAG_DEFAULT));\n  result = trackSelector.selectTracks(textRendererCapabilities, trackGroups, periodId, TIMELINE);\n  assertFixedSelection(result.selections[0], trackGroups, noFlag);\n}",
        "summary_tokens": [
            "tests",
            "text",
            "track",
            "selection",
            "flags"
        ]
    },
    {
        "id": 1642,
        "code": "public void forcedAndDefaultTextTracksInteractWithSelectedAudioLanguageAsExpected()\n    throws ExoPlaybackException {\n  Format.Builder forcedTextBuilder =\n      TEXT_FORMAT.buildUpon().setSelectionFlags(C.SELECTION_FLAG_FORCED);\n  Format.Builder defaultTextBuilder =\n      TEXT_FORMAT.buildUpon().setSelectionFlags(C.SELECTION_FLAG_DEFAULT);\n  Format forcedEnglish = forcedTextBuilder.setLanguage(\"eng\").build();\n  Format defaultEnglish = defaultTextBuilder.setLanguage(\"eng\").build();\n  Format forcedGerman = forcedTextBuilder.setLanguage(\"deu\").build();\n  Format defaultGerman = defaultTextBuilder.setLanguage(\"deu\").build();\n  Format forcedNoLanguage = forcedTextBuilder.setLanguage(C.LANGUAGE_UNDETERMINED).build();\n\n  Format noLanguageAudio = AUDIO_FORMAT.buildUpon().setLanguage(null).build();\n  Format germanAudio = AUDIO_FORMAT.buildUpon().setLanguage(\"deu\").build();\n\n  RendererCapabilities[] rendererCapabilities =\n      new RendererCapabilities[] {\n        ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES,\n        ALL_TEXT_FORMAT_SUPPORTED_RENDERER_CAPABILITIES\n      };\n\n    \n    \n  TrackGroupArray trackGroups = wrapFormats(noLanguageAudio, forcedNoLanguage);\n  TrackSelectorResult result =\n      trackSelector.selectTracks(rendererCapabilities, trackGroups, periodId, TIMELINE);\n  assertFixedSelection(result.selections[1], trackGroups, forcedNoLanguage);\n\n    \n    \n  trackGroups = wrapFormats(noLanguageAudio, forcedEnglish, forcedGerman);\n  result = trackSelector.selectTracks(rendererCapabilities, trackGroups, periodId, TIMELINE);\n  assertNoSelection(result.selections[1]);\n\n    \n  trackGroups = wrapFormats(germanAudio, forcedGerman, forcedEnglish);\n  result = trackSelector.selectTracks(rendererCapabilities, trackGroups, periodId, TIMELINE);\n  assertFixedSelection(result.selections[1], trackGroups, forcedGerman);\n\n    \n  trackGroups = wrapFormats(germanAudio, forcedEnglish, forcedGerman);\n  result = trackSelector.selectTracks(rendererCapabilities, trackGroups, periodId, TIMELINE);\n  assertFixedSelection(result.selections[1], trackGroups, forcedGerman);\n\n    \n    \n  trackGroups =\n      wrapFormats(germanAudio, forcedGerman, defaultGerman, forcedEnglish, defaultEnglish);\n  result = trackSelector.selectTracks(rendererCapabilities, trackGroups, periodId, TIMELINE);\n  assertFixedSelection(result.selections[1], trackGroups, defaultGerman);\n\n    \n    \n  trackGroups = wrapFormats(germanAudio, forcedGerman, forcedEnglish, defaultEnglish);\n  result = trackSelector.selectTracks(rendererCapabilities, trackGroups, periodId, TIMELINE);\n  assertFixedSelection(result.selections[1], trackGroups, defaultEnglish);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "the",
            "default",
            "track",
            "selector",
            "will",
            "select"
        ]
    },
    {
        "id": 1643,
        "code": "public void selectUndeterminedTextLanguageAsFallback() throws ExoPlaybackException {\n  Format.Builder formatBuilder = TEXT_FORMAT.buildUpon();\n  Format spanish = formatBuilder.setLanguage(\"spa\").build();\n  Format german = formatBuilder.setLanguage(\"de\").build();\n  Format undeterminedUnd = formatBuilder.setLanguage(C.LANGUAGE_UNDETERMINED).build();\n  Format undeterminedNull = formatBuilder.setLanguage(null).build();\n\n  RendererCapabilities[] textRendererCapabilites =\n      new RendererCapabilities[] {ALL_TEXT_FORMAT_SUPPORTED_RENDERER_CAPABILITIES};\n\n  TrackGroupArray trackGroups = wrapFormats(spanish, german, undeterminedUnd, undeterminedNull);\n  TrackSelectorResult result =\n      trackSelector.selectTracks(textRendererCapabilites, trackGroups, periodId, TIMELINE);\n  assertNoSelection(result.selections[0]);\n\n  trackSelector.setParameters(\n      defaultParameters.buildUpon().setSelectUndeterminedTextLanguage(true));\n  result = trackSelector.selectTracks(textRendererCapabilites, trackGroups, periodId, TIMELINE);\n  assertFixedSelection(result.selections[0], trackGroups, undeterminedUnd);\n\n  Parameters.Builder builder = defaultParameters.buildUpon().setPreferredTextLanguage(\"spa\");\n  trackSelector.setParameters(builder);\n  result = trackSelector.selectTracks(textRendererCapabilites, trackGroups, periodId, TIMELINE);\n  assertFixedSelection(result.selections[0], trackGroups, spanish);\n\n  trackGroups = wrapFormats(german, undeterminedUnd, undeterminedNull);\n\n  result = trackSelector.selectTracks(textRendererCapabilites, trackGroups, periodId, TIMELINE);\n  assertNoSelection(result.selections[0]);\n\n  trackSelector.setParameters(builder.setSelectUndeterminedTextLanguage(true));\n  result = trackSelector.selectTracks(textRendererCapabilites, trackGroups, periodId, TIMELINE);\n  assertFixedSelection(result.selections[0], trackGroups, undeterminedUnd);\n\n  trackGroups = wrapFormats(german, undeterminedNull);\n  result = trackSelector.selectTracks(textRendererCapabilites, trackGroups, periodId, TIMELINE);\n  assertFixedSelection(result.selections[0], trackGroups, undeterminedNull);\n\n  trackGroups = wrapFormats(german);\n  result = trackSelector.selectTracks(textRendererCapabilites, trackGroups, periodId, TIMELINE);\n  assertNoSelection(result.selections[0]);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "the",
            "default",
            "track",
            "selector",
            "will",
            "select",
            "a",
            "text",
            "track",
            "with",
            "undetermined",
            "language",
            "if",
            "no",
            "text",
            "track",
            "with",
            "the",
            "preferred",
            "language",
            "is",
            "available",
            "but",
            "parameters",
            "select",
            "undetermined",
            "text",
            "language",
            "is",
            "true"
        ]
    },
    {
        "id": 1644,
        "code": "public void selectPreferredTextTrackMultipleRenderers() throws Exception {\n  Format.Builder formatBuilder = TEXT_FORMAT.buildUpon();\n  Format english = formatBuilder.setId(\"en\").setLanguage(\"en\").build();\n  Format german = formatBuilder.setId(\"de\").setLanguage(\"de\").build();\n\n    \n  Map<String, Integer> firstRendererMappedCapabilities = new HashMap<>();\n  firstRendererMappedCapabilities.put(english.id, FORMAT_HANDLED);\n  firstRendererMappedCapabilities.put(german.id, FORMAT_UNSUPPORTED_SUBTYPE);\n  RendererCapabilities firstRendererCapabilities =\n      new FakeMappedRendererCapabilities(C.TRACK_TYPE_TEXT, firstRendererMappedCapabilities);\n\n    \n  Map<String, Integer> secondRendererMappedCapabilities = new HashMap<>();\n  secondRendererMappedCapabilities.put(english.id, FORMAT_UNSUPPORTED_SUBTYPE);\n  secondRendererMappedCapabilities.put(german.id, FORMAT_HANDLED);\n  RendererCapabilities secondRendererCapabilities =\n      new FakeMappedRendererCapabilities(C.TRACK_TYPE_TEXT, secondRendererMappedCapabilities);\n\n  RendererCapabilities[] rendererCapabilities =\n      new RendererCapabilities[] {firstRendererCapabilities, secondRendererCapabilities};\n  TrackGroupArray trackGroups = wrapFormats(english, german);\n\n    \n  TrackSelectorResult result =\n      trackSelector.selectTracks(rendererCapabilities, trackGroups, periodId, TIMELINE);\n  assertNoSelection(result.selections[0]);\n  assertNoSelection(result.selections[1]);\n\n    \n  trackSelector.setParameters(defaultParameters.buildUpon().setPreferredTextLanguage(\"en\"));\n  result = trackSelector.selectTracks(rendererCapabilities, trackGroups, periodId, TIMELINE);\n  assertFixedSelection(result.selections[0], trackGroups, english);\n  assertNoSelection(result.selections[1]);\n\n    \n  trackSelector.setParameters(defaultParameters.buildUpon().setPreferredTextLanguage(\"de\"));\n  result = trackSelector.selectTracks(rendererCapabilities, trackGroups, periodId, TIMELINE);\n  assertNoSelection(result.selections[0]);\n  assertFixedSelection(result.selections[1], trackGroups, german);\n}",
        "summary_tokens": [
            "tests",
            "audio",
            "track",
            "selection",
            "when",
            "there",
            "are",
            "multiple",
            "audio",
            "renderers"
        ]
    },
    {
        "id": 1645,
        "code": "public void selectTracks_withPreferredTextRoleFlags_selectPreferredTrack() throws Exception {\n  Format.Builder formatBuilder = TEXT_FORMAT.buildUpon();\n  Format noRoleFlags = formatBuilder.build();\n  Format lessRoleFlags = formatBuilder.setRoleFlags(C.ROLE_FLAG_CAPTION).build();\n  Format moreRoleFlags =\n      formatBuilder\n          .setRoleFlags(C.ROLE_FLAG_CAPTION | C.ROLE_FLAG_COMMENTARY | C.ROLE_FLAG_DUB)\n          .build();\n  TrackGroupArray trackGroups = wrapFormats(noRoleFlags, moreRoleFlags, lessRoleFlags);\n\n  trackSelector.setParameters(\n      defaultParameters\n          .buildUpon()\n          .setPreferredTextRoleFlags(C.ROLE_FLAG_CAPTION | C.ROLE_FLAG_COMMENTARY));\n  TrackSelectorResult result =\n      trackSelector.selectTracks(\n          new RendererCapabilities[] {ALL_TEXT_FORMAT_SUPPORTED_RENDERER_CAPABILITIES},\n          trackGroups,\n          periodId,\n          TIMELINE);\n  assertFixedSelection(result.selections[0], trackGroups, moreRoleFlags);\n\n    \n  trackSelector.setParameters(\n      defaultParameters.buildUpon().setPreferredTextRoleFlags(C.ROLE_FLAG_CAPTION));\n  result =\n      trackSelector.selectTracks(\n          new RendererCapabilities[] {ALL_TEXT_FORMAT_SUPPORTED_RENDERER_CAPABILITIES},\n          trackGroups,\n          periodId,\n          TIMELINE);\n  assertFixedSelection(result.selections[0], trackGroups, lessRoleFlags);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "track",
            "selector",
            "will",
            "select",
            "the",
            "text",
            "track",
            "with",
            "the",
            "highest",
            "number",
            "of",
            "matching",
            "role",
            "flags",
            "given",
            "by",
            "parameters"
        ]
    },
    {
        "id": 1646,
        "code": "public void selectTracksWithinCapabilitiesAndForceLowestBitrateSelectLowerBitrate()\n    throws Exception {\n  Format.Builder formatBuilder = AUDIO_FORMAT.buildUpon();\n  Format unsupportedLowBitrateFormat =\n      formatBuilder.setId(\"unsupported\").setAverageBitrate(5000).build();\n  Format lowerBitrateFormat = formatBuilder.setId(\"lower\").setAverageBitrate(15000).build();\n  Format higherBitrateFormat = formatBuilder.setId(\"higher\").setAverageBitrate(30000).build();\n  TrackGroupArray trackGroups =\n      wrapFormats(unsupportedLowBitrateFormat, lowerBitrateFormat, higherBitrateFormat);\n\n  Map<String, Integer> mappedCapabilities = new HashMap<>();\n  mappedCapabilities.put(unsupportedLowBitrateFormat.id, FORMAT_EXCEEDS_CAPABILITIES);\n  mappedCapabilities.put(lowerBitrateFormat.id, FORMAT_HANDLED);\n  mappedCapabilities.put(higherBitrateFormat.id, FORMAT_HANDLED);\n  RendererCapabilities mappedAudioRendererCapabilities =\n      new FakeMappedRendererCapabilities(C.TRACK_TYPE_AUDIO, mappedCapabilities);\n\n  trackSelector.setParameters(defaultParameters.buildUpon().setForceLowestBitrate(true));\n  TrackSelectorResult result =\n      trackSelector.selectTracks(\n          new RendererCapabilities[] {mappedAudioRendererCapabilities},\n          trackGroups,\n          periodId,\n          TIMELINE);\n  assertFixedSelection(result.selections[0], trackGroups, lowerBitrateFormat);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "track",
            "selector",
            "will",
            "select",
            "the",
            "lowest",
            "bitrate",
            "supported",
            "audio",
            "track",
            "when",
            "parameters",
            "force",
            "lowest",
            "bitrate",
            "is",
            "set"
        ]
    },
    {
        "id": 1647,
        "code": "public void selectTracksWithinCapabilitiesAndForceHighestBitrateSelectHigherBitrate()\n    throws Exception {\n  Format.Builder formatBuilder = AUDIO_FORMAT.buildUpon();\n  Format lowerBitrateFormat = formatBuilder.setId(\"5000\").setAverageBitrate(5000).build();\n  Format higherBitrateFormat = formatBuilder.setId(\"15000\").setAverageBitrate(15000).build();\n  Format exceedsBitrateFormat = formatBuilder.setId(\"30000\").setAverageBitrate(30000).build();\n  TrackGroupArray trackGroups =\n      wrapFormats(lowerBitrateFormat, higherBitrateFormat, exceedsBitrateFormat);\n\n  Map<String, Integer> mappedCapabilities = new HashMap<>();\n  mappedCapabilities.put(lowerBitrateFormat.id, FORMAT_HANDLED);\n  mappedCapabilities.put(higherBitrateFormat.id, FORMAT_HANDLED);\n  mappedCapabilities.put(exceedsBitrateFormat.id, FORMAT_EXCEEDS_CAPABILITIES);\n  RendererCapabilities mappedAudioRendererCapabilities =\n      new FakeMappedRendererCapabilities(C.TRACK_TYPE_AUDIO, mappedCapabilities);\n\n  trackSelector.setParameters(\n      defaultParameters.buildUpon().setForceHighestSupportedBitrate(true));\n  TrackSelectorResult result =\n      trackSelector.selectTracks(\n          new RendererCapabilities[] {mappedAudioRendererCapabilities},\n          trackGroups,\n          periodId,\n          TIMELINE);\n  assertFixedSelection(result.selections[0], trackGroups, higherBitrateFormat);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "track",
            "selector",
            "will",
            "select",
            "the",
            "highest",
            "bitrate",
            "supported",
            "audio",
            "track",
            "when",
            "parameters",
            "force",
            "highest",
            "supported",
            "bitrate",
            "is",
            "set"
        ]
    },
    {
        "id": 1648,
        "code": "public void selectTracks_stereoAndMultichannelAACTracks_selectsStereo()\n    throws ExoPlaybackException {\n  Format stereoAudioFormat = AUDIO_FORMAT.buildUpon().setChannelCount(2).setId(\"0\").build();\n  Format multichannelAudioFormat = AUDIO_FORMAT.buildUpon().setChannelCount(6).setId(\"1\").build();\n  TrackGroupArray trackGroups = singleTrackGroup(stereoAudioFormat, multichannelAudioFormat);\n\n  TrackSelectorResult result =\n      trackSelector.selectTracks(\n          new RendererCapabilities[] {AUDIO_CAPABILITIES}, trackGroups, periodId, TIMELINE);\n\n  assertThat(result.length).isEqualTo(1);\n  assertThat(result.selections[0].getSelectedFormat()).isSameInstanceAs(stereoAudioFormat);\n}",
        "summary_tokens": [
            "the",
            "following",
            "test",
            "is",
            "subject",
            "to",
            "the",
            "execution",
            "context"
        ]
    },
    {
        "id": 1649,
        "code": "public void\n    selectTracks_withAACStereoAndDolbyMultichannelTrackWithinCapabilities_selectsDolbyMultichannelTrack()\n        throws ExoPlaybackException {\n  Format stereoAudioFormat = AUDIO_FORMAT.buildUpon().setChannelCount(2).setId(\"0\").build();\n  Format multichannelAudioFormat =\n      AUDIO_FORMAT\n          .buildUpon()\n          .setSampleMimeType(MimeTypes.AUDIO_AC3)\n          .setChannelCount(6)\n          .setId(\"1\")\n          .build();\n  TrackGroupArray trackGroups = singleTrackGroup(stereoAudioFormat, multichannelAudioFormat);\n\n  TrackSelectorResult result =\n      trackSelector.selectTracks(\n          new RendererCapabilities[] {AUDIO_CAPABILITIES}, trackGroups, periodId, TIMELINE);\n\n  assertThat(result.length).isEqualTo(1);\n  assertThat(result.selections[0].getSelectedFormat()).isSameInstanceAs(multichannelAudioFormat);\n}",
        "summary_tokens": [
            "the",
            "following",
            "test",
            "is",
            "subject",
            "to",
            "the",
            "execution",
            "context"
        ]
    },
    {
        "id": 1650,
        "code": "public void selectPreferredAudioTrackMultipleRenderers() throws Exception {\n  Format.Builder formatBuilder = AUDIO_FORMAT.buildUpon();\n  Format english = formatBuilder.setId(\"en\").setLanguage(\"en\").build();\n  Format german = formatBuilder.setId(\"de\").setLanguage(\"de\").build();\n\n    \n  Map<String, Integer> firstRendererMappedCapabilities = new HashMap<>();\n  firstRendererMappedCapabilities.put(english.id, FORMAT_HANDLED);\n  firstRendererMappedCapabilities.put(german.id, FORMAT_UNSUPPORTED_SUBTYPE);\n  RendererCapabilities firstRendererCapabilities =\n      new FakeMappedRendererCapabilities(C.TRACK_TYPE_AUDIO, firstRendererMappedCapabilities);\n\n    \n  Map<String, Integer> secondRendererMappedCapabilities = new HashMap<>();\n  secondRendererMappedCapabilities.put(english.id, FORMAT_UNSUPPORTED_SUBTYPE);\n  secondRendererMappedCapabilities.put(german.id, FORMAT_HANDLED);\n  RendererCapabilities secondRendererCapabilities =\n      new FakeMappedRendererCapabilities(C.TRACK_TYPE_AUDIO, secondRendererMappedCapabilities);\n\n  RendererCapabilities[] rendererCapabilities =\n      new RendererCapabilities[] {firstRendererCapabilities, secondRendererCapabilities};\n\n    \n  TrackGroupArray trackGroups = wrapFormats(english, german);\n  TrackSelectorResult result =\n      trackSelector.selectTracks(rendererCapabilities, trackGroups, periodId, TIMELINE);\n  assertFixedSelection(result.selections[0], trackGroups, english);\n  assertNoSelection(result.selections[1]);\n\n    \n  trackSelector.setParameters(defaultParameters.buildUpon().setPreferredAudioLanguage(\"en\"));\n  result = trackSelector.selectTracks(rendererCapabilities, trackGroups, periodId, TIMELINE);\n  assertFixedSelection(result.selections[0], trackGroups, english);\n  assertNoSelection(result.selections[1]);\n\n    \n  trackSelector.setParameters(defaultParameters.buildUpon().setPreferredAudioLanguage(\"de\"));\n  result = trackSelector.selectTracks(rendererCapabilities, trackGroups, periodId, TIMELINE);\n  assertNoSelection(result.selections[0]);\n  assertFixedSelection(result.selections[1], trackGroups, german);\n}",
        "summary_tokens": [
            "tests",
            "audio",
            "track",
            "selection",
            "when",
            "there",
            "are",
            "multiple",
            "audio",
            "renderers"
        ]
    },
    {
        "id": 1651,
        "code": "public void selectTracks_withPreferredVideoRoleFlags_selectPreferredTrack() throws Exception {\n  Format.Builder formatBuilder = VIDEO_FORMAT.buildUpon();\n  Format noRoleFlagsLow = formatBuilder.setAverageBitrate(4000).build();\n  Format noRoleFlagsHigh = formatBuilder.setAverageBitrate(8000).build();\n  Format lessRoleFlags = formatBuilder.setRoleFlags(C.ROLE_FLAG_CAPTION).build();\n  Format moreRoleFlags =\n      formatBuilder\n          .setRoleFlags(C.ROLE_FLAG_CAPTION | C.ROLE_FLAG_COMMENTARY | C.ROLE_FLAG_DUB)\n          .build();\n    \n  TrackGroup adaptiveNoRoleFlagsGroup = new TrackGroup(noRoleFlagsLow, noRoleFlagsHigh);\n  TrackGroupArray trackGroups =\n      new TrackGroupArray(\n          adaptiveNoRoleFlagsGroup, new TrackGroup(moreRoleFlags), new TrackGroup(lessRoleFlags));\n\n  trackSelector.setParameters(\n      defaultParameters\n          .buildUpon()\n          .setPreferredVideoRoleFlags(C.ROLE_FLAG_CAPTION | C.ROLE_FLAG_COMMENTARY));\n  TrackSelectorResult result =\n      trackSelector.selectTracks(\n          new RendererCapabilities[] {VIDEO_CAPABILITIES}, trackGroups, periodId, TIMELINE);\n  assertFixedSelection(result.selections[0], trackGroups, moreRoleFlags);\n\n    \n  trackSelector.setParameters(\n      defaultParameters.buildUpon().setPreferredVideoRoleFlags(C.ROLE_FLAG_CAPTION));\n  result =\n      trackSelector.selectTracks(\n          new RendererCapabilities[] {VIDEO_CAPABILITIES}, trackGroups, periodId, TIMELINE);\n  assertFixedSelection(result.selections[0], trackGroups, lessRoleFlags);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "track",
            "selector",
            "will",
            "select",
            "the",
            "video",
            "track",
            "with",
            "the",
            "highest",
            "number",
            "of",
            "matching",
            "role",
            "flags",
            "given",
            "by",
            "parameters"
        ]
    },
    {
        "id": 1652,
        "code": "public void selectTracks_multipleRenderer_allSelected() throws Exception {\n  RendererCapabilities[] rendererCapabilities =\n      new RendererCapabilities[] {VIDEO_CAPABILITIES, AUDIO_CAPABILITIES, AUDIO_CAPABILITIES};\n  TrackGroupArray trackGroupArray = new TrackGroupArray(AUDIO_TRACK_GROUP);\n\n  TrackSelectorResult result =\n      trackSelector.selectTracks(rendererCapabilities, trackGroupArray, periodId, TIMELINE);\n\n  assertThat(result.length).isEqualTo(3);\n  assertThat(result.rendererConfigurations)\n      .asList()\n      .containsExactly(null, DEFAULT, null)\n      .inOrder();\n  assertThat(result.selections[0]).isNull();\n  assertFixedSelection(\n      result.selections[1], trackGroupArray, trackGroupArray.get(0).getFormat(0));\n  assertThat(result.selections[2]).isNull();\n  ImmutableList<Tracks.Group> trackGroups = result.tracks.getGroups();\n  assertThat(trackGroups).hasSize(1);\n  assertThat(trackGroups.get(0).getMediaTrackGroup()).isEqualTo(AUDIO_TRACK_GROUP);\n  assertThat(trackGroups.get(0).isTrackSelected(0)).isTrue();\n  assertThat(trackGroups.get(0).getTrackSupport(0)).isEqualTo(FORMAT_HANDLED);\n}",
        "summary_tokens": [
            "tests",
            "audio",
            "track",
            "selection",
            "when",
            "there",
            "are",
            "multiple",
            "audio",
            "renderers"
        ]
    },
    {
        "id": 1653,
        "code": "public void roundTripViaBundle_ofSelectionOverride_yieldsEqualInstance() {\n  SelectionOverride selectionOverrideToBundle =\n      new SelectionOverride( 1,  2, 3);\n\n  SelectionOverride selectionOverrideFromBundle =\n      DefaultTrackSelector.SelectionOverride.CREATOR.fromBundle(\n          selectionOverrideToBundle.toBundle());\n\n  assertThat(selectionOverrideFromBundle).isEqualTo(selectionOverrideToBundle);\n}",
        "summary_tokens": [
            "tests",
            "selection",
            "override",
            "s",
            "bundleable",
            "implementation"
        ]
    },
    {
        "id": 1654,
        "code": "public void deprecatedParametersBuilderOverridesAllTrackSelectionParametersBuilderMethods()\n    throws Exception {\n  List<Method> methods = TestUtil.getPublicMethods(TrackSelectionParameters.Builder.class);\n  for (Method method : methods) {\n    assertThat(\n            DefaultTrackSelector.ParametersBuilder.class\n                .getDeclaredMethod(method.getName(), method.getParameterTypes())\n                .getDeclaringClass())\n        .isEqualTo(DefaultTrackSelector.ParametersBuilder.class);\n  }\n}",
        "summary_tokens": [
            "the",
            "deprecated",
            "default",
            "track",
            "selector"
        ]
    },
    {
        "id": 1655,
        "code": "private static Parameters buildParametersForEqualsTest() {\n  return Parameters.DEFAULT_WITHOUT_CONTEXT\n      .buildUpon()\n        \n      .setMaxVideoSize( 0,  1)\n      .setMaxVideoFrameRate(2)\n      .setMaxVideoBitrate(3)\n      .setMinVideoSize( 4,  5)\n      .setMinVideoFrameRate(6)\n      .setMinVideoBitrate(7)\n      .setExceedVideoConstraintsIfNecessary(false)\n      .setAllowVideoMixedMimeTypeAdaptiveness(true)\n      .setAllowVideoNonSeamlessAdaptiveness(false)\n      .setAllowVideoMixedDecoderSupportAdaptiveness(true)\n      .setViewportSize(\n           8,\n           9,\n           true)\n      .setPreferredVideoMimeTypes(MimeTypes.VIDEO_AV1, MimeTypes.VIDEO_H264)\n        \n      .setPreferredAudioLanguages(\"zh\", \"jp\")\n      .setPreferredAudioRoleFlags(C.ROLE_FLAG_COMMENTARY)\n      .setMaxAudioChannelCount(10)\n      .setMaxAudioBitrate(11)\n      .setExceedAudioConstraintsIfNecessary(false)\n      .setAllowAudioMixedMimeTypeAdaptiveness(true)\n      .setAllowAudioMixedSampleRateAdaptiveness(false)\n      .setAllowAudioMixedChannelCountAdaptiveness(true)\n      .setAllowAudioMixedDecoderSupportAdaptiveness(false)\n      .setPreferredAudioMimeTypes(MimeTypes.AUDIO_AC3, MimeTypes.AUDIO_E_AC3)\n      .setConstrainAudioChannelCountToDeviceCapabilities(false)\n        \n      .setPreferredTextLanguages(\"de\", \"en\")\n      .setPreferredTextRoleFlags(C.ROLE_FLAG_CAPTION)\n      .setSelectUndeterminedTextLanguage(true)\n      .setIgnoredTextSelectionFlags(C.SELECTION_FLAG_AUTOSELECT)\n        \n      .setForceLowestBitrate(false)\n      .setForceHighestSupportedBitrate(true)\n      .setExceedRendererCapabilitiesIfNecessary(false)\n      .setTunnelingEnabled(true)\n      .setAllowMultipleAdaptiveSelections(true)\n      .setSelectionOverride(\n           2,\n          new TrackGroupArray(VIDEO_TRACK_GROUP),\n          new SelectionOverride(0, 1))\n      .setSelectionOverride(\n           2, new TrackGroupArray(AUDIO_TRACK_GROUP),  null)\n      .setSelectionOverride(\n           5, new TrackGroupArray(VIDEO_TRACK_GROUP),  null)\n      .setRendererDisabled(1, true)\n      .setRendererDisabled(3, true)\n      .setRendererDisabled(5, false)\n      .setOverrideForType(\n          new TrackSelectionOverride(\n              new TrackGroup(AUDIO_FORMAT, AUDIO_FORMAT, AUDIO_FORMAT, AUDIO_FORMAT),\n               ImmutableList.of(0, 2, 3)))\n      .setDisabledTrackTypes(ImmutableSet.of(C.TRACK_TYPE_AUDIO))\n      .build();\n}",
        "summary_tokens": [
            "returns",
            "parameters",
            "suitable",
            "for",
            "simple",
            "round",
            "trip",
            "equality",
            "tests"
        ]
    },
    {
        "id": 1656,
        "code": "private static void testSubMesh(Projection.Mesh leftMesh) {\n  assertThat(leftMesh.getSubMeshCount()).isEqualTo(1);\n\n  Projection.SubMesh subMesh = leftMesh.getSubMesh(0);\n  assertThat(subMesh.mode).isEqualTo(Projection.DRAW_MODE_TRIANGLES);\n\n  float[] vertices = subMesh.vertices;\n  float[] uv = subMesh.textureCoords;\n  assertThat(vertices.length).isEqualTo(VERTEX_COUNT * 3);\n  assertThat(subMesh.textureCoords.length).isEqualTo(VERTEX_COUNT * 2);\n\n    \n  testCoordinate(FIRST_VERTEX, vertices,  0);\n    \n  testCoordinate(LAST_VERTEX, vertices,  VERTEX_COUNT * 3 - 3);\n\n    \n  testCoordinate(FIRST_UV, uv,  0);\n    \n  testCoordinate(LAST_UV, uv,  VERTEX_COUNT * 2 - 2);\n}",
        "summary_tokens": [
            "tests",
            "the",
            "that",
            "sub",
            "mesh",
            "mesh",
            "with",
            "the",
            "video",
            "contains",
            "expected",
            "data"
        ]
    },
    {
        "id": 1657,
        "code": "private static void testCoordinate(float[] expected, float[] output, int offset) {\n  float[] adjustedOutput = Arrays.copyOfRange(output, offset, offset + expected.length);\n  assertThat(adjustedOutput).isEqualTo(expected);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "the",
            "output",
            "coordinates",
            "match",
            "the",
            "expected"
        ]
    },
    {
        "id": 1658,
        "code": "public void exclude(BaseUrl baseUrlToExclude, long exclusionDurationMs) {\n  long excludeUntilMs = SystemClock.elapsedRealtime() + exclusionDurationMs;\n  addExclusion(baseUrlToExclude.serviceLocation, excludeUntilMs, excludedServiceLocations);\n  if (baseUrlToExclude.priority != BaseUrl.PRIORITY_UNSET) {\n    addExclusion(baseUrlToExclude.priority, excludeUntilMs, excludedPriorities);\n  }\n}",
        "summary_tokens": [
            "excludes",
            "the",
            "given",
            "base",
            "url"
        ]
    },
    {
        "id": 1659,
        "code": "public BaseUrl selectBaseUrl(List<BaseUrl> baseUrls) {\n  List<BaseUrl> includedBaseUrls = applyExclusions(baseUrls);\n  if (includedBaseUrls.size() < 2) {\n    return Iterables.getFirst(includedBaseUrls,  null);\n  }\n    \n  Collections.sort(includedBaseUrls, BaseUrlExclusionList::compareBaseUrl);\n    \n  List<Pair<String, Integer>> candidateKeys = new ArrayList<>();\n  int lowestPriority = includedBaseUrls.get(0).priority;\n  for (int i = 0; i < includedBaseUrls.size(); i++) {\n    BaseUrl baseUrl = includedBaseUrls.get(i);\n    if (lowestPriority != baseUrl.priority) {\n      if (candidateKeys.size() == 1) {\n          \n        return includedBaseUrls.get(0);\n      }\n      break;\n    }\n    candidateKeys.add(new Pair<>(baseUrl.serviceLocation, baseUrl.weight));\n  }\n    \n  @Nullable BaseUrl baseUrl = selectionsTaken.get(candidateKeys);\n  if (baseUrl == null) {\n      \n    baseUrl = selectWeighted(includedBaseUrls.subList(0, candidateKeys.size()));\n      \n    selectionsTaken.put(candidateKeys, baseUrl);\n  }\n  return baseUrl;\n}",
        "summary_tokens": [
            "selects",
            "the",
            "base",
            "url",
            "to",
            "use",
            "from",
            "the",
            "given",
            "list"
        ]
    },
    {
        "id": 1660,
        "code": "public int getPriorityCountAfterExclusion(List<BaseUrl> baseUrls) {\n  Set<Integer> priorities = new HashSet<>();\n  List<BaseUrl> includedBaseUrls = applyExclusions(baseUrls);\n  for (int i = 0; i < includedBaseUrls.size(); i++) {\n    priorities.add(includedBaseUrls.get(i).priority);\n  }\n  return priorities.size();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "priority",
            "levels",
            "for",
            "the",
            "given",
            "list",
            "of",
            "base",
            "urls",
            "after",
            "exclusion"
        ]
    },
    {
        "id": 1661,
        "code": "public static int getPriorityCount(List<BaseUrl> baseUrls) {\n  Set<Integer> priorities = new HashSet<>();\n  for (int i = 0; i < baseUrls.size(); i++) {\n    priorities.add(baseUrls.get(i).priority);\n  }\n  return priorities.size();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "priority",
            "levels",
            "of",
            "the",
            "given",
            "list",
            "of",
            "base",
            "urls"
        ]
    },
    {
        "id": 1662,
        "code": "private static int compareBaseUrl(BaseUrl a, BaseUrl b) {\n  int compare = Integer.compare(a.priority, b.priority);\n  return compare != 0 ? compare : a.serviceLocation.compareTo(b.serviceLocation);\n}",
        "summary_tokens": [
            "compare",
            "by",
            "priority",
            "and",
            "service",
            "location"
        ]
    },
    {
        "id": 1663,
        "code": "public void updateManifest(DashManifest manifest, int periodIndex) {\n  this.manifest = manifest;\n  this.periodIndex = periodIndex;\n  playerEmsgHandler.updateManifest(manifest);\n  if (sampleStreams != null) {\n    for (ChunkSampleStream<DashChunkSource> sampleStream : sampleStreams) {\n      sampleStream.getChunkSource().updateManifest(manifest, periodIndex);\n    }\n    callback.onContinueLoadingRequested(this);\n  }\n  eventStreams = manifest.getPeriod(periodIndex).eventStreams;\n  for (EventSampleStream eventSampleStream : eventSampleStreams) {\n    for (EventStream eventStream : eventStreams) {\n      if (eventStream.id().equals(eventSampleStream.eventStreamId())) {\n        int lastPeriodIndex = manifest.getPeriodCount() - 1;\n        eventSampleStream.updateEventStream(\n            eventStream,\n             manifest.dynamic && periodIndex == lastPeriodIndex);\n        break;\n      }\n    }\n  }\n}",
        "summary_tokens": [
            "updates",
            "the",
            "dash",
            "manifest",
            "and",
            "the",
            "index",
            "of",
            "this",
            "period",
            "in",
            "the",
            "manifest"
        ]
    },
    {
        "id": 1664,
        "code": "private static int identifyEmbeddedTracks(\n    int primaryGroupCount,\n    List<AdaptationSet> adaptationSets,\n    int[][] groupedAdaptationSetIndices,\n    boolean[] primaryGroupHasEventMessageTrackFlags,\n    Format[][] primaryGroupClosedCaptionTrackFormats) {\n  int numEmbeddedTrackGroups = 0;\n  for (int i = 0; i < primaryGroupCount; i++) {\n    if (hasEventMessageTrack(adaptationSets, groupedAdaptationSetIndices[i])) {\n      primaryGroupHasEventMessageTrackFlags[i] = true;\n      numEmbeddedTrackGroups++;\n    }\n    primaryGroupClosedCaptionTrackFormats[i] =\n        getClosedCaptionTrackFormats(adaptationSets, groupedAdaptationSetIndices[i]);\n    if (primaryGroupClosedCaptionTrackFormats[i].length != 0) {\n      numEmbeddedTrackGroups++;\n    }\n  }\n  return numEmbeddedTrackGroups;\n}",
        "summary_tokens": [
            "iterates",
            "through",
            "list",
            "of",
            "primary",
            "track",
            "groups",
            "and",
            "identifies",
            "embedded",
            "tracks"
        ]
    },
    {
        "id": 1665,
        "code": "public void replaceManifestUri(Uri manifestUri) {\n  synchronized (manifestUriLock) {\n    this.manifestUri = manifestUri;\n    this.initialManifestUri = manifestUri;\n  }\n}",
        "summary_tokens": [
            "manually",
            "replaces",
            "the",
            "manifest",
            "uri"
        ]
    },
    {
        "id": 1666,
        "code": "public static DataSpec buildDataSpec(\n    Representation representation, RangedUri requestUri, int flags) {\n  return buildDataSpec(representation, representation.baseUrls.get(0).url, requestUri, flags);\n}",
        "summary_tokens": [
            "builds",
            "a",
            "data",
            "spec",
            "for",
            "a",
            "given",
            "ranged",
            "uri",
            "belonging",
            "to",
            "representation"
        ]
    },
    {
        "id": 1667,
        "code": "public static DashManifest loadManifest(DataSource dataSource, Uri uri) throws IOException {\n  return ParsingLoadable.load(dataSource, new DashManifestParser(), uri, C.DATA_TYPE_MANIFEST);\n}",
        "summary_tokens": [
            "loads",
            "a",
            "dash",
            "manifest"
        ]
    },
    {
        "id": 1668,
        "code": "public static Format loadFormatWithDrmInitData(DataSource dataSource, Period period)\n    throws IOException {\n  @C.TrackType int primaryTrackType = C.TRACK_TYPE_VIDEO;\n  Representation representation = getFirstRepresentation(period, primaryTrackType);\n  if (representation == null) {\n    primaryTrackType = C.TRACK_TYPE_AUDIO;\n    representation = getFirstRepresentation(period, primaryTrackType);\n    if (representation == null) {\n      return null;\n    }\n  }\n  Format manifestFormat = representation.format;\n  @Nullable\n  Format sampleFormat = DashUtil.loadSampleFormat(dataSource, primaryTrackType, representation);\n  return sampleFormat == null\n      ? manifestFormat\n      : sampleFormat.withManifestFormatInfo(manifestFormat);\n}",
        "summary_tokens": [
            "loads",
            "a",
            "format",
            "for",
            "acquiring",
            "keys",
            "for",
            "a",
            "given",
            "period",
            "in",
            "a",
            "dash",
            "manifest"
        ]
    },
    {
        "id": 1669,
        "code": "public static Format loadSampleFormat(\n    DataSource dataSource, int trackType, Representation representation) throws IOException {\n  return loadSampleFormat(dataSource, trackType, representation,  0);\n}",
        "summary_tokens": [
            "loads",
            "initialization",
            "data",
            "for",
            "the",
            "representation",
            "and",
            "returns",
            "the",
            "sample",
            "format"
        ]
    },
    {
        "id": 1670,
        "code": "public static ChunkIndex loadChunkIndex(\n    DataSource dataSource, int trackType, Representation representation) throws IOException {\n  return loadChunkIndex(dataSource, trackType, representation,  0);\n}",
        "summary_tokens": [
            "loads",
            "initialization",
            "and",
            "index",
            "data",
            "for",
            "the",
            "representation",
            "and",
            "returns",
            "the",
            "chunk",
            "index"
        ]
    },
    {
        "id": 1671,
        "code": "public static void loadInitializationData(\n    ChunkExtractor chunkExtractor,\n    DataSource dataSource,\n    Representation representation,\n    boolean loadIndex)\n    throws IOException {\n  loadInitializationData(\n      chunkExtractor, dataSource, representation,  0, loadIndex);\n}",
        "summary_tokens": [
            "loads",
            "initialization",
            "data",
            "for",
            "the",
            "representation",
            "and",
            "optionally",
            "index",
            "data",
            "then",
            "returns",
            "a",
            "bundled",
            "chunk",
            "extractor",
            "which",
            "contains",
            "the",
            "output"
        ]
    },
    {
        "id": 1672,
        "code": "public static String resolveCacheKey(Representation representation, RangedUri rangedUri) {\n  @Nullable String cacheKey = representation.getCacheKey();\n  return cacheKey != null\n      ? cacheKey\n      : rangedUri.resolveUri(representation.baseUrls.get(0).url).toString();\n}",
        "summary_tokens": [
            "resolves",
            "the",
            "cache",
            "key",
            "to",
            "be",
            "used",
            "when",
            "requesting",
            "the",
            "given",
            "ranged",
            "uri",
            "for",
            "the",
            "given",
            "representation"
        ]
    },
    {
        "id": 1673,
        "code": "public void seekToUs(long positionUs) {\n  currentIndex =\n      Util.binarySearchCeil(\n          eventTimesUs, positionUs,  true,  false);\n  boolean isPendingSeek = eventStreamAppendable && currentIndex == eventTimesUs.length;\n  pendingSeekPositionUs = isPendingSeek ? positionUs : C.TIME_UNSET;\n}",
        "summary_tokens": [
            "seeks",
            "to",
            "the",
            "specified",
            "position",
            "in",
            "microseconds"
        ]
    },
    {
        "id": 1674,
        "code": "public void updateManifest(DashManifest newManifest) {\n  isWaitingForManifestRefresh = false;\n  expiredManifestPublishTimeUs = C.TIME_UNSET;\n  this.manifest = newManifest;\n  removePreviouslyExpiredManifestPublishTimeValues();\n}",
        "summary_tokens": [
            "updates",
            "the",
            "dash",
            "manifest",
            "that",
            "this",
            "handler",
            "works",
            "on"
        ]
    },
    {
        "id": 1675,
        "code": "public PlayerTrackEmsgHandler newPlayerTrackEmsgHandler() {\n  return new PlayerTrackEmsgHandler(allocator);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "track",
            "output",
            "that",
            "emsg",
            "messages",
            "could",
            "be",
            "written",
            "to"
        ]
    },
    {
        "id": 1676,
        "code": "public void release() {\n  released = true;\n  handler.removeCallbacksAndMessages(null);\n}",
        "summary_tokens": [
            "release",
            "this",
            "emsg",
            "handler"
        ]
    },
    {
        "id": 1677,
        "code": "private void maybeNotifyDashManifestRefreshNeeded() {\n  if (!chunkLoadedCompletedSinceLastManifestRefreshRequest) {\n      \n    return;\n  }\n  isWaitingForManifestRefresh = true;\n  chunkLoadedCompletedSinceLastManifestRefreshRequest = false;\n  playerEmsgCallback.onDashManifestRefreshRequested();\n}",
        "summary_tokens": [
            "requests",
            "dash",
            "media",
            "manifest",
            "to",
            "be",
            "refreshed",
            "if",
            "necessary"
        ]
    },
    {
        "id": 1678,
        "code": "private static boolean isPlayerEmsgEvent(String schemeIdUri, String value) {\n  return \"urn:mpeg:dash:event:2012\".equals(schemeIdUri)\n      && (\"1\".equals(value) || \"2\".equals(value) || \"3\".equals(value));\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "an",
            "event",
            "with",
            "given",
            "scheme",
            "id",
            "uri",
            "and",
            "value",
            "is",
            "a",
            "dash",
            "emsg",
            "event",
            "targeting",
            "the",
            "player"
        ]
    },
    {
        "id": 1679,
        "code": "public String id() {\n  return schemeIdUri + \"/\" + value;\n}",
        "summary_tokens": [
            "a",
            "constructed",
            "id",
            "of",
            "this",
            "event",
            "stream"
        ]
    },
    {
        "id": 1680,
        "code": "public int getAdaptationSetIndex(int type) {\n  int adaptationCount = adaptationSets.size();\n  for (int i = 0; i < adaptationCount; i++) {\n    if (adaptationSets.get(i).type == type) {\n      return i;\n    }\n  }\n  return C.INDEX_UNSET;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "index",
            "of",
            "the",
            "first",
            "adaptation",
            "set",
            "of",
            "a",
            "given",
            "type",
            "or",
            "c",
            "index",
            "unset",
            "if",
            "no",
            "adaptation",
            "set",
            "of",
            "the",
            "specified",
            "type",
            "exists"
        ]
    },
    {
        "id": 1681,
        "code": "public Uri resolveUri(String baseUri) {\n  return UriUtil.resolveToUri(baseUri, referenceUri);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "resolved",
            "uri",
            "represented",
            "by",
            "the",
            "instance"
        ]
    },
    {
        "id": 1682,
        "code": "public String resolveUriString(String baseUri) {\n  return UriUtil.resolve(baseUri, referenceUri);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "resolved",
            "uri",
            "represented",
            "by",
            "the",
            "instance",
            "as",
            "a",
            "string"
        ]
    },
    {
        "id": 1683,
        "code": "public RangedUri attemptMerge(@Nullable RangedUri other, String baseUri) {\n  final String resolvedUri = resolveUriString(baseUri);\n  if (other == null || !resolvedUri.equals(other.resolveUriString(baseUri))) {\n    return null;\n  } else if (length != C.LENGTH_UNSET && start + length == other.start) {\n    return new RangedUri(\n        resolvedUri,\n        start,\n        other.length == C.LENGTH_UNSET ? C.LENGTH_UNSET : length + other.length);\n  } else if (other.length != C.LENGTH_UNSET && other.start + other.length == start) {\n    return new RangedUri(\n        resolvedUri,\n        other.start,\n        length == C.LENGTH_UNSET ? C.LENGTH_UNSET : other.length + length);\n  } else {\n    return null;\n  }\n}",
        "summary_tokens": [
            "attempts",
            "to",
            "merge",
            "this",
            "ranged",
            "uri",
            "with",
            "another",
            "and",
            "an",
            "optional",
            "common",
            "base",
            "uri"
        ]
    },
    {
        "id": 1684,
        "code": "public static Representation newInstance(\n    long revisionId,\n    Format format,\n    List<BaseUrl> baseUrls,\n    SegmentBase segmentBase,\n    @Nullable List<Descriptor> inbandEventStreams,\n    List<Descriptor> essentialProperties,\n    List<Descriptor> supplementalProperties,\n    @Nullable String cacheKey) {\n  if (segmentBase instanceof SingleSegmentBase) {\n    return new SingleSegmentRepresentation(\n        revisionId,\n        format,\n        baseUrls,\n        (SingleSegmentBase) segmentBase,\n        inbandEventStreams,\n        essentialProperties,\n        supplementalProperties,\n        cacheKey,\n         C.LENGTH_UNSET);\n  } else if (segmentBase instanceof MultiSegmentBase) {\n    return new MultiSegmentRepresentation(\n        revisionId,\n        format,\n        baseUrls,\n        (MultiSegmentBase) segmentBase,\n        inbandEventStreams,\n        essentialProperties,\n        supplementalProperties);\n  } else {\n    throw new IllegalArgumentException(\n        \"segmentBase must be of type SingleSegmentBase or \" + \"MultiSegmentBase\");\n  }\n}",
        "summary_tokens": [
            "constructs",
            "a",
            "new",
            "instance"
        ]
    },
    {
        "id": 1685,
        "code": "public RangedUri getInitializationUri() {\n  return initializationUri;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "ranged",
            "uri",
            "defining",
            "the",
            "location",
            "of",
            "the",
            "representation",
            "s",
            "initialization",
            "data",
            "or",
            "null",
            "if",
            "no",
            "initialization",
            "data",
            "exists"
        ]
    },
    {
        "id": 1686,
        "code": "public RangedUri getInitialization(Representation representation) {\n  return initialization;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "ranged",
            "uri",
            "defining",
            "the",
            "location",
            "of",
            "initialization",
            "data",
            "for",
            "a",
            "given",
            "representation",
            "or",
            "null",
            "if",
            "no",
            "initialization",
            "data",
            "exists"
        ]
    },
    {
        "id": 1687,
        "code": "public long getPresentationTimeOffsetUs() {\n  return Util.scaleLargeTimestamp(presentationTimeOffset, C.MICROS_PER_SECOND, timescale);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "presentation",
            "time",
            "offset",
            "in",
            "microseconds"
        ]
    },
    {
        "id": 1688,
        "code": "public static UrlTemplate compile(String template) {\n    \n    \n  String[] urlPieces = new String[5];\n  int[] identifiers = new int[4];\n  String[] identifierFormatTags = new String[4];\n  int identifierCount = parseTemplate(template, urlPieces, identifiers, identifierFormatTags);\n  return new UrlTemplate(urlPieces, identifiers, identifierFormatTags, identifierCount);\n}",
        "summary_tokens": [
            "compile",
            "an",
            "instance",
            "from",
            "the",
            "provided",
            "template",
            "string"
        ]
    },
    {
        "id": 1689,
        "code": "public String buildUri(String representationId, long segmentNumber, int bandwidth, long time) {\n  StringBuilder builder = new StringBuilder();\n  for (int i = 0; i < identifierCount; i++) {\n    builder.append(urlPieces[i]);\n    if (identifiers[i] == REPRESENTATION_ID) {\n      builder.append(representationId);\n    } else if (identifiers[i] == NUMBER_ID) {\n      builder.append(String.format(Locale.US, identifierFormatTags[i], segmentNumber));\n    } else if (identifiers[i] == BANDWIDTH_ID) {\n      builder.append(String.format(Locale.US, identifierFormatTags[i], bandwidth));\n    } else if (identifiers[i] == TIME_ID) {\n      builder.append(String.format(Locale.US, identifierFormatTags[i], time));\n    }\n  }\n  builder.append(urlPieces[identifierCount]);\n  return builder.toString();\n}",
        "summary_tokens": [
            "constructs",
            "a",
            "uri",
            "from",
            "the",
            "template",
            "substituting",
            "in",
            "the",
            "provided",
            "arguments"
        ]
    },
    {
        "id": 1690,
        "code": "private static int parseTemplate(\n    String template, String[] urlPieces, int[] identifiers, String[] identifierFormatTags) {\n  urlPieces[0] = \"\";\n  int templateIndex = 0;\n  int identifierCount = 0;\n  while (templateIndex < template.length()) {\n    int dollarIndex = template.indexOf(\"$\", templateIndex);\n    if (dollarIndex == -1) {\n      urlPieces[identifierCount] += template.substring(templateIndex);\n      templateIndex = template.length();\n    } else if (dollarIndex != templateIndex) {\n      urlPieces[identifierCount] += template.substring(templateIndex, dollarIndex);\n      templateIndex = dollarIndex;\n    } else if (template.startsWith(ESCAPED_DOLLAR, templateIndex)) {\n      urlPieces[identifierCount] += \"$\";\n      templateIndex += 2;\n    } else {\n      int secondIndex = template.indexOf(\"$\", templateIndex + 1);\n      String identifier = template.substring(templateIndex + 1, secondIndex);\n      if (identifier.equals(REPRESENTATION)) {\n        identifiers[identifierCount] = REPRESENTATION_ID;\n      } else {\n        int formatTagIndex = identifier.indexOf(\"%0\");\n        String formatTag = DEFAULT_FORMAT_TAG;\n        if (formatTagIndex != -1) {\n          formatTag = identifier.substring(formatTagIndex);\n            \n            \n            \n          if (!formatTag.endsWith(\"d\") && !formatTag.endsWith(\"x\") && !formatTag.endsWith(\"X\")) {\n            formatTag += \"d\";\n          }\n          identifier = identifier.substring(0, formatTagIndex);\n        }\n        switch (identifier) {\n          case NUMBER:\n            identifiers[identifierCount] = NUMBER_ID;\n            break;\n          case BANDWIDTH:\n            identifiers[identifierCount] = BANDWIDTH_ID;\n            break;\n          case TIME:\n            identifiers[identifierCount] = TIME_ID;\n            break;\n          default:\n            throw new IllegalArgumentException(\"Invalid template: \" + template);\n        }\n        identifierFormatTags[identifierCount] = formatTag;\n      }\n      identifierCount++;\n      urlPieces[identifierCount] = \"\";\n      templateIndex = secondIndex + 1;\n    }\n  }\n  return identifierCount;\n}",
        "summary_tokens": [
            "parses",
            "template",
            "placing",
            "the",
            "decomposed",
            "components",
            "into",
            "the",
            "provided",
            "arrays"
        ]
    },
    {
        "id": 1691,
        "code": "public void readDataReturnFormatForFirstRead() {\n  EventStream eventStream =\n      new EventStream(SCHEME_ID, VALUE, TIME_SCALE, new long[0], new EventMessage[0]);\n    \n    \n  EventSampleStream sampleStream =\n      new EventSampleStream(eventStream, FORMAT,  true);\n\n  int result = readData(sampleStream);\n  assertThat(result).isEqualTo(C.RESULT_FORMAT_READ);\n  assertThat(formatHolder.format).isEqualTo(FORMAT);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "event",
            "sample",
            "stream",
            "read",
            "data",
            "format",
            "holder",
            "decoder",
            "input",
            "buffer",
            "int",
            "will",
            "return",
            "format",
            "for",
            "the",
            "first",
            "call"
        ]
    },
    {
        "id": 1692,
        "code": "public void readDataOutOfBoundReturnEndOfStreamAfterFormatForNonDynamicEventSampleStream() {\n  EventStream eventStream =\n      new EventStream(SCHEME_ID, VALUE, TIME_SCALE, new long[0], new EventMessage[0]);\n  EventSampleStream sampleStream = new EventSampleStream(eventStream, FORMAT, false);\n    \n  readData(sampleStream);\n\n  int result = readData(sampleStream);\n  assertThat(result).isEqualTo(C.RESULT_BUFFER_READ);\n  assertThat(inputBuffer.isEndOfStream()).isTrue();\n}",
        "summary_tokens": [
            "tests",
            "that",
            "a",
            "non",
            "dynamic",
            "event",
            "sample",
            "stream",
            "will",
            "return",
            "a",
            "buffer",
            "with",
            "c",
            "buffer",
            "flag",
            "end",
            "of",
            "stream",
            "when",
            "trying",
            "to",
            "read",
            "sample",
            "out",
            "of",
            "bound"
        ]
    },
    {
        "id": 1693,
        "code": "public void readDataOutOfBoundReturnEndOfStreamAfterFormatForDynamicEventSampleStream() {\n  EventStream eventStream =\n      new EventStream(SCHEME_ID, VALUE, TIME_SCALE, new long[0], new EventMessage[0]);\n  EventSampleStream sampleStream = new EventSampleStream(eventStream, FORMAT, true);\n    \n  readData(sampleStream);\n\n  int result = readData(sampleStream);\n  assertThat(result).isEqualTo(C.RESULT_NOTHING_READ);\n}",
        "summary_tokens": [
            "tests",
            "that",
            "a",
            "dynamic",
            "event",
            "sample",
            "stream",
            "will",
            "return",
            "c",
            "result",
            "nothing",
            "read",
            "when",
            "trying",
            "to",
            "read",
            "sample",
            "out",
            "of",
            "bound"
        ]
    },
    {
        "id": 1694,
        "code": "public void readDataReturnDataAfterFormat() {\n  long presentationTimeUs = 1000000;\n  EventMessage eventMessage = newEventMessageWithId(1);\n  EventStream eventStream =\n      new EventStream(\n          SCHEME_ID,\n          VALUE,\n          TIME_SCALE,\n          new long[] {presentationTimeUs},\n          new EventMessage[] {eventMessage});\n  EventSampleStream sampleStream = new EventSampleStream(eventStream, FORMAT, false);\n    \n  readData(sampleStream);\n\n  int result = readData(sampleStream);\n  assertThat(result).isEqualTo(C.RESULT_BUFFER_READ);\n  assertThat(inputBuffer.data.array()).isEqualTo(getEncodedMessage(eventMessage));\n}",
        "summary_tokens": [
            "tests",
            "that",
            "event",
            "sample",
            "stream",
            "read",
            "data",
            "format",
            "holder",
            "decoder",
            "input",
            "buffer",
            "int",
            "will",
            "return",
            "sample",
            "data",
            "after",
            "the",
            "first",
            "call"
        ]
    },
    {
        "id": 1695,
        "code": "public void skipDataThenReadDataReturnDataFromSkippedPosition() {\n  long presentationTimeUs1 = 1000000;\n  long presentationTimeUs2 = 2000000;\n  EventMessage eventMessage1 = newEventMessageWithId(1);\n  EventMessage eventMessage2 = newEventMessageWithId(2);\n  EventStream eventStream =\n      new EventStream(\n          SCHEME_ID,\n          VALUE,\n          TIME_SCALE,\n          new long[] {presentationTimeUs1, presentationTimeUs2},\n          new EventMessage[] {eventMessage1, eventMessage2});\n  EventSampleStream sampleStream = new EventSampleStream(eventStream, FORMAT, false);\n    \n  readData(sampleStream);\n\n  int skipped = sampleStream.skipData(presentationTimeUs2);\n  int result = readData(sampleStream);\n  assertThat(skipped).isEqualTo(1);\n  assertThat(result).isEqualTo(C.RESULT_BUFFER_READ);\n  assertThat(inputBuffer.data.array()).isEqualTo(getEncodedMessage(eventMessage2));\n}",
        "summary_tokens": [
            "tests",
            "that",
            "event",
            "sample",
            "stream",
            "skip",
            "data",
            "long",
            "will",
            "skip",
            "until",
            "the",
            "given",
            "position",
            "and",
            "the",
            "next",
            "event",
            "sample",
            "stream",
            "read",
            "data",
            "format",
            "holder",
            "decoder",
            "input",
            "buffer",
            "int",
            "call",
            "will",
            "return",
            "sample",
            "data",
            "from",
            "that",
            "position"
        ]
    },
    {
        "id": 1696,
        "code": "public void seekToUsThenReadDataReturnDataFromSeekPosition() {\n  long presentationTimeUs1 = 1000000;\n  long presentationTimeUs2 = 2000000;\n  EventMessage eventMessage1 = newEventMessageWithId(1);\n  EventMessage eventMessage2 = newEventMessageWithId(2);\n  EventStream eventStream =\n      new EventStream(\n          SCHEME_ID,\n          VALUE,\n          TIME_SCALE,\n          new long[] {presentationTimeUs1, presentationTimeUs2},\n          new EventMessage[] {eventMessage1, eventMessage2});\n  EventSampleStream sampleStream = new EventSampleStream(eventStream, FORMAT, false);\n    \n  readData(sampleStream);\n\n  sampleStream.seekToUs(presentationTimeUs2);\n  int result = readData(sampleStream);\n  assertThat(result).isEqualTo(C.RESULT_BUFFER_READ);\n  assertThat(inputBuffer.data.array()).isEqualTo(getEncodedMessage(eventMessage2));\n}",
        "summary_tokens": [
            "tests",
            "that",
            "event",
            "sample",
            "stream",
            "seek",
            "to",
            "us",
            "long",
            "long",
            "will",
            "seek",
            "to",
            "the",
            "given",
            "position",
            "and",
            "the",
            "next",
            "event",
            "sample",
            "stream",
            "read",
            "data",
            "format",
            "holder",
            "decoder",
            "input",
            "buffer",
            "int",
            "call",
            "will",
            "return",
            "sample",
            "data",
            "from",
            "that",
            "position"
        ]
    },
    {
        "id": 1697,
        "code": "public void updateEventStreamContinueToReadAfterLastReadSamplePresentationTime() {\n  long presentationTimeUs1 = 1000000;\n  long presentationTimeUs2 = 2000000;\n  long presentationTimeUs3 = 3000000;\n  EventMessage eventMessage1 = newEventMessageWithId(1);\n  EventMessage eventMessage2 = newEventMessageWithId(2);\n  EventMessage eventMessage3 = newEventMessageWithId(3);\n  EventStream eventStream1 =\n      new EventStream(\n          SCHEME_ID,\n          VALUE,\n          TIME_SCALE,\n          new long[] {presentationTimeUs1, presentationTimeUs2},\n          new EventMessage[] {eventMessage1, eventMessage2});\n  EventStream eventStream2 =\n      new EventStream(\n          SCHEME_ID,\n          VALUE,\n          TIME_SCALE,\n          new long[] {presentationTimeUs1, presentationTimeUs2, presentationTimeUs3},\n          new EventMessage[] {eventMessage1, eventMessage2, eventMessage3});\n  EventSampleStream sampleStream = new EventSampleStream(eventStream1, FORMAT, true);\n    \n  readData(sampleStream);\n    \n  readData(sampleStream);\n  readData(sampleStream);\n\n  sampleStream.updateEventStream(eventStream2, true);\n  int result = readData(sampleStream);\n  assertThat(result).isEqualTo(C.RESULT_BUFFER_READ);\n  assertThat(inputBuffer.data.array()).isEqualTo(getEncodedMessage(eventMessage3));\n}",
        "summary_tokens": [
            "tests",
            "that",
            "event",
            "sample",
            "stream",
            "update",
            "event",
            "stream",
            "event",
            "stream",
            "boolean",
            "will",
            "update",
            "the",
            "underlying",
            "event",
            "stream",
            "but",
            "keep",
            "the",
            "read",
            "timestamp",
            "so",
            "the",
            "next",
            "event",
            "sample",
            "stream",
            "read",
            "data",
            "format",
            "holder",
            "decoder",
            "input",
            "buffer",
            "int",
            "call",
            "will",
            "return",
            "sample",
            "data",
            "from",
            "after",
            "the",
            "last",
            "read",
            "sample",
            "timestamp"
        ]
    },
    {
        "id": 1698,
        "code": "public void skipDataThenUpdateStreamContinueToReadFromSkippedPosition() {\n  long presentationTimeUs1 = 1000000;\n  long presentationTimeUs2 = 2000000;\n  long presentationTimeUs3 = 3000000;\n  EventMessage eventMessage1 = newEventMessageWithId(1);\n  EventMessage eventMessage2 = newEventMessageWithId(2);\n  EventMessage eventMessage3 = newEventMessageWithId(3);\n  EventStream eventStream1 =\n      new EventStream(\n          SCHEME_ID,\n          VALUE,\n          TIME_SCALE,\n          new long[] {presentationTimeUs1, presentationTimeUs2},\n          new EventMessage[] {eventMessage1, eventMessage2});\n  EventStream eventStream2 =\n      new EventStream(\n          SCHEME_ID,\n          VALUE,\n          TIME_SCALE,\n          new long[] {presentationTimeUs1, presentationTimeUs2, presentationTimeUs3},\n          new EventMessage[] {eventMessage1, eventMessage2, eventMessage3});\n  EventSampleStream sampleStream = new EventSampleStream(eventStream1, FORMAT, true);\n    \n  readData(sampleStream);\n  sampleStream.skipData(presentationTimeUs2 + 1);\n\n  sampleStream.updateEventStream(eventStream2, true);\n  int result = readData(sampleStream);\n  assertThat(result).isEqualTo(C.RESULT_BUFFER_READ);\n  assertThat(inputBuffer.data.array()).isEqualTo(getEncodedMessage(eventMessage3));\n}",
        "summary_tokens": [
            "tests",
            "that",
            "event",
            "sample",
            "stream",
            "update",
            "event",
            "stream",
            "event",
            "stream",
            "boolean",
            "will",
            "update",
            "the",
            "underlying",
            "event",
            "stream",
            "but",
            "keep",
            "the",
            "timestamp",
            "the",
            "stream",
            "has",
            "skipped",
            "to",
            "so",
            "the",
            "next",
            "event",
            "sample",
            "stream",
            "read",
            "data",
            "format",
            "holder",
            "decoder",
            "input",
            "buffer",
            "int",
            "call",
            "will",
            "return",
            "sample",
            "data",
            "from",
            "the",
            "skipped",
            "position"
        ]
    },
    {
        "id": 1699,
        "code": "public void skipDataThenUpdateStreamContinueToReadDoNotSkippedMoreThanAvailable() {\n  long presentationTimeUs1 = 1000000;\n  long presentationTimeUs2 = 2000000;\n  long presentationTimeUs3 = 3000000;\n  EventMessage eventMessage1 = newEventMessageWithId(1);\n  EventMessage eventMessage2 = newEventMessageWithId(2);\n  EventMessage eventMessage3 = newEventMessageWithId(3);\n  EventStream eventStream1 =\n      new EventStream(\n          SCHEME_ID,\n          VALUE,\n          TIME_SCALE,\n          new long[] {presentationTimeUs1},\n          new EventMessage[] {eventMessage1});\n  EventStream eventStream2 =\n      new EventStream(\n          SCHEME_ID,\n          VALUE,\n          TIME_SCALE,\n          new long[] {presentationTimeUs1, presentationTimeUs2, presentationTimeUs3},\n          new EventMessage[] {eventMessage1, eventMessage2, eventMessage3});\n  EventSampleStream sampleStream = new EventSampleStream(eventStream1, FORMAT, true);\n    \n  readData(sampleStream);\n    \n    \n  sampleStream.skipData(presentationTimeUs2 + 1);\n\n  sampleStream.updateEventStream(eventStream2, true);\n  int result = readData(sampleStream);\n  assertThat(result).isEqualTo(C.RESULT_BUFFER_READ);\n  assertThat(inputBuffer.data.array()).isEqualTo(getEncodedMessage(eventMessage2));\n}",
        "summary_tokens": [
            "tests",
            "that",
            "event",
            "sample",
            "stream",
            "skip",
            "data",
            "long",
            "will",
            "only",
            "skip",
            "to",
            "the",
            "point",
            "right",
            "after",
            "it",
            "last",
            "event"
        ]
    },
    {
        "id": 1700,
        "code": "public void seekToUsThenUpdateStreamContinueToReadFromSeekPosition() {\n  long presentationTimeUs1 = 1000000;\n  long presentationTimeUs2 = 2000000;\n  long presentationTimeUs3 = 3000000;\n  EventMessage eventMessage1 = newEventMessageWithId(1);\n  EventMessage eventMessage2 = newEventMessageWithId(2);\n  EventMessage eventMessage3 = newEventMessageWithId(3);\n  EventStream eventStream1 =\n      new EventStream(\n          SCHEME_ID,\n          VALUE,\n          TIME_SCALE,\n          new long[] {presentationTimeUs1, presentationTimeUs2},\n          new EventMessage[] {eventMessage1, eventMessage2});\n  EventStream eventStream2 =\n      new EventStream(\n          SCHEME_ID,\n          VALUE,\n          TIME_SCALE,\n          new long[] {presentationTimeUs1, presentationTimeUs2, presentationTimeUs3},\n          new EventMessage[] {eventMessage1, eventMessage2, eventMessage3});\n  EventSampleStream sampleStream = new EventSampleStream(eventStream1, FORMAT, true);\n    \n  readData(sampleStream);\n  sampleStream.seekToUs(presentationTimeUs2);\n\n  sampleStream.updateEventStream(eventStream2, true);\n  int result = readData(sampleStream);\n  assertThat(result).isEqualTo(C.RESULT_BUFFER_READ);\n  assertThat(inputBuffer.data.array()).isEqualTo(getEncodedMessage(eventMessage2));\n}",
        "summary_tokens": [
            "tests",
            "that",
            "event",
            "sample",
            "stream",
            "update",
            "event",
            "stream",
            "event",
            "stream",
            "boolean",
            "will",
            "update",
            "the",
            "underlying",
            "event",
            "stream",
            "but",
            "keep",
            "the",
            "timestamp",
            "the",
            "stream",
            "has",
            "seek",
            "to",
            "so",
            "the",
            "next",
            "event",
            "sample",
            "stream",
            "read",
            "data",
            "format",
            "holder",
            "decoder",
            "input",
            "buffer",
            "int",
            "call",
            "will",
            "return",
            "sample",
            "data",
            "from",
            "the",
            "seek",
            "position"
        ]
    },
    {
        "id": 1701,
        "code": "public void seekToThenUpdateStreamContinueToReadFromSeekPositionEvenSeekMoreThanAvailable() {\n  long presentationTimeUs1 = 1000000;\n  long presentationTimeUs2 = 2000000;\n  long presentationTimeUs3 = 3000000;\n  EventMessage eventMessage1 = newEventMessageWithId(1);\n  EventMessage eventMessage2 = newEventMessageWithId(2);\n  EventMessage eventMessage3 = newEventMessageWithId(3);\n  EventStream eventStream1 =\n      new EventStream(\n          SCHEME_ID,\n          VALUE,\n          TIME_SCALE,\n          new long[] {presentationTimeUs1},\n          new EventMessage[] {eventMessage1});\n  EventStream eventStream2 =\n      new EventStream(\n          SCHEME_ID,\n          VALUE,\n          TIME_SCALE,\n          new long[] {presentationTimeUs1, presentationTimeUs2, presentationTimeUs3},\n          new EventMessage[] {eventMessage1, eventMessage2, eventMessage3});\n  EventSampleStream sampleStream = new EventSampleStream(eventStream1, FORMAT, true);\n    \n  readData(sampleStream);\n  sampleStream.seekToUs(presentationTimeUs2 + 1);\n\n  sampleStream.updateEventStream(eventStream2, true);\n  int result = readData(sampleStream);\n  assertThat(result).isEqualTo(C.RESULT_BUFFER_READ);\n  assertThat(inputBuffer.data.array()).isEqualTo(getEncodedMessage(eventMessage3));\n}",
        "summary_tokens": [
            "tests",
            "that",
            "event",
            "sample",
            "stream",
            "update",
            "event",
            "stream",
            "event",
            "stream",
            "boolean",
            "will",
            "update",
            "the",
            "underlying",
            "event",
            "stream",
            "but",
            "keep",
            "the",
            "timestamp",
            "the",
            "stream",
            "has",
            "seek",
            "to",
            "so",
            "the",
            "next",
            "event",
            "sample",
            "stream",
            "read",
            "data",
            "format",
            "holder",
            "decoder",
            "input",
            "buffer",
            "int",
            "call",
            "will",
            "return",
            "sample",
            "data",
            "from",
            "the",
            "seek",
            "position"
        ]
    },
    {
        "id": 1702,
        "code": "public void parseMediaPresentationDescription() throws IOException {\n  DashManifestParser parser = new DashManifestParser();\n  parser.parse(\n      Uri.parse(\"https://example.com/test.mpd\"),\n      TestUtil.getInputStream(ApplicationProvider.getApplicationContext(), SAMPLE_MPD_LIVE));\n  parser.parse(\n      Uri.parse(\"https://example.com/test.mpd\"),\n      TestUtil.getInputStream(\n          ApplicationProvider.getApplicationContext(), SAMPLE_MPD_UNKNOWN_MIME_TYPE));\n}",
        "summary_tokens": [
            "simple",
            "test",
            "to",
            "ensure",
            "the",
            "sample",
            "manifests",
            "parse",
            "without",
            "any",
            "exceptions",
            "being",
            "thrown"
        ]
    },
    {
        "id": 1703,
        "code": "public void getSegmentCount_withSegmentTemplate_avoidsIncorrectRounding() {\n  SegmentBase.SegmentTemplate segmentTemplate =\n      new SegmentBase.SegmentTemplate(\n           null,\n           90000,\n           0,\n           0,\n           C.INDEX_UNSET,\n           179989,\n           null,\n           C.TIME_UNSET,\n           null,\n           null,\n           C.TIME_UNSET,\n           C.TIME_UNSET);\n  assertThat(segmentTemplate.getSegmentCount(2931820000L)).isEqualTo(1466);\n}",
        "summary_tokens": [
            "regression",
            "test",
            "for",
            "https",
            "github"
        ]
    },
    {
        "id": 1704,
        "code": "private static void wipeDatabase(SQLiteDatabase db) {\n  String[] columns = {\"type\", \"name\"};\n  try (Cursor cursor =\n      db.query(\n          \"sqlite_master\",\n          columns,\n           null,\n           null,\n           null,\n           null,\n           null)) {\n    while (cursor.moveToNext()) {\n      String type = cursor.getString(0);\n      String name = cursor.getString(1);\n      if (!\"sqlite_sequence\".equals(name)) {\n          \n        String sql = \"DROP \" + type + \" IF EXISTS \" + name;\n        try {\n          db.execSQL(sql);\n        } catch (SQLException e) {\n          Log.e(TAG, \"Error executing \" + sql, e);\n        }\n      }\n    }\n  }\n}",
        "summary_tokens": [
            "makes",
            "a",
            "best",
            "effort",
            "to",
            "wipe",
            "the",
            "existing",
            "database"
        ]
    },
    {
        "id": 1705,
        "code": "public static void setVersion(\n    SQLiteDatabase writableDatabase, @Feature int feature, String instanceUid, int version)\n    throws DatabaseIOException {\n  try {\n    writableDatabase.execSQL(SQL_CREATE_TABLE_IF_NOT_EXISTS);\n    ContentValues values = new ContentValues();\n    values.put(COLUMN_FEATURE, feature);\n    values.put(COLUMN_INSTANCE_UID, instanceUid);\n    values.put(COLUMN_VERSION, version);\n    writableDatabase.replaceOrThrow(TABLE_NAME,  null, values);\n  } catch (SQLException e) {\n    throw new DatabaseIOException(e);\n  }\n}",
        "summary_tokens": [
            "sets",
            "the",
            "version",
            "of",
            "a",
            "specified",
            "instance",
            "of",
            "a",
            "specified",
            "feature"
        ]
    },
    {
        "id": 1706,
        "code": "public static void removeVersion(\n    SQLiteDatabase writableDatabase, @Feature int feature, String instanceUid)\n    throws DatabaseIOException {\n  try {\n    if (!Util.tableExists(writableDatabase, TABLE_NAME)) {\n      return;\n    }\n    writableDatabase.delete(\n        TABLE_NAME,\n        WHERE_FEATURE_AND_INSTANCE_UID_EQUALS,\n        featureAndInstanceUidArguments(feature, instanceUid));\n  } catch (SQLException e) {\n    throw new DatabaseIOException(e);\n  }\n}",
        "summary_tokens": [
            "removes",
            "the",
            "version",
            "of",
            "a",
            "specified",
            "instance",
            "of",
            "a",
            "feature"
        ]
    },
    {
        "id": 1707,
        "code": "public static int getVersion(SQLiteDatabase database, @Feature int feature, String instanceUid)\n    throws DatabaseIOException {\n  try {\n    if (!Util.tableExists(database, TABLE_NAME)) {\n      return VERSION_UNSET;\n    }\n    try (Cursor cursor =\n        database.query(\n            TABLE_NAME,\n            new String[] {COLUMN_VERSION},\n            WHERE_FEATURE_AND_INSTANCE_UID_EQUALS,\n            featureAndInstanceUidArguments(feature, instanceUid),\n             null,\n             null,\n             null)) {\n      if (cursor.getCount() == 0) {\n        return VERSION_UNSET;\n      }\n      cursor.moveToNext();\n      return cursor.getInt( 0);\n    }\n  } catch (SQLException e) {\n    throw new DatabaseIOException(e);\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "version",
            "of",
            "a",
            "specified",
            "instance",
            "of",
            "a",
            "feature",
            "or",
            "version",
            "unset",
            "if",
            "no",
            "version",
            "is",
            "set"
        ]
    },
    {
        "id": 1708,
        "code": "public void open_withSpecifiedRequestParameters_usesCorrectParameters() throws Exception {\n  MockWebServer mockWebServer = new MockWebServer();\n  mockWebServer.enqueue(new MockResponse());\n\n  String propertyFromFactory = \"fromFactory\";\n  Map<String, String> defaultRequestProperties = new HashMap<>();\n  defaultRequestProperties.put(\"0\", propertyFromFactory);\n  defaultRequestProperties.put(\"1\", propertyFromFactory);\n  defaultRequestProperties.put(\"2\", propertyFromFactory);\n  defaultRequestProperties.put(\"4\", propertyFromFactory);\n  DefaultHttpDataSource dataSource =\n      new DefaultHttpDataSource.Factory()\n          .setConnectTimeoutMs(1000)\n          .setReadTimeoutMs(1000)\n          .setDefaultRequestProperties(defaultRequestProperties)\n          .createDataSource();\n\n  String propertyFromSetter = \"fromSetter\";\n  dataSource.setRequestProperty(\"1\", propertyFromSetter);\n  dataSource.setRequestProperty(\"2\", propertyFromSetter);\n  dataSource.setRequestProperty(\"3\", propertyFromSetter);\n  dataSource.setRequestProperty(\"5\", propertyFromSetter);\n\n  String propertyFromDataSpec = \"fromDataSpec\";\n  Map<String, String> dataSpecRequestProperties = new HashMap<>();\n  dataSpecRequestProperties.put(\"2\", propertyFromDataSpec);\n  dataSpecRequestProperties.put(\"3\", propertyFromDataSpec);\n  dataSpecRequestProperties.put(\"4\", propertyFromDataSpec);\n  dataSpecRequestProperties.put(\"6\", propertyFromDataSpec);\n  DataSpec dataSpec =\n      new DataSpec.Builder()\n          .setUri(mockWebServer.url(\"/test-path\").toString())\n          .setHttpRequestHeaders(dataSpecRequestProperties)\n          .build();\n\n  dataSource.open(dataSpec);\n\n  Headers headers = mockWebServer.takeRequest(10, SECONDS).getHeaders();\n  assertThat(headers.get(\"0\")).isEqualTo(propertyFromFactory);\n  assertThat(headers.get(\"1\")).isEqualTo(propertyFromSetter);\n  assertThat(headers.get(\"2\")).isEqualTo(propertyFromDataSpec);\n  assertThat(headers.get(\"3\")).isEqualTo(propertyFromDataSpec);\n  assertThat(headers.get(\"4\")).isEqualTo(propertyFromDataSpec);\n  assertThat(headers.get(\"5\")).isEqualTo(propertyFromSetter);\n  assertThat(headers.get(\"6\")).isEqualTo(propertyFromDataSpec);\n}",
        "summary_tokens": [
            "this",
            "test",
            "will",
            "set",
            "http",
            "default",
            "request",
            "parameters",
            "0",
            "in",
            "the",
            "default",
            "http",
            "data",
            "source",
            "0",
            "via",
            "default",
            "http",
            "data",
            "source"
        ]
    },
    {
        "id": 1709,
        "code": "protected final void transferInitializing(DataSpec dataSpec) {\n  for (int i = 0; i < listenerCount; i++) {\n    listeners.get(i).onTransferInitializing( this, dataSpec, isNetwork);\n  }\n}",
        "summary_tokens": [
            "notifies",
            "listeners",
            "that",
            "data",
            "transfer",
            "for",
            "the",
            "specified",
            "data",
            "spec",
            "is",
            "being",
            "initialized"
        ]
    },
    {
        "id": 1710,
        "code": "protected final void transferStarted(DataSpec dataSpec) {\n  this.dataSpec = dataSpec;\n  for (int i = 0; i < listenerCount; i++) {\n    listeners.get(i).onTransferStart( this, dataSpec, isNetwork);\n  }\n}",
        "summary_tokens": [
            "notifies",
            "listeners",
            "that",
            "data",
            "transfer",
            "for",
            "the",
            "specified",
            "data",
            "spec",
            "started"
        ]
    },
    {
        "id": 1711,
        "code": "protected final void bytesTransferred(int bytesTransferred) {\n  DataSpec dataSpec = castNonNull(this.dataSpec);\n  for (int i = 0; i < listenerCount; i++) {\n    listeners\n        .get(i)\n        .onBytesTransferred( this, dataSpec, isNetwork, bytesTransferred);\n  }\n}",
        "summary_tokens": [
            "notifies",
            "listeners",
            "that",
            "bytes",
            "were",
            "transferred"
        ]
    },
    {
        "id": 1712,
        "code": "protected final void transferEnded() {\n  DataSpec dataSpec = castNonNull(this.dataSpec);\n  for (int i = 0; i < listenerCount; i++) {\n    listeners.get(i).onTransferEnd( this, dataSpec, isNetwork);\n  }\n  this.dataSpec = null;\n}",
        "summary_tokens": [
            "notifies",
            "listeners",
            "that",
            "a",
            "transfer",
            "ended"
        ]
    },
    {
        "id": 1713,
        "code": "public byte[] getData() {\n  return stream == null ? null : stream.toByteArray();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "data",
            "written",
            "to",
            "the",
            "sink",
            "since",
            "the",
            "last",
            "call",
            "to",
            "open",
            "data",
            "spec",
            "or",
            "null",
            "if",
            "open",
            "data",
            "spec",
            "has",
            "never",
            "been",
            "called"
        ]
    },
    {
        "id": 1714,
        "code": "default Map<String, List<String>> getResponseHeaders() {\n  return Collections.emptyMap();\n}",
        "summary_tokens": [
            "when",
            "the",
            "source",
            "is",
            "open",
            "returns",
            "the",
            "response",
            "headers",
            "associated",
            "with",
            "the",
            "last",
            "open",
            "call"
        ]
    },
    {
        "id": 1715,
        "code": "public static boolean isCausedByPositionOutOfRange(IOException e) {\n  @Nullable Throwable cause = e;\n  while (cause != null) {\n    if (cause instanceof DataSourceException) {\n      int reason = ((DataSourceException) cause).reason;\n      if (reason == PlaybackException.ERROR_CODE_IO_READ_POSITION_OUT_OF_RANGE) {\n        return true;\n      }\n    }\n    cause = cause.getCause();\n  }\n  return false;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "given",
            "ioexception",
            "was",
            "caused",
            "by",
            "a",
            "data",
            "source",
            "exception",
            "whose",
            "reason",
            "is",
            "playback",
            "exception",
            "error",
            "code",
            "io",
            "read",
            "position",
            "out",
            "of",
            "range",
            "in",
            "its",
            "cause",
            "stack"
        ]
    },
    {
        "id": 1716,
        "code": "public long bytesRead() {\n  return totalBytesRead;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "total",
            "number",
            "of",
            "bytes",
            "that",
            "have",
            "been",
            "read",
            "or",
            "skipped"
        ]
    },
    {
        "id": 1717,
        "code": "public void open() throws IOException {\n  checkOpened();\n}",
        "summary_tokens": [
            "optional",
            "call",
            "to",
            "open",
            "the",
            "underlying",
            "data",
            "source"
        ]
    },
    {
        "id": 1718,
        "code": "public static byte[] readToEnd(DataSource dataSource) throws IOException {\n  byte[] data = new byte[1024];\n  int position = 0;\n  int bytesRead = 0;\n  while (bytesRead != C.RESULT_END_OF_INPUT) {\n    if (position == data.length) {\n      data = Arrays.copyOf(data, data.length * 2);\n    }\n    bytesRead = dataSource.read(data, position, data.length - position);\n    if (bytesRead != C.RESULT_END_OF_INPUT) {\n      position += bytesRead;\n    }\n  }\n  return Arrays.copyOf(data, position);\n}",
        "summary_tokens": [
            "reads",
            "data",
            "from",
            "the",
            "specified",
            "opened",
            "data",
            "source",
            "until",
            "it",
            "ends",
            "and",
            "returns",
            "a",
            "byte",
            "array",
            "containing",
            "the",
            "read",
            "data"
        ]
    },
    {
        "id": 1719,
        "code": "public static byte[] readExactly(DataSource dataSource, int length) throws IOException {\n  byte[] data = new byte[length];\n  int position = 0;\n  while (position < length) {\n    int bytesRead = dataSource.read(data, position, data.length - position);\n    if (bytesRead == C.RESULT_END_OF_INPUT) {\n      throw new IllegalStateException(\n          \"Not enough data could be read: \" + position + \" < \" + length);\n    }\n    position += bytesRead;\n  }\n  return data;\n}",
        "summary_tokens": [
            "reads",
            "length",
            "bytes",
            "from",
            "the",
            "specified",
            "opened",
            "data",
            "source",
            "and",
            "returns",
            "a",
            "byte",
            "array",
            "containing",
            "the",
            "read",
            "data"
        ]
    },
    {
        "id": 1720,
        "code": "public static void closeQuietly(@Nullable DataSource dataSource) {\n  try {\n    if (dataSource != null) {\n      dataSource.close();\n    }\n  } catch (IOException e) {\n      \n  }\n}",
        "summary_tokens": [
            "closes",
            "a",
            "data",
            "source",
            "suppressing",
            "any",
            "ioexception",
            "that",
            "may",
            "occur"
        ]
    },
    {
        "id": 1721,
        "code": "public static String getStringForHttpMethod(@HttpMethod int httpMethod) {\n  switch (httpMethod) {\n    case HTTP_METHOD_GET:\n      return \"GET\";\n    case HTTP_METHOD_POST:\n      return \"POST\";\n    case HTTP_METHOD_HEAD:\n      return \"HEAD\";\n    default:\n        \n      throw new IllegalStateException();\n  }\n}",
        "summary_tokens": [
            "returns",
            "an",
            "uppercase",
            "http",
            "method",
            "name",
            "e"
        ]
    },
    {
        "id": 1722,
        "code": "public boolean isFlagSet(@Flags int flag) {\n  return (this.flags & flag) == flag;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "given",
            "flag",
            "is",
            "set"
        ]
    },
    {
        "id": 1723,
        "code": "public final String getHttpMethodString() {\n  return getStringForHttpMethod(httpMethod);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "uppercase",
            "http",
            "method",
            "name",
            "e"
        ]
    },
    {
        "id": 1724,
        "code": "public DataSpec.Builder buildUpon() {\n  return new Builder(this);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "data",
            "spec"
        ]
    },
    {
        "id": 1725,
        "code": "public DataSpec subrange(long offset, long length) {\n  if (offset == 0 && this.length == length) {\n    return this;\n  } else {\n    return new DataSpec(\n        uri,\n        uriPositionOffset,\n        httpMethod,\n        httpBody,\n        httpRequestHeaders,\n        position + offset,\n        length,\n        key,\n        flags,\n        customData);\n  }\n}",
        "summary_tokens": [
            "returns",
            "a",
            "data",
            "spec",
            "that",
            "represents",
            "a",
            "subrange",
            "of",
            "the",
            "data",
            "defined",
            "by",
            "this",
            "data",
            "spec"
        ]
    },
    {
        "id": 1726,
        "code": "public DataSpec withUri(Uri uri) {\n  return new DataSpec(\n      uri,\n      uriPositionOffset,\n      httpMethod,\n      httpBody,\n      httpRequestHeaders,\n      position,\n      length,\n      key,\n      flags,\n      customData);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "copy",
            "of",
            "this",
            "data",
            "spec",
            "with",
            "the",
            "specified",
            "uri"
        ]
    },
    {
        "id": 1727,
        "code": "public DataSpec withRequestHeaders(Map<String, String> httpRequestHeaders) {\n  return new DataSpec(\n      uri,\n      uriPositionOffset,\n      httpMethod,\n      httpBody,\n      httpRequestHeaders,\n      position,\n      length,\n      key,\n      flags,\n      customData);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "copy",
            "of",
            "this",
            "data",
            "spec",
            "with",
            "the",
            "specified",
            "http",
            "request",
            "headers"
        ]
    },
    {
        "id": 1728,
        "code": "public DataSpec withAdditionalHeaders(Map<String, String> additionalHttpRequestHeaders) {\n  Map<String, String> httpRequestHeaders = new HashMap<>(this.httpRequestHeaders);\n  httpRequestHeaders.putAll(additionalHttpRequestHeaders);\n  return new DataSpec(\n      uri,\n      uriPositionOffset,\n      httpMethod,\n      httpBody,\n      httpRequestHeaders,\n      position,\n      length,\n      key,\n      flags,\n      customData);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "copy",
            "this",
            "data",
            "spec",
            "with",
            "additional",
            "http",
            "request",
            "headers"
        ]
    },
    {
        "id": 1729,
        "code": "public void setContentTypePredicate(@Nullable Predicate<String> contentTypePredicate) {\n  this.contentTypePredicate = contentTypePredicate;\n}",
        "summary_tokens": [
            "use",
            "default",
            "http",
            "data",
            "source"
        ]
    },
    {
        "id": 1730,
        "code": "public long open(DataSpec dataSpec) throws HttpDataSourceException {\n  this.dataSpec = dataSpec;\n  bytesRead = 0;\n  bytesToRead = 0;\n  transferInitializing(dataSpec);\n\n  String responseMessage;\n  HttpURLConnection connection;\n  try {\n    this.connection = makeConnection(dataSpec);\n    connection = this.connection;\n    responseCode = connection.getResponseCode();\n    responseMessage = connection.getResponseMessage();\n  } catch (IOException e) {\n    closeConnectionQuietly();\n    throw HttpDataSourceException.createForIOException(\n        e, dataSpec, HttpDataSourceException.TYPE_OPEN);\n  }\n\n    \n  if (responseCode < 200 || responseCode > 299) {\n    Map<String, List<String>> headers = connection.getHeaderFields();\n    if (responseCode == 416) {\n      long documentSize =\n          HttpUtil.getDocumentSize(connection.getHeaderField(HttpHeaders.CONTENT_RANGE));\n      if (dataSpec.position == documentSize) {\n        opened = true;\n        transferStarted(dataSpec);\n        return dataSpec.length != C.LENGTH_UNSET ? dataSpec.length : 0;\n      }\n    }\n\n    @Nullable InputStream errorStream = connection.getErrorStream();\n    byte[] errorResponseBody;\n    try {\n      errorResponseBody =\n          errorStream != null ? Util.toByteArray(errorStream) : Util.EMPTY_BYTE_ARRAY;\n    } catch (IOException e) {\n      errorResponseBody = Util.EMPTY_BYTE_ARRAY;\n    }\n    closeConnectionQuietly();\n    @Nullable\n    IOException cause =\n        responseCode == 416\n            ? new DataSourceException(PlaybackException.ERROR_CODE_IO_READ_POSITION_OUT_OF_RANGE)\n            : null;\n    throw new InvalidResponseCodeException(\n        responseCode, responseMessage, cause, headers, dataSpec, errorResponseBody);\n  }\n\n    \n  String contentType = connection.getContentType();\n  if (contentTypePredicate != null && !contentTypePredicate.apply(contentType)) {\n    closeConnectionQuietly();\n    throw new InvalidContentTypeException(contentType, dataSpec);\n  }\n\n    \n    \n    \n  long bytesToSkip = responseCode == 200 && dataSpec.position != 0 ? dataSpec.position : 0;\n\n    \n  boolean isCompressed = isCompressed(connection);\n  if (!isCompressed) {\n    if (dataSpec.length != C.LENGTH_UNSET) {\n      bytesToRead = dataSpec.length;\n    } else {\n      long contentLength =\n          HttpUtil.getContentLength(\n              connection.getHeaderField(HttpHeaders.CONTENT_LENGTH),\n              connection.getHeaderField(HttpHeaders.CONTENT_RANGE));\n      bytesToRead =\n          contentLength != C.LENGTH_UNSET ? (contentLength - bytesToSkip) : C.LENGTH_UNSET;\n    }\n  } else {\n      \n      \n      \n    bytesToRead = dataSpec.length;\n  }\n\n  try {\n    inputStream = connection.getInputStream();\n    if (isCompressed) {\n      inputStream = new GZIPInputStream(inputStream);\n    }\n  } catch (IOException e) {\n    closeConnectionQuietly();\n    throw new HttpDataSourceException(\n        e,\n        dataSpec,\n        PlaybackException.ERROR_CODE_IO_UNSPECIFIED,\n        HttpDataSourceException.TYPE_OPEN);\n  }\n\n  opened = true;\n  transferStarted(dataSpec);\n\n  try {\n    skipFully(bytesToSkip, dataSpec);\n  } catch (IOException e) {\n    closeConnectionQuietly();\n\n    if (e instanceof HttpDataSourceException) {\n      throw (HttpDataSourceException) e;\n    }\n    throw new HttpDataSourceException(\n        e,\n        dataSpec,\n        PlaybackException.ERROR_CODE_IO_UNSPECIFIED,\n        HttpDataSourceException.TYPE_OPEN);\n  }\n\n  return bytesToRead;\n}",
        "summary_tokens": [
            "opens",
            "the",
            "source",
            "to",
            "read",
            "the",
            "specified",
            "data"
        ]
    },
    {
        "id": 1731,
        "code": "private HttpURLConnection makeConnection(\n    URL url,\n    @HttpMethod int httpMethod,\n    @Nullable byte[] httpBody,\n    long position,\n    long length,\n    boolean allowGzip,\n    boolean followRedirects,\n    Map<String, String> requestParameters)\n    throws IOException {\n  HttpURLConnection connection = openConnection(url);\n  connection.setConnectTimeout(connectTimeoutMillis);\n  connection.setReadTimeout(readTimeoutMillis);\n\n  Map<String, String> requestHeaders = new HashMap<>();\n  if (defaultRequestProperties != null) {\n    requestHeaders.putAll(defaultRequestProperties.getSnapshot());\n  }\n  requestHeaders.putAll(requestProperties.getSnapshot());\n  requestHeaders.putAll(requestParameters);\n\n  for (Map.Entry<String, String> property : requestHeaders.entrySet()) {\n    connection.setRequestProperty(property.getKey(), property.getValue());\n  }\n\n  @Nullable String rangeHeader = buildRangeRequestHeader(position, length);\n  if (rangeHeader != null) {\n    connection.setRequestProperty(HttpHeaders.RANGE, rangeHeader);\n  }\n  if (userAgent != null) {\n    connection.setRequestProperty(HttpHeaders.USER_AGENT, userAgent);\n  }\n  connection.setRequestProperty(HttpHeaders.ACCEPT_ENCODING, allowGzip ? \"gzip\" : \"identity\");\n  connection.setInstanceFollowRedirects(followRedirects);\n  connection.setDoOutput(httpBody != null);\n  connection.setRequestMethod(DataSpec.getStringForHttpMethod(httpMethod));\n\n  if (httpBody != null) {\n    connection.setFixedLengthStreamingMode(httpBody.length);\n    connection.connect();\n    OutputStream os = connection.getOutputStream();\n    os.write(httpBody);\n    os.close();\n  } else {\n    connection.connect();\n  }\n  return connection;\n}",
        "summary_tokens": [
            "configures",
            "a",
            "connection",
            "and",
            "opens",
            "it"
        ]
    },
    {
        "id": 1732,
        "code": " HttpURLConnection openConnection(URL url) throws IOException {\n  return (HttpURLConnection) url.openConnection();\n}",
        "summary_tokens": [
            "creates",
            "an",
            "http",
            "urlconnection",
            "that",
            "is",
            "connected",
            "with",
            "the",
            "url"
        ]
    },
    {
        "id": 1733,
        "code": "private void skipFully(long bytesToSkip, DataSpec dataSpec) throws IOException {\n  if (bytesToSkip == 0) {\n    return;\n  }\n  byte[] skipBuffer = new byte[4096];\n  while (bytesToSkip > 0) {\n    int readLength = (int) min(bytesToSkip, skipBuffer.length);\n    int read = castNonNull(inputStream).read(skipBuffer, 0, readLength);\n    if (Thread.currentThread().isInterrupted()) {\n      throw new HttpDataSourceException(\n          new InterruptedIOException(),\n          dataSpec,\n          PlaybackException.ERROR_CODE_IO_UNSPECIFIED,\n          HttpDataSourceException.TYPE_OPEN);\n    }\n    if (read == -1) {\n      throw new HttpDataSourceException(\n          dataSpec,\n          PlaybackException.ERROR_CODE_IO_READ_POSITION_OUT_OF_RANGE,\n          HttpDataSourceException.TYPE_OPEN);\n    }\n    bytesToSkip -= read;\n    bytesTransferred(read);\n  }\n}",
        "summary_tokens": [
            "attempts",
            "to",
            "skip",
            "the",
            "specified",
            "number",
            "of",
            "bytes",
            "in",
            "full"
        ]
    },
    {
        "id": 1734,
        "code": "private int readInternal(byte[] buffer, int offset, int readLength) throws IOException {\n  if (readLength == 0) {\n    return 0;\n  }\n  if (bytesToRead != C.LENGTH_UNSET) {\n    long bytesRemaining = bytesToRead - bytesRead;\n    if (bytesRemaining == 0) {\n      return C.RESULT_END_OF_INPUT;\n    }\n    readLength = (int) min(readLength, bytesRemaining);\n  }\n\n  int read = castNonNull(inputStream).read(buffer, offset, readLength);\n  if (read == -1) {\n    return C.RESULT_END_OF_INPUT;\n  }\n\n  bytesRead += read;\n  bytesTransferred(read);\n  return read;\n}",
        "summary_tokens": [
            "reads",
            "up",
            "to",
            "length",
            "bytes",
            "of",
            "data",
            "and",
            "stores",
            "them",
            "into",
            "buffer",
            "starting",
            "at",
            "index",
            "offset"
        ]
    },
    {
        "id": 1735,
        "code": "private static void maybeTerminateInputStream(\n    @Nullable HttpURLConnection connection, long bytesRemaining) {\n  if (connection == null || Util.SDK_INT < 19 || Util.SDK_INT > 20) {\n    return;\n  }\n\n  try {\n    InputStream inputStream = connection.getInputStream();\n    if (bytesRemaining == C.LENGTH_UNSET) {\n        \n      if (inputStream.read() == -1) {\n        return;\n      }\n    } else if (bytesRemaining <= MAX_BYTES_TO_DRAIN) {\n        \n        \n      return;\n    }\n    String className = inputStream.getClass().getName();\n    if (\"com.android.okhttp.internal.http.HttpTransport$ChunkedInputStream\".equals(className)\n        || \"com.android.okhttp.internal.http.HttpTransport$FixedLengthInputStream\"\n            .equals(className)) {\n      Class<?> superclass = inputStream.getClass().getSuperclass();\n      Method unexpectedEndOfInput =\n          checkNotNull(superclass).getDeclaredMethod(\"unexpectedEndOfInput\");\n      unexpectedEndOfInput.setAccessible(true);\n      unexpectedEndOfInput.invoke(inputStream);\n    }\n  } catch (Exception e) {\n      \n      \n      \n  }\n}",
        "summary_tokens": [
            "on",
            "platform",
            "api",
            "levels",
            "0",
            "and",
            "0",
            "okhttp",
            "s",
            "implementation",
            "of",
            "input",
            "stream",
            "close",
            "can",
            "block",
            "for",
            "a",
            "long",
            "time",
            "if",
            "the",
            "stream",
            "has",
            "a",
            "lot",
            "of",
            "data",
            "remaining"
        ]
    },
    {
        "id": 1736,
        "code": "private void closeConnectionQuietly() {\n  if (connection != null) {\n    try {\n      connection.disconnect();\n    } catch (Exception e) {\n      Log.e(TAG, \"Unexpected error while disconnecting\", e);\n    }\n    connection = null;\n  }\n}",
        "summary_tokens": [
            "closes",
            "the",
            "current",
            "connection",
            "quietly",
            "if",
            "there",
            "is",
            "one"
        ]
    },
    {
        "id": 1737,
        "code": "public static String buildRangeRequestHeader(long position, long length) {\n  if (position == 0 && length == C.LENGTH_UNSET) {\n    return null;\n  }\n  StringBuilder rangeValue = new StringBuilder();\n  rangeValue.append(\"bytes=\");\n  rangeValue.append(position);\n  rangeValue.append(\"-\");\n  if (length != C.LENGTH_UNSET) {\n    rangeValue.append(position + length - 1);\n  }\n  return rangeValue.toString();\n}",
        "summary_tokens": [
            "builds",
            "a",
            "http",
            "headers",
            "range",
            "range",
            "header",
            "for",
            "the",
            "given",
            "position",
            "and",
            "length"
        ]
    },
    {
        "id": 1738,
        "code": "public static long getDocumentSize(@Nullable String contentRangeHeader) {\n  if (TextUtils.isEmpty(contentRangeHeader)) {\n    return C.LENGTH_UNSET;\n  }\n  Matcher matcher = CONTENT_RANGE_WITH_SIZE.matcher(contentRangeHeader);\n  return matcher.matches() ? Long.parseLong(checkNotNull(matcher.group(1))) : C.LENGTH_UNSET;\n}",
        "summary_tokens": [
            "attempts",
            "to",
            "parse",
            "the",
            "document",
            "size",
            "from",
            "a",
            "http",
            "headers",
            "content",
            "range",
            "content",
            "range",
            "header"
        ]
    },
    {
        "id": 1739,
        "code": "public static long getContentLength(\n    @Nullable String contentLengthHeader, @Nullable String contentRangeHeader) {\n  long contentLength = C.LENGTH_UNSET;\n  if (!TextUtils.isEmpty(contentLengthHeader)) {\n    try {\n      contentLength = Long.parseLong(contentLengthHeader);\n    } catch (NumberFormatException e) {\n      Log.e(TAG, \"Unexpected Content-Length [\" + contentLengthHeader + \"]\");\n    }\n  }\n  if (!TextUtils.isEmpty(contentRangeHeader)) {\n    Matcher matcher = CONTENT_RANGE_WITH_START_AND_END.matcher(contentRangeHeader);\n    if (matcher.matches()) {\n      try {\n        long contentLengthFromRange =\n            Long.parseLong(checkNotNull(matcher.group(2)))\n                - Long.parseLong(checkNotNull(matcher.group(1)))\n                + 1;\n        if (contentLength < 0) {\n            \n            \n          contentLength = contentLengthFromRange;\n        } else if (contentLength != contentLengthFromRange) {\n            \n            \n            \n            \n          Log.w(\n              TAG,\n              \"Inconsistent headers [\" + contentLengthHeader + \"] [\" + contentRangeHeader + \"]\");\n          contentLength = max(contentLength, contentLengthFromRange);\n        }\n      } catch (NumberFormatException e) {\n        Log.e(TAG, \"Unexpected Content-Range [\" + contentRangeHeader + \"]\");\n      }\n    }\n  }\n  return contentLength;\n}",
        "summary_tokens": [
            "attempts",
            "to",
            "parse",
            "the",
            "length",
            "of",
            "a",
            "response",
            "body",
            "from",
            "the",
            "corresponding",
            "response",
            "headers"
        ]
    },
    {
        "id": 1740,
        "code": "public static Uri buildRawResourceUri(int rawResourceId) {\n  return Uri.parse(RAW_RESOURCE_SCHEME + \":///\" + rawResourceId);\n}",
        "summary_tokens": [
            "builds",
            "a",
            "uri",
            "for",
            "the",
            "specified",
            "raw",
            "resource",
            "identifier"
        ]
    },
    {
        "id": 1741,
        "code": "public void resetBytesRead() {\n  bytesRead = 0;\n}",
        "summary_tokens": [
            "resets",
            "the",
            "number",
            "of",
            "bytes",
            "read",
            "as",
            "returned",
            "from",
            "get",
            "bytes",
            "read",
            "to",
            "zero"
        ]
    },
    {
        "id": 1742,
        "code": "public long getBytesRead() {\n  return bytesRead;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "total",
            "number",
            "of",
            "bytes",
            "that",
            "have",
            "been",
            "read",
            "from",
            "the",
            "data",
            "source"
        ]
    },
    {
        "id": 1743,
        "code": "public Uri getLastOpenedUri() {\n  return lastOpenedUri;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "uri",
            "associated",
            "with",
            "the",
            "last",
            "open",
            "data",
            "spec",
            "call"
        ]
    },
    {
        "id": 1744,
        "code": "public Map<String, List<String>> getLastResponseHeaders() {\n  return lastResponseHeaders;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "response",
            "headers",
            "associated",
            "with",
            "the",
            "last",
            "open",
            "data",
            "spec",
            "call"
        ]
    },
    {
        "id": 1745,
        "code": "public int getLocalPort() {\n  if (socket == null) {\n    return UDP_PORT_UNSET;\n  }\n  return socket.getLocalPort();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "local",
            "port",
            "number",
            "opened",
            "for",
            "the",
            "udp",
            "connection",
            "or",
            "udp",
            "port",
            "unset",
            "if",
            "no",
            "connection",
            "is",
            "open"
        ]
    },
    {
        "id": 1746,
        "code": "public Cache getCache() {\n  return cache;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "cache",
            "used",
            "by",
            "this",
            "instance"
        ]
    },
    {
        "id": 1747,
        "code": "public CacheKeyFactory getCacheKeyFactory() {\n  return cacheKeyFactory;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "cache",
            "key",
            "factory",
            "used",
            "by",
            "this",
            "instance"
        ]
    },
    {
        "id": 1748,
        "code": "private void openNextSource(DataSpec requestDataSpec, boolean checkCache) throws IOException {\n  @Nullable CacheSpan nextSpan;\n  String key = castNonNull(requestDataSpec.key);\n  if (currentRequestIgnoresCache) {\n    nextSpan = null;\n  } else if (blockOnCache) {\n    try {\n      nextSpan = cache.startReadWrite(key, readPosition, bytesRemaining);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw new InterruptedIOException();\n    }\n  } else {\n    nextSpan = cache.startReadWriteNonBlocking(key, readPosition, bytesRemaining);\n  }\n\n  DataSpec nextDataSpec;\n  DataSource nextDataSource;\n  if (nextSpan == null) {\n      \n      \n    nextDataSource = upstreamDataSource;\n    nextDataSpec =\n        requestDataSpec.buildUpon().setPosition(readPosition).setLength(bytesRemaining).build();\n  } else if (nextSpan.isCached) {\n      \n    Uri fileUri = Uri.fromFile(castNonNull(nextSpan.file));\n    long filePositionOffset = nextSpan.position;\n    long positionInFile = readPosition - filePositionOffset;\n    long length = nextSpan.length - positionInFile;\n    if (bytesRemaining != C.LENGTH_UNSET) {\n      length = min(length, bytesRemaining);\n    }\n    nextDataSpec =\n        requestDataSpec\n            .buildUpon()\n            .setUri(fileUri)\n            .setUriPositionOffset(filePositionOffset)\n            .setPosition(positionInFile)\n            .setLength(length)\n            .build();\n    nextDataSource = cacheReadDataSource;\n  } else {\n      \n    long length;\n    if (nextSpan.isOpenEnded()) {\n      length = bytesRemaining;\n    } else {\n      length = nextSpan.length;\n      if (bytesRemaining != C.LENGTH_UNSET) {\n        length = min(length, bytesRemaining);\n      }\n    }\n    nextDataSpec =\n        requestDataSpec.buildUpon().setPosition(readPosition).setLength(length).build();\n    if (cacheWriteDataSource != null) {\n      nextDataSource = cacheWriteDataSource;\n    } else {\n      nextDataSource = upstreamDataSource;\n      cache.releaseHoleSpan(nextSpan);\n      nextSpan = null;\n    }\n  }\n\n  checkCachePosition =\n      !currentRequestIgnoresCache && nextDataSource == upstreamDataSource\n          ? readPosition + MIN_READ_BEFORE_CHECKING_CACHE\n          : Long.MAX_VALUE;\n  if (checkCache) {\n    Assertions.checkState(isBypassingCache());\n    if (nextDataSource == upstreamDataSource) {\n        \n      return;\n    }\n      \n    try {\n      closeCurrentSource();\n    } catch (Throwable e) {\n      if (castNonNull(nextSpan).isHoleSpan()) {\n          \n        cache.releaseHoleSpan(nextSpan);\n      }\n      throw e;\n    }\n  }\n\n  if (nextSpan != null && nextSpan.isHoleSpan()) {\n    currentHoleSpan = nextSpan;\n  }\n  currentDataSource = nextDataSource;\n  currentDataSpec = nextDataSpec;\n  currentDataSourceBytesRead = 0;\n  long resolvedLength = nextDataSource.open(nextDataSpec);\n\n    \n  ContentMetadataMutations mutations = new ContentMetadataMutations();\n  if (nextDataSpec.length == C.LENGTH_UNSET && resolvedLength != C.LENGTH_UNSET) {\n    bytesRemaining = resolvedLength;\n    ContentMetadataMutations.setContentLength(mutations, readPosition + bytesRemaining);\n  }\n  if (isReadingFromUpstream()) {\n    actualUri = nextDataSource.getUri();\n    boolean isRedirected = !requestDataSpec.uri.equals(actualUri);\n    ContentMetadataMutations.setRedirectedUri(mutations, isRedirected ? actualUri : null);\n  }\n  if (isWritingToCache()) {\n    cache.applyContentMetadataMutations(key, mutations);\n  }\n}",
        "summary_tokens": [
            "opens",
            "the",
            "next",
            "source"
        ]
    },
    {
        "id": 1749,
        "code": "public static void delete(DatabaseProvider databaseProvider, long uid)\n    throws DatabaseIOException {\n  String hexUid = Long.toHexString(uid);\n  try {\n    String tableName = getTableName(hexUid);\n    SQLiteDatabase writableDatabase = databaseProvider.getWritableDatabase();\n    writableDatabase.beginTransactionNonExclusive();\n    try {\n      VersionTable.removeVersion(\n          writableDatabase, VersionTable.FEATURE_CACHE_FILE_METADATA, hexUid);\n      dropTable(writableDatabase, tableName);\n      writableDatabase.setTransactionSuccessful();\n    } finally {\n      writableDatabase.endTransaction();\n    }\n  } catch (SQLException e) {\n    throw new DatabaseIOException(e);\n  }\n}",
        "summary_tokens": [
            "deletes",
            "index",
            "data",
            "for",
            "the",
            "specified",
            "cache"
        ]
    },
    {
        "id": 1750,
        "code": "public void initialize(long uid) throws DatabaseIOException {\n  try {\n    String hexUid = Long.toHexString(uid);\n    tableName = getTableName(hexUid);\n    SQLiteDatabase readableDatabase = databaseProvider.getReadableDatabase();\n    int version =\n        VersionTable.getVersion(\n            readableDatabase, VersionTable.FEATURE_CACHE_FILE_METADATA, hexUid);\n    if (version != TABLE_VERSION) {\n      SQLiteDatabase writableDatabase = databaseProvider.getWritableDatabase();\n      writableDatabase.beginTransactionNonExclusive();\n      try {\n        VersionTable.setVersion(\n            writableDatabase, VersionTable.FEATURE_CACHE_FILE_METADATA, hexUid, TABLE_VERSION);\n        dropTable(writableDatabase, tableName);\n        writableDatabase.execSQL(\"CREATE TABLE \" + tableName + \" \" + TABLE_SCHEMA);\n        writableDatabase.setTransactionSuccessful();\n      } finally {\n        writableDatabase.endTransaction();\n      }\n    }\n  } catch (SQLException e) {\n    throw new DatabaseIOException(e);\n  }\n}",
        "summary_tokens": [
            "initializes",
            "the",
            "index",
            "for",
            "the",
            "given",
            "cache",
            "uid"
        ]
    },
    {
        "id": 1751,
        "code": "public Map<String, CacheFileMetadata> getAll() throws DatabaseIOException {\n  try (Cursor cursor = getCursor()) {\n    Map<String, CacheFileMetadata> fileMetadata = new HashMap<>(cursor.getCount());\n    while (cursor.moveToNext()) {\n      String name = checkNotNull(cursor.getString(COLUMN_INDEX_NAME));\n      long length = cursor.getLong(COLUMN_INDEX_LENGTH);\n      long lastTouchTimestamp = cursor.getLong(COLUMN_INDEX_LAST_TOUCH_TIMESTAMP);\n      fileMetadata.put(name, new CacheFileMetadata(length, lastTouchTimestamp));\n    }\n    return fileMetadata;\n  } catch (SQLException e) {\n    throw new DatabaseIOException(e);\n  }\n}",
        "summary_tokens": [
            "returns",
            "all",
            "file",
            "metadata",
            "keyed",
            "by",
            "file",
            "name"
        ]
    },
    {
        "id": 1752,
        "code": "public void set(String name, long length, long lastTouchTimestamp) throws DatabaseIOException {\n  Assertions.checkNotNull(tableName);\n  try {\n    SQLiteDatabase writableDatabase = databaseProvider.getWritableDatabase();\n    ContentValues values = new ContentValues();\n    values.put(COLUMN_NAME, name);\n    values.put(COLUMN_LENGTH, length);\n    values.put(COLUMN_LAST_TOUCH_TIMESTAMP, lastTouchTimestamp);\n    writableDatabase.replaceOrThrow(tableName,  null, values);\n  } catch (SQLException e) {\n    throw new DatabaseIOException(e);\n  }\n}",
        "summary_tokens": [
            "sets",
            "metadata",
            "for",
            "a",
            "given",
            "file"
        ]
    },
    {
        "id": 1753,
        "code": "public boolean isOpenEnded() {\n  return length == C.LENGTH_UNSET;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "this",
            "is",
            "an",
            "open",
            "ended",
            "cache",
            "span"
        ]
    },
    {
        "id": 1754,
        "code": "public boolean isHoleSpan() {\n  return !isCached;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "this",
            "is",
            "a",
            "hole",
            "cache",
            "span"
        ]
    },
    {
        "id": 1755,
        "code": "public void cancel() {\n  isCanceled = true;\n}",
        "summary_tokens": [
            "cancels",
            "this",
            "writer",
            "s",
            "caching",
            "operation"
        ]
    },
    {
        "id": 1756,
        "code": "public void cache() throws IOException {\n  throwIfCanceled();\n\n  bytesCached = cache.getCachedBytes(cacheKey, dataSpec.position, dataSpec.length);\n  if (dataSpec.length != C.LENGTH_UNSET) {\n    endPosition = dataSpec.position + dataSpec.length;\n  } else {\n    long contentLength = ContentMetadata.getContentLength(cache.getContentMetadata(cacheKey));\n    endPosition = contentLength == C.LENGTH_UNSET ? C.POSITION_UNSET : contentLength;\n  }\n  if (progressListener != null) {\n    progressListener.onProgress(getLength(), bytesCached,  0);\n  }\n\n  while (endPosition == C.POSITION_UNSET || nextPosition < endPosition) {\n    throwIfCanceled();\n    long maxRemainingLength =\n        endPosition == C.POSITION_UNSET ? Long.MAX_VALUE : endPosition - nextPosition;\n    long blockLength = cache.getCachedLength(cacheKey, nextPosition, maxRemainingLength);\n    if (blockLength > 0) {\n      nextPosition += blockLength;\n    } else {\n        \n      blockLength = -blockLength;\n      long nextRequestLength = blockLength == Long.MAX_VALUE ? C.LENGTH_UNSET : blockLength;\n      nextPosition += readBlockToCache(nextPosition, nextRequestLength);\n    }\n  }\n}",
        "summary_tokens": [
            "caches",
            "the",
            "requested",
            "data",
            "skipping",
            "any",
            "that",
            "s",
            "already",
            "cached"
        ]
    },
    {
        "id": 1757,
        "code": "private long readBlockToCache(long position, long length) throws IOException {\n  boolean isLastBlock = position + length == endPosition || length == C.LENGTH_UNSET;\n\n  long resolvedLength = C.LENGTH_UNSET;\n  boolean isDataSourceOpen = false;\n  if (length != C.LENGTH_UNSET) {\n      \n      \n    DataSpec boundedDataSpec =\n        dataSpec.buildUpon().setPosition(position).setLength(length).build();\n    try {\n      resolvedLength = dataSource.open(boundedDataSpec);\n      isDataSourceOpen = true;\n    } catch (IOException e) {\n      DataSourceUtil.closeQuietly(dataSource);\n    }\n  }\n\n  if (!isDataSourceOpen) {\n      \n      \n    throwIfCanceled();\n    DataSpec unboundedDataSpec =\n        dataSpec.buildUpon().setPosition(position).setLength(C.LENGTH_UNSET).build();\n    try {\n      resolvedLength = dataSource.open(unboundedDataSpec);\n    } catch (IOException e) {\n      DataSourceUtil.closeQuietly(dataSource);\n      throw e;\n    }\n  }\n\n  int totalBytesRead = 0;\n  try {\n    if (isLastBlock && resolvedLength != C.LENGTH_UNSET) {\n      onRequestEndPosition(position + resolvedLength);\n    }\n    int bytesRead = 0;\n    while (bytesRead != C.RESULT_END_OF_INPUT) {\n      throwIfCanceled();\n      bytesRead = dataSource.read(temporaryBuffer,  0, temporaryBuffer.length);\n      if (bytesRead != C.RESULT_END_OF_INPUT) {\n        onNewBytesCached(bytesRead);\n        totalBytesRead += bytesRead;\n      }\n    }\n    if (isLastBlock) {\n      onRequestEndPosition(position + totalBytesRead);\n    }\n  } catch (IOException e) {\n    DataSourceUtil.closeQuietly(dataSource);\n    throw e;\n  }\n\n    \n    \n    \n  dataSource.close();\n  return totalBytesRead;\n}",
        "summary_tokens": [
            "reads",
            "the",
            "specified",
            "block",
            "of",
            "data",
            "writing",
            "it",
            "into",
            "the",
            "cache"
        ]
    },
    {
        "id": 1758,
        "code": "public boolean applyMetadataMutations(ContentMetadataMutations mutations) {\n  DefaultContentMetadata oldMetadata = metadata;\n  metadata = metadata.copyWithMutationsApplied(mutations);\n  return !metadata.equals(oldMetadata);\n}",
        "summary_tokens": [
            "applies",
            "mutations",
            "to",
            "the",
            "metadata"
        ]
    },
    {
        "id": 1759,
        "code": "public boolean isFullyUnlocked() {\n  return lockedRanges.isEmpty();\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "entire",
            "resource",
            "is",
            "fully",
            "unlocked"
        ]
    },
    {
        "id": 1760,
        "code": "public boolean isFullyLocked(long position, long length) {\n  for (int i = 0; i < lockedRanges.size(); i++) {\n    if (lockedRanges.get(i).contains(position, length)) {\n      return true;\n    }\n  }\n  return false;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "specified",
            "range",
            "of",
            "the",
            "resource",
            "is",
            "fully",
            "locked",
            "by",
            "a",
            "single",
            "lock"
        ]
    },
    {
        "id": 1761,
        "code": "public boolean lockRange(long position, long length) {\n  for (int i = 0; i < lockedRanges.size(); i++) {\n    if (lockedRanges.get(i).intersects(position, length)) {\n      return false;\n    }\n  }\n  lockedRanges.add(new Range(position, length));\n  return true;\n}",
        "summary_tokens": [
            "attempts",
            "to",
            "lock",
            "the",
            "specified",
            "range",
            "of",
            "the",
            "resource"
        ]
    },
    {
        "id": 1762,
        "code": "public void unlockRange(long position) {\n  for (int i = 0; i < lockedRanges.size(); i++) {\n    if (lockedRanges.get(i).position == position) {\n      lockedRanges.remove(i);\n      return;\n    }\n  }\n  throw new IllegalStateException();\n}",
        "summary_tokens": [
            "unlocks",
            "the",
            "currently",
            "locked",
            "range",
            "starting",
            "at",
            "the",
            "specified",
            "position"
        ]
    },
    {
        "id": 1763,
        "code": "public void addSpan(SimpleCacheSpan span) {\n  cachedSpans.add(span);\n}",
        "summary_tokens": [
            "adds",
            "the",
            "given",
            "simple",
            "cache",
            "span",
            "which",
            "contains",
            "a",
            "part",
            "of",
            "the",
            "content"
        ]
    },
    {
        "id": 1764,
        "code": "public TreeSet<SimpleCacheSpan> getSpans() {\n  return cachedSpans;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "set",
            "of",
            "all",
            "simple",
            "cache",
            "span",
            "s"
        ]
    },
    {
        "id": 1765,
        "code": "public SimpleCacheSpan getSpan(long position, long length) {\n  SimpleCacheSpan lookupSpan = SimpleCacheSpan.createLookup(key, position);\n  SimpleCacheSpan floorSpan = cachedSpans.floor(lookupSpan);\n  if (floorSpan != null && floorSpan.position + floorSpan.length > position) {\n    return floorSpan;\n  }\n  SimpleCacheSpan ceilSpan = cachedSpans.ceiling(lookupSpan);\n  if (ceilSpan != null) {\n    long holeLength = ceilSpan.position - position;\n    length = length == C.LENGTH_UNSET ? holeLength : min(holeLength, length);\n  }\n  return SimpleCacheSpan.createHole(key, position, length);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "cache",
            "span",
            "corresponding",
            "to",
            "the",
            "provided",
            "range"
        ]
    },
    {
        "id": 1766,
        "code": "public long getCachedBytesLength(long position, long length) {\n  checkArgument(position >= 0);\n  checkArgument(length >= 0);\n  SimpleCacheSpan span = getSpan(position, length);\n  if (span.isHoleSpan()) {\n      \n    return -min(span.isOpenEnded() ? Long.MAX_VALUE : span.length, length);\n  }\n  long queryEndPosition = position + length;\n  if (queryEndPosition < 0) {\n      \n    queryEndPosition = Long.MAX_VALUE;\n  }\n  long currentEndPosition = span.position + span.length;\n  if (currentEndPosition < queryEndPosition) {\n    for (SimpleCacheSpan next : cachedSpans.tailSet(span, false)) {\n      if (next.position > currentEndPosition) {\n          \n        break;\n      }\n        \n        \n      currentEndPosition = max(currentEndPosition, next.position + next.length);\n      if (currentEndPosition >= queryEndPosition) {\n          \n        break;\n      }\n    }\n  }\n  return min(currentEndPosition - position, length);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "length",
            "of",
            "continuously",
            "cached",
            "data",
            "starting",
            "from",
            "position",
            "up",
            "to",
            "a",
            "maximum",
            "of",
            "max",
            "length"
        ]
    },
    {
        "id": 1767,
        "code": "public SimpleCacheSpan setLastTouchTimestamp(\n    SimpleCacheSpan cacheSpan, long lastTouchTimestamp, boolean updateFile) {\n  checkState(cachedSpans.remove(cacheSpan));\n  File file = checkNotNull(cacheSpan.file);\n  if (updateFile) {\n    File directory = checkNotNull(file.getParentFile());\n    long position = cacheSpan.position;\n    File newFile = SimpleCacheSpan.getCacheFile(directory, id, position, lastTouchTimestamp);\n    if (file.renameTo(newFile)) {\n      file = newFile;\n    } else {\n      Log.w(TAG, \"Failed to rename \" + file + \" to \" + newFile);\n    }\n  }\n  SimpleCacheSpan newCacheSpan =\n      cacheSpan.copyWithFileAndLastTouchTimestamp(file, lastTouchTimestamp);\n  cachedSpans.add(newCacheSpan);\n  return newCacheSpan;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "given",
            "span",
            "s",
            "last",
            "touch",
            "timestamp"
        ]
    },
    {
        "id": 1768,
        "code": "public boolean isEmpty() {\n  return cachedSpans.isEmpty();\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "there",
            "are",
            "any",
            "spans",
            "cached"
        ]
    },
    {
        "id": 1769,
        "code": "public boolean removeSpan(CacheSpan span) {\n  if (cachedSpans.remove(span)) {\n    if (span.file != null) {\n      span.file.delete();\n    }\n    return true;\n  }\n  return false;\n}",
        "summary_tokens": [
            "removes",
            "the",
            "given",
            "span",
            "from",
            "cache"
        ]
    },
    {
        "id": 1770,
        "code": "static long getContentLength(ContentMetadata contentMetadata) {\n  return contentMetadata.get(KEY_CONTENT_LENGTH, C.LENGTH_UNSET);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "value",
            "stored",
            "under",
            "key",
            "content",
            "length",
            "or",
            "c",
            "length",
            "unset",
            "if",
            "not",
            "set"
        ]
    },
    {
        "id": 1771,
        "code": "static Uri getRedirectedUri(ContentMetadata contentMetadata) {\n  @Nullable String redirectedUri = contentMetadata.get(KEY_REDIRECTED_URI, (String) null);\n  return redirectedUri == null ? null : Uri.parse(redirectedUri);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "value",
            "stored",
            "under",
            "key",
            "redirected",
            "uri",
            "as",
            "a",
            "uri",
            "or",
            "code",
            "null",
            "if",
            "not",
            "set"
        ]
    },
    {
        "id": 1772,
        "code": "public static ContentMetadataMutations setContentLength(\n    ContentMetadataMutations mutations, long length) {\n  return mutations.set(ContentMetadata.KEY_CONTENT_LENGTH, length);\n}",
        "summary_tokens": [
            "adds",
            "a",
            "mutation",
            "to",
            "set",
            "the",
            "content",
            "metadata",
            "key",
            "content",
            "length",
            "value",
            "or",
            "to",
            "remove",
            "any",
            "existing",
            "value",
            "if",
            "c",
            "length",
            "unset",
            "is",
            "passed"
        ]
    },
    {
        "id": 1773,
        "code": "public static ContentMetadataMutations setRedirectedUri(\n    ContentMetadataMutations mutations, @Nullable Uri uri) {\n  if (uri == null) {\n    return mutations.remove(ContentMetadata.KEY_REDIRECTED_URI);\n  } else {\n    return mutations.set(ContentMetadata.KEY_REDIRECTED_URI, uri.toString());\n  }\n}",
        "summary_tokens": [
            "adds",
            "a",
            "mutation",
            "to",
            "set",
            "the",
            "content",
            "metadata",
            "key",
            "redirected",
            "uri",
            "value",
            "or",
            "to",
            "remove",
            "any",
            "existing",
            "entry",
            "if",
            "null",
            "is",
            "passed"
        ]
    },
    {
        "id": 1774,
        "code": "public ContentMetadataMutations set(String name, byte[] value) {\n  return checkAndSet(name, Arrays.copyOf(value, value.length));\n}",
        "summary_tokens": [
            "adds",
            "a",
            "mutation",
            "to",
            "set",
            "a",
            "metadata",
            "value"
        ]
    },
    {
        "id": 1775,
        "code": "public ContentMetadataMutations remove(String name) {\n  removedValues.add(name);\n  editedValues.remove(name);\n  return this;\n}",
        "summary_tokens": [
            "adds",
            "a",
            "mutation",
            "to",
            "remove",
            "a",
            "metadata",
            "value"
        ]
    },
    {
        "id": 1776,
        "code": "public List<String> getRemovedValues() {\n  return Collections.unmodifiableList(new ArrayList<>(removedValues));\n}",
        "summary_tokens": [
            "returns",
            "a",
            "list",
            "of",
            "names",
            "of",
            "metadata",
            "values",
            "to",
            "be",
            "removed"
        ]
    },
    {
        "id": 1777,
        "code": "public Map<String, Object> getEditedValues() {\n  HashMap<String, Object> hashMap = new HashMap<>(editedValues);\n  for (Entry<String, Object> entry : hashMap.entrySet()) {\n    Object value = entry.getValue();\n    if (value instanceof byte[]) {\n      byte[] bytes = (byte[]) value;\n      entry.setValue(Arrays.copyOf(bytes, bytes.length));\n    }\n  }\n  return Collections.unmodifiableMap(hashMap);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "map",
            "of",
            "metadata",
            "name",
            "value",
            "pairs",
            "to",
            "be",
            "set"
        ]
    },
    {
        "id": 1778,
        "code": "public DefaultContentMetadata copyWithMutationsApplied(ContentMetadataMutations mutations) {\n  Map<String, byte[]> mutatedMetadata = applyMutations(metadata, mutations);\n  if (isMetadataEqual(metadata, mutatedMetadata)) {\n    return this;\n  }\n  return new DefaultContentMetadata(mutatedMetadata);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "copy",
            "default",
            "content",
            "metadata",
            "with",
            "mutations",
            "applied"
        ]
    },
    {
        "id": 1779,
        "code": "public Set<Entry<String, byte[]>> entrySet() {\n  return metadata.entrySet();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "set",
            "of",
            "metadata",
            "entries",
            "in",
            "their",
            "raw",
            "byte",
            "array",
            "form"
        ]
    },
    {
        "id": 1780,
        "code": "public void reset(OutputStream out) {\n  Assertions.checkState(closed);\n  this.out = out;\n  count = 0;\n  closed = false;\n}",
        "summary_tokens": [
            "resets",
            "this",
            "stream",
            "and",
            "uses",
            "the",
            "given",
            "output",
            "stream",
            "for",
            "writing"
        ]
    },
    {
        "id": 1781,
        "code": "public static synchronized boolean isCacheFolderLocked(File cacheFolder) {\n  return lockedCacheDirs.contains(cacheFolder.getAbsoluteFile());\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "cache",
            "folder",
            "is",
            "locked",
            "by",
            "a",
            "simple",
            "cache",
            "instance"
        ]
    },
    {
        "id": 1782,
        "code": "public static void delete(File cacheDir, @Nullable DatabaseProvider databaseProvider) {\n  if (!cacheDir.exists()) {\n    return;\n  }\n\n  File[] files = cacheDir.listFiles();\n  if (files == null) {\n    cacheDir.delete();\n    return;\n  }\n\n  if (databaseProvider != null) {\n      \n      \n    long uid = loadUid(files);\n    if (uid != UID_UNSET) {\n      try {\n        CacheFileMetadataIndex.delete(databaseProvider, uid);\n      } catch (DatabaseIOException e) {\n        Log.w(TAG, \"Failed to delete file metadata: \" + uid);\n      }\n      try {\n        CachedContentIndex.delete(databaseProvider, uid);\n      } catch (DatabaseIOException e) {\n        Log.w(TAG, \"Failed to delete file metadata: \" + uid);\n      }\n    }\n  }\n\n  Util.recursiveDelete(cacheDir);\n}",
        "summary_tokens": [
            "deletes",
            "all",
            "content",
            "belonging",
            "to",
            "a",
            "cache",
            "instance"
        ]
    },
    {
        "id": 1783,
        "code": "public synchronized void checkInitialization() throws CacheException {\n  if (initializationException != null) {\n    throw initializationException;\n  }\n}",
        "summary_tokens": [
            "checks",
            "whether",
            "the",
            "cache",
            "was",
            "initialized",
            "successfully"
        ]
    },
    {
        "id": 1784,
        "code": "private void initialize() {\n  if (!cacheDir.exists()) {\n    try {\n      createCacheDirectories(cacheDir);\n    } catch (CacheException e) {\n      initializationException = e;\n      return;\n    }\n  }\n\n  @Nullable File[] files = cacheDir.listFiles();\n  if (files == null) {\n    String message = \"Failed to list cache directory files: \" + cacheDir;\n    Log.e(TAG, message);\n    initializationException = new CacheException(message);\n    return;\n  }\n\n  uid = loadUid(files);\n  if (uid == UID_UNSET) {\n    try {\n      uid = createUid(cacheDir);\n    } catch (IOException e) {\n      String message = \"Failed to create cache UID: \" + cacheDir;\n      Log.e(TAG, message, e);\n      initializationException = new CacheException(message, e);\n      return;\n    }\n  }\n\n  try {\n    contentIndex.initialize(uid);\n    if (fileIndex != null) {\n      fileIndex.initialize(uid);\n      Map<String, CacheFileMetadata> fileMetadata = fileIndex.getAll();\n      loadDirectory(cacheDir,  true, files, fileMetadata);\n      fileIndex.removeAll(fileMetadata.keySet());\n    } else {\n      loadDirectory(cacheDir,  true, files,  null);\n    }\n  } catch (IOException e) {\n    String message = \"Failed to initialize cache indices: \" + cacheDir;\n    Log.e(TAG, message, e);\n    initializationException = new CacheException(message, e);\n    return;\n  }\n\n  contentIndex.removeEmpty();\n  try {\n    contentIndex.store();\n  } catch (IOException e) {\n    Log.e(TAG, \"Storing index file failed\", e);\n  }\n}",
        "summary_tokens": [
            "ensures",
            "that",
            "the",
            "cache",
            "s",
            "in",
            "memory",
            "representation",
            "has",
            "been",
            "initialized"
        ]
    },
    {
        "id": 1785,
        "code": "private void loadDirectory(\n    File directory,\n    boolean isRoot,\n    @Nullable File[] files,\n    @Nullable Map<String, CacheFileMetadata> fileMetadata) {\n  if (files == null || files.length == 0) {\n      \n    if (!isRoot) {\n        \n        \n      directory.delete();\n    }\n    return;\n  }\n  for (File file : files) {\n    String fileName = file.getName();\n    if (isRoot && fileName.indexOf('.') == -1) {\n      loadDirectory(file,  false, file.listFiles(), fileMetadata);\n    } else {\n      if (isRoot\n          && (CachedContentIndex.isIndexFile(fileName) || fileName.endsWith(UID_FILE_SUFFIX))) {\n          \n        continue;\n      }\n      long length = C.LENGTH_UNSET;\n      long lastTouchTimestamp = C.TIME_UNSET;\n      @Nullable\n      CacheFileMetadata metadata = fileMetadata != null ? fileMetadata.remove(fileName) : null;\n      if (metadata != null) {\n        length = metadata.length;\n        lastTouchTimestamp = metadata.lastTouchTimestamp;\n      }\n      @Nullable\n      SimpleCacheSpan span =\n          SimpleCacheSpan.createCacheEntry(file, length, lastTouchTimestamp, contentIndex);\n      if (span != null) {\n        addSpan(span);\n      } else {\n        file.delete();\n      }\n    }\n  }\n}",
        "summary_tokens": [
            "loads",
            "a",
            "cache",
            "directory"
        ]
    },
    {
        "id": 1786,
        "code": "private SimpleCacheSpan touchSpan(String key, SimpleCacheSpan span) {\n  if (!touchCacheSpans) {\n    return span;\n  }\n  String fileName = Assertions.checkNotNull(span.file).getName();\n  long length = span.length;\n  long lastTouchTimestamp = System.currentTimeMillis();\n  boolean updateFile = false;\n  if (fileIndex != null) {\n    try {\n      fileIndex.set(fileName, length, lastTouchTimestamp);\n    } catch (IOException e) {\n      Log.w(TAG, \"Failed to update index with new touch timestamp.\");\n    }\n  } else {\n      \n      \n    updateFile = true;\n  }\n  SimpleCacheSpan newSpan =\n      contentIndex.get(key).setLastTouchTimestamp(span, lastTouchTimestamp, updateFile);\n  notifySpanTouched(span, newSpan);\n  return newSpan;\n}",
        "summary_tokens": [
            "touches",
            "a",
            "cache",
            "span",
            "returning",
            "the",
            "updated",
            "result"
        ]
    },
    {
        "id": 1787,
        "code": "private SimpleCacheSpan getSpan(String key, long position, long length) {\n  @Nullable CachedContent cachedContent = contentIndex.get(key);\n  if (cachedContent == null) {\n    return SimpleCacheSpan.createHole(key, position, length);\n  }\n  while (true) {\n    SimpleCacheSpan span = cachedContent.getSpan(position, length);\n    if (span.isCached && span.file.length() != span.length) {\n        \n        \n      removeStaleSpans();\n      continue;\n    }\n    return span;\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "cache",
            "span",
            "corresponding",
            "to",
            "the",
            "provided",
            "key",
            "and",
            "range"
        ]
    },
    {
        "id": 1788,
        "code": "private void addSpan(SimpleCacheSpan span) {\n  contentIndex.getOrAdd(span.key).addSpan(span);\n  totalSpace += span.length;\n  notifySpanAdded(span);\n}",
        "summary_tokens": [
            "adds",
            "a",
            "cached",
            "span",
            "to",
            "the",
            "in",
            "memory",
            "representation"
        ]
    },
    {
        "id": 1789,
        "code": "private void removeStaleSpans() {\n  ArrayList<CacheSpan> spansToBeRemoved = new ArrayList<>();\n  for (CachedContent cachedContent : contentIndex.getAll()) {\n    for (CacheSpan span : cachedContent.getSpans()) {\n      if (span.file.length() != span.length) {\n        spansToBeRemoved.add(span);\n      }\n    }\n  }\n  for (int i = 0; i < spansToBeRemoved.size(); i++) {\n    removeSpanInternal(spansToBeRemoved.get(i));\n  }\n}",
        "summary_tokens": [
            "scans",
            "all",
            "of",
            "the",
            "cached",
            "spans",
            "in",
            "the",
            "in",
            "memory",
            "representation",
            "removing",
            "any",
            "for",
            "which",
            "the",
            "underlying",
            "file",
            "lengths",
            "no",
            "longer",
            "match"
        ]
    },
    {
        "id": 1790,
        "code": "private static long loadUid(File[] files) {\n  for (File file : files) {\n    String fileName = file.getName();\n    if (fileName.endsWith(UID_FILE_SUFFIX)) {\n      try {\n        return parseUid(fileName);\n      } catch (NumberFormatException e) {\n          \n        Log.e(TAG, \"Malformed UID file: \" + file);\n        file.delete();\n      }\n    }\n  }\n  return UID_UNSET;\n}",
        "summary_tokens": [
            "loads",
            "the",
            "cache",
            "uid",
            "from",
            "the",
            "files",
            "belonging",
            "to",
            "the",
            "root",
            "directory"
        ]
    },
    {
        "id": 1791,
        "code": "public static File getCacheFile(File cacheDir, int id, long position, long timestamp) {\n  return new File(cacheDir, id + \".\" + position + \".\" + timestamp + SUFFIX);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "file",
            "instance",
            "from",
            "cache",
            "dir",
            "id",
            "position",
            "timestamp"
        ]
    },
    {
        "id": 1792,
        "code": "public static SimpleCacheSpan createLookup(String key, long position) {\n  return new SimpleCacheSpan(key, position, C.LENGTH_UNSET, C.TIME_UNSET, null);\n}",
        "summary_tokens": [
            "creates",
            "a",
            "lookup",
            "span"
        ]
    },
    {
        "id": 1793,
        "code": "public static SimpleCacheSpan createHole(String key, long position, long length) {\n  return new SimpleCacheSpan(key, position, length, C.TIME_UNSET, null);\n}",
        "summary_tokens": [
            "creates",
            "a",
            "hole",
            "span"
        ]
    },
    {
        "id": 1794,
        "code": "public static SimpleCacheSpan createCacheEntry(\n    File file, long length, long lastTouchTimestamp, CachedContentIndex index) {\n  String name = file.getName();\n  if (!name.endsWith(SUFFIX)) {\n    @Nullable File upgradedFile = upgradeFile(file, index);\n    if (upgradedFile == null) {\n      return null;\n    }\n    file = upgradedFile;\n    name = file.getName();\n  }\n\n  Matcher matcher = CACHE_FILE_PATTERN_V3.matcher(name);\n  if (!matcher.matches()) {\n    return null;\n  }\n\n  int id = Integer.parseInt(Assertions.checkNotNull(matcher.group(1)));\n  @Nullable String key = index.getKeyForId(id);\n  if (key == null) {\n    return null;\n  }\n\n  if (length == C.LENGTH_UNSET) {\n    length = file.length();\n  }\n  if (length == 0) {\n    return null;\n  }\n\n  long position = Long.parseLong(Assertions.checkNotNull(matcher.group(2)));\n  if (lastTouchTimestamp == C.TIME_UNSET) {\n    lastTouchTimestamp = Long.parseLong(Assertions.checkNotNull(matcher.group(3)));\n  }\n  return new SimpleCacheSpan(key, position, length, lastTouchTimestamp, file);\n}",
        "summary_tokens": [
            "creates",
            "a",
            "cache",
            "span",
            "from",
            "an",
            "underlying",
            "cache",
            "file"
        ]
    },
    {
        "id": 1795,
        "code": "private static File upgradeFile(File file, CachedContentIndex index) {\n  @Nullable String key = null;\n  String filename = file.getName();\n  Matcher matcher = CACHE_FILE_PATTERN_V2.matcher(filename);\n  if (matcher.matches()) {\n    key = Util.unescapeFileName(Assertions.checkNotNull(matcher.group(1)));\n  } else {\n    matcher = CACHE_FILE_PATTERN_V1.matcher(filename);\n    if (matcher.matches()) {\n      key = Assertions.checkNotNull(matcher.group(1)); \n    }\n  }\n\n  if (key == null) {\n    return null;\n  }\n\n  File newCacheFile =\n      getCacheFile(\n          Assertions.checkStateNotNull(file.getParentFile()),\n          index.assignIdForKey(key),\n          Long.parseLong(Assertions.checkNotNull(matcher.group(2))),\n          Long.parseLong(Assertions.checkNotNull(matcher.group(3))));\n  if (!file.renameTo(newCacheFile)) {\n    return null;\n  }\n  return newCacheFile;\n}",
        "summary_tokens": [
            "upgrades",
            "the",
            "cache",
            "file",
            "if",
            "it",
            "is",
            "created",
            "by",
            "an",
            "earlier",
            "version",
            "of",
            "simple",
            "cache"
        ]
    },
    {
        "id": 1796,
        "code": "public SimpleCacheSpan copyWithFileAndLastTouchTimestamp(File file, long lastTouchTimestamp) {\n  Assertions.checkState(isCached);\n  return new SimpleCacheSpan(key, position, length, lastTouchTimestamp, file);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "copy",
            "of",
            "this",
            "cache",
            "span",
            "with",
            "a",
            "new",
            "file",
            "and",
            "last",
            "touch",
            "timestamp"
        ]
    },
    {
        "id": 1797,
        "code": "private static long getFNV64Hash(@Nullable String input) {\n  if (input == null) {\n    return 0;\n  }\n\n  long hash = 0;\n  for (int i = 0; i < input.length(); i++) {\n    hash ^= input.charAt(i);\n      \n    hash += (hash << 1) + (hash << 4) + (hash << 5) + (hash << 7) + (hash << 8) + (hash << 40);\n  }\n  return hash;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "hash",
            "value",
            "of",
            "the",
            "input",
            "as",
            "a",
            "long",
            "using",
            "the",
            "0",
            "bit",
            "fnv",
            "0",
            "a",
            "hash",
            "function"
        ]
    },
    {
        "id": 1798,
        "code": "private void readTestData(\n    byte[] testData,\n    int dataOffset,\n    int dataLength,\n    int outputBufferLength,\n    int writeOffset,\n    int maxReadLength,\n    boolean expectFailOnOpen) {\n  int expectedFinalBytesRead = testData.length - dataOffset;\n  if (dataLength != C.LENGTH_UNSET) {\n    expectedFinalBytesRead = min(expectedFinalBytesRead, dataLength);\n  }\n  ByteArrayDataSource dataSource = new ByteArrayDataSource(testData);\n  boolean opened = false;\n  try {\n      \n    long length = dataSource.open(new DataSpec(Uri.EMPTY, dataOffset, dataLength));\n    opened = true;\n    assertThat(expectFailOnOpen).isFalse();\n\n      \n    assertThat(length)\n        .isEqualTo(dataLength != C.LENGTH_UNSET ? dataLength : expectedFinalBytesRead);\n\n    byte[] outputBuffer = new byte[outputBufferLength];\n    int accumulatedBytesRead = 0;\n    while (true) {\n        \n        \n      int requestedReadLength = min(maxReadLength, outputBufferLength - writeOffset);\n      assertThat(requestedReadLength).isGreaterThan(0);\n\n      int bytesRead = dataSource.read(outputBuffer, writeOffset, requestedReadLength);\n      if (bytesRead != C.RESULT_END_OF_INPUT) {\n        assertThat(bytesRead).isGreaterThan(0);\n        assertThat(bytesRead).isAtMost(requestedReadLength);\n          \n        for (int i = 0; i < bytesRead; i++) {\n          assertThat(outputBuffer[writeOffset + i])\n              .isEqualTo(testData[dataOffset + accumulatedBytesRead + i]);\n        }\n          \n        accumulatedBytesRead += bytesRead;\n        assertThat(accumulatedBytesRead).isAtMost(expectedFinalBytesRead);\n          \n        assertThat(\n                accumulatedBytesRead == expectedFinalBytesRead\n                    || bytesRead == requestedReadLength)\n            .isTrue();\n      } else {\n          \n        assertThat(accumulatedBytesRead).isEqualTo(expectedFinalBytesRead);\n        return;\n      }\n    }\n  } catch (IOException e) {\n    if (expectFailOnOpen && !opened) {\n        \n      return;\n    }\n      \n    fail();\n  }\n}",
        "summary_tokens": [
            "tests",
            "reading",
            "from",
            "a",
            "byte",
            "array",
            "data",
            "source",
            "with",
            "various",
            "parameters"
        ]
    },
    {
        "id": 1799,
        "code": "private static void assertDataSourceContent(\n    DataSource dataSource, DataSpec dataSpec, byte[] expectedData) throws IOException {\n  try {\n    long length = dataSource.open(dataSpec);\n    assertThat(length).isEqualTo(expectedData.length);\n    byte[] readData = DataSourceUtil.readToEnd(dataSource);\n    assertThat(readData).isEqualTo(expectedData);\n  } finally {\n    dataSource.close();\n  }\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "data",
            "read",
            "from",
            "a",
            "data",
            "source",
            "matches",
            "expected"
        ]
    },
    {
        "id": 1800,
        "code": "private static int findFreeUdpPort() {\n  for (int i = 50000; i <= 60000; i++) {\n    try {\n      new DatagramSocket(i).close();\n      return i;\n    } catch (SocketException e) {\n        \n    }\n  }\n  throw new IllegalStateException();\n}",
        "summary_tokens": [
            "finds",
            "a",
            "free",
            "udp",
            "port",
            "in",
            "the",
            "range",
            "of",
            "unreserved",
            "ports",
            "0",
            "0",
            "that",
            "can",
            "be",
            "used",
            "from",
            "the",
            "test",
            "or",
            "throws",
            "an",
            "illegal",
            "state",
            "exception",
            "if",
            "no",
            "port",
            "is",
            "available"
        ]
    },
    {
        "id": 1801,
        "code": "private void assertReadDataContentLength(\n    CacheDataSource cacheDataSource,\n    DataSpec dataSpec,\n    boolean unknownLength,\n    boolean customCacheKey)\n    throws IOException {\n  assertReadData(cacheDataSource, dataSpec, unknownLength);\n    \n    \n    \n  ContentMetadata metadata =\n      cache.getContentMetadata(customCacheKey ? this.customCacheKey : defaultCacheKey);\n  assertThat(ContentMetadata.getContentLength(metadata))\n      .isEqualTo(dataSpec.length == C.LENGTH_UNSET ? TEST_DATA.length : C.LENGTH_UNSET);\n}",
        "summary_tokens": [
            "reads",
            "data",
            "until",
            "eoi",
            "and",
            "compares",
            "it",
            "to",
            "test",
            "data"
        ]
    },
    {
        "id": 1802,
        "code": "private void assertSingleOpen(FakeDataSource upstreamSource, int start, int end) {\n  DataSpec[] openedDataSpecs = upstreamSource.getAndClearOpenedDataSpecs();\n  assertThat(openedDataSpecs).hasLength(1);\n  assertThat(openedDataSpecs[0].position).isEqualTo(start);\n  assertThat(openedDataSpecs[0].length).isEqualTo(end - start);\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "a",
            "single",
            "data",
            "source",
            "open",
            "data",
            "spec",
            "call",
            "has",
            "been",
            "made",
            "to",
            "the",
            "upstream",
            "source",
            "with",
            "the",
            "specified",
            "start",
            "inclusive",
            "and",
            "end",
            "exclusive",
            "positions"
        ]
    },
    {
        "id": 1803,
        "code": "private void assertNoOpen(FakeDataSource upstreamSource) {\n  DataSpec[] openedDataSpecs = upstreamSource.getAndClearOpenedDataSpecs();\n  assertThat(openedDataSpecs).hasLength(0);\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "the",
            "upstream",
            "source",
            "was",
            "not",
            "opened"
        ]
    },
    {
        "id": 1804,
        "code": "public final boolean isDecodeOnly() {\n  return getFlag(C.BUFFER_FLAG_DECODE_ONLY);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "c",
            "buffer",
            "flag",
            "decode",
            "only",
            "flag",
            "is",
            "set"
        ]
    },
    {
        "id": 1805,
        "code": "public final boolean isFirstSample() {\n  return getFlag(C.BUFFER_FLAG_FIRST_SAMPLE);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "c",
            "buffer",
            "flag",
            "first",
            "sample",
            "flag",
            "is",
            "set"
        ]
    },
    {
        "id": 1806,
        "code": "public final boolean isEndOfStream() {\n  return getFlag(C.BUFFER_FLAG_END_OF_STREAM);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "c",
            "buffer",
            "flag",
            "end",
            "of",
            "stream",
            "flag",
            "is",
            "set"
        ]
    },
    {
        "id": 1807,
        "code": "public final boolean isKeyFrame() {\n  return getFlag(C.BUFFER_FLAG_KEY_FRAME);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "c",
            "buffer",
            "flag",
            "key",
            "frame",
            "flag",
            "is",
            "set"
        ]
    },
    {
        "id": 1808,
        "code": "public final boolean hasSupplementalData() {\n  return getFlag(C.BUFFER_FLAG_HAS_SUPPLEMENTAL_DATA);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "c",
            "buffer",
            "flag",
            "has",
            "supplemental",
            "data",
            "flag",
            "is",
            "set"
        ]
    },
    {
        "id": 1809,
        "code": "public final void setFlags(@C.BufferFlags int flags) {\n  this.flags = flags;\n}",
        "summary_tokens": [
            "replaces",
            "this",
            "buffer",
            "s",
            "flags",
            "with",
            "flags"
        ]
    },
    {
        "id": 1810,
        "code": "public final void addFlag(@C.BufferFlags int flag) {\n  flags |= flag;\n}",
        "summary_tokens": [
            "adds",
            "the",
            "flag",
            "to",
            "this",
            "buffer",
            "s",
            "flags"
        ]
    },
    {
        "id": 1811,
        "code": "public final void clearFlag(@C.BufferFlags int flag) {\n  flags &= ~flag;\n}",
        "summary_tokens": [
            "removes",
            "the",
            "flag",
            "from",
            "this",
            "buffer",
            "s",
            "flags",
            "if",
            "it",
            "is",
            "set"
        ]
    },
    {
        "id": 1812,
        "code": "protected final boolean getFlag(@C.BufferFlags int flag) {\n  return (flags & flag) == flag;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "specified",
            "flag",
            "has",
            "been",
            "set",
            "on",
            "this",
            "buffer"
        ]
    },
    {
        "id": 1813,
        "code": "public android.media.MediaCodec.CryptoInfo getFrameworkCryptoInfo() {\n  return frameworkCryptoInfo;\n}",
        "summary_tokens": [
            "returns",
            "an",
            "equivalent",
            "android"
        ]
    },
    {
        "id": 1814,
        "code": "public void increaseClearDataFirstSubSampleBy(int count) {\n  if (count == 0) {\n    return;\n  }\n  if (numBytesOfClearData == null) {\n    numBytesOfClearData = new int[1];\n    frameworkCryptoInfo.numBytesOfClearData = numBytesOfClearData;\n  }\n  numBytesOfClearData[0] += count;\n}",
        "summary_tokens": [
            "increases",
            "the",
            "number",
            "of",
            "clear",
            "data",
            "for",
            "the",
            "first",
            "sub",
            "sample",
            "by",
            "count"
        ]
    },
    {
        "id": 1815,
        "code": "public static DecoderInputBuffer newNoDataInstance() {\n  return new DecoderInputBuffer(BUFFER_REPLACEMENT_MODE_DISABLED);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "instance",
            "that",
            "s",
            "not",
            "able",
            "to",
            "hold",
            "any",
            "data"
        ]
    },
    {
        "id": 1816,
        "code": "public void resetSupplementalData(int length) {\n  if (supplementalData == null || supplementalData.capacity() < length) {\n    supplementalData = ByteBuffer.allocate(length);\n  } else {\n    supplementalData.clear();\n  }\n}",
        "summary_tokens": [
            "clears",
            "supplemental",
            "data",
            "and",
            "ensures",
            "that",
            "it",
            "s",
            "large",
            "enough",
            "to",
            "accommodate",
            "length",
            "bytes"
        ]
    },
    {
        "id": 1817,
        "code": "public void ensureSpaceForWrite(int length) {\n  length += paddingSize;\n  @Nullable ByteBuffer currentData = data;\n  if (currentData == null) {\n    data = createReplacementByteBuffer(length);\n    return;\n  }\n    \n  int capacity = currentData.capacity();\n  int position = currentData.position();\n  int requiredCapacity = position + length;\n  if (capacity >= requiredCapacity) {\n    data = currentData;\n    return;\n  }\n    \n  ByteBuffer newData = createReplacementByteBuffer(requiredCapacity);\n  newData.order(currentData.order());\n    \n  if (position > 0) {\n    currentData.flip();\n    newData.put(currentData);\n  }\n    \n  data = newData;\n}",
        "summary_tokens": [
            "ensures",
            "that",
            "data",
            "is",
            "large",
            "enough",
            "to",
            "accommodate",
            "a",
            "write",
            "of",
            "a",
            "given",
            "length",
            "at",
            "its",
            "current",
            "position"
        ]
    },
    {
        "id": 1818,
        "code": "public final boolean isEncrypted() {\n  return getFlag(C.BUFFER_FLAG_ENCRYPTED);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "c",
            "buffer",
            "flag",
            "encrypted",
            "flag",
            "is",
            "set"
        ]
    },
    {
        "id": 1819,
        "code": "public final void flip() {\n  if (data != null) {\n    data.flip();\n  }\n  if (supplementalData != null) {\n    supplementalData.flip();\n  }\n}",
        "summary_tokens": [
            "flips",
            "data",
            "and",
            "supplemental",
            "data",
            "in",
            "preparation",
            "for",
            "being",
            "queued",
            "to",
            "a",
            "decoder"
        ]
    },
    {
        "id": 1820,
        "code": "protected final void setInitialInputBufferSize(int size) {\n  Assertions.checkState(availableInputBufferCount == availableInputBuffers.length);\n  for (I inputBuffer : availableInputBuffers) {\n    inputBuffer.ensureSpaceForWrite(size);\n  }\n}",
        "summary_tokens": [
            "sets",
            "the",
            "initial",
            "size",
            "of",
            "each",
            "input",
            "buffer"
        ]
    },
    {
        "id": 1821,
        "code": "protected void releaseOutputBuffer(O outputBuffer) {\n  synchronized (lock) {\n    releaseOutputBufferInternal(outputBuffer);\n    maybeNotifyDecodeLoop();\n  }\n}",
        "summary_tokens": [
            "releases",
            "an",
            "output",
            "buffer",
            "back",
            "to",
            "the",
            "decoder"
        ]
    },
    {
        "id": 1822,
        "code": "private void maybeThrowException() throws E {\n  @Nullable E exception = this.exception;\n  if (exception != null) {\n    throw exception;\n  }\n}",
        "summary_tokens": [
            "throws",
            "a",
            "decode",
            "exception",
            "if",
            "there",
            "is",
            "one"
        ]
    },
    {
        "id": 1823,
        "code": "private void maybeNotifyDecodeLoop() {\n  if (canDecodeBuffer()) {\n    lock.notify();\n  }\n}",
        "summary_tokens": [
            "notifies",
            "the",
            "decode",
            "loop",
            "if",
            "there",
            "exists",
            "a",
            "queued",
            "input",
            "buffer",
            "and",
            "an",
            "available",
            "output",
            "buffer",
            "to",
            "decode",
            "into"
        ]
    },
    {
        "id": 1824,
        "code": "public boolean initForYuvFrame(int width, int height, int yStride, int uvStride, int colorspace) {\n  this.width = width;\n  this.height = height;\n  this.colorspace = colorspace;\n  int uvHeight = (int) (((long) height + 1) / 2);\n  if (!isSafeToMultiply(yStride, height) || !isSafeToMultiply(uvStride, uvHeight)) {\n    return false;\n  }\n  int yLength = yStride * height;\n  int uvLength = uvStride * uvHeight;\n  int minimumYuvSize = yLength + (uvLength * 2);\n  if (!isSafeToMultiply(uvLength, 2) || minimumYuvSize < yLength) {\n    return false;\n  }\n\n    \n  if (data == null || data.capacity() < minimumYuvSize) {\n    data = ByteBuffer.allocateDirect(minimumYuvSize);\n  } else {\n    data.position(0);\n    data.limit(minimumYuvSize);\n  }\n\n  if (yuvPlanes == null) {\n    yuvPlanes = new ByteBuffer[3];\n  }\n\n  ByteBuffer data = this.data;\n  ByteBuffer[] yuvPlanes = this.yuvPlanes;\n\n    \n  yuvPlanes[0] = data.slice();\n  yuvPlanes[0].limit(yLength);\n  data.position(yLength);\n  yuvPlanes[1] = data.slice();\n  yuvPlanes[1].limit(uvLength);\n  data.position(yLength + uvLength);\n  yuvPlanes[2] = data.slice();\n  yuvPlanes[2].limit(uvLength);\n  if (yuvStrides == null) {\n    yuvStrides = new int[3];\n  }\n  yuvStrides[0] = yStride;\n  yuvStrides[1] = uvStride;\n  yuvStrides[2] = uvStride;\n  return true;\n}",
        "summary_tokens": [
            "resizes",
            "the",
            "buffer",
            "based",
            "on",
            "the",
            "given",
            "stride"
        ]
    },
    {
        "id": 1825,
        "code": "public void initForPrivateFrame(int width, int height) {\n  this.width = width;\n  this.height = height;\n}",
        "summary_tokens": [
            "configures",
            "the",
            "buffer",
            "for",
            "the",
            "given",
            "frame",
            "dimensions",
            "when",
            "passing",
            "actual",
            "frame",
            "data",
            "via",
            "decoder",
            "private"
        ]
    },
    {
        "id": 1826,
        "code": "private static boolean isSafeToMultiply(int a, int b) {\n  return a >= 0 && b >= 0 && !(b > 0 && a >= Integer.MAX_VALUE / b);\n}",
        "summary_tokens": [
            "ensures",
            "that",
            "the",
            "result",
            "of",
            "multiplying",
            "individual",
            "numbers",
            "can",
            "fit",
            "into",
            "the",
            "size",
            "limit",
            "of",
            "an",
            "integer"
        ]
    },
    {
        "id": 1827,
        "code": "public static Config parseAudioSpecificConfig(ParsableBitArray bitArray, boolean forceReadToEnd)\n    throws ParserException {\n  int audioObjectType = getAudioObjectType(bitArray);\n  int sampleRateHz = getSamplingFrequency(bitArray);\n  int channelConfiguration = bitArray.readBits(4);\n  String codecs = CODECS_STRING_PREFIX + audioObjectType;\n  if (audioObjectType == AUDIO_OBJECT_TYPE_AAC_SBR\n      || audioObjectType == AUDIO_OBJECT_TYPE_AAC_PS) {\n      \n      \n      \n      \n      \n    sampleRateHz = getSamplingFrequency(bitArray);\n    audioObjectType = getAudioObjectType(bitArray);\n    if (audioObjectType == AUDIO_OBJECT_TYPE_AAC_ER_BSAC) {\n        \n      channelConfiguration = bitArray.readBits(4);\n    }\n  }\n\n  if (forceReadToEnd) {\n    switch (audioObjectType) {\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n      case 6:\n      case 7:\n      case 17:\n      case 19:\n      case 20:\n      case 21:\n      case 22:\n      case 23:\n        parseGaSpecificConfig(bitArray, audioObjectType, channelConfiguration);\n        break;\n      default:\n        throw ParserException.createForUnsupportedContainerFeature(\n            \"Unsupported audio object type: \" + audioObjectType);\n    }\n    switch (audioObjectType) {\n      case 17:\n      case 19:\n      case 20:\n      case 21:\n      case 22:\n      case 23:\n        int epConfig = bitArray.readBits(2);\n        if (epConfig == 2 || epConfig == 3) {\n          throw ParserException.createForUnsupportedContainerFeature(\n              \"Unsupported epConfig: \" + epConfig);\n        }\n        break;\n      default:\n        break;\n    }\n  }\n    \n  int channelCount = AUDIO_SPECIFIC_CONFIG_CHANNEL_COUNT_TABLE[channelConfiguration];\n  if (channelCount == AUDIO_SPECIFIC_CONFIG_CHANNEL_CONFIGURATION_INVALID) {\n    throw ParserException.createForMalformedContainer( null,  null);\n  }\n  return new Config(sampleRateHz, channelCount, codecs);\n}",
        "summary_tokens": [
            "parses",
            "an",
            "aac",
            "audio",
            "specific",
            "config",
            "as",
            "defined",
            "in",
            "iso",
            "0",
            "0",
            "0"
        ]
    },
    {
        "id": 1828,
        "code": "public static byte[] buildAacLcAudioSpecificConfig(int sampleRate, int channelCount) {\n  int sampleRateIndex = C.INDEX_UNSET;\n  for (int i = 0; i < AUDIO_SPECIFIC_CONFIG_SAMPLING_RATE_TABLE.length; ++i) {\n    if (sampleRate == AUDIO_SPECIFIC_CONFIG_SAMPLING_RATE_TABLE[i]) {\n      sampleRateIndex = i;\n    }\n  }\n  int channelConfig = C.INDEX_UNSET;\n  for (int i = 0; i < AUDIO_SPECIFIC_CONFIG_CHANNEL_COUNT_TABLE.length; ++i) {\n    if (channelCount == AUDIO_SPECIFIC_CONFIG_CHANNEL_COUNT_TABLE[i]) {\n      channelConfig = i;\n    }\n  }\n  if (sampleRate == C.INDEX_UNSET || channelConfig == C.INDEX_UNSET) {\n    throw new IllegalArgumentException(\n        \"Invalid sample rate or number of channels: \" + sampleRate + \", \" + channelCount);\n  }\n  return buildAudioSpecificConfig(AUDIO_OBJECT_TYPE_AAC_LC, sampleRateIndex, channelConfig);\n}",
        "summary_tokens": [
            "builds",
            "a",
            "simple",
            "aac",
            "lc",
            "audio",
            "specific",
            "config",
            "as",
            "defined",
            "in",
            "iso",
            "0",
            "0",
            "0"
        ]
    },
    {
        "id": 1829,
        "code": "public static byte[] buildAudioSpecificConfig(\n    int audioObjectType, int sampleRateIndex, int channelConfig) {\n  byte[] specificConfig = new byte[2];\n  specificConfig[0] = (byte) (((audioObjectType << 3) & 0xF8) | ((sampleRateIndex >> 1) & 0x07));\n  specificConfig[1] = (byte) (((sampleRateIndex << 7) & 0x80) | ((channelConfig << 3) & 0x78));\n  return specificConfig;\n}",
        "summary_tokens": [
            "builds",
            "a",
            "simple",
            "audio",
            "specific",
            "config",
            "as",
            "defined",
            "in",
            "iso",
            "0",
            "0",
            "0"
        ]
    },
    {
        "id": 1830,
        "code": "private static int getAudioObjectType(ParsableBitArray bitArray) {\n  int audioObjectType = bitArray.readBits(5);\n  if (audioObjectType == AUDIO_OBJECT_TYPE_ESCAPE) {\n    audioObjectType = 32 + bitArray.readBits(6);\n  }\n  return audioObjectType;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "aac",
            "audio",
            "object",
            "type",
            "as",
            "specified",
            "in",
            "0",
            "0",
            "0",
            "table",
            "0"
        ]
    },
    {
        "id": 1831,
        "code": "private static int getSamplingFrequency(ParsableBitArray bitArray) throws ParserException {\n  int samplingFrequency;\n  int frequencyIndex = bitArray.readBits(4);\n  if (frequencyIndex == AUDIO_SPECIFIC_CONFIG_FREQUENCY_INDEX_ARBITRARY) {\n    samplingFrequency = bitArray.readBits(24);\n  } else if (frequencyIndex < 13) {\n    samplingFrequency = AUDIO_SPECIFIC_CONFIG_SAMPLING_RATE_TABLE[frequencyIndex];\n  } else {\n    throw ParserException.createForMalformedContainer( null,  null);\n  }\n  return samplingFrequency;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "aac",
            "sampling",
            "frequency",
            "or",
            "extension",
            "sampling",
            "frequency",
            "as",
            "specified",
            "in",
            "0",
            "0",
            "0",
            "table",
            "0"
        ]
    },
    {
        "id": 1832,
        "code": "public static Format parseAc3AnnexFFormat(\n    ParsableByteArray data, String trackId, String language, @Nullable DrmInitData drmInitData) {\n  int fscod = (data.readUnsignedByte() & 0xC0) >> 6;\n  int sampleRate = SAMPLE_RATE_BY_FSCOD[fscod];\n  int nextByte = data.readUnsignedByte();\n  int channelCount = CHANNEL_COUNT_BY_ACMOD[(nextByte & 0x38) >> 3];\n  if ((nextByte & 0x04) != 0) { \n    channelCount++;\n  }\n  return new Format.Builder()\n      .setId(trackId)\n      .setSampleMimeType(MimeTypes.AUDIO_AC3)\n      .setChannelCount(channelCount)\n      .setSampleRate(sampleRate)\n      .setDrmInitData(drmInitData)\n      .setLanguage(language)\n      .build();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "ac",
            "0",
            "format",
            "given",
            "data",
            "containing",
            "the",
            "ac",
            "0",
            "specific",
            "box",
            "according",
            "to",
            "annex",
            "f"
        ]
    },
    {
        "id": 1833,
        "code": "public static Format parseEAc3AnnexFFormat(\n    ParsableByteArray data, String trackId, String language, @Nullable DrmInitData drmInitData) {\n  data.skipBytes(2); \n\n    \n  int fscod = (data.readUnsignedByte() & 0xC0) >> 6;\n  int sampleRate = SAMPLE_RATE_BY_FSCOD[fscod];\n  int nextByte = data.readUnsignedByte();\n  int channelCount = CHANNEL_COUNT_BY_ACMOD[(nextByte & 0x0E) >> 1];\n  if ((nextByte & 0x01) != 0) { \n    channelCount++;\n  }\n\n    \n  nextByte = data.readUnsignedByte();\n  int numDepSub = ((nextByte & 0x1E) >> 1);\n  if (numDepSub > 0) {\n    int lowByteChanLoc = data.readUnsignedByte();\n      \n      \n    if ((lowByteChanLoc & 0x02) != 0) {\n      channelCount += 2;\n    }\n  }\n  String mimeType = MimeTypes.AUDIO_E_AC3;\n  if (data.bytesLeft() > 0) {\n    nextByte = data.readUnsignedByte();\n    if ((nextByte & 0x01) != 0) { \n      mimeType = MimeTypes.AUDIO_E_AC3_JOC;\n    }\n  }\n  return new Format.Builder()\n      .setId(trackId)\n      .setSampleMimeType(mimeType)\n      .setChannelCount(channelCount)\n      .setSampleRate(sampleRate)\n      .setDrmInitData(drmInitData)\n      .setLanguage(language)\n      .build();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "e",
            "ac",
            "0",
            "format",
            "given",
            "data",
            "containing",
            "the",
            "ec",
            "0",
            "specific",
            "box",
            "according",
            "to",
            "annex",
            "f"
        ]
    },
    {
        "id": 1834,
        "code": "public static SyncFrameInfo parseAc3SyncframeInfo(ParsableBitArray data) {\n  int initialPosition = data.getPosition();\n  data.skipBits(40);\n    \n  boolean isEac3 = data.readBits(5) > 10;\n  data.setPosition(initialPosition);\n  @Nullable String mimeType;\n  @StreamType int streamType = SyncFrameInfo.STREAM_TYPE_UNDEFINED;\n  int sampleRate;\n  int acmod;\n  int frameSize;\n  int sampleCount;\n  boolean lfeon;\n  int channelCount;\n  if (isEac3) {\n      \n    data.skipBits(16); \n    switch (data.readBits(2)) { \n      case 0:\n        streamType = SyncFrameInfo.STREAM_TYPE_TYPE0;\n        break;\n      case 1:\n        streamType = SyncFrameInfo.STREAM_TYPE_TYPE1;\n        break;\n      case 2:\n        streamType = SyncFrameInfo.STREAM_TYPE_TYPE2;\n        break;\n      default:\n        streamType = SyncFrameInfo.STREAM_TYPE_UNDEFINED;\n        break;\n    }\n    data.skipBits(3); \n    frameSize = (data.readBits(11) + 1) * 2; \n    int fscod = data.readBits(2);\n    int audioBlocks;\n    int numblkscod;\n    if (fscod == 3) {\n      numblkscod = 3;\n      sampleRate = SAMPLE_RATE_BY_FSCOD2[data.readBits(2)];\n      audioBlocks = 6;\n    } else {\n      numblkscod = data.readBits(2);\n      audioBlocks = BLOCKS_PER_SYNCFRAME_BY_NUMBLKSCOD[numblkscod];\n      sampleRate = SAMPLE_RATE_BY_FSCOD[fscod];\n    }\n    sampleCount = AUDIO_SAMPLES_PER_AUDIO_BLOCK * audioBlocks;\n    acmod = data.readBits(3);\n    lfeon = data.readBit();\n    channelCount = CHANNEL_COUNT_BY_ACMOD[acmod] + (lfeon ? 1 : 0);\n    data.skipBits(5 + 5); \n    if (data.readBit()) { \n      data.skipBits(8); \n    }\n    if (acmod == 0) {\n      data.skipBits(5); \n      if (data.readBit()) { \n        data.skipBits(8); \n      }\n    }\n    if (streamType == SyncFrameInfo.STREAM_TYPE_TYPE1 && data.readBit()) { \n      data.skipBits(16); \n    }\n    if (data.readBit()) { \n      if (acmod > 2) {\n        data.skipBits(2); \n      }\n      if ((acmod & 0x01) != 0 && acmod > 2) {\n        data.skipBits(3 + 3); \n      }\n      if ((acmod & 0x04) != 0) {\n        data.skipBits(6); \n      }\n      if (lfeon && data.readBit()) { \n        data.skipBits(5); \n      }\n      if (streamType == SyncFrameInfo.STREAM_TYPE_TYPE0) {\n        if (data.readBit()) { \n          data.skipBits(6); \n        }\n        if (acmod == 0 && data.readBit()) { \n          data.skipBits(6); \n        }\n        if (data.readBit()) { \n          data.skipBits(6); \n        }\n        int mixdef = data.readBits(2);\n        if (mixdef == 1) {\n          data.skipBits(1 + 1 + 3); \n        } else if (mixdef == 2) {\n          data.skipBits(12); \n        } else if (mixdef == 3) {\n          int mixdeflen = data.readBits(5);\n          if (data.readBit()) { \n            data.skipBits(1 + 1 + 3); \n            if (data.readBit()) { \n              data.skipBits(4); \n            }\n            if (data.readBit()) { \n              data.skipBits(4); \n            }\n            if (data.readBit()) { \n              data.skipBits(4); \n            }\n            if (data.readBit()) { \n              data.skipBits(4); \n            }\n            if (data.readBit()) { \n              data.skipBits(4); \n            }\n            if (data.readBit()) { \n              data.skipBits(4); \n            }\n            if (data.readBit()) { \n              data.skipBits(4); \n            }\n            if (data.readBit()) { \n              if (data.readBit()) { \n                data.skipBits(4); \n              }\n              if (data.readBit()) { \n                data.skipBits(4); \n              }\n            }\n          }\n          if (data.readBit()) { \n            data.skipBits(5); \n            if (data.readBit()) { \n              data.skipBits(5 + 2); \n              if (data.readBit()) { \n                data.skipBits(5 + 3); \n              }\n            }\n          }\n          data.skipBits(8 * (mixdeflen + 2)); \n          data.byteAlign(); \n        }\n        if (acmod < 2) {\n          if (data.readBit()) { \n            data.skipBits(8 + 6); \n          }\n          if (acmod == 0) {\n            if (data.readBit()) { \n              data.skipBits(8 + 6); \n            }\n          }\n        }\n        if (data.readBit()) { \n          if (numblkscod == 0) {\n            data.skipBits(5); \n          } else {\n            for (int blk = 0; blk < audioBlocks; blk++) {\n              if (data.readBit()) { \n                data.skipBits(5); \n              }\n            }\n          }\n        }\n      }\n    }\n    if (data.readBit()) { \n      data.skipBits(3 + 1 + 1); \n      if (acmod == 2) {\n        data.skipBits(2 + 2); \n      }\n      if (acmod >= 6) {\n        data.skipBits(2); \n      }\n      if (data.readBit()) { \n        data.skipBits(5 + 2 + 1); \n      }\n      if (acmod == 0 && data.readBit()) { \n        data.skipBits(5 + 2 + 1); \n      }\n      if (fscod < 3) {\n        data.skipBit(); \n      }\n    }\n    if (streamType == SyncFrameInfo.STREAM_TYPE_TYPE0 && numblkscod != 3) {\n      data.skipBit(); \n    }\n    if (streamType == SyncFrameInfo.STREAM_TYPE_TYPE2\n        && (numblkscod == 3 || data.readBit())) { \n      data.skipBits(6); \n    }\n    mimeType = MimeTypes.AUDIO_E_AC3;\n    if (data.readBit()) { \n      int addbsil = data.readBits(6);\n      if (addbsil == 1 && data.readBits(8) == 1) { \n        mimeType = MimeTypes.AUDIO_E_AC3_JOC;\n      }\n    }\n  } else  {\n    mimeType = MimeTypes.AUDIO_AC3;\n    data.skipBits(16 + 16); \n    int fscod = data.readBits(2);\n    if (fscod == 3) {\n        \n        \n      mimeType = null;\n    }\n    int frmsizecod = data.readBits(6);\n    frameSize = getAc3SyncframeSize(fscod, frmsizecod);\n    data.skipBits(5 + 3); \n    acmod = data.readBits(3);\n    if ((acmod & 0x01) != 0 && acmod != 1) {\n      data.skipBits(2); \n    }\n    if ((acmod & 0x04) != 0) {\n      data.skipBits(2); \n    }\n    if (acmod == 2) {\n      data.skipBits(2); \n    }\n    sampleRate =\n        fscod < SAMPLE_RATE_BY_FSCOD.length ? SAMPLE_RATE_BY_FSCOD[fscod] : Format.NO_VALUE;\n    sampleCount = AC3_SYNCFRAME_AUDIO_SAMPLE_COUNT;\n    lfeon = data.readBit();\n    channelCount = CHANNEL_COUNT_BY_ACMOD[acmod] + (lfeon ? 1 : 0);\n  }\n  return new SyncFrameInfo(\n      mimeType, streamType, channelCount, sampleRate, frameSize, sampleCount);\n}",
        "summary_tokens": [
            "returns",
            "e",
            "ac",
            "0",
            "format",
            "information",
            "given",
            "data",
            "containing",
            "a",
            "syncframe"
        ]
    },
    {
        "id": 1835,
        "code": "public static int parseAc3SyncframeSize(byte[] data) {\n  if (data.length < 6) {\n    return C.LENGTH_UNSET;\n  }\n    \n  boolean isEac3 = ((data[5] & 0xF8) >> 3) > 10;\n  if (isEac3) {\n    int frmsiz = (data[2] & 0x07) << 8; \n    frmsiz |= data[3] & 0xFF; \n    return (frmsiz + 1) * 2; \n  } else {\n    int fscod = (data[4] & 0xC0) >> 6;\n    int frmsizecod = data[4] & 0x3F;\n    return getAc3SyncframeSize(fscod, frmsizecod);\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "size",
            "in",
            "bytes",
            "of",
            "the",
            "given",
            "e",
            "ac",
            "0",
            "syncframe"
        ]
    },
    {
        "id": 1836,
        "code": "public static int parseAc3SyncframeAudioSampleCount(ByteBuffer buffer) {\n    \n  boolean isEac3 = ((buffer.get(buffer.position() + 5) & 0xF8) >> 3) > 10;\n  if (isEac3) {\n    int fscod = (buffer.get(buffer.position() + 4) & 0xC0) >> 6;\n    int numblkscod = fscod == 0x03 ? 3 : (buffer.get(buffer.position() + 4) & 0x30) >> 4;\n    return BLOCKS_PER_SYNCFRAME_BY_NUMBLKSCOD[numblkscod] * AUDIO_SAMPLES_PER_AUDIO_BLOCK;\n  } else {\n    return AC3_SYNCFRAME_AUDIO_SAMPLE_COUNT;\n  }\n}",
        "summary_tokens": [
            "reads",
            "the",
            "number",
            "of",
            "audio",
            "samples",
            "represented",
            "by",
            "the",
            "given",
            "e",
            "ac",
            "0",
            "syncframe"
        ]
    },
    {
        "id": 1837,
        "code": "public static int findTrueHdSyncframeOffset(ByteBuffer buffer) {\n  int startIndex = buffer.position();\n  int endIndex = buffer.limit() - TRUEHD_SYNCFRAME_PREFIX_LENGTH;\n  for (int i = startIndex; i <= endIndex; i++) {\n      \n    if ((Util.getBigEndianInt(buffer, i + 4) & 0xFFFFFFFE) == 0xF8726FBA) {\n      return i - startIndex;\n    }\n  }\n  return C.INDEX_UNSET;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "offset",
            "relative",
            "to",
            "the",
            "buffer",
            "s",
            "position",
            "of",
            "the",
            "start",
            "of",
            "a",
            "true",
            "hd",
            "syncframe",
            "or",
            "c",
            "index",
            "unset",
            "if",
            "no",
            "syncframe",
            "was",
            "found"
        ]
    },
    {
        "id": 1838,
        "code": "public static int parseTrueHdSyncframeAudioSampleCount(ByteBuffer buffer, int offset) {\n    \n  boolean isMlp = (buffer.get(buffer.position() + offset + 7) & 0xFF) == 0xBB;\n  return 40 << ((buffer.get(buffer.position() + offset + (isMlp ? 9 : 8)) >> 4) & 0x07);\n}",
        "summary_tokens": [
            "reads",
            "the",
            "number",
            "of",
            "audio",
            "samples",
            "represented",
            "by",
            "a",
            "true",
            "hd",
            "syncframe"
        ]
    },
    {
        "id": 1839,
        "code": "public static Format parseAc4AnnexEFormat(\n    ParsableByteArray data, String trackId, String language, @Nullable DrmInitData drmInitData) {\n  data.skipBytes(1); \n  int sampleRate = ((data.readUnsignedByte() & 0x20) >> 5 == 1) ? 48000 : 44100;\n  return new Format.Builder()\n      .setId(trackId)\n      .setSampleMimeType(MimeTypes.AUDIO_AC4)\n      .setChannelCount(CHANNEL_COUNT_2)\n      .setSampleRate(sampleRate)\n      .setDrmInitData(drmInitData)\n      .setLanguage(language)\n      .build();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "ac",
            "0",
            "format",
            "given",
            "data",
            "containing",
            "the",
            "ac",
            "0",
            "specific",
            "box",
            "according",
            "to",
            "etsi",
            "ts",
            "0",
            "0",
            "0",
            "annex",
            "e"
        ]
    },
    {
        "id": 1840,
        "code": "public static SyncFrameInfo parseAc4SyncframeInfo(ParsableBitArray data) {\n  int headerSize = 0;\n  int syncWord = data.readBits(16);\n  headerSize += 2;\n  int frameSize = data.readBits(16);\n  headerSize += 2;\n  if (frameSize == 0xFFFF) {\n    frameSize = data.readBits(24);\n    headerSize += 3; \n  }\n  frameSize += headerSize;\n  if (syncWord == AC41_SYNCWORD) {\n    frameSize += 2; \n  }\n  int bitstreamVersion = data.readBits(2);\n  if (bitstreamVersion == 3) {\n    bitstreamVersion += readVariableBits(data,  2);\n  }\n  int sequenceCounter = data.readBits(10);\n  if (data.readBit()) { \n    if (data.readBits(3) > 0) { \n      data.skipBits(2); \n    }\n  }\n  int sampleRate = data.readBit() ? 48000 : 44100;\n  int frameRateIndex = data.readBits(4);\n  int sampleCount = 0;\n  if (sampleRate == 44100 && frameRateIndex == 13) {\n    sampleCount = SAMPLE_COUNT[frameRateIndex];\n  } else if (sampleRate == 48000 && frameRateIndex < SAMPLE_COUNT.length) {\n    sampleCount = SAMPLE_COUNT[frameRateIndex];\n    switch (sequenceCounter % 5) {\n      case 1: \n      case 3:\n        if (frameRateIndex == 3 || frameRateIndex == 8) {\n          sampleCount++;\n        }\n        break;\n      case 2:\n        if (frameRateIndex == 8 || frameRateIndex == 11) {\n          sampleCount++;\n        }\n        break;\n      case 4:\n        if (frameRateIndex == 3 || frameRateIndex == 8 || frameRateIndex == 11) {\n          sampleCount++;\n        }\n        break;\n      default:\n        break;\n    }\n  }\n  return new SyncFrameInfo(bitstreamVersion, CHANNEL_COUNT_2, sampleRate, frameSize, sampleCount);\n}",
        "summary_tokens": [
            "returns",
            "ac",
            "0",
            "format",
            "information",
            "given",
            "data",
            "containing",
            "a",
            "syncframe"
        ]
    },
    {
        "id": 1841,
        "code": "public static int parseAc4SyncframeSize(byte[] data, int syncword) {\n  if (data.length < 7) {\n    return C.LENGTH_UNSET;\n  }\n  int headerSize = 2; \n  int frameSize = ((data[2] & 0xFF) << 8) | (data[3] & 0xFF);\n  headerSize += 2;\n  if (frameSize == 0xFFFF) {\n    frameSize = ((data[4] & 0xFF) << 16) | ((data[5] & 0xFF) << 8) | (data[6] & 0xFF);\n    headerSize += 3;\n  }\n  if (syncword == AC41_SYNCWORD) {\n    headerSize += 2;\n  }\n  frameSize += headerSize;\n  return frameSize;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "size",
            "in",
            "bytes",
            "of",
            "the",
            "given",
            "ac",
            "0",
            "syncframe"
        ]
    },
    {
        "id": 1842,
        "code": "public static int parseAc4SyncframeAudioSampleCount(ByteBuffer buffer) {\n  byte[] bufferBytes = new byte[HEADER_SIZE_FOR_PARSER];\n  int position = buffer.position();\n  buffer.get(bufferBytes);\n  buffer.position(position);\n  return parseAc4SyncframeInfo(new ParsableBitArray(bufferBytes)).sampleCount;\n}",
        "summary_tokens": [
            "reads",
            "the",
            "number",
            "of",
            "audio",
            "samples",
            "represented",
            "by",
            "the",
            "given",
            "ac",
            "0",
            "syncframe"
        ]
    },
    {
        "id": 1843,
        "code": "public static void getAc4SampleHeader(int size, ParsableByteArray buffer) {\n    \n  buffer.reset(SAMPLE_HEADER_SIZE);\n  byte[] data = buffer.getData();\n  data[0] = (byte) 0xAC;\n  data[1] = 0x40;\n  data[2] = (byte) 0xFF;\n  data[3] = (byte) 0xFF;\n  data[4] = (byte) ((size >> 16) & 0xFF);\n  data[5] = (byte) ((size >> 8) & 0xFF);\n  data[6] = (byte) (size & 0xFF);\n}",
        "summary_tokens": [
            "populates",
            "buffer",
            "with",
            "an",
            "ac",
            "0",
            "sample",
            "header",
            "for",
            "a",
            "sample",
            "of",
            "the",
            "specified",
            "size"
        ]
    },
    {
        "id": 1844,
        "code": "public static boolean isSyncWord(int word) {\n  return word == SYNC_VALUE_BE\n      || word == SYNC_VALUE_LE\n      || word == SYNC_VALUE_14B_BE\n      || word == SYNC_VALUE_14B_LE;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "a",
            "given",
            "integer",
            "matches",
            "a",
            "dts",
            "sync",
            "word"
        ]
    },
    {
        "id": 1845,
        "code": "public static Format parseDtsFormat(\n    byte[] frame,\n    @Nullable String trackId,\n    @Nullable String language,\n    @Nullable DrmInitData drmInitData) {\n  ParsableBitArray frameBits = getNormalizedFrameHeader(frame);\n  frameBits.skipBits(32 + 1 + 5 + 1 + 7 + 14); \n  int amode = frameBits.readBits(6);\n  int channelCount = CHANNELS_BY_AMODE[amode];\n  int sfreq = frameBits.readBits(4);\n  int sampleRate = SAMPLE_RATE_BY_SFREQ[sfreq];\n  int rate = frameBits.readBits(5);\n  int bitrate =\n      rate >= TWICE_BITRATE_KBPS_BY_RATE.length\n          ? Format.NO_VALUE\n          : TWICE_BITRATE_KBPS_BY_RATE[rate] * 1000 / 2;\n  frameBits.skipBits(10); \n  channelCount += frameBits.readBits(2) > 0 ? 1 : 0; \n  return new Format.Builder()\n      .setId(trackId)\n      .setSampleMimeType(MimeTypes.AUDIO_DTS)\n      .setAverageBitrate(bitrate)\n      .setChannelCount(channelCount)\n      .setSampleRate(sampleRate)\n      .setDrmInitData(drmInitData)\n      .setLanguage(language)\n      .build();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "dts",
            "format",
            "given",
            "data",
            "containing",
            "the",
            "dts",
            "frame",
            "according",
            "to",
            "etsi",
            "ts",
            "0",
            "0",
            "subsections",
            "0"
        ]
    },
    {
        "id": 1846,
        "code": "public static int parseDtsAudioSampleCount(ByteBuffer buffer) {\n    \n  int position = buffer.position();\n  int nblks;\n  switch (buffer.get(position)) {\n    case FIRST_BYTE_LE:\n      nblks = ((buffer.get(position + 5) & 0x01) << 6) | ((buffer.get(position + 4) & 0xFC) >> 2);\n      break;\n    case FIRST_BYTE_14B_LE:\n      nblks = ((buffer.get(position + 4) & 0x07) << 4) | ((buffer.get(position + 7) & 0x3C) >> 2);\n      break;\n    case FIRST_BYTE_14B_BE:\n      nblks = ((buffer.get(position + 5) & 0x07) << 4) | ((buffer.get(position + 6) & 0x3C) >> 2);\n      break;\n    default:\n        \n      nblks = ((buffer.get(position + 4) & 0x01) << 6) | ((buffer.get(position + 5) & 0xFC) >> 2);\n  }\n  return (nblks + 1) * 32;\n}",
        "summary_tokens": [
            "like",
            "parse",
            "dts",
            "audio",
            "sample",
            "count",
            "byte",
            "but",
            "reads",
            "from",
            "a",
            "byte",
            "buffer"
        ]
    },
    {
        "id": 1847,
        "code": "public static int getDtsFrameSize(byte[] data) {\n  int fsize;\n  boolean uses14BitPerWord = false;\n  switch (data[0]) {\n    case FIRST_BYTE_14B_BE:\n      fsize = (((data[6] & 0x03) << 12) | ((data[7] & 0xFF) << 4) | ((data[8] & 0x3C) >> 2)) + 1;\n      uses14BitPerWord = true;\n      break;\n    case FIRST_BYTE_LE:\n      fsize = (((data[4] & 0x03) << 12) | ((data[7] & 0xFF) << 4) | ((data[6] & 0xF0) >> 4)) + 1;\n      break;\n    case FIRST_BYTE_14B_LE:\n      fsize = (((data[7] & 0x03) << 12) | ((data[6] & 0xFF) << 4) | ((data[9] & 0x3C) >> 2)) + 1;\n      uses14BitPerWord = true;\n      break;\n    default:\n        \n      fsize = (((data[5] & 0x03) << 12) | ((data[6] & 0xFF) << 4) | ((data[7] & 0xF0) >> 4)) + 1;\n  }\n\n    \n  return uses14BitPerWord ? fsize * 16 / 14 : fsize;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "size",
            "in",
            "bytes",
            "of",
            "the",
            "given",
            "dts",
            "frame"
        ]
    },
    {
        "id": 1848,
        "code": "public static int getFrameSize(int headerData) {\n  if (!isMagicPresent(headerData)) {\n    return C.LENGTH_UNSET;\n  }\n\n  int version = (headerData >>> 19) & 3;\n  if (version == 1) {\n    return C.LENGTH_UNSET;\n  }\n\n  int layer = (headerData >>> 17) & 3;\n  if (layer == 0) {\n    return C.LENGTH_UNSET;\n  }\n\n  int bitrateIndex = (headerData >>> 12) & 15;\n  if (bitrateIndex == 0 || bitrateIndex == 0xF) {\n      \n    return C.LENGTH_UNSET;\n  }\n\n  int samplingRateIndex = (headerData >>> 10) & 3;\n  if (samplingRateIndex == 3) {\n    return C.LENGTH_UNSET;\n  }\n\n  int samplingRate = SAMPLING_RATE_V1[samplingRateIndex];\n  if (version == 2) {\n      \n    samplingRate /= 2;\n  } else if (version == 0) {\n      \n    samplingRate /= 4;\n  }\n\n  int bitrate;\n  int padding = (headerData >>> 9) & 1;\n  if (layer == 3) {\n      \n    bitrate = version == 3 ? BITRATE_V1_L1[bitrateIndex - 1] : BITRATE_V2_L1[bitrateIndex - 1];\n    return (12 * bitrate / samplingRate + padding) * 4;\n  } else {\n      \n    if (version == 3) {\n      bitrate = layer == 2 ? BITRATE_V1_L2[bitrateIndex - 1] : BITRATE_V1_L3[bitrateIndex - 1];\n    } else {\n        \n      bitrate = BITRATE_V2[bitrateIndex - 1];\n    }\n  }\n\n  if (version == 3) {\n      \n    return 144 * bitrate / samplingRate + padding;\n  } else {\n      \n    return (layer == 1 ? 72 : 144) * bitrate / samplingRate + padding;\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "size",
            "of",
            "the",
            "frame",
            "associated",
            "with",
            "header",
            "or",
            "c",
            "length",
            "unset",
            "if",
            "it",
            "is",
            "invalid"
        ]
    },
    {
        "id": 1849,
        "code": "public static int parseMpegAudioFrameSampleCount(int headerData) {\n  if (!isMagicPresent(headerData)) {\n    return C.LENGTH_UNSET;\n  }\n\n  int version = (headerData >>> 19) & 3;\n  if (version == 1) {\n    return C.LENGTH_UNSET;\n  }\n\n  int layer = (headerData >>> 17) & 3;\n  if (layer == 0) {\n    return C.LENGTH_UNSET;\n  }\n\n    \n  int bitrateIndex = (headerData >>> 12) & 15;\n  int samplingRateIndex = (headerData >>> 10) & 3;\n  if (bitrateIndex == 0 || bitrateIndex == 0xF || samplingRateIndex == 3) {\n    return C.LENGTH_UNSET;\n  }\n\n  return getFrameSizeInSamples(version, layer);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "samples",
            "per",
            "frame",
            "associated",
            "with",
            "header",
            "data",
            "or",
            "c",
            "length",
            "unset",
            "if",
            "it",
            "is",
            "invalid"
        ]
    },
    {
        "id": 1850,
        "code": "public static int getChannelCount(byte[] header) {\n  return header[9] & 0xFF;\n}",
        "summary_tokens": [
            "parses",
            "the",
            "channel",
            "count",
            "from",
            "an",
            "opus",
            "identification",
            "header"
        ]
    },
    {
        "id": 1851,
        "code": "public static List<byte[]> buildInitializationData(byte[] header) {\n  int preSkipSamples = getPreSkipSamples(header);\n  long preSkipNanos = sampleCountToNanoseconds(preSkipSamples);\n  long seekPreRollNanos = sampleCountToNanoseconds(DEFAULT_SEEK_PRE_ROLL_SAMPLES);\n\n  List<byte[]> initializationData = new ArrayList<>(FULL_CODEC_INITIALIZATION_DATA_BUFFER_COUNT);\n  initializationData.add(header);\n  initializationData.add(buildNativeOrderByteArray(preSkipNanos));\n  initializationData.add(buildNativeOrderByteArray(seekPreRollNanos));\n  return initializationData;\n}",
        "summary_tokens": [
            "builds",
            "codec",
            "initialization",
            "data",
            "from",
            "an",
            "opus",
            "identification",
            "header"
        ]
    },
    {
        "id": 1852,
        "code": "public static int getTypeForPcmEncoding(@C.PcmEncoding int pcmEncoding) {\n  switch (pcmEncoding) {\n    case C.ENCODING_PCM_8BIT:\n    case C.ENCODING_PCM_16BIT:\n    case C.ENCODING_PCM_24BIT:\n    case C.ENCODING_PCM_32BIT:\n      return TYPE_PCM;\n    case C.ENCODING_PCM_FLOAT:\n      return TYPE_FLOAT;\n    case C.ENCODING_PCM_16BIT_BIG_ENDIAN: \n    case C.ENCODING_INVALID:\n    case Format.NO_VALUE:\n    default:\n      throw new IllegalArgumentException();\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "wave",
            "format",
            "type",
            "value",
            "for",
            "the",
            "given",
            "c"
        ]
    },
    {
        "id": 1853,
        "code": "public final SeekMap getSeekMap() {\n  return seekMap;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "seek",
            "map",
            "for",
            "the",
            "stream"
        ]
    },
    {
        "id": 1854,
        "code": "public final void setSeekTargetUs(long timeUs) {\n  if (seekOperationParams != null && seekOperationParams.getSeekTimeUs() == timeUs) {\n    return;\n  }\n  seekOperationParams = createSeekParamsForTargetTimeUs(timeUs);\n}",
        "summary_tokens": [
            "sets",
            "the",
            "target",
            "time",
            "in",
            "microseconds",
            "within",
            "the",
            "stream",
            "to",
            "seek",
            "to"
        ]
    },
    {
        "id": 1855,
        "code": "public final boolean isSeeking() {\n  return seekOperationParams != null;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "last",
            "operation",
            "set",
            "by",
            "set",
            "seek",
            "target",
            "us",
            "long",
            "is",
            "still",
            "pending"
        ]
    },
    {
        "id": 1856,
        "code": "public int handlePendingSeek(ExtractorInput input, PositionHolder seekPositionHolder)\n    throws IOException {\n  while (true) {\n    SeekOperationParams seekOperationParams =\n        Assertions.checkStateNotNull(this.seekOperationParams);\n    long floorPosition = seekOperationParams.getFloorBytePosition();\n    long ceilingPosition = seekOperationParams.getCeilingBytePosition();\n    long searchPosition = seekOperationParams.getNextSearchBytePosition();\n\n    if (ceilingPosition - floorPosition <= minimumSearchRange) {\n        \n      markSeekOperationFinished( false, floorPosition);\n      return seekToPosition(input, floorPosition, seekPositionHolder);\n    }\n    if (!skipInputUntilPosition(input, searchPosition)) {\n      return seekToPosition(input, searchPosition, seekPositionHolder);\n    }\n\n    input.resetPeekPosition();\n    TimestampSearchResult timestampSearchResult =\n        timestampSeeker.searchForTimestamp(input, seekOperationParams.getTargetTimePosition());\n\n    switch (timestampSearchResult.type) {\n      case TimestampSearchResult.TYPE_POSITION_OVERESTIMATED:\n        seekOperationParams.updateSeekCeiling(\n            timestampSearchResult.timestampToUpdate, timestampSearchResult.bytePositionToUpdate);\n        break;\n      case TimestampSearchResult.TYPE_POSITION_UNDERESTIMATED:\n        seekOperationParams.updateSeekFloor(\n            timestampSearchResult.timestampToUpdate, timestampSearchResult.bytePositionToUpdate);\n        break;\n      case TimestampSearchResult.TYPE_TARGET_TIMESTAMP_FOUND:\n        skipInputUntilPosition(input, timestampSearchResult.bytePositionToUpdate);\n        markSeekOperationFinished(\n             true, timestampSearchResult.bytePositionToUpdate);\n        return seekToPosition(\n            input, timestampSearchResult.bytePositionToUpdate, seekPositionHolder);\n      case TimestampSearchResult.TYPE_NO_TIMESTAMP:\n          \n          \n        markSeekOperationFinished( false, searchPosition);\n        return seekToPosition(input, searchPosition, seekPositionHolder);\n      default:\n        throw new IllegalStateException(\"Invalid case\");\n    }\n  }\n}",
        "summary_tokens": [
            "continues",
            "to",
            "handle",
            "the",
            "pending",
            "seek",
            "operation"
        ]
    },
    {
        "id": 1857,
        "code": "public static void consume(\n    long presentationTimeUs, ParsableByteArray seiBuffer, TrackOutput[] outputs) {\n  while (seiBuffer.bytesLeft() > 1 ) {\n    int payloadType = readNon255TerminatedValue(seiBuffer);\n    int payloadSize = readNon255TerminatedValue(seiBuffer);\n    int nextPayloadPosition = seiBuffer.getPosition() + payloadSize;\n      \n    if (payloadSize == -1 || payloadSize > seiBuffer.bytesLeft()) {\n        \n      Log.w(TAG, \"Skipping remainder of malformed SEI NAL unit.\");\n      nextPayloadPosition = seiBuffer.limit();\n    } else if (payloadType == PAYLOAD_TYPE_CC && payloadSize >= 8) {\n      int countryCode = seiBuffer.readUnsignedByte();\n      int providerCode = seiBuffer.readUnsignedShort();\n      int userIdentifier = 0;\n      if (providerCode == PROVIDER_CODE_ATSC) {\n        userIdentifier = seiBuffer.readInt();\n      }\n      int userDataTypeCode = seiBuffer.readUnsignedByte();\n      if (providerCode == PROVIDER_CODE_DIRECTV) {\n        seiBuffer.skipBytes(1); \n      }\n      boolean messageIsSupportedCeaCaption =\n          countryCode == COUNTRY_CODE\n              && (providerCode == PROVIDER_CODE_ATSC || providerCode == PROVIDER_CODE_DIRECTV)\n              && userDataTypeCode == USER_DATA_TYPE_CODE_MPEG_CC;\n      if (providerCode == PROVIDER_CODE_ATSC) {\n        messageIsSupportedCeaCaption &= userIdentifier == USER_DATA_IDENTIFIER_GA94;\n      }\n      if (messageIsSupportedCeaCaption) {\n        consumeCcData(presentationTimeUs, seiBuffer, outputs);\n      }\n    }\n    seiBuffer.setPosition(nextPayloadPosition);\n  }\n}",
        "summary_tokens": [
            "consumes",
            "the",
            "unescaped",
            "content",
            "of",
            "an",
            "sei",
            "nal",
            "unit",
            "writing",
            "the",
            "content",
            "of",
            "any",
            "cea",
            "0",
            "0",
            "messages",
            "as",
            "samples",
            "to",
            "all",
            "of",
            "the",
            "provided",
            "outputs"
        ]
    },
    {
        "id": 1858,
        "code": "public static void consumeCcData(\n    long presentationTimeUs, ParsableByteArray ccDataBuffer, TrackOutput[] outputs) {\n    \n  int firstByte = ccDataBuffer.readUnsignedByte();\n  boolean processCcDataFlag = (firstByte & 0x40) != 0;\n  if (!processCcDataFlag) {\n      \n    return;\n  }\n  int ccCount = firstByte & 0x1F;\n  ccDataBuffer.skipBytes(1); \n    \n    \n  int sampleLength = ccCount * 3;\n  int sampleStartPosition = ccDataBuffer.getPosition();\n  for (TrackOutput output : outputs) {\n    ccDataBuffer.setPosition(sampleStartPosition);\n    output.sampleData(ccDataBuffer, sampleLength);\n    if (presentationTimeUs != C.TIME_UNSET) {\n      output.sampleMetadata(\n          presentationTimeUs,\n          C.BUFFER_FLAG_KEY_FRAME,\n          sampleLength,\n           0,\n           null);\n    }\n  }\n}",
        "summary_tokens": [
            "consumes",
            "caption",
            "data",
            "cc",
            "data",
            "writing",
            "the",
            "content",
            "as",
            "samples",
            "to",
            "all",
            "of",
            "the",
            "provided",
            "outputs"
        ]
    },
    {
        "id": 1859,
        "code": "private static int readNon255TerminatedValue(ParsableByteArray buffer) {\n  int b;\n  int value = 0;\n  do {\n    if (buffer.bytesLeft() == 0) {\n      return -1;\n    }\n    b = buffer.readUnsignedByte();\n    value += b;\n  } while (b == 0xFF);\n  return value;\n}",
        "summary_tokens": [
            "reads",
            "a",
            "value",
            "from",
            "the",
            "provided",
            "buffer",
            "consisting",
            "of",
            "zero",
            "or",
            "more",
            "0",
            "x",
            "ff",
            "bytes",
            "followed",
            "by",
            "a",
            "terminating",
            "byte",
            "not",
            "equal",
            "to",
            "0",
            "x",
            "ff"
        ]
    },
    {
        "id": 1860,
        "code": "public int getChunkIndex(long timeUs) {\n  return Util.binarySearchFloor(timesUs, timeUs,  true,  true);\n}",
        "summary_tokens": [
            "obtains",
            "the",
            "index",
            "of",
            "the",
            "chunk",
            "corresponding",
            "to",
            "a",
            "given",
            "time"
        ]
    },
    {
        "id": 1861,
        "code": "private static long getTimeUsAtPosition(long position, long firstFrameBytePosition, int bitrate) {\n  return max(0, position - firstFrameBytePosition)\n      * C.BITS_PER_BYTE\n      * C.MICROS_PER_SECOND\n      / bitrate;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "stream",
            "time",
            "in",
            "microseconds",
            "for",
            "a",
            "given",
            "stream",
            "position"
        ]
    },
    {
        "id": 1862,
        "code": "private void ensureSpaceForPeek(int length) {\n  int requiredLength = peekBufferPosition + length;\n  if (requiredLength > peekBuffer.length) {\n    int newPeekCapacity =\n        Util.constrainValue(\n            peekBuffer.length * 2,\n            requiredLength + PEEK_MIN_FREE_SPACE_AFTER_RESIZE,\n            requiredLength + PEEK_MAX_FREE_SPACE);\n    peekBuffer = Arrays.copyOf(peekBuffer, newPeekCapacity);\n  }\n}",
        "summary_tokens": [
            "ensures",
            "peek",
            "buffer",
            "is",
            "large",
            "enough",
            "to",
            "store",
            "at",
            "least",
            "length",
            "bytes",
            "from",
            "the",
            "current",
            "peek",
            "position"
        ]
    },
    {
        "id": 1863,
        "code": "private int skipFromPeekBuffer(int length) {\n  int bytesSkipped = min(peekBufferLength, length);\n  updatePeekBuffer(bytesSkipped);\n  return bytesSkipped;\n}",
        "summary_tokens": [
            "skips",
            "from",
            "the",
            "peek",
            "buffer"
        ]
    },
    {
        "id": 1864,
        "code": "private int readFromPeekBuffer(byte[] target, int offset, int length) {\n  if (peekBufferLength == 0) {\n    return 0;\n  }\n  int peekBytes = min(peekBufferLength, length);\n  System.arraycopy(peekBuffer, 0, target, offset, peekBytes);\n  updatePeekBuffer(peekBytes);\n  return peekBytes;\n}",
        "summary_tokens": [
            "reads",
            "from",
            "the",
            "peek",
            "buffer"
        ]
    },
    {
        "id": 1865,
        "code": "private void updatePeekBuffer(int bytesConsumed) {\n  peekBufferLength -= bytesConsumed;\n  peekBufferPosition = 0;\n  byte[] newPeekBuffer = peekBuffer;\n  if (peekBufferLength < peekBuffer.length - PEEK_MAX_FREE_SPACE) {\n    newPeekBuffer = new byte[peekBufferLength + PEEK_MIN_FREE_SPACE_AFTER_RESIZE];\n  }\n  System.arraycopy(peekBuffer, bytesConsumed, newPeekBuffer, 0, peekBufferLength);\n  peekBuffer = newPeekBuffer;\n}",
        "summary_tokens": [
            "updates",
            "the",
            "peek",
            "buffer",
            "s",
            "length",
            "position",
            "and",
            "contents",
            "after",
            "consuming",
            "data"
        ]
    },
    {
        "id": 1866,
        "code": "private int readFromUpstream(\n    byte[] target, int offset, int length, int bytesAlreadyRead, boolean allowEndOfInput)\n    throws IOException {\n  if (Thread.interrupted()) {\n    throw new InterruptedIOException();\n  }\n  int bytesRead = dataReader.read(target, offset + bytesAlreadyRead, length - bytesAlreadyRead);\n  if (bytesRead == C.RESULT_END_OF_INPUT) {\n    if (bytesAlreadyRead == 0 && allowEndOfInput) {\n      return C.RESULT_END_OF_INPUT;\n    }\n    throw new EOFException();\n  }\n  return bytesAlreadyRead + bytesRead;\n}",
        "summary_tokens": [
            "starts",
            "or",
            "continues",
            "a",
            "read",
            "from",
            "the",
            "data",
            "reader"
        ]
    },
    {
        "id": 1867,
        "code": "private void commitBytesRead(int bytesRead) {\n  if (bytesRead != C.RESULT_END_OF_INPUT) {\n    position += bytesRead;\n  }\n}",
        "summary_tokens": [
            "advances",
            "the",
            "position",
            "by",
            "the",
            "specified",
            "number",
            "of",
            "bytes",
            "read"
        ]
    },
    {
        "id": 1868,
        "code": "public synchronized DefaultExtractorsFactory setConstantBitrateSeekingEnabled(\n    boolean constantBitrateSeekingEnabled) {\n  this.constantBitrateSeekingEnabled = constantBitrateSeekingEnabled;\n  return this;\n}",
        "summary_tokens": [
            "convenience",
            "method",
            "to",
            "set",
            "whether",
            "approximate",
            "seeking",
            "using",
            "constant",
            "bitrate",
            "assumptions",
            "should",
            "be",
            "enabled",
            "for",
            "all",
            "extractors",
            "that",
            "support",
            "it"
        ]
    },
    {
        "id": 1869,
        "code": "public synchronized DefaultExtractorsFactory setConstantBitrateSeekingAlwaysEnabled(\n    boolean constantBitrateSeekingAlwaysEnabled) {\n  this.constantBitrateSeekingAlwaysEnabled = constantBitrateSeekingAlwaysEnabled;\n  return this;\n}",
        "summary_tokens": [
            "convenience",
            "method",
            "to",
            "set",
            "whether",
            "approximate",
            "seeking",
            "using",
            "constant",
            "bitrate",
            "assumptions",
            "should",
            "be",
            "enabled",
            "for",
            "all",
            "extractors",
            "that",
            "support",
            "it",
            "and",
            "if",
            "it",
            "should",
            "be",
            "enabled",
            "even",
            "if",
            "the",
            "content",
            "length",
            "and",
            "hence",
            "the",
            "duration",
            "of",
            "the",
            "media",
            "is",
            "unknown"
        ]
    },
    {
        "id": 1870,
        "code": "public synchronized DefaultExtractorsFactory setAdtsExtractorFlags(\n    @AdtsExtractor.Flags int flags) {\n  this.adtsFlags = flags;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "flags",
            "for",
            "adts",
            "extractor",
            "instances",
            "created",
            "by",
            "the",
            "factory"
        ]
    },
    {
        "id": 1871,
        "code": "public synchronized DefaultExtractorsFactory setAmrExtractorFlags(@AmrExtractor.Flags int flags) {\n  this.amrFlags = flags;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "flags",
            "for",
            "amr",
            "extractor",
            "instances",
            "created",
            "by",
            "the",
            "factory"
        ]
    },
    {
        "id": 1872,
        "code": "public synchronized DefaultExtractorsFactory setFlacExtractorFlags(\n    @FlacExtractor.Flags int flags) {\n  this.flacFlags = flags;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "flags",
            "for",
            "flac",
            "extractor",
            "instances",
            "created",
            "by",
            "the",
            "factory"
        ]
    },
    {
        "id": 1873,
        "code": "public synchronized DefaultExtractorsFactory setMatroskaExtractorFlags(\n    @MatroskaExtractor.Flags int flags) {\n  this.matroskaFlags = flags;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "flags",
            "for",
            "matroska",
            "extractor",
            "instances",
            "created",
            "by",
            "the",
            "factory"
        ]
    },
    {
        "id": 1874,
        "code": "public synchronized DefaultExtractorsFactory setMp4ExtractorFlags(@Mp4Extractor.Flags int flags) {\n  this.mp4Flags = flags;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "flags",
            "for",
            "mp",
            "0",
            "extractor",
            "instances",
            "created",
            "by",
            "the",
            "factory"
        ]
    },
    {
        "id": 1875,
        "code": "public synchronized DefaultExtractorsFactory setFragmentedMp4ExtractorFlags(\n    @FragmentedMp4Extractor.Flags int flags) {\n  this.fragmentedMp4Flags = flags;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "flags",
            "for",
            "fragmented",
            "mp",
            "0",
            "extractor",
            "instances",
            "created",
            "by",
            "the",
            "factory"
        ]
    },
    {
        "id": 1876,
        "code": "public synchronized DefaultExtractorsFactory setMp3ExtractorFlags(@Mp3Extractor.Flags int flags) {\n  mp3Flags = flags;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "flags",
            "for",
            "mp",
            "0",
            "extractor",
            "instances",
            "created",
            "by",
            "the",
            "factory"
        ]
    },
    {
        "id": 1877,
        "code": "public synchronized DefaultExtractorsFactory setTsExtractorMode(@TsExtractor.Mode int mode) {\n  tsMode = mode;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "mode",
            "for",
            "ts",
            "extractor",
            "instances",
            "created",
            "by",
            "the",
            "factory"
        ]
    },
    {
        "id": 1878,
        "code": "public synchronized DefaultExtractorsFactory setTsExtractorFlags(\n    @DefaultTsPayloadReaderFactory.Flags int flags) {\n  tsFlags = flags;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "flags",
            "for",
            "default",
            "ts",
            "payload",
            "reader",
            "factory",
            "s",
            "used",
            "by",
            "ts",
            "extractor",
            "instances",
            "created",
            "by",
            "the",
            "factory"
        ]
    },
    {
        "id": 1879,
        "code": "public synchronized DefaultExtractorsFactory setTsExtractorTimestampSearchBytes(\n    int timestampSearchBytes) {\n  tsTimestampSearchBytes = timestampSearchBytes;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "number",
            "of",
            "bytes",
            "searched",
            "to",
            "find",
            "a",
            "timestamp",
            "for",
            "ts",
            "extractor",
            "instances",
            "created",
            "by",
            "the",
            "factory"
        ]
    },
    {
        "id": 1880,
        "code": "public static void checkContainerInput(boolean expression, @Nullable String message)\n    throws ParserException {\n  if (!expression) {\n    throw ParserException.createForMalformedContainer(message,  null);\n  }\n}",
        "summary_tokens": [
            "if",
            "expression",
            "is",
            "false",
            "throws",
            "a",
            "parser",
            "exception",
            "create",
            "for",
            "malformed",
            "container",
            "container",
            "malformed",
            "parser",
            "exception",
            "with",
            "the",
            "given",
            "message"
        ]
    },
    {
        "id": 1881,
        "code": "public static int peekToLength(ExtractorInput input, byte[] target, int offset, int length)\n    throws IOException {\n  int totalBytesPeeked = 0;\n  while (totalBytesPeeked < length) {\n    int bytesPeeked = input.peek(target, offset + totalBytesPeeked, length - totalBytesPeeked);\n    if (bytesPeeked == C.RESULT_END_OF_INPUT) {\n      break;\n    }\n    totalBytesPeeked += bytesPeeked;\n  }\n  return totalBytesPeeked;\n}",
        "summary_tokens": [
            "peeks",
            "length",
            "bytes",
            "from",
            "the",
            "input",
            "peek",
            "position",
            "or",
            "all",
            "the",
            "bytes",
            "to",
            "the",
            "end",
            "of",
            "the",
            "input",
            "if",
            "there",
            "was",
            "less",
            "than",
            "length",
            "bytes",
            "left"
        ]
    },
    {
        "id": 1882,
        "code": "public static boolean readFullyQuietly(\n    ExtractorInput input, byte[] output, int offset, int length) throws IOException {\n  try {\n    input.readFully(output, offset, length);\n  } catch (EOFException e) {\n    return false;\n  }\n  return true;\n}",
        "summary_tokens": [
            "equivalent",
            "to",
            "extractor",
            "input",
            "read",
            "fully",
            "byte",
            "int",
            "int",
            "except",
            "that",
            "it",
            "returns",
            "false",
            "instead",
            "of",
            "throwing",
            "an",
            "eofexception",
            "if",
            "the",
            "end",
            "of",
            "input",
            "is",
            "encountered",
            "without",
            "having",
            "fully",
            "satisfied",
            "the",
            "read"
        ]
    },
    {
        "id": 1883,
        "code": "public static boolean skipFullyQuietly(ExtractorInput input, int length) throws IOException {\n  try {\n    input.skipFully(length);\n  } catch (EOFException e) {\n    return false;\n  }\n  return true;\n}",
        "summary_tokens": [
            "equivalent",
            "to",
            "extractor",
            "input",
            "skip",
            "fully",
            "int",
            "except",
            "that",
            "it",
            "returns",
            "false",
            "instead",
            "of",
            "throwing",
            "an",
            "eofexception",
            "if",
            "the",
            "end",
            "of",
            "input",
            "is",
            "encountered",
            "without",
            "having",
            "fully",
            "satisfied",
            "the",
            "skip"
        ]
    },
    {
        "id": 1884,
        "code": "public static boolean peekFullyQuietly(\n    ExtractorInput input, byte[] output, int offset, int length, boolean allowEndOfInput)\n    throws IOException {\n  try {\n    return input.peekFully(output, offset, length,  allowEndOfInput);\n  } catch (EOFException e) {\n    if (allowEndOfInput) {\n      return false;\n    } else {\n      throw e;\n    }\n  }\n}",
        "summary_tokens": [
            "peeks",
            "data",
            "from",
            "input",
            "respecting",
            "allow",
            "end",
            "of",
            "input"
        ]
    },
    {
        "id": 1885,
        "code": "default Extractor[] createExtractors(Uri uri, Map<String, List<String>> responseHeaders) {\n  return createExtractors();\n}",
        "summary_tokens": [
            "returns",
            "an",
            "array",
            "of",
            "new",
            "extractor",
            "instances"
        ]
    },
    {
        "id": 1886,
        "code": "public static boolean checkAndReadFrameHeader(\n    ParsableByteArray data,\n    FlacStreamMetadata flacStreamMetadata,\n    int frameStartMarker,\n    SampleNumberHolder sampleNumberHolder) {\n  int frameStartPosition = data.getPosition();\n\n  long frameHeaderBytes = data.readUnsignedInt();\n  if (frameHeaderBytes >>> 16 != frameStartMarker) {\n    return false;\n  }\n\n  boolean isBlockSizeVariable = (frameHeaderBytes >>> 16 & 1) == 1;\n  int blockSizeKey = (int) (frameHeaderBytes >> 12 & 0xF);\n  int sampleRateKey = (int) (frameHeaderBytes >> 8 & 0xF);\n  int channelAssignmentKey = (int) (frameHeaderBytes >> 4 & 0xF);\n  int bitsPerSampleKey = (int) (frameHeaderBytes >> 1 & 0x7);\n  boolean reservedBit = (frameHeaderBytes & 1) == 1;\n  return checkChannelAssignment(channelAssignmentKey, flacStreamMetadata)\n      && checkBitsPerSample(bitsPerSampleKey, flacStreamMetadata)\n      && !reservedBit\n      && checkAndReadFirstSampleNumber(\n          data, flacStreamMetadata, isBlockSizeVariable, sampleNumberHolder)\n      && checkAndReadBlockSizeSamples(data, flacStreamMetadata, blockSizeKey)\n      && checkAndReadSampleRate(data, flacStreamMetadata, sampleRateKey)\n      && checkAndReadCrc(data, frameStartPosition);\n}",
        "summary_tokens": [
            "checks",
            "whether",
            "the",
            "given",
            "flac",
            "frame",
            "header",
            "is",
            "valid",
            "and",
            "if",
            "so",
            "reads",
            "it",
            "and",
            "writes",
            "the",
            "frame",
            "first",
            "sample",
            "number",
            "in",
            "sample",
            "number",
            "holder"
        ]
    },
    {
        "id": 1887,
        "code": "public static boolean checkFrameHeaderFromPeek(\n    ExtractorInput input,\n    FlacStreamMetadata flacStreamMetadata,\n    int frameStartMarker,\n    SampleNumberHolder sampleNumberHolder)\n    throws IOException {\n  long originalPeekPosition = input.getPeekPosition();\n\n  byte[] frameStartBytes = new byte[2];\n  input.peekFully(frameStartBytes, 0, 2);\n  int frameStart = (frameStartBytes[0] & 0xFF) << 8 | (frameStartBytes[1] & 0xFF);\n  if (frameStart != frameStartMarker) {\n    input.resetPeekPosition();\n    input.advancePeekPosition((int) (originalPeekPosition - input.getPosition()));\n    return false;\n  }\n\n  ParsableByteArray scratch = new ParsableByteArray(FlacConstants.MAX_FRAME_HEADER_SIZE);\n  System.arraycopy(\n      frameStartBytes,  0, scratch.getData(),  0,  2);\n\n  int totalBytesPeeked =\n      ExtractorUtil.peekToLength(\n          input, scratch.getData(), 2, FlacConstants.MAX_FRAME_HEADER_SIZE - 2);\n  scratch.setLimit(totalBytesPeeked);\n\n  input.resetPeekPosition();\n  input.advancePeekPosition((int) (originalPeekPosition - input.getPosition()));\n\n  return checkAndReadFrameHeader(\n      scratch, flacStreamMetadata, frameStartMarker, sampleNumberHolder);\n}",
        "summary_tokens": [
            "checks",
            "whether",
            "the",
            "given",
            "flac",
            "frame",
            "header",
            "is",
            "valid",
            "and",
            "if",
            "so",
            "writes",
            "the",
            "frame",
            "first",
            "sample",
            "number",
            "in",
            "sample",
            "number",
            "holder"
        ]
    },
    {
        "id": 1888,
        "code": "public static long getFirstSampleNumber(\n    ExtractorInput input, FlacStreamMetadata flacStreamMetadata) throws IOException {\n  input.resetPeekPosition();\n  input.advancePeekPosition(1);\n  byte[] blockingStrategyByte = new byte[1];\n  input.peekFully(blockingStrategyByte, 0, 1);\n  boolean isBlockSizeVariable = (blockingStrategyByte[0] & 1) == 1;\n  input.advancePeekPosition(2);\n\n  int maxUtf8SampleNumberSize = isBlockSizeVariable ? 7 : 6;\n  ParsableByteArray scratch = new ParsableByteArray(maxUtf8SampleNumberSize);\n  int totalBytesPeeked =\n      ExtractorUtil.peekToLength(input, scratch.getData(), 0, maxUtf8SampleNumberSize);\n  scratch.setLimit(totalBytesPeeked);\n  input.resetPeekPosition();\n\n  SampleNumberHolder sampleNumberHolder = new SampleNumberHolder();\n  if (!checkAndReadFirstSampleNumber(\n      scratch, flacStreamMetadata, isBlockSizeVariable, sampleNumberHolder)) {\n    throw ParserException.createForMalformedContainer( null,  null);\n  }\n\n  return sampleNumberHolder.sampleNumber;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "the",
            "first",
            "sample",
            "in",
            "the",
            "given",
            "frame"
        ]
    },
    {
        "id": 1889,
        "code": "public static int readFrameBlockSizeSamplesFromKey(ParsableByteArray data, int blockSizeKey) {\n  switch (blockSizeKey) {\n    case 1:\n      return 192;\n    case 2:\n    case 3:\n    case 4:\n    case 5:\n      return 576 << (blockSizeKey - 2);\n    case 6:\n      return data.readUnsignedByte() + 1;\n    case 7:\n      return data.readUnsignedShort() + 1;\n    case 8:\n    case 9:\n    case 10:\n    case 11:\n    case 12:\n    case 13:\n    case 14:\n    case 15:\n      return 256 << (blockSizeKey - 8);\n    default:\n      return -1;\n  }\n}",
        "summary_tokens": [
            "reads",
            "the",
            "given",
            "block",
            "size"
        ]
    },
    {
        "id": 1890,
        "code": "private static boolean checkChannelAssignment(\n    int channelAssignmentKey, FlacStreamMetadata flacStreamMetadata) {\n  if (channelAssignmentKey <= 7) {\n    return channelAssignmentKey == flacStreamMetadata.channels - 1;\n  } else if (channelAssignmentKey <= 10) {\n    return flacStreamMetadata.channels == 2;\n  } else {\n    return false;\n  }\n}",
        "summary_tokens": [
            "checks",
            "whether",
            "the",
            "given",
            "channel",
            "assignment",
            "is",
            "valid"
        ]
    },
    {
        "id": 1891,
        "code": "private static boolean checkBitsPerSample(\n    int bitsPerSampleKey, FlacStreamMetadata flacStreamMetadata) {\n  if (bitsPerSampleKey == 0) {\n    return true;\n  }\n  return bitsPerSampleKey == flacStreamMetadata.bitsPerSampleLookupKey;\n}",
        "summary_tokens": [
            "checks",
            "whether",
            "the",
            "given",
            "number",
            "of",
            "bits",
            "per",
            "sample",
            "is",
            "valid"
        ]
    },
    {
        "id": 1892,
        "code": "private static boolean checkAndReadFirstSampleNumber(\n    ParsableByteArray data,\n    FlacStreamMetadata flacStreamMetadata,\n    boolean isBlockSizeVariable,\n    SampleNumberHolder sampleNumberHolder) {\n  long utf8Value;\n  try {\n    utf8Value = data.readUtf8EncodedLong();\n  } catch (NumberFormatException e) {\n    return false;\n  }\n\n  sampleNumberHolder.sampleNumber =\n      isBlockSizeVariable ? utf8Value : utf8Value * flacStreamMetadata.maxBlockSizeSamples;\n  return true;\n}",
        "summary_tokens": [
            "checks",
            "whether",
            "the",
            "given",
            "sample",
            "number",
            "is",
            "valid",
            "and",
            "if",
            "so",
            "reads",
            "it",
            "and",
            "writes",
            "it",
            "in",
            "sample",
            "number",
            "holder"
        ]
    },
    {
        "id": 1893,
        "code": "private static boolean checkAndReadBlockSizeSamples(\n    ParsableByteArray data, FlacStreamMetadata flacStreamMetadata, int blockSizeKey) {\n  int blockSizeSamples = readFrameBlockSizeSamplesFromKey(data, blockSizeKey);\n  return blockSizeSamples != -1 && blockSizeSamples <= flacStreamMetadata.maxBlockSizeSamples;\n}",
        "summary_tokens": [
            "checks",
            "whether",
            "the",
            "given",
            "frame",
            "block",
            "size",
            "key",
            "and",
            "block",
            "size",
            "bits",
            "are",
            "valid",
            "and",
            "if",
            "so",
            "reads",
            "the",
            "block",
            "size",
            "bits"
        ]
    },
    {
        "id": 1894,
        "code": "private static boolean checkAndReadSampleRate(\n    ParsableByteArray data, FlacStreamMetadata flacStreamMetadata, int sampleRateKey) {\n  int expectedSampleRate = flacStreamMetadata.sampleRate;\n  if (sampleRateKey == 0) {\n    return true;\n  } else if (sampleRateKey <= 11) {\n    return sampleRateKey == flacStreamMetadata.sampleRateLookupKey;\n  } else if (sampleRateKey == 12) {\n    return data.readUnsignedByte() * 1000 == expectedSampleRate;\n  } else if (sampleRateKey <= 14) {\n    int sampleRate = data.readUnsignedShort();\n    if (sampleRateKey == 14) {\n      sampleRate *= 10;\n    }\n    return sampleRate == expectedSampleRate;\n  } else {\n    return false;\n  }\n}",
        "summary_tokens": [
            "checks",
            "whether",
            "the",
            "given",
            "sample",
            "rate",
            "key",
            "and",
            "sample",
            "rate",
            "bits",
            "are",
            "valid",
            "and",
            "if",
            "so",
            "reads",
            "the",
            "sample",
            "rate",
            "bits"
        ]
    },
    {
        "id": 1895,
        "code": "private static boolean checkAndReadCrc(ParsableByteArray data, int frameStartPosition) {\n  int crc = data.readUnsignedByte();\n  int frameEndPosition = data.getPosition();\n  int expectedCrc =\n      Util.crc8(data.getData(), frameStartPosition, frameEndPosition - 1,  0);\n  return crc == expectedCrc;\n}",
        "summary_tokens": [
            "checks",
            "whether",
            "the",
            "given",
            "crc",
            "is",
            "valid",
            "and",
            "if",
            "so",
            "reads",
            "it"
        ]
    },
    {
        "id": 1896,
        "code": "public static Metadata peekId3Metadata(ExtractorInput input, boolean parseData)\n    throws IOException {\n  @Nullable\n  Id3Decoder.FramePredicate id3FramePredicate = parseData ? null : Id3Decoder.NO_FRAMES_PREDICATE;\n  @Nullable Metadata id3Metadata = new Id3Peeker().peekId3Data(input, id3FramePredicate);\n  return id3Metadata == null || id3Metadata.length() == 0 ? null : id3Metadata;\n}",
        "summary_tokens": [
            "peeks",
            "id",
            "0",
            "data"
        ]
    },
    {
        "id": 1897,
        "code": "public static boolean checkAndPeekStreamMarker(ExtractorInput input) throws IOException {\n  ParsableByteArray scratch = new ParsableByteArray(FlacConstants.STREAM_MARKER_SIZE);\n  input.peekFully(scratch.getData(), 0, FlacConstants.STREAM_MARKER_SIZE);\n  return scratch.readUnsignedInt() == STREAM_MARKER;\n}",
        "summary_tokens": [
            "peeks",
            "the",
            "flac",
            "stream",
            "marker"
        ]
    },
    {
        "id": 1898,
        "code": "public static Metadata readId3Metadata(ExtractorInput input, boolean parseData)\n    throws IOException {\n  input.resetPeekPosition();\n  long startingPeekPosition = input.getPeekPosition();\n  @Nullable Metadata id3Metadata = peekId3Metadata(input, parseData);\n  int peekedId3Bytes = (int) (input.getPeekPosition() - startingPeekPosition);\n  input.skipFully(peekedId3Bytes);\n  return id3Metadata;\n}",
        "summary_tokens": [
            "reads",
            "id",
            "0",
            "data"
        ]
    },
    {
        "id": 1899,
        "code": "public static void readStreamMarker(ExtractorInput input) throws IOException {\n  ParsableByteArray scratch = new ParsableByteArray(FlacConstants.STREAM_MARKER_SIZE);\n  input.readFully(scratch.getData(), 0, FlacConstants.STREAM_MARKER_SIZE);\n  if (scratch.readUnsignedInt() != STREAM_MARKER) {\n    throw ParserException.createForMalformedContainer(\n        \"Failed to read FLAC stream marker.\",  null);\n  }\n}",
        "summary_tokens": [
            "reads",
            "the",
            "flac",
            "stream",
            "marker"
        ]
    },
    {
        "id": 1900,
        "code": "public static boolean readMetadataBlock(\n    ExtractorInput input, FlacStreamMetadataHolder metadataHolder) throws IOException {\n  input.resetPeekPosition();\n  ParsableBitArray scratch = new ParsableBitArray(new byte[4]);\n  input.peekFully(scratch.data, 0, FlacConstants.METADATA_BLOCK_HEADER_SIZE);\n\n  boolean isLastMetadataBlock = scratch.readBit();\n  int type = scratch.readBits(7);\n  int length = FlacConstants.METADATA_BLOCK_HEADER_SIZE + scratch.readBits(24);\n  if (type == FlacConstants.METADATA_TYPE_STREAM_INFO) {\n    metadataHolder.flacStreamMetadata = readStreamInfoBlock(input);\n  } else {\n    @Nullable FlacStreamMetadata flacStreamMetadata = metadataHolder.flacStreamMetadata;\n    if (flacStreamMetadata == null) {\n      throw new IllegalArgumentException();\n    }\n    if (type == FlacConstants.METADATA_TYPE_SEEK_TABLE) {\n      FlacStreamMetadata.SeekTable seekTable = readSeekTableMetadataBlock(input, length);\n      metadataHolder.flacStreamMetadata = flacStreamMetadata.copyWithSeekTable(seekTable);\n    } else if (type == FlacConstants.METADATA_TYPE_VORBIS_COMMENT) {\n      List<String> vorbisComments = readVorbisCommentMetadataBlock(input, length);\n      metadataHolder.flacStreamMetadata =\n          flacStreamMetadata.copyWithVorbisComments(vorbisComments);\n    } else if (type == FlacConstants.METADATA_TYPE_PICTURE) {\n      ParsableByteArray pictureBlock = new ParsableByteArray(length);\n      input.readFully(pictureBlock.getData(), 0, length);\n      pictureBlock.skipBytes(FlacConstants.METADATA_BLOCK_HEADER_SIZE);\n      PictureFrame pictureFrame = PictureFrame.fromPictureBlock(pictureBlock);\n      metadataHolder.flacStreamMetadata =\n          flacStreamMetadata.copyWithPictureFrames(ImmutableList.of(pictureFrame));\n    } else {\n      input.skipFully(length);\n    }\n  }\n\n  return isLastMetadataBlock;\n}",
        "summary_tokens": [
            "reads",
            "one",
            "flac",
            "metadata",
            "block"
        ]
    },
    {
        "id": 1901,
        "code": "public static FlacStreamMetadata.SeekTable readSeekTableMetadataBlock(ParsableByteArray data) {\n  data.skipBytes(1);\n  int length = data.readUnsignedInt24();\n\n  long seekTableEndPosition = (long) data.getPosition() + length;\n  int seekPointCount = length / SEEK_POINT_SIZE;\n  long[] pointSampleNumbers = new long[seekPointCount];\n  long[] pointOffsets = new long[seekPointCount];\n  for (int i = 0; i < seekPointCount; i++) {\n      \n      \n    long sampleNumber = data.readLong();\n    if (sampleNumber == -1) {\n      pointSampleNumbers = Arrays.copyOf(pointSampleNumbers, i);\n      pointOffsets = Arrays.copyOf(pointOffsets, i);\n      break;\n    }\n    pointSampleNumbers[i] = sampleNumber;\n    pointOffsets[i] = data.readLong();\n    data.skipBytes(2);\n  }\n\n  data.skipBytes((int) (seekTableEndPosition - data.getPosition()));\n  return new FlacStreamMetadata.SeekTable(pointSampleNumbers, pointOffsets);\n}",
        "summary_tokens": [
            "reads",
            "a",
            "flac",
            "seek",
            "table",
            "metadata",
            "block"
        ]
    },
    {
        "id": 1902,
        "code": "public static int getFrameStartMarker(ExtractorInput input) throws IOException {\n  input.resetPeekPosition();\n  ParsableByteArray scratch = new ParsableByteArray(2);\n  input.peekFully(scratch.getData(), 0, 2);\n\n  int frameStartMarker = scratch.readUnsignedShort();\n  int syncCode = frameStartMarker >> 2;\n  if (syncCode != SYNC_CODE) {\n    input.resetPeekPosition();\n    throw ParserException.createForMalformedContainer(\n        \"First frame does not start with sync code.\",  null);\n  }\n\n  input.resetPeekPosition();\n  return frameStartMarker;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "frame",
            "start",
            "marker",
            "consisting",
            "of",
            "the",
            "0",
            "first",
            "bytes",
            "of",
            "the",
            "first",
            "frame"
        ]
    },
    {
        "id": 1903,
        "code": "public int getMaxDecodedFrameSize() {\n  return maxBlockSizeSamples * channels * (bitsPerSample / 8);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "maximum",
            "size",
            "for",
            "a",
            "decoded",
            "frame",
            "from",
            "the",
            "flac",
            "stream"
        ]
    },
    {
        "id": 1904,
        "code": "public int getDecodedBitrate() {\n  return bitsPerSample * sampleRate * channels;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "bitrate",
            "of",
            "the",
            "stream",
            "after",
            "it",
            "s",
            "decoded",
            "into",
            "pcm"
        ]
    },
    {
        "id": 1905,
        "code": "public long getDurationUs() {\n  return totalSamples == 0 ? C.TIME_UNSET : totalSamples * C.MICROS_PER_SECOND / sampleRate;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "duration",
            "of",
            "the",
            "flac",
            "stream",
            "in",
            "microseconds",
            "or",
            "c",
            "time",
            "unset",
            "if",
            "the",
            "total",
            "number",
            "of",
            "samples",
            "if",
            "unknown"
        ]
    },
    {
        "id": 1906,
        "code": "public long getSampleNumber(long timeUs) {\n  long sampleNumber = (timeUs * sampleRate) / C.MICROS_PER_SECOND;\n  return Util.constrainValue(sampleNumber,  0, totalSamples - 1);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "sample",
            "number",
            "of",
            "the",
            "sample",
            "at",
            "a",
            "given",
            "time"
        ]
    },
    {
        "id": 1907,
        "code": "public long getApproxBytesPerFrame() {\n  long approxBytesPerFrame;\n  if (maxFrameSize > 0) {\n    approxBytesPerFrame = ((long) maxFrameSize + minFrameSize) / 2 + 1;\n  } else {\n      \n      \n    long blockSizeSamples =\n        (minBlockSizeSamples == maxBlockSizeSamples && minBlockSizeSamples > 0)\n            ? minBlockSizeSamples\n            : 4096;\n    approxBytesPerFrame = (blockSizeSamples * channels * bitsPerSample) / 8 + 64;\n  }\n  return approxBytesPerFrame;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "approximate",
            "number",
            "of",
            "bytes",
            "per",
            "frame",
            "for",
            "the",
            "current",
            "flac",
            "stream"
        ]
    },
    {
        "id": 1908,
        "code": "public Format getFormat(byte[] streamMarkerAndInfoBlock, @Nullable Metadata id3Metadata) {\n    \n  streamMarkerAndInfoBlock[4] = (byte) 0x80;\n  int maxInputSize = maxFrameSize > 0 ? maxFrameSize : Format.NO_VALUE;\n  @Nullable Metadata metadataWithId3 = getMetadataCopyWithAppendedEntriesFrom(id3Metadata);\n  return new Format.Builder()\n      .setSampleMimeType(MimeTypes.AUDIO_FLAC)\n      .setMaxInputSize(maxInputSize)\n      .setChannelCount(channels)\n      .setSampleRate(sampleRate)\n      .setInitializationData(Collections.singletonList(streamMarkerAndInfoBlock))\n      .setMetadata(metadataWithId3)\n      .build();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "format",
            "extracted",
            "from",
            "the",
            "flac",
            "stream",
            "metadata"
        ]
    },
    {
        "id": 1909,
        "code": "public Metadata getMetadataCopyWithAppendedEntriesFrom(@Nullable Metadata other) {\n  return metadata == null ? other : metadata.copyWithAppendedEntriesFrom(other);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "copy",
            "of",
            "the",
            "content",
            "metadata",
            "with",
            "entries",
            "from",
            "other",
            "appended"
        ]
    },
    {
        "id": 1910,
        "code": "public FlacStreamMetadata copyWithSeekTable(@Nullable SeekTable seekTable) {\n  return new FlacStreamMetadata(\n      minBlockSizeSamples,\n      maxBlockSizeSamples,\n      minFrameSize,\n      maxFrameSize,\n      sampleRate,\n      channels,\n      bitsPerSample,\n      totalSamples,\n      seekTable,\n      metadata);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "copy",
            "of",
            "this",
            "with",
            "the",
            "seek",
            "table",
            "replaced",
            "by",
            "the",
            "one",
            "given"
        ]
    },
    {
        "id": 1911,
        "code": "public FlacStreamMetadata copyWithVorbisComments(List<String> vorbisComments) {\n  @Nullable\n  Metadata appendedMetadata =\n      getMetadataCopyWithAppendedEntriesFrom(parseVorbisComments(vorbisComments));\n  return new FlacStreamMetadata(\n      minBlockSizeSamples,\n      maxBlockSizeSamples,\n      minFrameSize,\n      maxFrameSize,\n      sampleRate,\n      channels,\n      bitsPerSample,\n      totalSamples,\n      seekTable,\n      appendedMetadata);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "copy",
            "of",
            "this",
            "with",
            "the",
            "given",
            "vorbis",
            "comments",
            "added",
            "to",
            "the",
            "metadata"
        ]
    },
    {
        "id": 1912,
        "code": "public FlacStreamMetadata copyWithPictureFrames(List<PictureFrame> pictureFrames) {\n  @Nullable\n  Metadata appendedMetadata = getMetadataCopyWithAppendedEntriesFrom(new Metadata(pictureFrames));\n  return new FlacStreamMetadata(\n      minBlockSizeSamples,\n      maxBlockSizeSamples,\n      minFrameSize,\n      maxFrameSize,\n      sampleRate,\n      channels,\n      bitsPerSample,\n      totalSamples,\n      seekTable,\n      appendedMetadata);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "copy",
            "of",
            "this",
            "with",
            "the",
            "given",
            "picture",
            "frames",
            "added",
            "to",
            "the",
            "metadata"
        ]
    },
    {
        "id": 1913,
        "code": "private static Metadata concatenateVorbisMetadata(\n    List<String> vorbisComments, List<PictureFrame> pictureFrames) {\n  @Nullable Metadata parsedVorbisComments = parseVorbisComments(vorbisComments);\n  if (parsedVorbisComments == null && pictureFrames.isEmpty()) {\n    return null;\n  }\n  return new Metadata(pictureFrames).copyWithAppendedEntriesFrom(parsedVorbisComments);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "metadata",
            "instance",
            "created",
            "from",
            "vorbis",
            "comments",
            "and",
            "picture",
            "frames"
        ]
    },
    {
        "id": 1914,
        "code": "public boolean setFromXingHeaderValue(int value) {\n  int encoderDelay = value >> 12;\n  int encoderPadding = value & 0x0FFF;\n  if (encoderDelay > 0 || encoderPadding > 0) {\n    this.encoderDelay = encoderDelay;\n    this.encoderPadding = encoderPadding;\n    return true;\n  }\n  return false;\n}",
        "summary_tokens": [
            "populates",
            "the",
            "holder",
            "with",
            "data",
            "from",
            "an",
            "mp",
            "0",
            "xing",
            "header",
            "if",
            "valid",
            "and",
            "non",
            "zero"
        ]
    },
    {
        "id": 1915,
        "code": "public boolean setFromMetadata(Metadata metadata) {\n  for (int i = 0; i < metadata.length(); i++) {\n    Metadata.Entry entry = metadata.get(i);\n    if (entry instanceof CommentFrame) {\n      CommentFrame commentFrame = (CommentFrame) entry;\n      if (GAPLESS_DESCRIPTION.equals(commentFrame.description)\n          && setFromComment(commentFrame.text)) {\n        return true;\n      }\n    } else if (entry instanceof InternalFrame) {\n      InternalFrame internalFrame = (InternalFrame) entry;\n      if (GAPLESS_DOMAIN.equals(internalFrame.domain)\n          && GAPLESS_DESCRIPTION.equals(internalFrame.description)\n          && setFromComment(internalFrame.text)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}",
        "summary_tokens": [
            "populates",
            "the",
            "holder",
            "with",
            "data",
            "parsed",
            "from",
            "id",
            "0",
            "metadata"
        ]
    },
    {
        "id": 1916,
        "code": "private boolean setFromComment(String data) {\n  Matcher matcher = GAPLESS_COMMENT_PATTERN.matcher(data);\n  if (matcher.find()) {\n    try {\n      int encoderDelay = Integer.parseInt(castNonNull(matcher.group(1)), 16);\n      int encoderPadding = Integer.parseInt(castNonNull(matcher.group(2)), 16);\n      if (encoderDelay > 0 || encoderPadding > 0) {\n        this.encoderDelay = encoderDelay;\n        this.encoderPadding = encoderPadding;\n        return true;\n      }\n    } catch (NumberFormatException e) {\n        \n    }\n  }\n  return false;\n}",
        "summary_tokens": [
            "populates",
            "the",
            "holder",
            "with",
            "data",
            "parsed",
            "from",
            "a",
            "gapless",
            "playback",
            "comment",
            "stored",
            "in",
            "an",
            "id",
            "0",
            "header",
            "or",
            "mpeg",
            "0",
            "user",
            "data",
            "if",
            "valid",
            "and",
            "non",
            "zero"
        ]
    },
    {
        "id": 1917,
        "code": "public boolean hasGaplessInfo() {\n  return encoderDelay != Format.NO_VALUE && encoderPadding != Format.NO_VALUE;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "encoder",
            "delay",
            "and",
            "encoder",
            "padding",
            "have",
            "been",
            "set"
        ]
    },
    {
        "id": 1918,
        "code": "public Metadata peekId3Data(\n    ExtractorInput input, @Nullable Id3Decoder.FramePredicate id3FramePredicate)\n    throws IOException {\n  int peekedId3Bytes = 0;\n  @Nullable Metadata metadata = null;\n  while (true) {\n    try {\n      input.peekFully(scratch.getData(),  0, Id3Decoder.ID3_HEADER_LENGTH);\n    } catch (EOFException e) {\n        \n      break;\n    }\n    scratch.setPosition(0);\n    if (scratch.readUnsignedInt24() != Id3Decoder.ID3_TAG) {\n        \n      break;\n    }\n    scratch.skipBytes(3); \n    int framesLength = scratch.readSynchSafeInt();\n    int tagLength = Id3Decoder.ID3_HEADER_LENGTH + framesLength;\n\n    if (metadata == null) {\n      byte[] id3Data = new byte[tagLength];\n      System.arraycopy(scratch.getData(), 0, id3Data, 0, Id3Decoder.ID3_HEADER_LENGTH);\n      input.peekFully(id3Data, Id3Decoder.ID3_HEADER_LENGTH, framesLength);\n\n      metadata = new Id3Decoder(id3FramePredicate).decode(id3Data, tagLength);\n    } else {\n      input.advancePeekPosition(framesLength);\n    }\n\n    peekedId3Bytes += tagLength;\n  }\n\n  input.resetPeekPosition();\n  input.advancePeekPosition(peekedId3Bytes);\n  return metadata;\n}",
        "summary_tokens": [
            "peeks",
            "id",
            "0",
            "data",
            "from",
            "the",
            "input",
            "and",
            "parses",
            "the",
            "first",
            "id",
            "0",
            "tag"
        ]
    },
    {
        "id": 1919,
        "code": "default void sampleData(ParsableByteArray data, int length) {\n  sampleData(data, length, SAMPLE_DATA_PART_MAIN);\n}",
        "summary_tokens": [
            "equivalent",
            "to",
            "sample",
            "data",
            "parsable",
            "byte",
            "array",
            "int",
            "int",
            "sample",
            "data",
            "data",
            "length",
            "sample",
            "data",
            "part",
            "main"
        ]
    },
    {
        "id": 1920,
        "code": "public void reset() {\n  byteOffset = 0;\n  bitOffset = 0;\n}",
        "summary_tokens": [
            "resets",
            "the",
            "reading",
            "position",
            "to",
            "zero"
        ]
    },
    {
        "id": 1921,
        "code": "public boolean readBit() {\n  boolean returnValue = (((data[byteOffset] & 0xFF) >> bitOffset) & 0x01) == 1;\n  skipBits(1);\n  return returnValue;\n}",
        "summary_tokens": [
            "reads",
            "a",
            "single",
            "bit"
        ]
    },
    {
        "id": 1922,
        "code": "public int readBits(int numBits) {\n  int tempByteOffset = byteOffset;\n  int bitsRead = min(numBits, 8 - bitOffset);\n  int returnValue = ((data[tempByteOffset++] & 0xFF) >> bitOffset) & (0xFF >> (8 - bitsRead));\n  while (bitsRead < numBits) {\n    returnValue |= (data[tempByteOffset++] & 0xFF) << bitsRead;\n    bitsRead += 8;\n  }\n  returnValue &= 0xFFFFFFFF >>> (32 - numBits);\n  skipBits(numBits);\n  return returnValue;\n}",
        "summary_tokens": [
            "reads",
            "up",
            "to",
            "0",
            "bits"
        ]
    },
    {
        "id": 1923,
        "code": "public void skipBits(int numBits) {\n  int numBytes = numBits / 8;\n  byteOffset += numBytes;\n  bitOffset += numBits - (numBytes * 8);\n  if (bitOffset > 7) {\n    byteOffset++;\n    bitOffset -= 8;\n  }\n  assertValidOffset();\n}",
        "summary_tokens": [
            "skips",
            "number",
            "of",
            "bits",
            "bits"
        ]
    },
    {
        "id": 1924,
        "code": "public int getPosition() {\n  return byteOffset * 8 + bitOffset;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "reading",
            "position",
            "in",
            "bits"
        ]
    },
    {
        "id": 1925,
        "code": "public void setPosition(int position) {\n  byteOffset = position / 8;\n  bitOffset = position - (byteOffset * 8);\n  assertValidOffset();\n}",
        "summary_tokens": [
            "sets",
            "the",
            "reading",
            "position",
            "in",
            "bits"
        ]
    },
    {
        "id": 1926,
        "code": "public int bitsLeft() {\n  return (byteLimit - byteOffset) * 8 - bitOffset;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "remaining",
            "bits"
        ]
    },
    {
        "id": 1927,
        "code": "public static int iLog(int x) {\n  int val = 0;\n  while (x > 0) {\n    val++;\n    x >>>= 1;\n  }\n  return val;\n}",
        "summary_tokens": [
            "returns",
            "ilog",
            "x",
            "which",
            "is",
            "the",
            "index",
            "of",
            "the",
            "highest",
            "set",
            "bit",
            "in",
            "x"
        ]
    },
    {
        "id": 1928,
        "code": "public static VorbisIdHeader readVorbisIdentificationHeader(ParsableByteArray headerData)\n    throws ParserException {\n\n  verifyVorbisHeaderCapturePattern(0x01, headerData, false);\n\n  int version = headerData.readLittleEndianUnsignedIntToInt();\n  int channels = headerData.readUnsignedByte();\n  int sampleRate = headerData.readLittleEndianUnsignedIntToInt();\n  int bitrateMaximum = headerData.readLittleEndianInt();\n  if (bitrateMaximum <= 0) {\n    bitrateMaximum = Format.NO_VALUE;\n  }\n  int bitrateNominal = headerData.readLittleEndianInt();\n  if (bitrateNominal <= 0) {\n    bitrateNominal = Format.NO_VALUE;\n  }\n  int bitrateMinimum = headerData.readLittleEndianInt();\n  if (bitrateMinimum <= 0) {\n    bitrateMinimum = Format.NO_VALUE;\n  }\n  int blockSize = headerData.readUnsignedByte();\n  int blockSize0 = (int) Math.pow(2, blockSize & 0x0F);\n  int blockSize1 = (int) Math.pow(2, (blockSize & 0xF0) >> 4);\n\n  boolean framingFlag = (headerData.readUnsignedByte() & 0x01) > 0;\n    \n  byte[] data = Arrays.copyOf(headerData.getData(), headerData.limit());\n\n  return new VorbisIdHeader(\n      version,\n      channels,\n      sampleRate,\n      bitrateMaximum,\n      bitrateNominal,\n      bitrateMinimum,\n      blockSize0,\n      blockSize1,\n      framingFlag,\n      data);\n}",
        "summary_tokens": [
            "reads",
            "a",
            "vorbis",
            "identification",
            "header",
            "from",
            "header",
            "data"
        ]
    },
    {
        "id": 1929,
        "code": "public static CommentHeader readVorbisCommentHeader(\n    ParsableByteArray headerData, boolean hasMetadataHeader, boolean hasFramingBit)\n    throws ParserException {\n\n  if (hasMetadataHeader) {\n    verifyVorbisHeaderCapturePattern( 0x03, headerData,  false);\n  }\n  int length = 7;\n\n  int len = (int) headerData.readLittleEndianUnsignedInt();\n  length += 4;\n  String vendor = headerData.readString(len);\n  length += vendor.length();\n\n  long commentListLen = headerData.readLittleEndianUnsignedInt();\n  String[] comments = new String[(int) commentListLen];\n  length += 4;\n  for (int i = 0; i < commentListLen; i++) {\n    len = (int) headerData.readLittleEndianUnsignedInt();\n    length += 4;\n    comments[i] = headerData.readString(len);\n    length += comments[i].length();\n  }\n  if (hasFramingBit && (headerData.readUnsignedByte() & 0x01) == 0) {\n    throw ParserException.createForMalformedContainer(\n        \"framing bit expected to be set\",  null);\n  }\n  length += 1;\n  return new CommentHeader(vendor, comments, length);\n}",
        "summary_tokens": [
            "reads",
            "a",
            "vorbis",
            "comment",
            "header"
        ]
    },
    {
        "id": 1930,
        "code": "public static Metadata parseVorbisComments(List<String> vorbisComments) {\n  List<Entry> metadataEntries = new ArrayList<>();\n  for (int i = 0; i < vorbisComments.size(); i++) {\n    String vorbisComment = vorbisComments.get(i);\n    String[] keyAndValue = Util.splitAtFirst(vorbisComment, \"=\");\n    if (keyAndValue.length != 2) {\n      Log.w(TAG, \"Failed to parse Vorbis comment: \" + vorbisComment);\n      continue;\n    }\n\n    if (keyAndValue[0].equals(\"METADATA_BLOCK_PICTURE\")) {\n        \n        \n        \n      try {\n        byte[] decoded = Base64.decode(keyAndValue[1], Base64.DEFAULT);\n        metadataEntries.add(PictureFrame.fromPictureBlock(new ParsableByteArray(decoded)));\n      } catch (RuntimeException e) {\n        Log.w(TAG, \"Failed to parse vorbis picture\", e);\n      }\n    } else {\n      VorbisComment entry = new VorbisComment(keyAndValue[0], keyAndValue[1]);\n      metadataEntries.add(entry);\n    }\n  }\n\n  return metadataEntries.isEmpty() ? null : new Metadata(metadataEntries);\n}",
        "summary_tokens": [
            "builds",
            "a",
            "metadata",
            "instance",
            "from",
            "a",
            "list",
            "of",
            "vorbis",
            "comments"
        ]
    },
    {
        "id": 1931,
        "code": "public static boolean verifyVorbisHeaderCapturePattern(\n    int headerType, ParsableByteArray header, boolean quiet) throws ParserException {\n  if (header.bytesLeft() < 7) {\n    if (quiet) {\n      return false;\n    } else {\n      throw ParserException.createForMalformedContainer(\n          \"too short header: \" + header.bytesLeft(),  null);\n    }\n  }\n\n  if (header.readUnsignedByte() != headerType) {\n    if (quiet) {\n      return false;\n    } else {\n      throw ParserException.createForMalformedContainer(\n          \"expected header type \" + Integer.toHexString(headerType),  null);\n    }\n  }\n\n  if (!(header.readUnsignedByte() == 'v'\n      && header.readUnsignedByte() == 'o'\n      && header.readUnsignedByte() == 'r'\n      && header.readUnsignedByte() == 'b'\n      && header.readUnsignedByte() == 'i'\n      && header.readUnsignedByte() == 's')) {\n    if (quiet) {\n      return false;\n    } else {\n      throw ParserException.createForMalformedContainer(\n          \"expected characters 'vorbis'\",  null);\n    }\n  }\n  return true;\n}",
        "summary_tokens": [
            "verifies",
            "whether",
            "the",
            "next",
            "bytes",
            "in",
            "header",
            "are",
            "a",
            "vorbis",
            "header",
            "of",
            "the",
            "given",
            "header",
            "type"
        ]
    },
    {
        "id": 1932,
        "code": "public static Mode[] readVorbisModes(ParsableByteArray headerData, int channels)\n    throws ParserException {\n\n  verifyVorbisHeaderCapturePattern(0x05, headerData, false);\n\n  int numberOfBooks = headerData.readUnsignedByte() + 1;\n\n  VorbisBitArray bitArray = new VorbisBitArray(headerData.getData());\n  bitArray.skipBits(headerData.getPosition() * 8);\n\n  for (int i = 0; i < numberOfBooks; i++) {\n    readBook(bitArray);\n  }\n\n  int timeCount = bitArray.readBits(6) + 1;\n  for (int i = 0; i < timeCount; i++) {\n    if (bitArray.readBits(16) != 0x00) {\n      throw ParserException.createForMalformedContainer(\n          \"placeholder of time domain transforms not zeroed out\",  null);\n    }\n  }\n  readFloors(bitArray);\n  readResidues(bitArray);\n  readMappings(channels, bitArray);\n\n  Mode[] modes = readModes(bitArray);\n  if (!bitArray.readBit()) {\n    throw ParserException.createForMalformedContainer(\n        \"framing bit after modes not set as expected\",  null);\n  }\n  return modes;\n}",
        "summary_tokens": [
            "this",
            "method",
            "reads",
            "the",
            "modes",
            "which",
            "are",
            "located",
            "at",
            "the",
            "very",
            "end",
            "of",
            "the",
            "vorbis",
            "setup",
            "header"
        ]
    },
    {
        "id": 1933,
        "code": "private boolean readAmrHeader(ExtractorInput input) throws IOException {\n  if (peekAmrSignature(input, amrSignatureNb)) {\n    isWideBand = false;\n    input.skipFully(amrSignatureNb.length);\n    return true;\n  } else if (peekAmrSignature(input, amrSignatureWb)) {\n    isWideBand = true;\n    input.skipFully(amrSignatureWb.length);\n    return true;\n  }\n  return false;\n}",
        "summary_tokens": [
            "peeks",
            "the",
            "amr",
            "header",
            "from",
            "the",
            "beginning",
            "of",
            "the",
            "input",
            "and",
            "consumes",
            "it",
            "if",
            "it",
            "exists"
        ]
    },
    {
        "id": 1934,
        "code": "private static boolean peekAmrSignature(ExtractorInput input, byte[] amrSignature)\n    throws IOException {\n  input.resetPeekPosition();\n  byte[] header = new byte[amrSignature.length];\n  input.peekFully(header, 0, amrSignature.length);\n  return Arrays.equals(header, amrSignature);\n}",
        "summary_tokens": [
            "peeks",
            "from",
            "the",
            "beginning",
            "of",
            "the",
            "input",
            "to",
            "see",
            "if",
            "the",
            "given",
            "amr",
            "signature",
            "exists"
        ]
    },
    {
        "id": 1935,
        "code": "private static int getBitrateFromFrameSize(int frameSize, long durationUsPerFrame) {\n  return (int)\n      ((frameSize * ((long) C.BITS_PER_BYTE) * C.MICROS_PER_SECOND) / durationUsPerFrame);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "stream",
            "bitrate",
            "given",
            "a",
            "frame",
            "size",
            "and",
            "the",
            "duration",
            "of",
            "that",
            "frame",
            "in",
            "microseconds"
        ]
    },
    {
        "id": 1936,
        "code": "private boolean resolvePendingReposition(ExtractorInput input, PositionHolder positionHolder)\n    throws IOException {\n  boolean needSeek = false;\n  if (pendingReposition != C.POSITION_UNSET) {\n    long currentPosition = input.getPosition();\n    if (pendingReposition < currentPosition\n        || pendingReposition > currentPosition + RELOAD_MINIMUM_SEEK_DISTANCE) {\n      positionHolder.position = pendingReposition;\n      needSeek = true;\n    } else {\n        \n        \n      input.skipFully((int) (pendingReposition - currentPosition));\n    }\n  }\n  pendingReposition = C.POSITION_UNSET;\n  return needSeek;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "a",
            "result",
            "seek",
            "is",
            "required",
            "for",
            "the",
            "pending",
            "reposition"
        ]
    },
    {
        "id": 1937,
        "code": "private void parseIdx1Body(ParsableByteArray body) {\n  long seekOffset = peekSeekOffset(body);\n  while (body.bytesLeft() >= 16) {\n    int chunkId = body.readLittleEndianInt();\n    int flags = body.readLittleEndianInt();\n    long offset = body.readLittleEndianInt() + seekOffset;\n    body.readLittleEndianInt(); \n    ChunkReader chunkReader = getChunkReader(chunkId);\n    if (chunkReader == null) {\n        \n      continue;\n    }\n    if ((flags & AVIIF_KEYFRAME) == AVIIF_KEYFRAME) {\n      chunkReader.appendKeyFrameToIndex(offset);\n    }\n    chunkReader.incrementIndexChunkCount();\n  }\n  for (ChunkReader chunkReader : chunkReaders) {\n    chunkReader.compactIndex();\n  }\n  seekMapHasBeenOutput = true;\n  extractorOutput.seekMap(new AviSeekMap(durationUs));\n}",
        "summary_tokens": [
            "builds",
            "and",
            "outputs",
            "the",
            "seek",
            "map",
            "from",
            "the",
            "idx",
            "0",
            "chunk"
        ]
    },
    {
        "id": 1938,
        "code": "private static void alignInputToEvenPosition(ExtractorInput input) throws IOException {\n  if ((input.getPosition() & 1) == 1) {\n    input.skipFully(1);\n  }\n}",
        "summary_tokens": [
            "skips",
            "one",
            "byte",
            "from",
            "the",
            "given",
            "input",
            "if",
            "the",
            "current",
            "position",
            "is",
            "odd"
        ]
    },
    {
        "id": 1939,
        "code": "public void onChunkStart(int size) {\n  currentChunkSize = size;\n  bytesRemainingInCurrentChunk = size;\n}",
        "summary_tokens": [
            "prepares",
            "for",
            "parsing",
            "a",
            "chunk",
            "with",
            "the",
            "given",
            "size"
        ]
    },
    {
        "id": 1940,
        "code": "public boolean onChunkData(ExtractorInput input) throws IOException {\n  bytesRemainingInCurrentChunk -=\n      trackOutput.sampleData(input, bytesRemainingInCurrentChunk, false);\n  boolean done = bytesRemainingInCurrentChunk == 0;\n  if (done) {\n    if (currentChunkSize > 0) {\n      trackOutput.sampleMetadata(\n          getCurrentChunkTimestampUs(),\n          (isCurrentFrameAKeyFrame() ? C.BUFFER_FLAG_KEY_FRAME : 0),\n          currentChunkSize,\n          0,\n          null);\n    }\n    advanceCurrentChunk();\n  }\n  return done;\n}",
        "summary_tokens": [
            "provides",
            "data",
            "associated",
            "to",
            "the",
            "current",
            "chunk",
            "and",
            "returns",
            "whether",
            "the",
            "full",
            "chunk",
            "has",
            "been",
            "parsed"
        ]
    },
    {
        "id": 1941,
        "code": "private long findFrame(ParsableByteArray data, boolean foundEndOfInput) {\n  Assertions.checkNotNull(flacStreamMetadata);\n\n  int frameOffset = data.getPosition();\n  while (frameOffset <= data.limit() - FlacConstants.MAX_FRAME_HEADER_SIZE) {\n    data.setPosition(frameOffset);\n    if (FlacFrameReader.checkAndReadFrameHeader(\n        data, flacStreamMetadata, frameStartMarker, sampleNumberHolder)) {\n      data.setPosition(frameOffset);\n      return sampleNumberHolder.sampleNumber;\n    }\n    frameOffset++;\n  }\n\n  if (foundEndOfInput) {\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    while (frameOffset <= data.limit() - minFrameSize) {\n      data.setPosition(frameOffset);\n      boolean frameFound;\n      try {\n        frameFound =\n            FlacFrameReader.checkAndReadFrameHeader(\n                data, flacStreamMetadata, frameStartMarker, sampleNumberHolder);\n      } catch (IndexOutOfBoundsException e) {\n          \n        frameFound = false;\n      }\n      if (data.getPosition() > data.limit()) {\n          \n          \n        frameFound = false;\n      }\n      if (frameFound) {\n          \n        data.setPosition(frameOffset);\n        return sampleNumberHolder.sampleNumber;\n      }\n      frameOffset++;\n    }\n      \n    data.setPosition(data.limit());\n  } else {\n    data.setPosition(frameOffset);\n  }\n\n  return SAMPLE_NUMBER_UNKNOWN;\n}",
        "summary_tokens": [
            "searches",
            "for",
            "the",
            "start",
            "of",
            "a",
            "frame",
            "in",
            "data"
        ]
    },
    {
        "id": 1942,
        "code": "private boolean readFlvHeader(ExtractorInput input) throws IOException {\n  if (!input.readFully(headerBuffer.getData(), 0, FLV_HEADER_SIZE, true)) {\n      \n    return false;\n  }\n\n  headerBuffer.setPosition(0);\n  headerBuffer.skipBytes(4);\n  int flags = headerBuffer.readUnsignedByte();\n  boolean hasAudio = (flags & 0x04) != 0;\n  boolean hasVideo = (flags & 0x01) != 0;\n  if (hasAudio && audioReader == null) {\n    audioReader =\n        new AudioTagPayloadReader(extractorOutput.track(TAG_TYPE_AUDIO, C.TRACK_TYPE_AUDIO));\n  }\n  if (hasVideo && videoReader == null) {\n    videoReader =\n        new VideoTagPayloadReader(extractorOutput.track(TAG_TYPE_VIDEO, C.TRACK_TYPE_VIDEO));\n  }\n  extractorOutput.endTracks();\n\n    \n  bytesToNextTagHeader = headerBuffer.readInt() - FLV_HEADER_SIZE + 4;\n  state = STATE_SKIPPING_TO_TAG_HEADER;\n  return true;\n}",
        "summary_tokens": [
            "reads",
            "an",
            "flv",
            "container",
            "header",
            "from",
            "the",
            "provided",
            "extractor",
            "input"
        ]
    },
    {
        "id": 1943,
        "code": "private void skipToTagHeader(ExtractorInput input) throws IOException {\n  input.skipFully(bytesToNextTagHeader);\n  bytesToNextTagHeader = 0;\n  state = STATE_READING_TAG_HEADER;\n}",
        "summary_tokens": [
            "skips",
            "over",
            "data",
            "to",
            "reach",
            "the",
            "next",
            "tag",
            "header"
        ]
    },
    {
        "id": 1944,
        "code": "private boolean readTagHeader(ExtractorInput input) throws IOException {\n  if (!input.readFully(tagHeaderBuffer.getData(), 0, FLV_TAG_HEADER_SIZE, true)) {\n      \n    return false;\n  }\n\n  tagHeaderBuffer.setPosition(0);\n  tagType = tagHeaderBuffer.readUnsignedByte();\n  tagDataSize = tagHeaderBuffer.readUnsignedInt24();\n  tagTimestampUs = tagHeaderBuffer.readUnsignedInt24();\n  tagTimestampUs = ((tagHeaderBuffer.readUnsignedByte() << 24) | tagTimestampUs) * 1000L;\n  tagHeaderBuffer.skipBytes(3); \n  state = STATE_READING_TAG_DATA;\n  return true;\n}",
        "summary_tokens": [
            "reads",
            "a",
            "tag",
            "header",
            "from",
            "the",
            "provided",
            "extractor",
            "input"
        ]
    },
    {
        "id": 1945,
        "code": "private boolean readTagData(ExtractorInput input) throws IOException {\n  boolean wasConsumed = true;\n  boolean wasSampleOutput = false;\n  long timestampUs = getCurrentTimestampUs();\n  if (tagType == TAG_TYPE_AUDIO && audioReader != null) {\n    ensureReadyForMediaOutput();\n    wasSampleOutput = audioReader.consume(prepareTagData(input), timestampUs);\n  } else if (tagType == TAG_TYPE_VIDEO && videoReader != null) {\n    ensureReadyForMediaOutput();\n    wasSampleOutput = videoReader.consume(prepareTagData(input), timestampUs);\n  } else if (tagType == TAG_TYPE_SCRIPT_DATA && !outputSeekMap) {\n    wasSampleOutput = metadataReader.consume(prepareTagData(input), timestampUs);\n    long durationUs = metadataReader.getDurationUs();\n    if (durationUs != C.TIME_UNSET) {\n      extractorOutput.seekMap(\n          new IndexSeekMap(\n              metadataReader.getKeyFrameTagPositions(),\n              metadataReader.getKeyFrameTimesUs(),\n              durationUs));\n      outputSeekMap = true;\n    }\n  } else {\n    input.skipFully(tagDataSize);\n    wasConsumed = false;\n  }\n  if (!outputFirstSample && wasSampleOutput) {\n    outputFirstSample = true;\n    mediaTagTimestampOffsetUs =\n        metadataReader.getDurationUs() == C.TIME_UNSET ? -tagTimestampUs : 0;\n  }\n  bytesToNextTagHeader = 4; \n  state = STATE_SKIPPING_TO_TAG_HEADER;\n  return wasConsumed;\n}",
        "summary_tokens": [
            "reads",
            "the",
            "body",
            "of",
            "a",
            "tag",
            "from",
            "the",
            "provided",
            "extractor",
            "input"
        ]
    },
    {
        "id": 1946,
        "code": "private static Boolean readAmfBoolean(ParsableByteArray data) {\n  return data.readUnsignedByte() == 1;\n}",
        "summary_tokens": [
            "read",
            "a",
            "boolean",
            "from",
            "an",
            "amf",
            "encoded",
            "buffer"
        ]
    },
    {
        "id": 1947,
        "code": "private static Double readAmfDouble(ParsableByteArray data) {\n  return Double.longBitsToDouble(data.readLong());\n}",
        "summary_tokens": [
            "read",
            "a",
            "double",
            "number",
            "from",
            "an",
            "amf",
            "encoded",
            "buffer"
        ]
    },
    {
        "id": 1948,
        "code": "private static String readAmfString(ParsableByteArray data) {\n  int size = data.readUnsignedShort();\n  int position = data.getPosition();\n  data.skipBytes(size);\n  return new String(data.getData(), position, size);\n}",
        "summary_tokens": [
            "read",
            "a",
            "string",
            "from",
            "an",
            "amf",
            "encoded",
            "buffer"
        ]
    },
    {
        "id": 1949,
        "code": "private static ArrayList<Object> readAmfStrictArray(ParsableByteArray data) {\n  int count = data.readUnsignedIntToInt();\n  ArrayList<Object> list = new ArrayList<>(count);\n  for (int i = 0; i < count; i++) {\n    int type = readAmfType(data);\n    Object value = readAmfData(data, type);\n    if (value != null) {\n      list.add(value);\n    }\n  }\n  return list;\n}",
        "summary_tokens": [
            "read",
            "an",
            "array",
            "from",
            "an",
            "amf",
            "encoded",
            "buffer"
        ]
    },
    {
        "id": 1950,
        "code": "private static HashMap<String, Object> readAmfObject(ParsableByteArray data) {\n  HashMap<String, Object> array = new HashMap<>();\n  while (true) {\n    String key = readAmfString(data);\n    int type = readAmfType(data);\n    if (type == AMF_TYPE_END_MARKER) {\n      break;\n    }\n    Object value = readAmfData(data, type);\n    if (value != null) {\n      array.put(key, value);\n    }\n  }\n  return array;\n}",
        "summary_tokens": [
            "read",
            "an",
            "object",
            "from",
            "an",
            "amf",
            "encoded",
            "buffer"
        ]
    },
    {
        "id": 1951,
        "code": "private static HashMap<String, Object> readAmfEcmaArray(ParsableByteArray data) {\n  int count = data.readUnsignedIntToInt();\n  HashMap<String, Object> array = new HashMap<>(count);\n  for (int i = 0; i < count; i++) {\n    String key = readAmfString(data);\n    int type = readAmfType(data);\n    Object value = readAmfData(data, type);\n    if (value != null) {\n      array.put(key, value);\n    }\n  }\n  return array;\n}",
        "summary_tokens": [
            "read",
            "an",
            "ecma",
            "array",
            "from",
            "an",
            "amf",
            "encoded",
            "buffer"
        ]
    },
    {
        "id": 1952,
        "code": "private static Date readAmfDate(ParsableByteArray data) {\n  Date date = new Date((long) readAmfDouble(data).doubleValue());\n  data.skipBytes(2); \n  return date;\n}",
        "summary_tokens": [
            "read",
            "a",
            "date",
            "from",
            "an",
            "amf",
            "encoded",
            "buffer"
        ]
    },
    {
        "id": 1953,
        "code": "private static MotionPhotoMetadata getMotionPhotoMetadata(String xmpString, long inputLength)\n    throws IOException {\n    \n    \n  if (inputLength == C.LENGTH_UNSET) {\n    return null;\n  }\n\n    \n  @Nullable\n  MotionPhotoDescription motionPhotoDescription =\n      XmpMotionPhotoDescriptionParser.parse(xmpString);\n  if (motionPhotoDescription == null) {\n    return null;\n  }\n  return motionPhotoDescription.getMotionPhotoMetadata(inputLength);\n}",
        "summary_tokens": [
            "attempts",
            "to",
            "parse",
            "the",
            "specified",
            "xmp",
            "data",
            "describing",
            "the",
            "motion",
            "photo",
            "returning",
            "the",
            "resulting",
            "motion",
            "photo",
            "metadata",
            "or",
            "null",
            "if",
            "it",
            "wasn",
            "t",
            "possible",
            "to",
            "derive",
            "motion",
            "photo",
            "metadata"
        ]
    },
    {
        "id": 1954,
        "code": "public MotionPhotoMetadata getMotionPhotoMetadata(long motionPhotoLength) {\n  if (items.size() < 2) {\n      \n    return null;\n  }\n    \n    \n    \n  long photoStartPosition = C.POSITION_UNSET;\n  long photoLength = C.LENGTH_UNSET;\n  long mp4StartPosition = C.POSITION_UNSET;\n  long mp4Length = C.LENGTH_UNSET;\n  boolean itemContainsMp4 = false;\n  long itemStartPosition = motionPhotoLength;\n  long itemEndPosition = motionPhotoLength;\n  for (int i = items.size() - 1; i >= 0; i--) {\n    MotionPhotoDescription.ContainerItem item = items.get(i);\n    itemContainsMp4 |= MimeTypes.VIDEO_MP4.equals(item.mime);\n    itemEndPosition = itemStartPosition;\n    if (i == 0) {\n        \n      itemStartPosition = 0;\n      itemEndPosition -= item.padding;\n    } else {\n      itemStartPosition -= item.length;\n    }\n    if (itemContainsMp4 && itemStartPosition != itemEndPosition) {\n      mp4StartPosition = itemStartPosition;\n      mp4Length = itemEndPosition - itemStartPosition;\n        \n      itemContainsMp4 = false;\n    }\n    if (i == 0) {\n      photoStartPosition = itemStartPosition;\n      photoLength = itemEndPosition;\n    }\n  }\n  if (mp4StartPosition == C.POSITION_UNSET\n      || mp4Length == C.LENGTH_UNSET\n      || photoStartPosition == C.POSITION_UNSET\n      || photoLength == C.LENGTH_UNSET) {\n    return null;\n  }\n  return new MotionPhotoMetadata(\n      photoStartPosition, photoLength, photoPresentationTimestampUs, mp4StartPosition, mp4Length);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "motion",
            "photo",
            "metadata",
            "for",
            "the",
            "motion",
            "photo",
            "represented",
            "by",
            "this",
            "instance",
            "or",
            "null",
            "if",
            "there",
            "wasn",
            "t",
            "enough",
            "information",
            "to",
            "derive",
            "the",
            "metadata"
        ]
    },
    {
        "id": 1955,
        "code": "public static MotionPhotoDescription parse(String xmpString) throws IOException {\n  try {\n    return parseInternal(xmpString);\n  } catch (XmlPullParserException | ParserException | NumberFormatException e) {\n    Log.w(TAG, \"Ignoring unexpected XMP metadata\");\n    return null;\n  }\n}",
        "summary_tokens": [
            "attempts",
            "to",
            "parse",
            "the",
            "specified",
            "xmp",
            "data",
            "describing",
            "the",
            "motion",
            "photo",
            "returning",
            "the",
            "resulting",
            "motion",
            "photo",
            "description",
            "or",
            "null",
            "if",
            "it",
            "wasn",
            "t",
            "possible",
            "to",
            "derive",
            "a",
            "motion",
            "photo",
            "description"
        ]
    },
    {
        "id": 1956,
        "code": "private long maybeResyncToNextLevel1Element(ExtractorInput input) throws IOException {\n  input.resetPeekPosition();\n  while (true) {\n    input.peekFully(scratch, 0, MAX_ID_BYTES);\n    int varintLength = VarintReader.parseUnsignedVarintLength(scratch[0]);\n    if (varintLength != C.LENGTH_UNSET && varintLength <= MAX_ID_BYTES) {\n      int potentialId = (int) VarintReader.assembleVarint(scratch, varintLength, false);\n      if (processor.isLevel1Element(potentialId)) {\n        input.skipFully(varintLength);\n        return potentialId;\n      }\n    }\n    input.skipFully(1);\n  }\n}",
        "summary_tokens": [
            "does",
            "a",
            "byte",
            "by",
            "byte",
            "search",
            "to",
            "try",
            "and",
            "find",
            "the",
            "next",
            "level",
            "0",
            "element"
        ]
    },
    {
        "id": 1957,
        "code": "private long readInteger(ExtractorInput input, int byteLength) throws IOException {\n  input.readFully(scratch, 0, byteLength);\n  long value = 0;\n  for (int i = 0; i < byteLength; i++) {\n    value = (value << 8) | (scratch[i] & 0xFF);\n  }\n  return value;\n}",
        "summary_tokens": [
            "reads",
            "and",
            "returns",
            "an",
            "integer",
            "of",
            "length",
            "byte",
            "length",
            "from",
            "the",
            "extractor",
            "input"
        ]
    },
    {
        "id": 1958,
        "code": "private double readFloat(ExtractorInput input, int byteLength) throws IOException {\n  long integerValue = readInteger(input, byteLength);\n  double floatValue;\n  if (byteLength == VALID_FLOAT32_ELEMENT_SIZE_BYTES) {\n    floatValue = Float.intBitsToFloat((int) integerValue);\n  } else {\n    floatValue = Double.longBitsToDouble(integerValue);\n  }\n  return floatValue;\n}",
        "summary_tokens": [
            "reads",
            "and",
            "returns",
            "a",
            "float",
            "of",
            "length",
            "byte",
            "length",
            "from",
            "the",
            "extractor",
            "input"
        ]
    },
    {
        "id": 1959,
        "code": "private static String readString(ExtractorInput input, int byteLength) throws IOException {\n  if (byteLength == 0) {\n    return \"\";\n  }\n  byte[] stringBytes = new byte[byteLength];\n  input.readFully(stringBytes, 0, byteLength);\n    \n  int trimmedLength = byteLength;\n  while (trimmedLength > 0 && stringBytes[trimmedLength - 1] == 0) {\n    trimmedLength--;\n  }\n  return new String(stringBytes, 0, trimmedLength);\n}",
        "summary_tokens": [
            "reads",
            "a",
            "string",
            "of",
            "length",
            "byte",
            "length",
            "from",
            "the",
            "extractor",
            "input"
        ]
    },
    {
        "id": 1960,
        "code": "public boolean sniff(ExtractorInput input) throws IOException {\n  long inputLength = input.getLength();\n  int bytesToSearch =\n      (int)\n          (inputLength == C.LENGTH_UNSET || inputLength > SEARCH_LENGTH\n              ? SEARCH_LENGTH\n              : inputLength);\n    \n  input.peekFully(scratch.getData(), 0, 4);\n  long tag = scratch.readUnsignedInt();\n  peekLength = 4;\n  while (tag != ID_EBML) {\n    if (++peekLength == bytesToSearch) {\n      return false;\n    }\n    input.peekFully(scratch.getData(), 0, 1);\n    tag = (tag << 8) & 0xFFFFFF00;\n    tag |= scratch.getData()[0] & 0xFF;\n  }\n\n    \n  long headerSize = readUint(input);\n  long headerStart = peekLength;\n  if (headerSize == Long.MIN_VALUE\n      || (inputLength != C.LENGTH_UNSET && headerStart + headerSize >= inputLength)) {\n    return false;\n  }\n\n    \n  while (peekLength < headerStart + headerSize) {\n    long id = readUint(input);\n    if (id == Long.MIN_VALUE) {\n      return false;\n    }\n    long size = readUint(input);\n    if (size < 0 || size > Integer.MAX_VALUE) {\n      return false;\n    }\n    if (size != 0) {\n      int sizeInt = (int) size;\n      input.advancePeekPosition(sizeInt);\n      peekLength += sizeInt;\n    }\n  }\n  return peekLength == headerStart + headerSize;\n}",
        "summary_tokens": [
            "see",
            "extractor",
            "sniff",
            "extractor",
            "input"
        ]
    },
    {
        "id": 1961,
        "code": "private long readUint(ExtractorInput input) throws IOException {\n  input.peekFully(scratch.getData(), 0, 1);\n  int value = scratch.getData()[0] & 0xFF;\n  if (value == 0) {\n    return Long.MIN_VALUE;\n  }\n  int mask = 0x80;\n  int length = 0;\n  while ((value & mask) == 0) {\n    mask >>= 1;\n    length++;\n  }\n  value &= ~mask;\n  input.peekFully(scratch.getData(), 1, length);\n  for (int i = 0; i < length; i++) {\n    value <<= 8;\n    value += scratch.getData()[i + 1] & 0xFF;\n  }\n  peekLength += length + 1;\n  return value;\n}",
        "summary_tokens": [
            "peeks",
            "a",
            "variable",
            "length",
            "unsigned",
            "ebml",
            "integer",
            "from",
            "the",
            "input"
        ]
    },
    {
        "id": 1962,
        "code": "public void reset() {\n  state = STATE_BEGIN_READING;\n  length = 0;\n}",
        "summary_tokens": [
            "resets",
            "the",
            "reader",
            "to",
            "start",
            "reading",
            "a",
            "new",
            "variable",
            "length",
            "integer"
        ]
    },
    {
        "id": 1963,
        "code": "public long readUnsignedVarint(\n    ExtractorInput input,\n    boolean allowEndOfInput,\n    boolean removeLengthMask,\n    int maximumAllowedLength)\n    throws IOException {\n  if (state == STATE_BEGIN_READING) {\n      \n    if (!input.readFully(scratch, 0, 1, allowEndOfInput)) {\n      return C.RESULT_END_OF_INPUT;\n    }\n    int firstByte = scratch[0] & 0xFF;\n    length = parseUnsignedVarintLength(firstByte);\n    if (length == C.LENGTH_UNSET) {\n      throw new IllegalStateException(\"No valid varint length mask found\");\n    }\n    state = STATE_READ_CONTENTS;\n  }\n\n  if (length > maximumAllowedLength) {\n    state = STATE_BEGIN_READING;\n    return C.RESULT_MAX_LENGTH_EXCEEDED;\n  }\n\n  if (length != 1) {\n      \n    input.readFully(scratch, 1, length - 1);\n  }\n\n  state = STATE_BEGIN_READING;\n  return assembleVarint(scratch, length, removeLengthMask);\n}",
        "summary_tokens": [
            "reads",
            "an",
            "ebml",
            "variable",
            "length",
            "integer",
            "varint",
            "from",
            "an",
            "extractor",
            "input",
            "such",
            "that",
            "reading",
            "can",
            "be",
            "resumed",
            "later",
            "if",
            "an",
            "error",
            "occurs",
            "having",
            "read",
            "only",
            "some",
            "of",
            "it"
        ]
    },
    {
        "id": 1964,
        "code": "public int getLastLength() {\n  return length;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "bytes",
            "occupied",
            "by",
            "the",
            "most",
            "recently",
            "parsed",
            "varint"
        ]
    },
    {
        "id": 1965,
        "code": "public static int parseUnsignedVarintLength(int firstByte) {\n  int varIntLength = C.LENGTH_UNSET;\n  for (int i = 0; i < VARINT_LENGTH_MASKS.length; i++) {\n    if ((VARINT_LENGTH_MASKS[i] & firstByte) != 0) {\n      varIntLength = i + 1;\n      break;\n    }\n  }\n  return varIntLength;\n}",
        "summary_tokens": [
            "parses",
            "and",
            "the",
            "length",
            "of",
            "the",
            "varint",
            "given",
            "the",
            "first",
            "byte"
        ]
    },
    {
        "id": 1966,
        "code": "public static long assembleVarint(\n    byte[] varintBytes, int varintLength, boolean removeLengthMask) {\n  long varint = varintBytes[0] & 0xFFL;\n  if (removeLengthMask) {\n    varint &= ~VARINT_LENGTH_MASKS[varintLength - 1];\n  }\n  for (int i = 1; i < varintLength; i++) {\n    varint = (varint << 8) | (varintBytes[i] & 0xFFL);\n  }\n  return varint;\n}",
        "summary_tokens": [
            "assemble",
            "a",
            "varint",
            "from",
            "the",
            "given",
            "byte",
            "array"
        ]
    },
    {
        "id": 1967,
        "code": "public void maybeAddSeekPoint(long timeUs, long position) {\n  if (isTimeUsInIndex(timeUs)) {\n    return;\n  }\n  timesUs.add(timeUs);\n  positions.add(position);\n}",
        "summary_tokens": [
            "adds",
            "a",
            "seek",
            "point",
            "to",
            "the",
            "index",
            "if",
            "it",
            "is",
            "sufficiently",
            "distant",
            "from",
            "the",
            "other",
            "points"
        ]
    },
    {
        "id": 1968,
        "code": "public boolean isTimeUsInIndex(long timeUs) {\n  long lastIndexedTimeUs = timesUs.get(timesUs.size() - 1);\n  return timeUs - lastIndexedTimeUs < MIN_TIME_BETWEEN_POINTS_US;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "time",
            "us",
            "in",
            "microseconds",
            "is",
            "included",
            "in",
            "the",
            "index"
        ]
    },
    {
        "id": 1969,
        "code": "public static MlltSeeker create(long firstFramePosition, MlltFrame mlltFrame, long durationUs) {\n  int referenceCount = mlltFrame.bytesDeviations.length;\n  long[] referencePositions = new long[1 + referenceCount];\n  long[] referenceTimesMs = new long[1 + referenceCount];\n  referencePositions[0] = firstFramePosition;\n  referenceTimesMs[0] = 0;\n  long position = firstFramePosition;\n  long timeMs = 0;\n  for (int i = 1; i <= referenceCount; i++) {\n    position += mlltFrame.bytesBetweenReference + mlltFrame.bytesDeviations[i - 1];\n    timeMs += mlltFrame.millisecondsBetweenReference + mlltFrame.millisecondsDeviations[i - 1];\n    referencePositions[i] = position;\n    referenceTimesMs[i] = timeMs;\n  }\n  return new MlltSeeker(referencePositions, referenceTimesMs, durationUs);\n}",
        "summary_tokens": [
            "returns",
            "an",
            "mllt",
            "seeker",
            "for",
            "seeking",
            "in",
            "the",
            "stream"
        ]
    },
    {
        "id": 1970,
        "code": "private static Pair<Long, Long> linearlyInterpolate(\n    long x, long[] xReferences, long[] yReferences) {\n  int previousReferenceIndex =\n      Util.binarySearchFloor(xReferences, x,  true,  true);\n  long xPreviousReference = xReferences[previousReferenceIndex];\n  long yPreviousReference = yReferences[previousReferenceIndex];\n  int nextReferenceIndex = previousReferenceIndex + 1;\n  if (nextReferenceIndex == xReferences.length) {\n    return Pair.create(xPreviousReference, yPreviousReference);\n  } else {\n    long xNextReference = xReferences[nextReferenceIndex];\n    long yNextReference = yReferences[nextReferenceIndex];\n    double proportion =\n        xNextReference == xPreviousReference\n            ? 0.0\n            : ((double) x - xPreviousReference) / (xNextReference - xPreviousReference);\n    long y = (long) (proportion * (yNextReference - yPreviousReference)) + yPreviousReference;\n    return Pair.create(x, y);\n  }\n}",
        "summary_tokens": [
            "given",
            "a",
            "set",
            "of",
            "reference",
            "points",
            "as",
            "coordinates",
            "in",
            "x",
            "references",
            "and",
            "y",
            "references",
            "and",
            "an",
            "x",
            "axis",
            "value",
            "linearly",
            "interpolates",
            "between",
            "corresponding",
            "reference",
            "points",
            "to",
            "give",
            "a",
            "y",
            "axis",
            "value"
        ]
    },
    {
        "id": 1971,
        "code": "public void disableSeeking() {\n  disableSeeking = true;\n}",
        "summary_tokens": [
            "disables",
            "the",
            "extractor",
            "from",
            "being",
            "able",
            "to",
            "seek",
            "through",
            "the",
            "media"
        ]
    },
    {
        "id": 1972,
        "code": "private boolean peekEndOfStreamOrHeader(ExtractorInput extractorInput) throws IOException {\n  if (seeker != null) {\n    long dataEndPosition = seeker.getDataEndPosition();\n    if (dataEndPosition != C.POSITION_UNSET\n        && extractorInput.getPeekPosition() > dataEndPosition - 4) {\n      return true;\n    }\n  }\n  try {\n    return !extractorInput.peekFully(\n        scratch.getData(),  0,  4,  true);\n  } catch (EOFException e) {\n    return true;\n  }\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "extractor",
            "input",
            "is",
            "peeking",
            "the",
            "end",
            "of",
            "the",
            "stream"
        ]
    },
    {
        "id": 1973,
        "code": "private Seeker maybeReadSeekFrame(ExtractorInput input) throws IOException {\n  ParsableByteArray frame = new ParsableByteArray(synchronizedHeader.frameSize);\n  input.peekFully(frame.getData(), 0, synchronizedHeader.frameSize);\n  int xingBase =\n      (synchronizedHeader.version & 1) != 0\n          ? (synchronizedHeader.channels != 1 ? 36 : 21) \n          : (synchronizedHeader.channels != 1 ? 21 : 13); \n  int seekHeader = getSeekFrameHeader(frame, xingBase);\n  @Nullable Seeker seeker;\n  if (seekHeader == SEEK_HEADER_XING || seekHeader == SEEK_HEADER_INFO) {\n    seeker = XingSeeker.create(input.getLength(), input.getPosition(), synchronizedHeader, frame);\n    if (seeker != null && !gaplessInfoHolder.hasGaplessInfo()) {\n        \n      input.resetPeekPosition();\n      input.advancePeekPosition(xingBase + 141);\n      input.peekFully(scratch.getData(), 0, 3);\n      scratch.setPosition(0);\n      gaplessInfoHolder.setFromXingHeaderValue(scratch.readUnsignedInt24());\n    }\n    input.skipFully(synchronizedHeader.frameSize);\n    if (seeker != null && !seeker.isSeekable() && seekHeader == SEEK_HEADER_INFO) {\n        \n      return getConstantBitrateSeeker(input,  false);\n    }\n  } else if (seekHeader == SEEK_HEADER_VBRI) {\n    seeker = VbriSeeker.create(input.getLength(), input.getPosition(), synchronizedHeader, frame);\n    input.skipFully(synchronizedHeader.frameSize);\n  } else { \n      \n    seeker = null;\n    input.resetPeekPosition();\n  }\n  return seeker;\n}",
        "summary_tokens": [
            "consumes",
            "the",
            "next",
            "frame",
            "from",
            "the",
            "input",
            "if",
            "it",
            "contains",
            "vbri",
            "or",
            "xing",
            "seeking",
            "metadata",
            "returning",
            "a",
            "seeker",
            "if",
            "the",
            "metadata",
            "was",
            "present",
            "and",
            "valid",
            "or",
            "null",
            "otherwise"
        ]
    },
    {
        "id": 1974,
        "code": "private Seeker getConstantBitrateSeeker(ExtractorInput input, boolean allowSeeksIfLengthUnknown)\n    throws IOException {\n  input.peekFully(scratch.getData(), 0, 4);\n  scratch.setPosition(0);\n  synchronizedHeader.setForHeaderData(scratch.readInt());\n  return new ConstantBitrateSeeker(\n      input.getLength(), input.getPosition(), synchronizedHeader, allowSeeksIfLengthUnknown);\n}",
        "summary_tokens": [
            "peeks",
            "the",
            "next",
            "frame",
            "and",
            "returns",
            "a",
            "constant",
            "bitrate",
            "seeker",
            "based",
            "on",
            "its",
            "bitrate"
        ]
    },
    {
        "id": 1975,
        "code": "private static boolean headersMatch(int headerA, long headerB) {\n  return (headerA & MPEG_AUDIO_HEADER_MASK) == (headerB & MPEG_AUDIO_HEADER_MASK);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "headers",
            "match",
            "in",
            "those",
            "bits",
            "masked",
            "by",
            "mpeg",
            "audio",
            "header",
            "mask"
        ]
    },
    {
        "id": 1976,
        "code": "private static int getSeekFrameHeader(ParsableByteArray frame, int xingBase) {\n  if (frame.limit() >= xingBase + 4) {\n    frame.setPosition(xingBase);\n    int headerData = frame.readInt();\n    if (headerData == SEEK_HEADER_XING || headerData == SEEK_HEADER_INFO) {\n      return headerData;\n    }\n  }\n  if (frame.limit() >= 40) {\n    frame.setPosition(36); \n    if (frame.readInt() == SEEK_HEADER_VBRI) {\n      return SEEK_HEADER_VBRI;\n    }\n  }\n  return SEEK_HEADER_UNSET;\n}",
        "summary_tokens": [
            "returns",
            "seek",
            "header",
            "xing",
            "seek",
            "header",
            "info",
            "or",
            "seek",
            "header",
            "vbri",
            "if",
            "the",
            "provided",
            "frame",
            "may",
            "have",
            "seeking",
            "metadata",
            "or",
            "seek",
            "header",
            "unset",
            "otherwise"
        ]
    },
    {
        "id": 1977,
        "code": "public static VbriSeeker create(\n    long inputLength,\n    long position,\n    MpegAudioUtil.Header mpegAudioHeader,\n    ParsableByteArray frame) {\n  frame.skipBytes(10);\n  int numFrames = frame.readInt();\n  if (numFrames <= 0) {\n    return null;\n  }\n  int sampleRate = mpegAudioHeader.sampleRate;\n  long durationUs =\n      Util.scaleLargeTimestamp(\n          numFrames, C.MICROS_PER_SECOND * (sampleRate >= 32000 ? 1152 : 576), sampleRate);\n  int entryCount = frame.readUnsignedShort();\n  int scale = frame.readUnsignedShort();\n  int entrySize = frame.readUnsignedShort();\n  frame.skipBytes(2);\n\n  long minPosition = position + mpegAudioHeader.frameSize;\n    \n  long[] timesUs = new long[entryCount];\n  long[] positions = new long[entryCount];\n  for (int index = 0; index < entryCount; index++) {\n    timesUs[index] = (index * durationUs) / entryCount;\n      \n      \n    positions[index] = max(position, minPosition);\n    int segmentSize;\n    switch (entrySize) {\n      case 1:\n        segmentSize = frame.readUnsignedByte();\n        break;\n      case 2:\n        segmentSize = frame.readUnsignedShort();\n        break;\n      case 3:\n        segmentSize = frame.readUnsignedInt24();\n        break;\n      case 4:\n        segmentSize = frame.readUnsignedIntToInt();\n        break;\n      default:\n        return null;\n    }\n    position += segmentSize * ((long) scale);\n  }\n  if (inputLength != C.LENGTH_UNSET && inputLength != position) {\n    Log.w(TAG, \"VBRI data size mismatch: \" + inputLength + \", \" + position);\n  }\n  return new VbriSeeker(timesUs, positions, durationUs,  position);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "vbri",
            "seeker",
            "for",
            "seeking",
            "in",
            "the",
            "stream",
            "if",
            "required",
            "information",
            "is",
            "present"
        ]
    },
    {
        "id": 1978,
        "code": "public static XingSeeker create(\n    long inputLength,\n    long position,\n    MpegAudioUtil.Header mpegAudioHeader,\n    ParsableByteArray frame) {\n  int samplesPerFrame = mpegAudioHeader.samplesPerFrame;\n  int sampleRate = mpegAudioHeader.sampleRate;\n\n  int flags = frame.readInt();\n  int frameCount;\n  if ((flags & 0x01) != 0x01 || (frameCount = frame.readUnsignedIntToInt()) == 0) {\n      \n    return null;\n  }\n  long durationUs =\n      Util.scaleLargeTimestamp(frameCount, samplesPerFrame * C.MICROS_PER_SECOND, sampleRate);\n  if ((flags & 0x06) != 0x06) {\n      \n    return new XingSeeker(position, mpegAudioHeader.frameSize, durationUs);\n  }\n\n  long dataSize = frame.readUnsignedInt();\n  long[] tableOfContents = new long[100];\n  for (int i = 0; i < 100; i++) {\n    tableOfContents[i] = frame.readUnsignedByte();\n  }\n\n    \n    \n    \n\n  if (inputLength != C.LENGTH_UNSET && inputLength != position + dataSize) {\n    Log.w(TAG, \"XING data size mismatch: \" + inputLength + \", \" + (position + dataSize));\n  }\n  return new XingSeeker(\n      position, mpegAudioHeader.frameSize, durationUs, dataSize, tableOfContents);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "xing",
            "seeker",
            "for",
            "seeking",
            "in",
            "the",
            "stream",
            "if",
            "required",
            "information",
            "is",
            "present"
        ]
    },
    {
        "id": 1979,
        "code": "private long getTimeUsForTableIndex(int tableIndex) {\n  return (durationUs * tableIndex) / 100;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "time",
            "in",
            "microseconds",
            "for",
            "a",
            "given",
            "table",
            "index"
        ]
    },
    {
        "id": 1980,
        "code": "public static int parseFullAtomVersion(int fullAtomInt) {\n  return 0x000000FF & (fullAtomInt >> 24);\n}",
        "summary_tokens": [
            "parses",
            "the",
            "version",
            "number",
            "out",
            "of",
            "the",
            "additional",
            "integer",
            "component",
            "of",
            "a",
            "full",
            "atom"
        ]
    },
    {
        "id": 1981,
        "code": "public static int parseFullAtomFlags(int fullAtomInt) {\n  return 0x00FFFFFF & fullAtomInt;\n}",
        "summary_tokens": [
            "parses",
            "the",
            "atom",
            "flags",
            "out",
            "of",
            "the",
            "additional",
            "integer",
            "component",
            "of",
            "a",
            "full",
            "atom"
        ]
    },
    {
        "id": 1982,
        "code": "public static String getAtomTypeString(int type) {\n  return \"\"\n      + (char) ((type >> 24) & 0xFF)\n      + (char) ((type >> 16) & 0xFF)\n      + (char) ((type >> 8) & 0xFF)\n      + (char) (type & 0xFF);\n}",
        "summary_tokens": [
            "converts",
            "a",
            "numeric",
            "atom",
            "type",
            "to",
            "the",
            "corresponding",
            "four",
            "character",
            "string"
        ]
    },
    {
        "id": 1983,
        "code": "public static Results rechunk(\n    int fixedSampleSize,\n    long[] chunkOffsets,\n    int[] chunkSampleCounts,\n    long timestampDeltaInTimeUnits) {\n  int maxSampleCount = MAX_SAMPLE_SIZE / fixedSampleSize;\n\n    \n  int rechunkedSampleCount = 0;\n  for (int chunkSampleCount : chunkSampleCounts) {\n    rechunkedSampleCount += Util.ceilDivide(chunkSampleCount, maxSampleCount);\n  }\n\n  long[] offsets = new long[rechunkedSampleCount];\n  int[] sizes = new int[rechunkedSampleCount];\n  int maximumSize = 0;\n  long[] timestamps = new long[rechunkedSampleCount];\n  int[] flags = new int[rechunkedSampleCount];\n\n  int originalSampleIndex = 0;\n  int newSampleIndex = 0;\n  for (int chunkIndex = 0; chunkIndex < chunkSampleCounts.length; chunkIndex++) {\n    int chunkSamplesRemaining = chunkSampleCounts[chunkIndex];\n    long sampleOffset = chunkOffsets[chunkIndex];\n\n    while (chunkSamplesRemaining > 0) {\n      int bufferSampleCount = min(maxSampleCount, chunkSamplesRemaining);\n\n      offsets[newSampleIndex] = sampleOffset;\n      sizes[newSampleIndex] = fixedSampleSize * bufferSampleCount;\n      maximumSize = max(maximumSize, sizes[newSampleIndex]);\n      timestamps[newSampleIndex] = (timestampDeltaInTimeUnits * originalSampleIndex);\n      flags[newSampleIndex] = C.BUFFER_FLAG_KEY_FRAME;\n\n      sampleOffset += sizes[newSampleIndex];\n      originalSampleIndex += bufferSampleCount;\n\n      chunkSamplesRemaining -= bufferSampleCount;\n      newSampleIndex++;\n    }\n  }\n  long duration = timestampDeltaInTimeUnits * originalSampleIndex;\n\n  return new Results(offsets, sizes, maximumSize, timestamps, flags, duration);\n}",
        "summary_tokens": [
            "rechunk",
            "the",
            "given",
            "fixed",
            "sample",
            "size",
            "input",
            "to",
            "produce",
            "a",
            "new",
            "sequence",
            "of",
            "samples"
        ]
    },
    {
        "id": 1984,
        "code": "private void onEmsgLeafAtomRead(ParsableByteArray atom) {\n  if (emsgTrackOutputs.length == 0) {\n    return;\n  }\n  atom.setPosition(Atom.HEADER_SIZE);\n  int fullAtom = atom.readInt();\n  int version = Atom.parseFullAtomVersion(fullAtom);\n  String schemeIdUri;\n  String value;\n  long timescale;\n  long presentationTimeDeltaUs = C.TIME_UNSET; \n  long sampleTimeUs = C.TIME_UNSET;\n  long durationMs;\n  long id;\n  switch (version) {\n    case 0:\n      schemeIdUri = checkNotNull(atom.readNullTerminatedString());\n      value = checkNotNull(atom.readNullTerminatedString());\n      timescale = atom.readUnsignedInt();\n      presentationTimeDeltaUs =\n          Util.scaleLargeTimestamp(atom.readUnsignedInt(), C.MICROS_PER_SECOND, timescale);\n      if (segmentIndexEarliestPresentationTimeUs != C.TIME_UNSET) {\n        sampleTimeUs = segmentIndexEarliestPresentationTimeUs + presentationTimeDeltaUs;\n      }\n      durationMs =\n          Util.scaleLargeTimestamp(atom.readUnsignedInt(), C.MILLIS_PER_SECOND, timescale);\n      id = atom.readUnsignedInt();\n      break;\n    case 1:\n      timescale = atom.readUnsignedInt();\n      sampleTimeUs =\n          Util.scaleLargeTimestamp(atom.readUnsignedLongToLong(), C.MICROS_PER_SECOND, timescale);\n      durationMs =\n          Util.scaleLargeTimestamp(atom.readUnsignedInt(), C.MILLIS_PER_SECOND, timescale);\n      id = atom.readUnsignedInt();\n      schemeIdUri = checkNotNull(atom.readNullTerminatedString());\n      value = checkNotNull(atom.readNullTerminatedString());\n      break;\n    default:\n      Log.w(TAG, \"Skipping unsupported emsg version: \" + version);\n      return;\n  }\n\n  byte[] messageData = new byte[atom.bytesLeft()];\n  atom.readBytes(messageData,  0, atom.bytesLeft());\n  EventMessage eventMessage = new EventMessage(schemeIdUri, value, durationMs, id, messageData);\n  ParsableByteArray encodedEventMessage =\n      new ParsableByteArray(eventMessageEncoder.encode(eventMessage));\n  int sampleSize = encodedEventMessage.bytesLeft();\n\n    \n  for (TrackOutput emsgTrackOutput : emsgTrackOutputs) {\n    encodedEventMessage.setPosition(0);\n    emsgTrackOutput.sampleData(encodedEventMessage, sampleSize);\n  }\n\n    \n  if (sampleTimeUs == C.TIME_UNSET) {\n      \n      \n    pendingMetadataSampleInfos.addLast(\n        new MetadataSampleInfo(\n            presentationTimeDeltaUs,  true, sampleSize));\n    pendingMetadataSampleBytes += sampleSize;\n  } else if (!pendingMetadataSampleInfos.isEmpty()) {\n      \n      \n      \n    pendingMetadataSampleInfos.addLast(\n        new MetadataSampleInfo(sampleTimeUs,  false, sampleSize));\n    pendingMetadataSampleBytes += sampleSize;\n  } else {\n      \n    if (timestampAdjuster != null) {\n      sampleTimeUs = timestampAdjuster.adjustSampleTimestamp(sampleTimeUs);\n    }\n    for (TrackOutput emsgTrackOutput : emsgTrackOutputs) {\n      emsgTrackOutput.sampleMetadata(\n          sampleTimeUs, C.BUFFER_FLAG_KEY_FRAME, sampleSize,  0, null);\n    }\n  }\n}",
        "summary_tokens": [
            "handles",
            "an",
            "emsg",
            "atom",
            "defined",
            "in",
            "0",
            "0"
        ]
    },
    {
        "id": 1985,
        "code": "private static Pair<Integer, DefaultSampleValues> parseTrex(ParsableByteArray trex) {\n  trex.setPosition(Atom.FULL_HEADER_SIZE);\n  int trackId = trex.readInt();\n  int defaultSampleDescriptionIndex = trex.readInt() - 1;\n  int defaultSampleDuration = trex.readInt();\n  int defaultSampleSize = trex.readInt();\n  int defaultSampleFlags = trex.readInt();\n\n  return Pair.create(\n      trackId,\n      new DefaultSampleValues(\n          defaultSampleDescriptionIndex,\n          defaultSampleDuration,\n          defaultSampleSize,\n          defaultSampleFlags));\n}",
        "summary_tokens": [
            "parses",
            "a",
            "trex",
            "atom",
            "defined",
            "in",
            "0",
            "0"
        ]
    },
    {
        "id": 1986,
        "code": "private static long parseMehd(ParsableByteArray mehd) {\n  mehd.setPosition(Atom.HEADER_SIZE);\n  int fullAtom = mehd.readInt();\n  int version = Atom.parseFullAtomVersion(fullAtom);\n  return version == 0 ? mehd.readUnsignedInt() : mehd.readUnsignedLongToLong();\n}",
        "summary_tokens": [
            "parses",
            "an",
            "mehd",
            "atom",
            "defined",
            "in",
            "0",
            "0"
        ]
    },
    {
        "id": 1987,
        "code": "private static void parseTraf(\n    ContainerAtom traf,\n    SparseArray<TrackBundle> trackBundles,\n    boolean haveSideloadedTrack,\n    @Flags int flags,\n    byte[] extendedTypeScratch)\n    throws ParserException {\n  LeafAtom tfhd = checkNotNull(traf.getLeafAtomOfType(Atom.TYPE_tfhd));\n  @Nullable TrackBundle trackBundle = parseTfhd(tfhd.data, trackBundles, haveSideloadedTrack);\n  if (trackBundle == null) {\n    return;\n  }\n\n  TrackFragment fragment = trackBundle.fragment;\n  long fragmentDecodeTime = fragment.nextFragmentDecodeTime;\n  boolean fragmentDecodeTimeIncludesMoov = fragment.nextFragmentDecodeTimeIncludesMoov;\n  trackBundle.resetFragmentInfo();\n  trackBundle.currentlyInFragment = true;\n  @Nullable LeafAtom tfdtAtom = traf.getLeafAtomOfType(Atom.TYPE_tfdt);\n  if (tfdtAtom != null && (flags & FLAG_WORKAROUND_IGNORE_TFDT_BOX) == 0) {\n    fragment.nextFragmentDecodeTime = parseTfdt(tfdtAtom.data);\n    fragment.nextFragmentDecodeTimeIncludesMoov = true;\n  } else {\n    fragment.nextFragmentDecodeTime = fragmentDecodeTime;\n    fragment.nextFragmentDecodeTimeIncludesMoov = fragmentDecodeTimeIncludesMoov;\n  }\n\n  parseTruns(traf, trackBundle, flags);\n\n  @Nullable\n  TrackEncryptionBox encryptionBox =\n      trackBundle.moovSampleTable.track.getSampleDescriptionEncryptionBox(\n          checkNotNull(fragment.header).sampleDescriptionIndex);\n\n  @Nullable LeafAtom saiz = traf.getLeafAtomOfType(Atom.TYPE_saiz);\n  if (saiz != null) {\n    parseSaiz(checkNotNull(encryptionBox), saiz.data, fragment);\n  }\n\n  @Nullable LeafAtom saio = traf.getLeafAtomOfType(Atom.TYPE_saio);\n  if (saio != null) {\n    parseSaio(saio.data, fragment);\n  }\n\n  @Nullable LeafAtom senc = traf.getLeafAtomOfType(Atom.TYPE_senc);\n  if (senc != null) {\n    parseSenc(senc.data, fragment);\n  }\n\n  parseSampleGroups(traf, encryptionBox != null ? encryptionBox.schemeType : null, fragment);\n\n  int leafChildrenSize = traf.leafChildren.size();\n  for (int i = 0; i < leafChildrenSize; i++) {\n    LeafAtom atom = traf.leafChildren.get(i);\n    if (atom.type == Atom.TYPE_uuid) {\n      parseUuid(atom.data, fragment, extendedTypeScratch);\n    }\n  }\n}",
        "summary_tokens": [
            "parses",
            "a",
            "traf",
            "atom",
            "defined",
            "in",
            "0",
            "0"
        ]
    },
    {
        "id": 1988,
        "code": "private static void parseSaio(ParsableByteArray saio, TrackFragment out) throws ParserException {\n  saio.setPosition(Atom.HEADER_SIZE);\n  int fullAtom = saio.readInt();\n  int flags = Atom.parseFullAtomFlags(fullAtom);\n  if ((flags & 0x01) == 1) {\n    saio.skipBytes(8);\n  }\n\n  int entryCount = saio.readUnsignedIntToInt();\n  if (entryCount != 1) {\n      \n    throw ParserException.createForMalformedContainer(\n        \"Unexpected saio entry count: \" + entryCount,  null);\n  }\n\n  int version = Atom.parseFullAtomVersion(fullAtom);\n  out.auxiliaryDataPosition +=\n      version == 0 ? saio.readUnsignedInt() : saio.readUnsignedLongToLong();\n}",
        "summary_tokens": [
            "parses",
            "a",
            "saio",
            "atom",
            "defined",
            "in",
            "0",
            "0"
        ]
    },
    {
        "id": 1989,
        "code": "private static TrackBundle parseTfhd(\n    ParsableByteArray tfhd, SparseArray<TrackBundle> trackBundles, boolean haveSideloadedTrack) {\n  tfhd.setPosition(Atom.HEADER_SIZE);\n  int fullAtom = tfhd.readInt();\n  int atomFlags = Atom.parseFullAtomFlags(fullAtom);\n  int trackId = tfhd.readInt();\n  @Nullable\n  TrackBundle trackBundle =\n      haveSideloadedTrack ? trackBundles.valueAt(0) : trackBundles.get(trackId);\n  if (trackBundle == null) {\n    return null;\n  }\n  if ((atomFlags & 0x01 ) != 0) {\n    long baseDataPosition = tfhd.readUnsignedLongToLong();\n    trackBundle.fragment.dataPosition = baseDataPosition;\n    trackBundle.fragment.auxiliaryDataPosition = baseDataPosition;\n  }\n\n  DefaultSampleValues defaultSampleValues = trackBundle.defaultSampleValues;\n  int defaultSampleDescriptionIndex =\n      ((atomFlags & 0x02 ) != 0)\n          ? tfhd.readInt() - 1\n          : defaultSampleValues.sampleDescriptionIndex;\n  int defaultSampleDuration =\n      ((atomFlags & 0x08 ) != 0)\n          ? tfhd.readInt()\n          : defaultSampleValues.duration;\n  int defaultSampleSize =\n      ((atomFlags & 0x10 ) != 0)\n          ? tfhd.readInt()\n          : defaultSampleValues.size;\n  int defaultSampleFlags =\n      ((atomFlags & 0x20 ) != 0)\n          ? tfhd.readInt()\n          : defaultSampleValues.flags;\n  trackBundle.fragment.header =\n      new DefaultSampleValues(\n          defaultSampleDescriptionIndex,\n          defaultSampleDuration,\n          defaultSampleSize,\n          defaultSampleFlags);\n  return trackBundle;\n}",
        "summary_tokens": [
            "parses",
            "a",
            "tfhd",
            "atom",
            "defined",
            "in",
            "0",
            "0",
            "updates",
            "the",
            "corresponding",
            "track",
            "fragment",
            "and",
            "returns",
            "the",
            "track",
            "bundle",
            "of",
            "the",
            "corresponding",
            "track"
        ]
    },
    {
        "id": 1990,
        "code": "private static long parseTfdt(ParsableByteArray tfdt) {\n  tfdt.setPosition(Atom.HEADER_SIZE);\n  int fullAtom = tfdt.readInt();\n  int version = Atom.parseFullAtomVersion(fullAtom);\n  return version == 1 ? tfdt.readUnsignedLongToLong() : tfdt.readUnsignedInt();\n}",
        "summary_tokens": [
            "parses",
            "a",
            "tfdt",
            "atom",
            "defined",
            "in",
            "0",
            "0"
        ]
    },
    {
        "id": 1991,
        "code": "private static int parseTrun(\n    TrackBundle trackBundle,\n    int index,\n    @Flags int flags,\n    ParsableByteArray trun,\n    int trackRunStart)\n    throws ParserException {\n  trun.setPosition(Atom.HEADER_SIZE);\n  int fullAtom = trun.readInt();\n  int atomFlags = Atom.parseFullAtomFlags(fullAtom);\n\n  Track track = trackBundle.moovSampleTable.track;\n  TrackFragment fragment = trackBundle.fragment;\n  DefaultSampleValues defaultSampleValues = castNonNull(fragment.header);\n\n  fragment.trunLength[index] = trun.readUnsignedIntToInt();\n  fragment.trunDataPosition[index] = fragment.dataPosition;\n  if ((atomFlags & 0x01 ) != 0) {\n    fragment.trunDataPosition[index] += trun.readInt();\n  }\n\n  boolean firstSampleFlagsPresent = (atomFlags & 0x04 ) != 0;\n  int firstSampleFlags = defaultSampleValues.flags;\n  if (firstSampleFlagsPresent) {\n    firstSampleFlags = trun.readInt();\n  }\n\n  boolean sampleDurationsPresent = (atomFlags & 0x100 ) != 0;\n  boolean sampleSizesPresent = (atomFlags & 0x200 ) != 0;\n  boolean sampleFlagsPresent = (atomFlags & 0x400 ) != 0;\n  boolean sampleCompositionTimeOffsetsPresent =\n      (atomFlags & 0x800 ) != 0;\n\n    \n    \n  long edtsOffset = 0;\n\n    \n    \n  if (track.editListDurations != null\n      && track.editListDurations.length == 1\n      && track.editListDurations[0] == 0) {\n    edtsOffset = castNonNull(track.editListMediaTimes)[0];\n  }\n\n  int[] sampleSizeTable = fragment.sampleSizeTable;\n  long[] samplePresentationTimesUs = fragment.samplePresentationTimesUs;\n  boolean[] sampleIsSyncFrameTable = fragment.sampleIsSyncFrameTable;\n\n  boolean workaroundEveryVideoFrameIsSyncFrame =\n      track.type == C.TRACK_TYPE_VIDEO\n          && (flags & FLAG_WORKAROUND_EVERY_VIDEO_FRAME_IS_SYNC_FRAME) != 0;\n\n  int trackRunEnd = trackRunStart + fragment.trunLength[index];\n  long timescale = track.timescale;\n  long cumulativeTime = fragment.nextFragmentDecodeTime;\n  for (int i = trackRunStart; i < trackRunEnd; i++) {\n      \n    int sampleDuration =\n        checkNonNegative(sampleDurationsPresent ? trun.readInt() : defaultSampleValues.duration);\n    int sampleSize =\n        checkNonNegative(sampleSizesPresent ? trun.readInt() : defaultSampleValues.size);\n    int sampleFlags =\n        sampleFlagsPresent\n            ? trun.readInt()\n            : (i == 0 && firstSampleFlagsPresent) ? firstSampleFlags : defaultSampleValues.flags;\n    int sampleCompositionTimeOffset = 0;\n    if (sampleCompositionTimeOffsetsPresent) {\n        \n        \n        \n        \n        \n      sampleCompositionTimeOffset = trun.readInt();\n    }\n    long samplePresentationTime = cumulativeTime + sampleCompositionTimeOffset - edtsOffset;\n    samplePresentationTimesUs[i] =\n        Util.scaleLargeTimestamp(samplePresentationTime, C.MICROS_PER_SECOND, timescale);\n    if (!fragment.nextFragmentDecodeTimeIncludesMoov) {\n      samplePresentationTimesUs[i] += trackBundle.moovSampleTable.durationUs;\n    }\n    sampleSizeTable[i] = sampleSize;\n    sampleIsSyncFrameTable[i] =\n        ((sampleFlags >> 16) & 0x1) == 0 && (!workaroundEveryVideoFrameIsSyncFrame || i == 0);\n    cumulativeTime += sampleDuration;\n  }\n  fragment.nextFragmentDecodeTime = cumulativeTime;\n  return trackRunEnd;\n}",
        "summary_tokens": [
            "parses",
            "a",
            "trun",
            "atom",
            "defined",
            "in",
            "0",
            "0"
        ]
    },
    {
        "id": 1992,
        "code": "private static Pair<Long, ChunkIndex> parseSidx(ParsableByteArray atom, long inputPosition)\n    throws ParserException {\n  atom.setPosition(Atom.HEADER_SIZE);\n  int fullAtom = atom.readInt();\n  int version = Atom.parseFullAtomVersion(fullAtom);\n\n  atom.skipBytes(4);\n  long timescale = atom.readUnsignedInt();\n  long earliestPresentationTime;\n  long offset = inputPosition;\n  if (version == 0) {\n    earliestPresentationTime = atom.readUnsignedInt();\n    offset += atom.readUnsignedInt();\n  } else {\n    earliestPresentationTime = atom.readUnsignedLongToLong();\n    offset += atom.readUnsignedLongToLong();\n  }\n  long earliestPresentationTimeUs =\n      Util.scaleLargeTimestamp(earliestPresentationTime, C.MICROS_PER_SECOND, timescale);\n\n  atom.skipBytes(2);\n\n  int referenceCount = atom.readUnsignedShort();\n  int[] sizes = new int[referenceCount];\n  long[] offsets = new long[referenceCount];\n  long[] durationsUs = new long[referenceCount];\n  long[] timesUs = new long[referenceCount];\n\n  long time = earliestPresentationTime;\n  long timeUs = earliestPresentationTimeUs;\n  for (int i = 0; i < referenceCount; i++) {\n    int firstInt = atom.readInt();\n\n    int type = 0x80000000 & firstInt;\n    if (type != 0) {\n      throw ParserException.createForMalformedContainer(\n          \"Unhandled indirect reference\",  null);\n    }\n    long referenceDuration = atom.readUnsignedInt();\n\n    sizes[i] = 0x7FFFFFFF & firstInt;\n    offsets[i] = offset;\n\n      \n      \n    timesUs[i] = timeUs;\n    time += referenceDuration;\n    timeUs = Util.scaleLargeTimestamp(time, C.MICROS_PER_SECOND, timescale);\n    durationsUs[i] = timeUs - timesUs[i];\n\n    atom.skipBytes(4);\n    offset += sizes[i];\n  }\n\n  return Pair.create(\n      earliestPresentationTimeUs, new ChunkIndex(sizes, offsets, durationsUs, timesUs));\n}",
        "summary_tokens": [
            "parses",
            "a",
            "sidx",
            "atom",
            "defined",
            "in",
            "0",
            "0"
        ]
    },
    {
        "id": 1993,
        "code": "private boolean readSample(ExtractorInput input) throws IOException {\n  @Nullable TrackBundle trackBundle = currentTrackBundle;\n  if (trackBundle == null) {\n    trackBundle = getNextTrackBundle(trackBundles);\n    if (trackBundle == null) {\n        \n        \n      int bytesToSkip = (int) (endOfMdatPosition - input.getPosition());\n      if (bytesToSkip < 0) {\n        throw ParserException.createForMalformedContainer(\n            \"Offset to end of mdat was negative.\",  null);\n      }\n      input.skipFully(bytesToSkip);\n      enterReadingAtomHeaderState();\n      return false;\n    }\n\n    long nextDataPosition = trackBundle.getCurrentSampleOffset();\n      \n    int bytesToSkip = (int) (nextDataPosition - input.getPosition());\n    if (bytesToSkip < 0) {\n        \n      Log.w(TAG, \"Ignoring negative offset to sample data.\");\n      bytesToSkip = 0;\n    }\n    input.skipFully(bytesToSkip);\n    currentTrackBundle = trackBundle;\n  }\n  if (parserState == STATE_READING_SAMPLE_START) {\n    sampleSize = trackBundle.getCurrentSampleSize();\n\n    if (trackBundle.currentSampleIndex < trackBundle.firstSampleToOutputIndex) {\n      input.skipFully(sampleSize);\n      trackBundle.skipSampleEncryptionData();\n      if (!trackBundle.next()) {\n        currentTrackBundle = null;\n      }\n      parserState = STATE_READING_SAMPLE_START;\n      return true;\n    }\n\n    if (trackBundle.moovSampleTable.track.sampleTransformation\n        == Track.TRANSFORMATION_CEA608_CDAT) {\n      sampleSize -= Atom.HEADER_SIZE;\n      input.skipFully(Atom.HEADER_SIZE);\n    }\n\n    if (MimeTypes.AUDIO_AC4.equals(trackBundle.moovSampleTable.track.format.sampleMimeType)) {\n        \n      sampleBytesWritten =\n          trackBundle.outputSampleEncryptionData(sampleSize, Ac4Util.SAMPLE_HEADER_SIZE);\n      Ac4Util.getAc4SampleHeader(sampleSize, scratch);\n      trackBundle.output.sampleData(scratch, Ac4Util.SAMPLE_HEADER_SIZE);\n      sampleBytesWritten += Ac4Util.SAMPLE_HEADER_SIZE;\n    } else {\n      sampleBytesWritten =\n          trackBundle.outputSampleEncryptionData(sampleSize,  0);\n    }\n    sampleSize += sampleBytesWritten;\n    parserState = STATE_READING_SAMPLE_CONTINUE;\n    sampleCurrentNalBytesRemaining = 0;\n  }\n\n  Track track = trackBundle.moovSampleTable.track;\n  TrackOutput output = trackBundle.output;\n  long sampleTimeUs = trackBundle.getCurrentSamplePresentationTimeUs();\n  if (timestampAdjuster != null) {\n    sampleTimeUs = timestampAdjuster.adjustSampleTimestamp(sampleTimeUs);\n  }\n  if (track.nalUnitLengthFieldLength != 0) {\n      \n      \n    byte[] nalPrefixData = nalPrefix.getData();\n    nalPrefixData[0] = 0;\n    nalPrefixData[1] = 0;\n    nalPrefixData[2] = 0;\n    int nalUnitPrefixLength = track.nalUnitLengthFieldLength + 1;\n    int nalUnitLengthFieldLengthDiff = 4 - track.nalUnitLengthFieldLength;\n      \n      \n      \n    while (sampleBytesWritten < sampleSize) {\n      if (sampleCurrentNalBytesRemaining == 0) {\n          \n        input.readFully(nalPrefixData, nalUnitLengthFieldLengthDiff, nalUnitPrefixLength);\n        nalPrefix.setPosition(0);\n        int nalLengthInt = nalPrefix.readInt();\n        if (nalLengthInt < 1) {\n          throw ParserException.createForMalformedContainer(\n              \"Invalid NAL length\",  null);\n        }\n        sampleCurrentNalBytesRemaining = nalLengthInt - 1;\n          \n        nalStartCode.setPosition(0);\n        output.sampleData(nalStartCode, 4);\n          \n        output.sampleData(nalPrefix, 1);\n        processSeiNalUnitPayload =\n            ceaTrackOutputs.length > 0\n                && NalUnitUtil.isNalUnitSei(track.format.sampleMimeType, nalPrefixData[4]);\n        sampleBytesWritten += 5;\n        sampleSize += nalUnitLengthFieldLengthDiff;\n      } else {\n        int writtenBytes;\n        if (processSeiNalUnitPayload) {\n            \n          nalBuffer.reset(sampleCurrentNalBytesRemaining);\n          input.readFully(nalBuffer.getData(), 0, sampleCurrentNalBytesRemaining);\n          output.sampleData(nalBuffer, sampleCurrentNalBytesRemaining);\n          writtenBytes = sampleCurrentNalBytesRemaining;\n            \n          int unescapedLength =\n              NalUnitUtil.unescapeStream(nalBuffer.getData(), nalBuffer.limit());\n            \n          nalBuffer.setPosition(MimeTypes.VIDEO_H265.equals(track.format.sampleMimeType) ? 1 : 0);\n          nalBuffer.setLimit(unescapedLength);\n          CeaUtil.consume(sampleTimeUs, nalBuffer, ceaTrackOutputs);\n        } else {\n            \n          writtenBytes = output.sampleData(input, sampleCurrentNalBytesRemaining, false);\n        }\n        sampleBytesWritten += writtenBytes;\n        sampleCurrentNalBytesRemaining -= writtenBytes;\n      }\n    }\n  } else {\n    while (sampleBytesWritten < sampleSize) {\n      int writtenBytes = output.sampleData(input, sampleSize - sampleBytesWritten, false);\n      sampleBytesWritten += writtenBytes;\n    }\n  }\n\n  @C.BufferFlags int sampleFlags = trackBundle.getCurrentSampleFlags();\n\n    \n  @Nullable TrackOutput.CryptoData cryptoData = null;\n  @Nullable TrackEncryptionBox encryptionBox = trackBundle.getEncryptionBoxIfEncrypted();\n  if (encryptionBox != null) {\n    cryptoData = encryptionBox.cryptoData;\n  }\n\n  output.sampleMetadata(sampleTimeUs, sampleFlags, sampleSize, 0, cryptoData);\n\n    \n  outputPendingMetadataSamples(sampleTimeUs);\n  if (!trackBundle.next()) {\n    currentTrackBundle = null;\n  }\n  parserState = STATE_READING_SAMPLE_START;\n  return true;\n}",
        "summary_tokens": [
            "attempts",
            "to",
            "read",
            "the",
            "next",
            "sample",
            "in",
            "the",
            "current",
            "mdat",
            "atom"
        ]
    },
    {
        "id": 1994,
        "code": "private void outputPendingMetadataSamples(long sampleTimeUs) {\n  while (!pendingMetadataSampleInfos.isEmpty()) {\n    MetadataSampleInfo metadataSampleInfo = pendingMetadataSampleInfos.removeFirst();\n    pendingMetadataSampleBytes -= metadataSampleInfo.size;\n    long metadataSampleTimeUs = metadataSampleInfo.sampleTimeUs;\n    if (metadataSampleInfo.sampleTimeIsRelative) {\n        \n        \n      metadataSampleTimeUs += sampleTimeUs;\n    }\n    if (timestampAdjuster != null) {\n      metadataSampleTimeUs = timestampAdjuster.adjustSampleTimestamp(metadataSampleTimeUs);\n    }\n    for (TrackOutput emsgTrackOutput : emsgTrackOutputs) {\n      emsgTrackOutput.sampleMetadata(\n          metadataSampleTimeUs,\n          C.BUFFER_FLAG_KEY_FRAME,\n          metadataSampleInfo.size,\n          pendingMetadataSampleBytes,\n          null);\n    }\n  }\n}",
        "summary_tokens": [
            "called",
            "immediately",
            "after",
            "outputting",
            "a",
            "non",
            "metadata",
            "sample",
            "to",
            "output",
            "any",
            "pending",
            "metadata",
            "samples"
        ]
    },
    {
        "id": 1995,
        "code": "private static TrackBundle getNextTrackBundle(SparseArray<TrackBundle> trackBundles) {\n  @Nullable TrackBundle nextTrackBundle = null;\n  long nextSampleOffset = Long.MAX_VALUE;\n\n  int trackBundlesSize = trackBundles.size();\n  for (int i = 0; i < trackBundlesSize; i++) {\n    TrackBundle trackBundle = trackBundles.valueAt(i);\n    if ((!trackBundle.currentlyInFragment\n            && trackBundle.currentSampleIndex == trackBundle.moovSampleTable.sampleCount)\n        || (trackBundle.currentlyInFragment\n            && trackBundle.currentTrackRunIndex == trackBundle.fragment.trunCount)) {\n        \n    } else {\n      long sampleOffset = trackBundle.getCurrentSampleOffset();\n      if (sampleOffset < nextSampleOffset) {\n        nextTrackBundle = trackBundle;\n        nextSampleOffset = sampleOffset;\n      }\n    }\n  }\n  return nextTrackBundle;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "track",
            "bundle",
            "whose",
            "sample",
            "has",
            "the",
            "earliest",
            "file",
            "position",
            "out",
            "of",
            "those",
            "yet",
            "to",
            "be",
            "consumed",
            "or",
            "null",
            "if",
            "all",
            "have",
            "been",
            "consumed"
        ]
    },
    {
        "id": 1996,
        "code": "private static DrmInitData getDrmInitDataFromAtoms(List<Atom.LeafAtom> leafChildren) {\n  @Nullable ArrayList<SchemeData> schemeDatas = null;\n  int leafChildrenSize = leafChildren.size();\n  for (int i = 0; i < leafChildrenSize; i++) {\n    LeafAtom child = leafChildren.get(i);\n    if (child.type == Atom.TYPE_pssh) {\n      if (schemeDatas == null) {\n        schemeDatas = new ArrayList<>();\n      }\n      byte[] psshData = child.data.getData();\n      @Nullable UUID uuid = PsshAtomUtil.parseUuid(psshData);\n      if (uuid == null) {\n        Log.w(TAG, \"Skipped pssh atom (failed to extract uuid)\");\n      } else {\n        schemeDatas.add(new SchemeData(uuid, MimeTypes.VIDEO_MP4, psshData));\n      }\n    }\n  }\n  return schemeDatas == null ? null : new DrmInitData(schemeDatas);\n}",
        "summary_tokens": [
            "returns",
            "drm",
            "init",
            "data",
            "from",
            "leaf",
            "atoms"
        ]
    },
    {
        "id": 1997,
        "code": "private static boolean shouldParseLeafAtom(int atom) {\n  return atom == Atom.TYPE_hdlr\n      || atom == Atom.TYPE_mdhd\n      || atom == Atom.TYPE_mvhd\n      || atom == Atom.TYPE_sidx\n      || atom == Atom.TYPE_stsd\n      || atom == Atom.TYPE_stts\n      || atom == Atom.TYPE_ctts\n      || atom == Atom.TYPE_stsc\n      || atom == Atom.TYPE_stsz\n      || atom == Atom.TYPE_stz2\n      || atom == Atom.TYPE_stco\n      || atom == Atom.TYPE_co64\n      || atom == Atom.TYPE_stss\n      || atom == Atom.TYPE_tfdt\n      || atom == Atom.TYPE_tfhd\n      || atom == Atom.TYPE_tkhd\n      || atom == Atom.TYPE_trex\n      || atom == Atom.TYPE_trun\n      || atom == Atom.TYPE_pssh\n      || atom == Atom.TYPE_saiz\n      || atom == Atom.TYPE_saio\n      || atom == Atom.TYPE_senc\n      || atom == Atom.TYPE_uuid\n      || atom == Atom.TYPE_sbgp\n      || atom == Atom.TYPE_sgpd\n      || atom == Atom.TYPE_elst\n      || atom == Atom.TYPE_mehd\n      || atom == Atom.TYPE_emsg;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "extractor",
            "should",
            "decode",
            "a",
            "leaf",
            "atom",
            "with",
            "type",
            "atom"
        ]
    },
    {
        "id": 1998,
        "code": "private static boolean shouldParseContainerAtom(int atom) {\n  return atom == Atom.TYPE_moov\n      || atom == Atom.TYPE_trak\n      || atom == Atom.TYPE_mdia\n      || atom == Atom.TYPE_minf\n      || atom == Atom.TYPE_stbl\n      || atom == Atom.TYPE_moof\n      || atom == Atom.TYPE_traf\n      || atom == Atom.TYPE_mvex\n      || atom == Atom.TYPE_edts;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "extractor",
            "should",
            "decode",
            "a",
            "container",
            "atom",
            "with",
            "type",
            "atom"
        ]
    },
    {
        "id": 1999,
        "code": "public static Metadata.Entry parseIlstElement(ParsableByteArray ilst) {\n  int position = ilst.getPosition();\n  int endPosition = position + ilst.readInt();\n  int type = ilst.readInt();\n  int typeTopByte = (type >> 24) & 0xFF;\n  try {\n    if (typeTopByte == TYPE_TOP_BYTE_COPYRIGHT || typeTopByte == TYPE_TOP_BYTE_REPLACEMENT) {\n      int shortType = type & 0x00FFFFFF;\n      if (shortType == SHORT_TYPE_COMMENT) {\n        return parseCommentAttribute(type, ilst);\n      } else if (shortType == SHORT_TYPE_NAME_1 || shortType == SHORT_TYPE_NAME_2) {\n        return parseTextAttribute(type, \"TIT2\", ilst);\n      } else if (shortType == SHORT_TYPE_COMPOSER_1 || shortType == SHORT_TYPE_COMPOSER_2) {\n        return parseTextAttribute(type, \"TCOM\", ilst);\n      } else if (shortType == SHORT_TYPE_YEAR) {\n        return parseTextAttribute(type, \"TDRC\", ilst);\n      } else if (shortType == SHORT_TYPE_ARTIST) {\n        return parseTextAttribute(type, \"TPE1\", ilst);\n      } else if (shortType == SHORT_TYPE_ENCODER) {\n        return parseTextAttribute(type, \"TSSE\", ilst);\n      } else if (shortType == SHORT_TYPE_ALBUM) {\n        return parseTextAttribute(type, \"TALB\", ilst);\n      } else if (shortType == SHORT_TYPE_LYRICS) {\n        return parseTextAttribute(type, \"USLT\", ilst);\n      } else if (shortType == SHORT_TYPE_GENRE) {\n        return parseTextAttribute(type, \"TCON\", ilst);\n      } else if (shortType == TYPE_GROUPING) {\n        return parseTextAttribute(type, \"TIT1\", ilst);\n      }\n    } else if (type == TYPE_GENRE) {\n      return parseStandardGenreAttribute(ilst);\n    } else if (type == TYPE_DISK_NUMBER) {\n      return parseIndexAndCountAttribute(type, \"TPOS\", ilst);\n    } else if (type == TYPE_TRACK_NUMBER) {\n      return parseIndexAndCountAttribute(type, \"TRCK\", ilst);\n    } else if (type == TYPE_TEMPO) {\n      return parseUint8Attribute(type, \"TBPM\", ilst, true, false);\n    } else if (type == TYPE_COMPILATION) {\n      return parseUint8Attribute(type, \"TCMP\", ilst, true, true);\n    } else if (type == TYPE_COVER_ART) {\n      return parseCoverArt(ilst);\n    } else if (type == TYPE_ALBUM_ARTIST) {\n      return parseTextAttribute(type, \"TPE2\", ilst);\n    } else if (type == TYPE_SORT_TRACK_NAME) {\n      return parseTextAttribute(type, \"TSOT\", ilst);\n    } else if (type == TYPE_SORT_ALBUM) {\n      return parseTextAttribute(type, \"TSO2\", ilst);\n    } else if (type == TYPE_SORT_ARTIST) {\n      return parseTextAttribute(type, \"TSOA\", ilst);\n    } else if (type == TYPE_SORT_ALBUM_ARTIST) {\n      return parseTextAttribute(type, \"TSOP\", ilst);\n    } else if (type == TYPE_SORT_COMPOSER) {\n      return parseTextAttribute(type, \"TSOC\", ilst);\n    } else if (type == TYPE_RATING) {\n      return parseUint8Attribute(type, \"ITUNESADVISORY\", ilst, false, false);\n    } else if (type == TYPE_GAPLESS_ALBUM) {\n      return parseUint8Attribute(type, \"ITUNESGAPLESS\", ilst, false, true);\n    } else if (type == TYPE_TV_SORT_SHOW) {\n      return parseTextAttribute(type, \"TVSHOWSORT\", ilst);\n    } else if (type == TYPE_TV_SHOW) {\n      return parseTextAttribute(type, \"TVSHOW\", ilst);\n    } else if (type == TYPE_INTERNAL) {\n      return parseInternalAttribute(ilst, endPosition);\n    }\n    Log.d(TAG, \"Skipped unknown metadata entry: \" + Atom.getAtomTypeString(type));\n    return null;\n  } finally {\n    ilst.setPosition(endPosition);\n  }\n}",
        "summary_tokens": [
            "parses",
            "a",
            "single",
            "userdata",
            "ilst",
            "element",
            "from",
            "a",
            "parsable",
            "byte",
            "array"
        ]
    },
    {
        "id": 2000,
        "code": "public static MdtaMetadataEntry parseMdtaMetadataEntryFromIlst(\n    ParsableByteArray ilst, int endPosition, String key) {\n  int atomPosition;\n  while ((atomPosition = ilst.getPosition()) < endPosition) {\n    int atomSize = ilst.readInt();\n    int atomType = ilst.readInt();\n    if (atomType == Atom.TYPE_data) {\n      int typeIndicator = ilst.readInt();\n      int localeIndicator = ilst.readInt();\n      int dataSize = atomSize - 16;\n      byte[] value = new byte[dataSize];\n      ilst.readBytes(value, 0, dataSize);\n      return new MdtaMetadataEntry(key, value, localeIndicator, typeIndicator);\n    }\n    ilst.setPosition(atomPosition + atomSize);\n  }\n  return null;\n}",
        "summary_tokens": [
            "parses",
            "an",
            "mdta",
            "metadata",
            "entry",
            "starting",
            "at",
            "the",
            "current",
            "position",
            "in",
            "an",
            "ilst",
            "box"
        ]
    },
    {
        "id": 2001,
        "code": "public static byte[] buildPsshAtom(\n    UUID systemId, @Nullable UUID[] keyIds, @Nullable byte[] data) {\n  int dataLength = data != null ? data.length : 0;\n  int psshBoxLength = Atom.FULL_HEADER_SIZE + 16  + 4  + dataLength;\n  if (keyIds != null) {\n    psshBoxLength += 4  + (keyIds.length * 16) ;\n  }\n  ByteBuffer psshBox = ByteBuffer.allocate(psshBoxLength);\n  psshBox.putInt(psshBoxLength);\n  psshBox.putInt(Atom.TYPE_pssh);\n  psshBox.putInt(keyIds != null ? 0x01000000 : 0 );\n  psshBox.putLong(systemId.getMostSignificantBits());\n  psshBox.putLong(systemId.getLeastSignificantBits());\n  if (keyIds != null) {\n    psshBox.putInt(keyIds.length);\n    for (UUID keyId : keyIds) {\n      psshBox.putLong(keyId.getMostSignificantBits());\n      psshBox.putLong(keyId.getLeastSignificantBits());\n    }\n  }\n  if (data != null && data.length != 0) {\n    psshBox.putInt(data.length);\n    psshBox.put(data);\n  } \n  return psshBox.array();\n}",
        "summary_tokens": [
            "builds",
            "a",
            "pssh",
            "atom",
            "for",
            "the",
            "given",
            "system",
            "id",
            "containing",
            "the",
            "given",
            "key",
            "ids",
            "and",
            "data"
        ]
    },
    {
        "id": 2002,
        "code": "public static boolean isPsshAtom(byte[] data) {\n  return parsePsshAtom(data) != null;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "data",
            "is",
            "a",
            "valid",
            "pssh",
            "atom"
        ]
    },
    {
        "id": 2003,
        "code": "public static UUID parseUuid(byte[] atom) {\n  @Nullable PsshAtom parsedAtom = parsePsshAtom(atom);\n  if (parsedAtom == null) {\n    return null;\n  }\n  return parsedAtom.uuid;\n}",
        "summary_tokens": [
            "parses",
            "the",
            "uuid",
            "from",
            "a",
            "pssh",
            "atom"
        ]
    },
    {
        "id": 2004,
        "code": "public static int parseVersion(byte[] atom) {\n  @Nullable PsshAtom parsedAtom = parsePsshAtom(atom);\n  if (parsedAtom == null) {\n    return -1;\n  }\n  return parsedAtom.version;\n}",
        "summary_tokens": [
            "parses",
            "the",
            "version",
            "from",
            "a",
            "pssh",
            "atom"
        ]
    },
    {
        "id": 2005,
        "code": "public static byte[] parseSchemeSpecificData(byte[] atom, UUID uuid) {\n  @Nullable PsshAtom parsedAtom = parsePsshAtom(atom);\n  if (parsedAtom == null) {\n    return null;\n  }\n  if (!uuid.equals(parsedAtom.uuid)) {\n    Log.w(TAG, \"UUID mismatch. Expected: \" + uuid + \", got: \" + parsedAtom.uuid + \".\");\n    return null;\n  }\n  return parsedAtom.schemeData;\n}",
        "summary_tokens": [
            "parses",
            "the",
            "scheme",
            "specific",
            "data",
            "from",
            "a",
            "pssh",
            "atom"
        ]
    },
    {
        "id": 2006,
        "code": "private static PsshAtom parsePsshAtom(byte[] atom) {\n  ParsableByteArray atomData = new ParsableByteArray(atom);\n  if (atomData.limit() < Atom.FULL_HEADER_SIZE + 16  + 4 ) {\n      \n    return null;\n  }\n  atomData.setPosition(0);\n  int atomSize = atomData.readInt();\n  if (atomSize != atomData.bytesLeft() + 4) {\n      \n    return null;\n  }\n  int atomType = atomData.readInt();\n  if (atomType != Atom.TYPE_pssh) {\n      \n    return null;\n  }\n  int atomVersion = Atom.parseFullAtomVersion(atomData.readInt());\n  if (atomVersion > 1) {\n    Log.w(TAG, \"Unsupported pssh version: \" + atomVersion);\n    return null;\n  }\n  UUID uuid = new UUID(atomData.readLong(), atomData.readLong());\n  if (atomVersion == 1) {\n    int keyIdCount = atomData.readUnsignedIntToInt();\n    atomData.skipBytes(16 * keyIdCount);\n  }\n  int dataSize = atomData.readUnsignedIntToInt();\n  if (dataSize != atomData.bytesLeft()) {\n      \n    return null;\n  }\n  byte[] data = new byte[dataSize];\n  atomData.readBytes(data, 0, dataSize);\n  return new PsshAtom(uuid, atomVersion, data);\n}",
        "summary_tokens": [
            "parses",
            "a",
            "pssh",
            "atom"
        ]
    },
    {
        "id": 2007,
        "code": "public static boolean sniffFragmented(ExtractorInput input) throws IOException {\n  return sniffInternal(input,  true,  false);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "data",
            "peeked",
            "from",
            "the",
            "current",
            "position",
            "in",
            "input",
            "is",
            "consistent",
            "with",
            "the",
            "input",
            "being",
            "a",
            "fragmented",
            "mp",
            "0",
            "file"
        ]
    },
    {
        "id": 2008,
        "code": "public static boolean sniffUnfragmented(ExtractorInput input, boolean acceptHeic)\n    throws IOException {\n  return sniffInternal(input,  false, acceptHeic);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "data",
            "peeked",
            "from",
            "the",
            "current",
            "position",
            "in",
            "input",
            "is",
            "consistent",
            "with",
            "the",
            "input",
            "being",
            "an",
            "unfragmented",
            "mp",
            "0",
            "file"
        ]
    },
    {
        "id": 2009,
        "code": "private static boolean isCompatibleBrand(int brand, boolean acceptHeic) {\n  if (brand >>> 8 == 0x00336770) {\n      \n    return true;\n  } else if (brand == BRAND_HEIC && acceptHeic) {\n    return true;\n  }\n  for (int compatibleBrand : COMPATIBLE_BRANDS) {\n    if (compatibleBrand == brand) {\n      return true;\n    }\n  }\n  return false;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "brand",
            "is",
            "an",
            "ftyp",
            "atom",
            "brand",
            "that",
            "is",
            "compatible",
            "with",
            "the",
            "mp",
            "0",
            "extractors"
        ]
    },
    {
        "id": 2010,
        "code": "public TrackEncryptionBox getSampleDescriptionEncryptionBox(int sampleDescriptionIndex) {\n  return sampleDescriptionEncryptionBoxes == null\n      ? null\n      : sampleDescriptionEncryptionBoxes[sampleDescriptionIndex];\n}",
        "summary_tokens": [
            "returns",
            "the",
            "track",
            "encryption",
            "box",
            "for",
            "the",
            "given",
            "sample",
            "description",
            "index"
        ]
    },
    {
        "id": 2011,
        "code": "public void initTables(int trunCount, int sampleCount) {\n  this.trunCount = trunCount;\n  this.sampleCount = sampleCount;\n  if (trunLength.length < trunCount) {\n    trunDataPosition = new long[trunCount];\n    trunLength = new int[trunCount];\n  }\n  if (sampleSizeTable.length < sampleCount) {\n      \n      \n    int tableSize = (sampleCount * 125) / 100;\n    sampleSizeTable = new int[tableSize];\n    samplePresentationTimesUs = new long[tableSize];\n    sampleIsSyncFrameTable = new boolean[tableSize];\n    sampleHasSubsampleEncryptionTable = new boolean[tableSize];\n  }\n}",
        "summary_tokens": [
            "configures",
            "the",
            "fragment",
            "for",
            "the",
            "specified",
            "number",
            "of",
            "samples"
        ]
    },
    {
        "id": 2012,
        "code": "public void initEncryptionData(int length) {\n  sampleEncryptionData.reset(length);\n  definesEncryptionData = true;\n  sampleEncryptionDataNeedsFill = true;\n}",
        "summary_tokens": [
            "configures",
            "the",
            "fragment",
            "to",
            "be",
            "one",
            "that",
            "defines",
            "encryption",
            "data",
            "of",
            "the",
            "specified",
            "length"
        ]
    },
    {
        "id": 2013,
        "code": "public void fillEncryptionData(ParsableByteArray source) {\n  source.readBytes(sampleEncryptionData.getData(), 0, sampleEncryptionData.limit());\n  sampleEncryptionData.setPosition(0);\n  sampleEncryptionDataNeedsFill = false;\n}",
        "summary_tokens": [
            "fills",
            "sample",
            "encryption",
            "data",
            "from",
            "the",
            "provided",
            "source"
        ]
    },
    {
        "id": 2014,
        "code": "public long getSamplePresentationTimeUs(int index) {\n  return samplePresentationTimesUs[index];\n}",
        "summary_tokens": [
            "returns",
            "the",
            "sample",
            "presentation",
            "timestamp",
            "in",
            "microseconds"
        ]
    },
    {
        "id": 2015,
        "code": "public boolean sampleHasSubsampleEncryptionTable(int index) {\n  return definesEncryptionData && sampleHasSubsampleEncryptionTable[index];\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "sample",
            "at",
            "the",
            "given",
            "index",
            "has",
            "a",
            "subsample",
            "encryption",
            "table"
        ]
    },
    {
        "id": 2016,
        "code": "public int getIndexOfEarlierOrEqualSynchronizationSample(long timeUs) {\n    \n    \n  int startIndex = Util.binarySearchFloor(timestampsUs, timeUs, true, false);\n  for (int i = startIndex; i >= 0; i--) {\n    if ((flags[i] & C.BUFFER_FLAG_KEY_FRAME) != 0) {\n      return i;\n    }\n  }\n  return C.INDEX_UNSET;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "sample",
            "index",
            "of",
            "the",
            "closest",
            "synchronization",
            "sample",
            "at",
            "or",
            "before",
            "the",
            "given",
            "timestamp",
            "if",
            "one",
            "is",
            "available"
        ]
    },
    {
        "id": 2017,
        "code": "public int getIndexOfLaterOrEqualSynchronizationSample(long timeUs) {\n  int startIndex = Util.binarySearchCeil(timestampsUs, timeUs, true, false);\n  for (int i = startIndex; i < timestampsUs.length; i++) {\n    if ((flags[i] & C.BUFFER_FLAG_KEY_FRAME) != 0) {\n      return i;\n    }\n  }\n  return C.INDEX_UNSET;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "sample",
            "index",
            "of",
            "the",
            "closest",
            "synchronization",
            "sample",
            "at",
            "or",
            "after",
            "the",
            "given",
            "timestamp",
            "if",
            "one",
            "is",
            "available"
        ]
    },
    {
        "id": 2018,
        "code": "private long getNextSeekPosition(ExtractorInput input) throws IOException {\n  if (start == end) {\n    return C.POSITION_UNSET;\n  }\n\n  long currentPosition = input.getPosition();\n  if (!pageHeader.skipToNextPage(input, end)) {\n    if (start == currentPosition) {\n      throw new IOException(\"No ogg page can be found.\");\n    }\n    return start;\n  }\n\n  pageHeader.populate(input,  false);\n  input.resetPeekPosition();\n\n  long granuleDistance = targetGranule - pageHeader.granulePosition;\n  int pageSize = pageHeader.headerSize + pageHeader.bodySize;\n  if (0 <= granuleDistance && granuleDistance < MATCH_RANGE) {\n    return C.POSITION_UNSET;\n  }\n\n  if (granuleDistance < 0) {\n    end = currentPosition;\n    endGranule = pageHeader.granulePosition;\n  } else {\n    start = input.getPosition() + pageSize;\n    startGranule = pageHeader.granulePosition;\n  }\n\n  if (end - start < MATCH_BYTE_RANGE) {\n    end = start;\n    return start;\n  }\n\n  long offset = pageSize * (granuleDistance <= 0 ? 2L : 1L);\n  long nextPosition =\n      input.getPosition()\n          - offset\n          + (granuleDistance * (end - start) / (endGranule - startGranule));\n  return Util.constrainValue(nextPosition, start, end - 1);\n}",
        "summary_tokens": [
            "performs",
            "a",
            "single",
            "step",
            "of",
            "a",
            "seeking",
            "binary",
            "search",
            "returning",
            "the",
            "byte",
            "position",
            "from",
            "which",
            "data",
            "should",
            "be",
            "provided",
            "for",
            "the",
            "next",
            "step",
            "or",
            "c",
            "position",
            "unset",
            "if",
            "the",
            "search",
            "has",
            "converged"
        ]
    },
    {
        "id": 2019,
        "code": "private void skipToPageOfTargetGranule(ExtractorInput input) throws IOException {\n  while (true) {\n      \n      \n    pageHeader.skipToNextPage(input);\n    pageHeader.populate(input,  false);\n    if (pageHeader.granulePosition > targetGranule) {\n      break;\n    }\n    input.skipFully(pageHeader.headerSize + pageHeader.bodySize);\n    start = input.getPosition();\n    startGranule = pageHeader.granulePosition;\n  }\n  input.resetPeekPosition();\n}",
        "summary_tokens": [
            "skips",
            "forward",
            "to",
            "the",
            "start",
            "of",
            "the",
            "page",
            "containing",
            "the",
            "target",
            "granule"
        ]
    },
    {
        "id": 2020,
        "code": "long readGranuleOfLastPage(ExtractorInput input) throws IOException {\n  pageHeader.reset();\n  if (!pageHeader.skipToNextPage(input)) {\n    throw new EOFException();\n  }\n  pageHeader.populate(input,  false);\n  input.skipFully(pageHeader.headerSize + pageHeader.bodySize);\n  long granulePosition = pageHeader.granulePosition;\n  while ((pageHeader.type & 0x04) != 0x04\n      && pageHeader.skipToNextPage(input)\n      && input.getPosition() < payloadEndPosition) {\n    boolean hasPopulated = pageHeader.populate(input,  true);\n    if (!hasPopulated || !skipFullyQuietly(input, pageHeader.headerSize + pageHeader.bodySize)) {\n        \n        \n      return granulePosition;\n    }\n    granulePosition = pageHeader.granulePosition;\n  }\n  return granulePosition;\n}",
        "summary_tokens": [
            "skips",
            "to",
            "the",
            "last",
            "ogg",
            "page",
            "in",
            "the",
            "stream",
            "and",
            "reads",
            "the",
            "header",
            "s",
            "granule",
            "field",
            "which",
            "is",
            "the",
            "total",
            "number",
            "of",
            "samples",
            "per",
            "channel"
        ]
    },
    {
        "id": 2021,
        "code": "public boolean populate(ExtractorInput input) throws IOException {\n  Assertions.checkState(input != null);\n\n  if (populated) {\n    populated = false;\n    packetArray.reset( 0);\n  }\n\n  while (!populated) {\n    if (currentSegmentIndex < 0) {\n        \n      if (!pageHeader.skipToNextPage(input) || !pageHeader.populate(input,  true)) {\n        return false;\n      }\n      int segmentIndex = 0;\n      int bytesToSkip = pageHeader.headerSize;\n      if ((pageHeader.type & 0x01) == 0x01 && packetArray.limit() == 0) {\n          \n          \n        bytesToSkip += calculatePacketSize(segmentIndex);\n        segmentIndex += segmentCount;\n      }\n      if (!skipFullyQuietly(input, bytesToSkip)) {\n        return false;\n      }\n      currentSegmentIndex = segmentIndex;\n    }\n\n    int size = calculatePacketSize(currentSegmentIndex);\n    int segmentIndex = currentSegmentIndex + segmentCount;\n    if (size > 0) {\n      packetArray.ensureCapacity(packetArray.limit() + size);\n      if (!readFullyQuietly(input, packetArray.getData(), packetArray.limit(), size)) {\n        return false;\n      }\n      packetArray.setLimit(packetArray.limit() + size);\n      populated = pageHeader.laces[segmentIndex - 1] != 255;\n    }\n      \n    currentSegmentIndex =\n        segmentIndex == pageHeader.pageSegmentCount ? C.INDEX_UNSET : segmentIndex;\n  }\n  return true;\n}",
        "summary_tokens": [
            "reads",
            "the",
            "next",
            "packet",
            "of",
            "the",
            "ogg",
            "stream"
        ]
    },
    {
        "id": 2022,
        "code": "public OggPageHeader getPageHeader() {\n  return pageHeader;\n}",
        "summary_tokens": [
            "an",
            "ogg",
            "packet",
            "may",
            "span",
            "multiple",
            "pages"
        ]
    },
    {
        "id": 2023,
        "code": "public ParsableByteArray getPayload() {\n  return packetArray;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "parsable",
            "byte",
            "array",
            "containing",
            "the",
            "packet",
            "s",
            "payload"
        ]
    },
    {
        "id": 2024,
        "code": "public void trimPayload() {\n  if (packetArray.getData().length == OggPageHeader.MAX_PAGE_PAYLOAD) {\n    return;\n  }\n  packetArray.reset(\n      Arrays.copyOf(\n          packetArray.getData(), max(OggPageHeader.MAX_PAGE_PAYLOAD, packetArray.limit())),\n       packetArray.limit());\n}",
        "summary_tokens": [
            "trims",
            "the",
            "packet",
            "data",
            "array"
        ]
    },
    {
        "id": 2025,
        "code": "private int calculatePacketSize(int startSegmentIndex) {\n  segmentCount = 0;\n  int size = 0;\n  while (startSegmentIndex + segmentCount < pageHeader.pageSegmentCount) {\n    int segmentLength = pageHeader.laces[startSegmentIndex + segmentCount++];\n    size += segmentLength;\n    if (segmentLength != 255) {\n        \n      break;\n    }\n  }\n  return size;\n}",
        "summary_tokens": [
            "calculates",
            "the",
            "size",
            "of",
            "the",
            "packet",
            "starting",
            "from",
            "start",
            "segment",
            "index"
        ]
    },
    {
        "id": 2026,
        "code": "public void reset() {\n  revision = 0;\n  type = 0;\n  granulePosition = 0;\n  streamSerialNumber = 0;\n  pageSequenceNumber = 0;\n  pageChecksum = 0;\n  pageSegmentCount = 0;\n  headerSize = 0;\n  bodySize = 0;\n}",
        "summary_tokens": [
            "resets",
            "all",
            "primitive",
            "member",
            "fields",
            "to",
            "zero"
        ]
    },
    {
        "id": 2027,
        "code": "public boolean skipToNextPage(ExtractorInput input, long limit) throws IOException {\n  Assertions.checkArgument(input.getPosition() == input.getPeekPosition());\n  scratch.reset( CAPTURE_PATTERN_SIZE);\n  while ((limit == C.POSITION_UNSET || input.getPosition() + CAPTURE_PATTERN_SIZE < limit)\n      && peekFullyQuietly(\n          input, scratch.getData(), 0, CAPTURE_PATTERN_SIZE,  true)) {\n    scratch.setPosition(0);\n    if (scratch.readUnsignedInt() == CAPTURE_PATTERN) {\n      input.resetPeekPosition();\n      return true;\n    }\n      \n    input.skipFully(1);\n  }\n    \n  while ((limit == C.POSITION_UNSET || input.getPosition() < limit)\n      && input.skip(1) != C.RESULT_END_OF_INPUT) {}\n  return false;\n}",
        "summary_tokens": [
            "advances",
            "through",
            "input",
            "looking",
            "for",
            "the",
            "start",
            "of",
            "the",
            "next",
            "ogg",
            "page"
        ]
    },
    {
        "id": 2028,
        "code": "public boolean populate(ExtractorInput input, boolean quiet) throws IOException {\n  reset();\n  scratch.reset( EMPTY_PAGE_HEADER_SIZE);\n  if (!peekFullyQuietly(input, scratch.getData(), 0, EMPTY_PAGE_HEADER_SIZE, quiet)\n      || scratch.readUnsignedInt() != CAPTURE_PATTERN) {\n    return false;\n  }\n\n  revision = scratch.readUnsignedByte();\n  if (revision != 0x00) {\n    if (quiet) {\n      return false;\n    } else {\n      throw ParserException.createForUnsupportedContainerFeature(\n          \"unsupported bit stream revision\");\n    }\n  }\n  type = scratch.readUnsignedByte();\n\n  granulePosition = scratch.readLittleEndianLong();\n  streamSerialNumber = scratch.readLittleEndianUnsignedInt();\n  pageSequenceNumber = scratch.readLittleEndianUnsignedInt();\n  pageChecksum = scratch.readLittleEndianUnsignedInt();\n  pageSegmentCount = scratch.readUnsignedByte();\n  headerSize = EMPTY_PAGE_HEADER_SIZE + pageSegmentCount;\n\n    \n  scratch.reset( pageSegmentCount);\n  if (!peekFullyQuietly(input, scratch.getData(), 0, pageSegmentCount, quiet)) {\n    return false;\n  }\n  for (int i = 0; i < pageSegmentCount; i++) {\n    laces[i] = scratch.readUnsignedByte();\n    bodySize += laces[i];\n  }\n\n  return true;\n}",
        "summary_tokens": [
            "peeks",
            "an",
            "ogg",
            "page",
            "header",
            "and",
            "updates",
            "this",
            "ogg",
            "page",
            "header"
        ]
    },
    {
        "id": 2029,
        "code": "private long getPacketDurationUs(byte[] packet) {\n  int toc = packet[0] & 0xFF;\n  int frames;\n  switch (toc & 0x3) {\n    case 0:\n      frames = 1;\n      break;\n    case 1:\n    case 2:\n      frames = 2;\n      break;\n    default:\n      frames = packet[1] & 0x3F;\n      break;\n  }\n\n  int config = toc >> 3;\n  int length = config & 0x3;\n  if (config >= 16) {\n    length = 2500 << length;\n  } else if (config >= 12) {\n    length = 10000 << (length & 0x1);\n  } else if (length == 3) {\n    length = 60000;\n  } else {\n    length = 10000 << length;\n  }\n  return (long) frames * length;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "duration",
            "of",
            "the",
            "given",
            "audio",
            "packet"
        ]
    },
    {
        "id": 2030,
        "code": "private static boolean peekPacketStartsWith(ParsableByteArray packet, byte[] expectedPrefix) {\n  if (packet.bytesLeft() < expectedPrefix.length) {\n    return false;\n  }\n  int startPosition = packet.getPosition();\n  byte[] header = new byte[expectedPrefix.length];\n  packet.readBytes(header, 0, expectedPrefix.length);\n  packet.setPosition(startPosition);\n  return Arrays.equals(header, expectedPrefix);\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "the",
            "given",
            "parsable",
            "byte",
            "array",
            "starts",
            "with",
            "expected",
            "prefix"
        ]
    },
    {
        "id": 2031,
        "code": "protected void reset(boolean headerData) {\n  if (headerData) {\n    setupData = new SetupData();\n    payloadStartPosition = 0;\n    state = STATE_READ_HEADERS;\n  } else {\n    state = STATE_SKIP_HEADERS;\n  }\n  targetGranule = -1;\n  currentGranule = 0;\n}",
        "summary_tokens": [
            "resets",
            "the",
            "state",
            "of",
            "the",
            "stream",
            "reader"
        ]
    },
    {
        "id": 2032,
        "code": "private boolean readHeaders(ExtractorInput input) throws IOException {\n  while (true) {\n    if (!oggPacket.populate(input)) {\n      state = STATE_END_OF_INPUT;\n      return false;\n    }\n    lengthOfReadPacket = input.getPosition() - payloadStartPosition;\n\n    if (readHeaders(oggPacket.getPayload(), payloadStartPosition, setupData)) {\n      payloadStartPosition = input.getPosition();\n    } else {\n      return true; \n    }\n  }\n}",
        "summary_tokens": [
            "read",
            "all",
            "header",
            "packets"
        ]
    },
    {
        "id": 2033,
        "code": "protected long convertGranuleToTime(long granule) {\n  return (granule * C.MICROS_PER_SECOND) / sampleRate;\n}",
        "summary_tokens": [
            "converts",
            "granule",
            "value",
            "to",
            "time"
        ]
    },
    {
        "id": 2034,
        "code": "protected long convertTimeToGranule(long timeUs) {\n  return (sampleRate * timeUs) / C.MICROS_PER_SECOND;\n}",
        "summary_tokens": [
            "converts",
            "time",
            "value",
            "to",
            "granule"
        ]
    },
    {
        "id": 2035,
        "code": "protected void onSeekEnd(long currentGranule) {\n  this.currentGranule = currentGranule;\n}",
        "summary_tokens": [
            "called",
            "on",
            "end",
            "of",
            "seeking"
        ]
    },
    {
        "id": 2036,
        "code": " static int readBits(byte src, int length, int leastSignificantBitIndex) {\n  return (src >> leastSignificantBitIndex) & (255 >>> (8 - length));\n}",
        "summary_tokens": [
            "reads",
            "an",
            "int",
            "of",
            "length",
            "bits",
            "from",
            "src",
            "starting",
            "at",
            "least",
            "significant",
            "bit",
            "index"
        ]
    },
    {
        "id": 2037,
        "code": "private boolean continueRead(ParsableByteArray source, byte[] target, int targetLength) {\n  int bytesToRead = min(source.bytesLeft(), targetLength - bytesRead);\n  source.readBytes(target, bytesRead, bytesToRead);\n  bytesRead += bytesToRead;\n  return bytesRead == targetLength;\n}",
        "summary_tokens": [
            "continues",
            "a",
            "read",
            "from",
            "the",
            "provided",
            "source",
            "into",
            "a",
            "given",
            "target"
        ]
    },
    {
        "id": 2038,
        "code": "private boolean skipToNextSync(ParsableByteArray pesBuffer) {\n  while (pesBuffer.bytesLeft() > 0) {\n    if (!lastByteWas0B) {\n      lastByteWas0B = pesBuffer.readUnsignedByte() == 0x0B;\n      continue;\n    }\n    int secondByte = pesBuffer.readUnsignedByte();\n    if (secondByte == 0x77) {\n      lastByteWas0B = false;\n      return true;\n    } else {\n      lastByteWas0B = secondByte == 0x0B;\n    }\n  }\n  return false;\n}",
        "summary_tokens": [
            "locates",
            "the",
            "next",
            "syncword",
            "advancing",
            "the",
            "position",
            "to",
            "the",
            "byte",
            "that",
            "immediately",
            "follows",
            "it"
        ]
    },
    {
        "id": 2039,
        "code": "private void parseHeader() {\n  headerScratchBits.setPosition(0);\n  SyncFrameInfo frameInfo = Ac3Util.parseAc3SyncframeInfo(headerScratchBits);\n  if (format == null\n      || frameInfo.channelCount != format.channelCount\n      || frameInfo.sampleRate != format.sampleRate\n      || !Util.areEqual(frameInfo.mimeType, format.sampleMimeType)) {\n    format =\n        new Format.Builder()\n            .setId(formatId)\n            .setSampleMimeType(frameInfo.mimeType)\n            .setChannelCount(frameInfo.channelCount)\n            .setSampleRate(frameInfo.sampleRate)\n            .setLanguage(language)\n            .build();\n    output.format(format);\n  }\n  sampleSize = frameInfo.frameSize;\n    \n    \n  sampleDurationUs = C.MICROS_PER_SECOND * frameInfo.sampleCount / format.sampleRate;\n}",
        "summary_tokens": [
            "parses",
            "the",
            "sample",
            "header"
        ]
    },
    {
        "id": 2040,
        "code": "private boolean continueRead(ParsableByteArray source, byte[] target, int targetLength) {\n  int bytesToRead = min(source.bytesLeft(), targetLength - bytesRead);\n  source.readBytes(target, bytesRead, bytesToRead);\n  bytesRead += bytesToRead;\n  return bytesRead == targetLength;\n}",
        "summary_tokens": [
            "continues",
            "a",
            "read",
            "from",
            "the",
            "provided",
            "source",
            "into",
            "a",
            "given",
            "target"
        ]
    },
    {
        "id": 2041,
        "code": "private boolean skipToNextSync(ParsableByteArray pesBuffer) {\n  while (pesBuffer.bytesLeft() > 0) {\n    if (!lastByteWasAC) {\n      lastByteWasAC = (pesBuffer.readUnsignedByte() == 0xAC);\n      continue;\n    }\n    int secondByte = pesBuffer.readUnsignedByte();\n    lastByteWasAC = secondByte == 0xAC;\n    if (secondByte == 0x40 || secondByte == 0x41) {\n      hasCRC = secondByte == 0x41;\n      return true;\n    }\n  }\n  return false;\n}",
        "summary_tokens": [
            "locates",
            "the",
            "next",
            "syncword",
            "advancing",
            "the",
            "position",
            "to",
            "the",
            "byte",
            "that",
            "immediately",
            "follows",
            "it"
        ]
    },
    {
        "id": 2042,
        "code": "private void parseHeader() {\n  headerScratchBits.setPosition(0);\n  SyncFrameInfo frameInfo = Ac4Util.parseAc4SyncframeInfo(headerScratchBits);\n  if (format == null\n      || frameInfo.channelCount != format.channelCount\n      || frameInfo.sampleRate != format.sampleRate\n      || !MimeTypes.AUDIO_AC4.equals(format.sampleMimeType)) {\n    format =\n        new Format.Builder()\n            .setId(formatId)\n            .setSampleMimeType(MimeTypes.AUDIO_AC4)\n            .setChannelCount(frameInfo.channelCount)\n            .setSampleRate(frameInfo.sampleRate)\n            .setLanguage(language)\n            .build();\n    output.format(format);\n  }\n  sampleSize = frameInfo.frameSize;\n    \n    \n  sampleDurationUs = C.MICROS_PER_SECOND * frameInfo.sampleCount / format.sampleRate;\n}",
        "summary_tokens": [
            "parses",
            "the",
            "sample",
            "header"
        ]
    },
    {
        "id": 2043,
        "code": "private static int getBitrateFromFrameSize(int frameSize, long durationUsPerFrame) {\n  return (int)\n      ((frameSize * ((long) C.BITS_PER_BYTE) * C.MICROS_PER_SECOND) / durationUsPerFrame);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "stream",
            "bitrate",
            "given",
            "a",
            "frame",
            "size",
            "and",
            "the",
            "duration",
            "of",
            "that",
            "frame",
            "in",
            "microseconds"
        ]
    },
    {
        "id": 2044,
        "code": "public static boolean isAdtsSyncWord(int candidateSyncWord) {\n  return (candidateSyncWord & 0xFFF6) == 0xFFF0;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "an",
            "integer",
            "matches",
            "an",
            "adts",
            "sync",
            "word"
        ]
    },
    {
        "id": 2045,
        "code": "public long getSampleDurationUs() {\n  return sampleDurationUs;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "duration",
            "in",
            "microseconds",
            "per",
            "sample",
            "or",
            "c",
            "time",
            "unset",
            "if",
            "the",
            "sample",
            "duration",
            "is",
            "not",
            "available"
        ]
    },
    {
        "id": 2046,
        "code": "private boolean continueRead(ParsableByteArray source, byte[] target, int targetLength) {\n  int bytesToRead = min(source.bytesLeft(), targetLength - bytesRead);\n  source.readBytes(target, bytesRead, bytesToRead);\n  bytesRead += bytesToRead;\n  return bytesRead == targetLength;\n}",
        "summary_tokens": [
            "continues",
            "a",
            "read",
            "from",
            "the",
            "provided",
            "source",
            "into",
            "a",
            "given",
            "target"
        ]
    },
    {
        "id": 2047,
        "code": "private void setFindingSampleState() {\n  state = STATE_FINDING_SAMPLE;\n  bytesRead = 0;\n  matchState = MATCH_STATE_START;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "state",
            "to",
            "state",
            "finding",
            "sample"
        ]
    },
    {
        "id": 2048,
        "code": "private void setReadingId3HeaderState() {\n  state = STATE_READING_ID3_HEADER;\n  bytesRead = ID3_IDENTIFIER.length;\n  sampleSize = 0;\n  id3HeaderBuffer.setPosition(0);\n}",
        "summary_tokens": [
            "sets",
            "the",
            "state",
            "to",
            "state",
            "reading",
            "id",
            "0",
            "header",
            "and",
            "resets",
            "the",
            "fields",
            "required",
            "for",
            "parse",
            "id",
            "0",
            "header"
        ]
    },
    {
        "id": 2049,
        "code": "private void setReadingSampleState(\n    TrackOutput outputToUse, long currentSampleDuration, int priorReadBytes, int sampleSize) {\n  state = STATE_READING_SAMPLE;\n  bytesRead = priorReadBytes;\n  this.currentOutput = outputToUse;\n  this.currentSampleDuration = currentSampleDuration;\n  this.sampleSize = sampleSize;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "state",
            "to",
            "state",
            "reading",
            "sample"
        ]
    },
    {
        "id": 2050,
        "code": "private void setReadingAdtsHeaderState() {\n  state = STATE_READING_ADTS_HEADER;\n  bytesRead = 0;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "state",
            "to",
            "state",
            "reading",
            "adts",
            "header"
        ]
    },
    {
        "id": 2051,
        "code": "private void setCheckingAdtsHeaderState() {\n  state = STATE_CHECKING_ADTS_HEADER;\n  bytesRead = 0;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "state",
            "to",
            "state",
            "checking",
            "adts",
            "header"
        ]
    },
    {
        "id": 2052,
        "code": "private void findNextSample(ParsableByteArray pesBuffer) {\n  byte[] adtsData = pesBuffer.getData();\n  int position = pesBuffer.getPosition();\n  int endOffset = pesBuffer.limit();\n  while (position < endOffset) {\n    int data = adtsData[position++] & 0xFF;\n    if (matchState == MATCH_STATE_FF && isAdtsSyncBytes((byte) 0xFF, (byte) data)) {\n      if (foundFirstFrame\n          || checkSyncPositionValid(pesBuffer,  position - 2)) {\n        currentFrameVersion = (data & 0x8) >> 3;\n        hasCrc = (data & 0x1) == 0;\n        if (!foundFirstFrame) {\n          setCheckingAdtsHeaderState();\n        } else {\n          setReadingAdtsHeaderState();\n        }\n        pesBuffer.setPosition(position);\n        return;\n      }\n    }\n\n    switch (matchState | data) {\n      case MATCH_STATE_START | 0xFF:\n        matchState = MATCH_STATE_FF;\n        break;\n      case MATCH_STATE_START | 'I':\n        matchState = MATCH_STATE_I;\n        break;\n      case MATCH_STATE_I | 'D':\n        matchState = MATCH_STATE_ID;\n        break;\n      case MATCH_STATE_ID | '3':\n        setReadingId3HeaderState();\n        pesBuffer.setPosition(position);\n        return;\n      default:\n        if (matchState != MATCH_STATE_START) {\n            \n            \n          matchState = MATCH_STATE_START;\n          position--;\n        }\n        break;\n    }\n  }\n  pesBuffer.setPosition(position);\n}",
        "summary_tokens": [
            "locates",
            "the",
            "next",
            "sample",
            "start",
            "advancing",
            "the",
            "position",
            "to",
            "the",
            "byte",
            "that",
            "immediately",
            "follows",
            "identifier"
        ]
    },
    {
        "id": 2053,
        "code": "private void checkAdtsHeader(ParsableByteArray buffer) {\n  if (buffer.bytesLeft() == 0) {\n      \n    return;\n  }\n    \n  adtsScratch.data[0] = buffer.getData()[buffer.getPosition()];\n\n  adtsScratch.setPosition(2);\n  int currentFrameSampleRateIndex = adtsScratch.readBits(4);\n  if (firstFrameSampleRateIndex != C.INDEX_UNSET\n      && currentFrameSampleRateIndex != firstFrameSampleRateIndex) {\n      \n    resetSync();\n    return;\n  }\n\n  if (!foundFirstFrame) {\n    foundFirstFrame = true;\n    firstFrameVersion = currentFrameVersion;\n    firstFrameSampleRateIndex = currentFrameSampleRateIndex;\n  }\n  setReadingAdtsHeaderState();\n}",
        "summary_tokens": [
            "peeks",
            "the",
            "adts",
            "header",
            "of",
            "the",
            "current",
            "frame",
            "and",
            "checks",
            "if",
            "it",
            "is",
            "valid"
        ]
    },
    {
        "id": 2054,
        "code": "private boolean checkSyncPositionValid(ParsableByteArray pesBuffer, int syncPositionCandidate) {\n  pesBuffer.setPosition(syncPositionCandidate + 1);\n  if (!tryRead(pesBuffer, adtsScratch.data, 1)) {\n    return false;\n  }\n\n    \n  adtsScratch.setPosition(4);\n  int currentFrameVersion = adtsScratch.readBits(1);\n  if (firstFrameVersion != VERSION_UNSET && currentFrameVersion != firstFrameVersion) {\n    return false;\n  }\n\n    \n  if (firstFrameSampleRateIndex != C.INDEX_UNSET) {\n    if (!tryRead(pesBuffer, adtsScratch.data, 1)) {\n        \n      return true;\n    }\n    adtsScratch.setPosition(2);\n    int currentFrameSampleRateIndex = adtsScratch.readBits(4);\n    if (currentFrameSampleRateIndex != firstFrameSampleRateIndex) {\n      return false;\n    }\n    pesBuffer.setPosition(syncPositionCandidate + 2);\n  }\n\n    \n  if (!tryRead(pesBuffer, adtsScratch.data, 4)) {\n      \n    return true;\n  }\n  adtsScratch.setPosition(14);\n  int frameSize = adtsScratch.readBits(13);\n  if (frameSize < 7) {\n    return false;\n  }\n\n    \n    \n  byte[] data = pesBuffer.getData();\n  int dataLimit = pesBuffer.limit();\n  int nextSyncPosition = syncPositionCandidate + frameSize;\n  if (nextSyncPosition >= dataLimit) {\n      \n    return true;\n  }\n  if (data[nextSyncPosition] == (byte) 0xFF) {\n    if (nextSyncPosition + 1 == dataLimit) {\n        \n      return true;\n    }\n    return isAdtsSyncBytes((byte) 0xFF, data[nextSyncPosition + 1])\n        && ((data[nextSyncPosition + 1] & 0x8) >> 3) == currentFrameVersion;\n  } else {\n    if (data[nextSyncPosition] != 'I') {\n      return false;\n    }\n    if (nextSyncPosition + 1 == dataLimit) {\n        \n      return true;\n    }\n    if (data[nextSyncPosition + 1] != 'D') {\n      return false;\n    }\n    if (nextSyncPosition + 2 == dataLimit) {\n        \n      return true;\n    }\n    return data[nextSyncPosition + 2] == '3';\n  }\n}",
        "summary_tokens": [
            "checks",
            "whether",
            "a",
            "candidate",
            "sync",
            "word",
            "position",
            "is",
            "likely",
            "to",
            "be",
            "the",
            "position",
            "of",
            "a",
            "real",
            "sync",
            "word"
        ]
    },
    {
        "id": 2055,
        "code": "private boolean tryRead(ParsableByteArray source, byte[] target, int targetLength) {\n  if (source.bytesLeft() < targetLength) {\n    return false;\n  }\n  source.readBytes(target,  0, targetLength);\n  return true;\n}",
        "summary_tokens": [
            "reads",
            "target",
            "length",
            "bytes",
            "into",
            "target",
            "and",
            "returns",
            "whether",
            "the",
            "read",
            "succeeded"
        ]
    },
    {
        "id": 2056,
        "code": "private void parseId3Header() {\n  id3Output.sampleData(id3HeaderBuffer, ID3_HEADER_SIZE);\n  id3HeaderBuffer.setPosition(ID3_SIZE_OFFSET);\n  setReadingSampleState(\n      id3Output, 0, ID3_HEADER_SIZE, id3HeaderBuffer.readSynchSafeInt() + ID3_HEADER_SIZE);\n}",
        "summary_tokens": [
            "parses",
            "the",
            "id",
            "0",
            "header"
        ]
    },
    {
        "id": 2057,
        "code": "private void parseAdtsHeader() throws ParserException {\n  adtsScratch.setPosition(0);\n\n  if (!hasOutputFormat) {\n    int audioObjectType = adtsScratch.readBits(2) + 1;\n    if (audioObjectType != 2) {\n        \n        \n        \n        \n        \n        \n        \n        \n        \n      Log.w(TAG, \"Detected audio object type: \" + audioObjectType + \", but assuming AAC LC.\");\n      audioObjectType = 2;\n    }\n\n    adtsScratch.skipBits(5);\n    int channelConfig = adtsScratch.readBits(3);\n\n    byte[] audioSpecificConfig =\n        AacUtil.buildAudioSpecificConfig(\n            audioObjectType, firstFrameSampleRateIndex, channelConfig);\n    AacUtil.Config aacConfig = AacUtil.parseAudioSpecificConfig(audioSpecificConfig);\n    Format format =\n        new Format.Builder()\n            .setId(formatId)\n            .setSampleMimeType(MimeTypes.AUDIO_AAC)\n            .setCodecs(aacConfig.codecs)\n            .setChannelCount(aacConfig.channelCount)\n            .setSampleRate(aacConfig.sampleRateHz)\n            .setInitializationData(Collections.singletonList(audioSpecificConfig))\n            .setLanguage(language)\n            .build();\n      \n      \n    sampleDurationUs = (C.MICROS_PER_SECOND * 1024) / format.sampleRate;\n    output.format(format);\n    hasOutputFormat = true;\n  } else {\n    adtsScratch.skipBits(10);\n  }\n\n  adtsScratch.skipBits(4);\n  int sampleSize = adtsScratch.readBits(13) - 2  - HEADER_SIZE;\n  if (hasCrc) {\n    sampleSize -= CRC_SIZE;\n  }\n\n  setReadingSampleState(output, sampleDurationUs, 0, sampleSize);\n}",
        "summary_tokens": [
            "parses",
            "the",
            "sample",
            "header"
        ]
    },
    {
        "id": 2058,
        "code": "private void readSample(ParsableByteArray data) {\n  int bytesToRead = min(data.bytesLeft(), sampleSize - bytesRead);\n  currentOutput.sampleData(data, bytesToRead);\n  bytesRead += bytesToRead;\n  if (bytesRead == sampleSize) {\n    if (timeUs != C.TIME_UNSET) {\n      currentOutput.sampleMetadata(timeUs, C.BUFFER_FLAG_KEY_FRAME, sampleSize, 0, null);\n      timeUs += currentSampleDuration;\n    }\n    setFindingSampleState();\n  }\n}",
        "summary_tokens": [
            "reads",
            "the",
            "rest",
            "of",
            "the",
            "sample"
        ]
    },
    {
        "id": 2059,
        "code": "private SeiReader buildSeiReader(EsInfo esInfo) {\n  return new SeiReader(getClosedCaptionFormats(esInfo));\n}",
        "summary_tokens": [
            "if",
            "flag",
            "override",
            "caption",
            "descriptors",
            "is",
            "set",
            "returns",
            "a",
            "sei",
            "reader",
            "for",
            "closed",
            "caption",
            "formats"
        ]
    },
    {
        "id": 2060,
        "code": "private UserDataReader buildUserDataReader(EsInfo esInfo) {\n  return new UserDataReader(getClosedCaptionFormats(esInfo));\n}",
        "summary_tokens": [
            "if",
            "flag",
            "override",
            "caption",
            "descriptors",
            "is",
            "set",
            "returns",
            "a",
            "user",
            "data",
            "reader",
            "for",
            "closed",
            "caption",
            "formats"
        ]
    },
    {
        "id": 2061,
        "code": "private List<Format> getClosedCaptionFormats(EsInfo esInfo) {\n  if (isSet(FLAG_OVERRIDE_CAPTION_DESCRIPTORS)) {\n    return closedCaptionFormats;\n  }\n  ParsableByteArray scratchDescriptorData = new ParsableByteArray(esInfo.descriptorBytes);\n  List<Format> closedCaptionFormats = this.closedCaptionFormats;\n  while (scratchDescriptorData.bytesLeft() > 0) {\n    int descriptorTag = scratchDescriptorData.readUnsignedByte();\n    int descriptorLength = scratchDescriptorData.readUnsignedByte();\n    int nextDescriptorPosition = scratchDescriptorData.getPosition() + descriptorLength;\n    if (descriptorTag == DESCRIPTOR_TAG_CAPTION_SERVICE) {\n        \n      closedCaptionFormats = new ArrayList<>();\n      int numberOfServices = scratchDescriptorData.readUnsignedByte() & 0x1F;\n      for (int i = 0; i < numberOfServices; i++) {\n        String language = scratchDescriptorData.readString(3);\n        int captionTypeByte = scratchDescriptorData.readUnsignedByte();\n        boolean isDigital = (captionTypeByte & 0x80) != 0;\n        String mimeType;\n        int accessibilityChannel;\n        if (isDigital) {\n          mimeType = MimeTypes.APPLICATION_CEA708;\n          accessibilityChannel = captionTypeByte & 0x3F;\n        } else {\n          mimeType = MimeTypes.APPLICATION_CEA608;\n          accessibilityChannel = 1;\n        }\n\n          \n        byte flags = (byte) scratchDescriptorData.readUnsignedByte();\n          \n        scratchDescriptorData.skipBytes(1);\n\n        @Nullable List<byte[]> initializationData = null;\n          \n        if (isDigital) {\n          boolean isWideAspectRatio = (flags & 0x40) != 0;\n          initializationData =\n              CodecSpecificDataUtil.buildCea708InitializationData(isWideAspectRatio);\n        }\n\n        closedCaptionFormats.add(\n            new Format.Builder()\n                .setSampleMimeType(mimeType)\n                .setLanguage(language)\n                .setAccessibilityChannel(accessibilityChannel)\n                .setInitializationData(initializationData)\n                .build());\n      }\n    } else {\n        \n    }\n    scratchDescriptorData.setPosition(nextDescriptorPosition);\n  }\n\n  return closedCaptionFormats;\n}",
        "summary_tokens": [
            "if",
            "flag",
            "override",
            "caption",
            "descriptors",
            "is",
            "set",
            "returns",
            "a",
            "list",
            "format",
            "of",
            "closed",
            "caption",
            "formats"
        ]
    },
    {
        "id": 2062,
        "code": "private boolean continueRead(ParsableByteArray source, byte[] target, int targetLength) {\n  int bytesToRead = min(source.bytesLeft(), targetLength - bytesRead);\n  source.readBytes(target, bytesRead, bytesToRead);\n  bytesRead += bytesToRead;\n  return bytesRead == targetLength;\n}",
        "summary_tokens": [
            "continues",
            "a",
            "read",
            "from",
            "the",
            "provided",
            "source",
            "into",
            "a",
            "given",
            "target"
        ]
    },
    {
        "id": 2063,
        "code": "private boolean skipToNextSync(ParsableByteArray pesBuffer) {\n  while (pesBuffer.bytesLeft() > 0) {\n    syncBytes <<= 8;\n    syncBytes |= pesBuffer.readUnsignedByte();\n    if (DtsUtil.isSyncWord(syncBytes)) {\n      byte[] headerData = headerScratchBytes.getData();\n      headerData[0] = (byte) ((syncBytes >> 24) & 0xFF);\n      headerData[1] = (byte) ((syncBytes >> 16) & 0xFF);\n      headerData[2] = (byte) ((syncBytes >> 8) & 0xFF);\n      headerData[3] = (byte) (syncBytes & 0xFF);\n      bytesRead = 4;\n      syncBytes = 0;\n      return true;\n    }\n  }\n  return false;\n}",
        "summary_tokens": [
            "locates",
            "the",
            "next",
            "sync",
            "value",
            "in",
            "the",
            "buffer",
            "advancing",
            "the",
            "position",
            "to",
            "the",
            "byte",
            "that",
            "immediately",
            "follows",
            "it"
        ]
    },
    {
        "id": 2064,
        "code": "private void parseHeader() {\n  byte[] frameData = headerScratchBytes.getData();\n  if (format == null) {\n    format = DtsUtil.parseDtsFormat(frameData, formatId, language, null);\n    output.format(format);\n  }\n  sampleSize = DtsUtil.getDtsFrameSize(frameData);\n    \n    \n  sampleDurationUs =\n      (int)\n          (C.MICROS_PER_SECOND * DtsUtil.parseDtsAudioSampleCount(frameData) / format.sampleRate);\n}",
        "summary_tokens": [
            "parses",
            "the",
            "sample",
            "header"
        ]
    },
    {
        "id": 2065,
        "code": "private static Pair<Format, Long> parseCsdBuffer(CsdBuffer csdBuffer, String formatId) {\n  byte[] csdData = Arrays.copyOf(csdBuffer.data, csdBuffer.length);\n\n  int firstByte = csdData[4] & 0xFF;\n  int secondByte = csdData[5] & 0xFF;\n  int thirdByte = csdData[6] & 0xFF;\n  int width = (firstByte << 4) | (secondByte >> 4);\n  int height = (secondByte & 0x0F) << 8 | thirdByte;\n\n  float pixelWidthHeightRatio = 1f;\n  int aspectRatioCode = (csdData[7] & 0xF0) >> 4;\n  switch (aspectRatioCode) {\n    case 2:\n      pixelWidthHeightRatio = (4 * height) / (float) (3 * width);\n      break;\n    case 3:\n      pixelWidthHeightRatio = (16 * height) / (float) (9 * width);\n      break;\n    case 4:\n      pixelWidthHeightRatio = (121 * height) / (float) (100 * width);\n      break;\n    default:\n        \n      break;\n  }\n\n  Format format =\n      new Format.Builder()\n          .setId(formatId)\n          .setSampleMimeType(MimeTypes.VIDEO_MPEG2)\n          .setWidth(width)\n          .setHeight(height)\n          .setPixelWidthHeightRatio(pixelWidthHeightRatio)\n          .setInitializationData(Collections.singletonList(csdData))\n          .build();\n\n  long frameDurationUs = 0;\n  int frameRateCodeMinusOne = (csdData[7] & 0x0F) - 1;\n  if (0 <= frameRateCodeMinusOne && frameRateCodeMinusOne < FRAME_RATE_VALUES.length) {\n    double frameRate = FRAME_RATE_VALUES[frameRateCodeMinusOne];\n    int sequenceExtensionPosition = csdBuffer.sequenceExtensionPosition;\n    int frameRateExtensionN = (csdData[sequenceExtensionPosition + 9] & 0x60) >> 5;\n    int frameRateExtensionD = (csdData[sequenceExtensionPosition + 9] & 0x1F);\n    if (frameRateExtensionN != frameRateExtensionD) {\n      frameRate *= (frameRateExtensionN + 1d) / (frameRateExtensionD + 1);\n    }\n    frameDurationUs = (long) (C.MICROS_PER_SECOND / frameRate);\n  }\n\n  return Pair.create(format, frameDurationUs);\n}",
        "summary_tokens": [
            "parses",
            "the",
            "format",
            "and",
            "frame",
            "duration",
            "from",
            "a",
            "csd",
            "buffer"
        ]
    },
    {
        "id": 2066,
        "code": "private static void skipScalingList(ParsableNalUnitBitArray bitArray) {\n  for (int sizeId = 0; sizeId < 4; sizeId++) {\n    for (int matrixId = 0; matrixId < 6; matrixId += sizeId == 3 ? 3 : 1) {\n      if (!bitArray.readBit()) { \n          \n        bitArray.readUnsignedExpGolombCodedInt();\n      } else {\n        int coefNum = min(64, 1 << (4 + (sizeId << 1)));\n        if (sizeId > 1) {\n            \n          bitArray.readSignedExpGolombCodedInt();\n        }\n        for (int i = 0; i < coefNum; i++) {\n          bitArray.readSignedExpGolombCodedInt(); \n        }\n      }\n    }\n  }\n}",
        "summary_tokens": [
            "skips",
            "scaling",
            "list",
            "data"
        ]
    },
    {
        "id": 2067,
        "code": "private static void skipShortTermRefPicSets(ParsableNalUnitBitArray bitArray) {\n  int numShortTermRefPicSets = bitArray.readUnsignedExpGolombCodedInt();\n  boolean interRefPicSetPredictionFlag = false;\n  int numNegativePics;\n  int numPositivePics;\n    \n    \n    \n  int previousNumDeltaPocs = 0;\n  for (int stRpsIdx = 0; stRpsIdx < numShortTermRefPicSets; stRpsIdx++) {\n    if (stRpsIdx != 0) {\n      interRefPicSetPredictionFlag = bitArray.readBit();\n    }\n    if (interRefPicSetPredictionFlag) {\n      bitArray.skipBit(); \n      bitArray.readUnsignedExpGolombCodedInt(); \n      for (int j = 0; j <= previousNumDeltaPocs; j++) {\n        if (bitArray.readBit()) { \n          bitArray.skipBit(); \n        }\n      }\n    } else {\n      numNegativePics = bitArray.readUnsignedExpGolombCodedInt();\n      numPositivePics = bitArray.readUnsignedExpGolombCodedInt();\n      previousNumDeltaPocs = numNegativePics + numPositivePics;\n      for (int i = 0; i < numNegativePics; i++) {\n        bitArray.readUnsignedExpGolombCodedInt(); \n        bitArray.skipBit(); \n      }\n      for (int i = 0; i < numPositivePics; i++) {\n        bitArray.readUnsignedExpGolombCodedInt(); \n        bitArray.skipBit(); \n      }\n    }\n  }\n}",
        "summary_tokens": [
            "reads",
            "the",
            "number",
            "of",
            "short",
            "term",
            "reference",
            "picture",
            "sets",
            "in",
            "a",
            "sps",
            "as",
            "ue",
            "v",
            "then",
            "skips",
            "all",
            "of",
            "them"
        ]
    },
    {
        "id": 2068,
        "code": "private void parseAudioMuxElement(ParsableBitArray data) throws ParserException {\n  boolean useSameStreamMux = data.readBit();\n  if (!useSameStreamMux) {\n    streamMuxRead = true;\n    parseStreamMuxConfig(data);\n  } else if (!streamMuxRead) {\n    return; \n  }\n\n  if (audioMuxVersionA == 0) {\n    if (numSubframes != 0) {\n      throw ParserException.createForMalformedContainer( null,  null);\n    }\n    int muxSlotLengthBytes = parsePayloadLengthInfo(data);\n    parsePayloadMux(data, muxSlotLengthBytes);\n    if (otherDataPresent) {\n      data.skipBits((int) otherDataLenBits);\n    }\n  } else {\n      \n    throw ParserException.createForMalformedContainer( null,  null);\n  }\n}",
        "summary_tokens": [
            "parses",
            "an",
            "audio",
            "mux",
            "element",
            "as",
            "defined",
            "in",
            "0",
            "0",
            "0",
            "section",
            "0"
        ]
    },
    {
        "id": 2069,
        "code": "private void parseStreamMuxConfig(ParsableBitArray data) throws ParserException {\n  int audioMuxVersion = data.readBits(1);\n  audioMuxVersionA = audioMuxVersion == 1 ? data.readBits(1) : 0;\n  if (audioMuxVersionA == 0) {\n    if (audioMuxVersion == 1) {\n      latmGetValue(data); \n    }\n    if (!data.readBit()) {\n      throw ParserException.createForMalformedContainer( null,  null);\n    }\n    numSubframes = data.readBits(6);\n    int numProgram = data.readBits(4);\n    int numLayer = data.readBits(3);\n    if (numProgram != 0 || numLayer != 0) {\n      throw ParserException.createForMalformedContainer( null,  null);\n    }\n    if (audioMuxVersion == 0) {\n      int startPosition = data.getPosition();\n      int readBits = parseAudioSpecificConfig(data);\n      data.setPosition(startPosition);\n      byte[] initData = new byte[(readBits + 7) / 8];\n      data.readBits(initData, 0, readBits);\n      Format format =\n          new Format.Builder()\n              .setId(formatId)\n              .setSampleMimeType(MimeTypes.AUDIO_AAC)\n              .setCodecs(codecs)\n              .setChannelCount(channelCount)\n              .setSampleRate(sampleRateHz)\n              .setInitializationData(Collections.singletonList(initData))\n              .setLanguage(language)\n              .build();\n      if (!format.equals(this.format)) {\n        this.format = format;\n        sampleDurationUs = (C.MICROS_PER_SECOND * 1024) / format.sampleRate;\n        output.format(format);\n      }\n    } else {\n      int ascLen = (int) latmGetValue(data);\n      int bitsRead = parseAudioSpecificConfig(data);\n      data.skipBits(ascLen - bitsRead); \n    }\n    parseFrameLength(data);\n    otherDataPresent = data.readBit();\n    otherDataLenBits = 0;\n    if (otherDataPresent) {\n      if (audioMuxVersion == 1) {\n        otherDataLenBits = latmGetValue(data);\n      } else {\n        boolean otherDataLenEsc;\n        do {\n          otherDataLenEsc = data.readBit();\n          otherDataLenBits = (otherDataLenBits << 8) + data.readBits(8);\n        } while (otherDataLenEsc);\n      }\n    }\n    boolean crcCheckPresent = data.readBit();\n    if (crcCheckPresent) {\n      data.skipBits(8); \n    }\n  } else {\n      \n    throw ParserException.createForMalformedContainer( null,  null);\n  }\n}",
        "summary_tokens": [
            "parses",
            "a",
            "stream",
            "mux",
            "config",
            "as",
            "defined",
            "in",
            "iso",
            "iec",
            "0",
            "0",
            "0",
            "section",
            "0"
        ]
    },
    {
        "id": 2070,
        "code": "private void findHeader(ParsableByteArray source) {\n  byte[] data = source.getData();\n  int startOffset = source.getPosition();\n  int endOffset = source.limit();\n  for (int i = startOffset; i < endOffset; i++) {\n    boolean byteIsFF = (data[i] & 0xFF) == 0xFF;\n    boolean found = lastByteWasFF && (data[i] & 0xE0) == 0xE0;\n    lastByteWasFF = byteIsFF;\n    if (found) {\n      source.setPosition(i + 1);\n        \n      lastByteWasFF = false;\n      headerScratch.getData()[1] = data[i];\n      frameBytesRead = 2;\n      state = STATE_READING_HEADER;\n      return;\n    }\n  }\n  source.setPosition(endOffset);\n}",
        "summary_tokens": [
            "attempts",
            "to",
            "locate",
            "the",
            "start",
            "of",
            "the",
            "next",
            "frame",
            "header"
        ]
    },
    {
        "id": 2071,
        "code": "private void readHeaderRemainder(ParsableByteArray source) {\n  int bytesToRead = min(source.bytesLeft(), HEADER_SIZE - frameBytesRead);\n  source.readBytes(headerScratch.getData(), frameBytesRead, bytesToRead);\n  frameBytesRead += bytesToRead;\n  if (frameBytesRead < HEADER_SIZE) {\n      \n    return;\n  }\n\n  headerScratch.setPosition(0);\n  boolean parsedHeader = header.setForHeaderData(headerScratch.readInt());\n  if (!parsedHeader) {\n      \n    frameBytesRead = 0;\n    state = STATE_READING_HEADER;\n    return;\n  }\n\n  frameSize = header.frameSize;\n  if (!hasOutputFormat) {\n    frameDurationUs = (C.MICROS_PER_SECOND * header.samplesPerFrame) / header.sampleRate;\n    Format format =\n        new Format.Builder()\n            .setId(formatId)\n            .setSampleMimeType(header.mimeType)\n            .setMaxInputSize(MpegAudioUtil.MAX_FRAME_SIZE_BYTES)\n            .setChannelCount(header.channels)\n            .setSampleRate(header.sampleRate)\n            .setLanguage(language)\n            .build();\n    output.format(format);\n    hasOutputFormat = true;\n  }\n\n  headerScratch.setPosition(0);\n  output.sampleData(headerScratch, HEADER_SIZE);\n  state = STATE_READING_FRAME;\n}",
        "summary_tokens": [
            "attempts",
            "to",
            "read",
            "the",
            "remaining",
            "two",
            "bytes",
            "of",
            "the",
            "frame",
            "header"
        ]
    },
    {
        "id": 2072,
        "code": "private void readFrameRemainder(ParsableByteArray source) {\n  int bytesToRead = min(source.bytesLeft(), frameSize - frameBytesRead);\n  output.sampleData(source, bytesToRead);\n  frameBytesRead += bytesToRead;\n  if (frameBytesRead < frameSize) {\n      \n    return;\n  }\n\n  if (timeUs != C.TIME_UNSET) {\n    output.sampleMetadata(timeUs, C.BUFFER_FLAG_KEY_FRAME, frameSize, 0, null);\n    timeUs += frameDurationUs;\n  }\n  frameBytesRead = 0;\n  state = STATE_FINDING_HEADER;\n}",
        "summary_tokens": [
            "attempts",
            "to",
            "read",
            "the",
            "remainder",
            "of",
            "the",
            "frame"
        ]
    },
    {
        "id": 2073,
        "code": "public void reset() {\n  isFilling = false;\n  isCompleted = false;\n}",
        "summary_tokens": [
            "resets",
            "the",
            "buffer",
            "clearing",
            "any",
            "data",
            "that",
            "it",
            "holds"
        ]
    },
    {
        "id": 2074,
        "code": "public boolean isCompleted() {\n  return isCompleted;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "buffer",
            "currently",
            "holds",
            "a",
            "complete",
            "nal",
            "unit",
            "of",
            "the",
            "target",
            "type"
        ]
    },
    {
        "id": 2075,
        "code": "public void startNalUnit(int type) {\n  Assertions.checkState(!isFilling);\n  isFilling = type == targetType;\n  if (isFilling) {\n      \n    nalLength = 3;\n    isCompleted = false;\n  }\n}",
        "summary_tokens": [
            "called",
            "to",
            "indicate",
            "that",
            "a",
            "nal",
            "unit",
            "has",
            "started"
        ]
    },
    {
        "id": 2076,
        "code": "public void appendToNalUnit(byte[] data, int offset, int limit) {\n  if (!isFilling) {\n    return;\n  }\n  int readLength = limit - offset;\n  if (nalData.length < nalLength + readLength) {\n    nalData = Arrays.copyOf(nalData, (nalLength + readLength) * 2);\n  }\n  System.arraycopy(data, offset, nalData, nalLength, readLength);\n  nalLength += readLength;\n}",
        "summary_tokens": [
            "called",
            "to",
            "pass",
            "stream",
            "data"
        ]
    },
    {
        "id": 2077,
        "code": "public boolean endNalUnit(int discardPadding) {\n  if (!isFilling) {\n    return false;\n  }\n  nalLength -= discardPadding;\n  isFilling = false;\n  isCompleted = true;\n  return true;\n}",
        "summary_tokens": [
            "called",
            "to",
            "indicate",
            "that",
            "a",
            "nal",
            "unit",
            "has",
            "ended"
        ]
    },
    {
        "id": 2078,
        "code": "private boolean continueRead(\n    ParsableByteArray source, @Nullable byte[] target, int targetLength) {\n  int bytesToRead = min(source.bytesLeft(), targetLength - bytesRead);\n  if (bytesToRead <= 0) {\n    return true;\n  } else if (target == null) {\n    source.skipBytes(bytesToRead);\n  } else {\n    source.readBytes(target, bytesRead, bytesToRead);\n  }\n  bytesRead += bytesToRead;\n  return bytesRead == targetLength;\n}",
        "summary_tokens": [
            "continues",
            "a",
            "read",
            "from",
            "the",
            "provided",
            "source",
            "into",
            "a",
            "given",
            "target"
        ]
    },
    {
        "id": 2079,
        "code": "public boolean isDurationReadFinished() {\n  return isDurationRead;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "a",
            "ps",
            "duration",
            "has",
            "been",
            "read"
        ]
    },
    {
        "id": 2080,
        "code": "public @Extractor.ReadResult int readDuration(\n    ExtractorInput input, PositionHolder seekPositionHolder) throws IOException {\n  if (!isLastScrValueRead) {\n    return readLastScrValue(input, seekPositionHolder);\n  }\n  if (lastScrValue == C.TIME_UNSET) {\n    return finishReadDuration(input);\n  }\n  if (!isFirstScrValueRead) {\n    return readFirstScrValue(input, seekPositionHolder);\n  }\n  if (firstScrValue == C.TIME_UNSET) {\n    return finishReadDuration(input);\n  }\n\n  long minScrPositionUs = scrTimestampAdjuster.adjustTsTimestamp(firstScrValue);\n  long maxScrPositionUs = scrTimestampAdjuster.adjustTsTimestamp(lastScrValue);\n  durationUs = maxScrPositionUs - minScrPositionUs;\n  if (durationUs < 0) {\n    Log.w(TAG, \"Invalid duration: \" + durationUs + \". Using TIME_UNSET instead.\");\n    durationUs = C.TIME_UNSET;\n  }\n  return finishReadDuration(input);\n}",
        "summary_tokens": [
            "reads",
            "a",
            "ps",
            "duration",
            "from",
            "the",
            "input"
        ]
    },
    {
        "id": 2081,
        "code": "public long getDurationUs() {\n  return durationUs;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "duration",
            "last",
            "read",
            "from",
            "read",
            "duration",
            "extractor",
            "input",
            "position",
            "holder"
        ]
    },
    {
        "id": 2082,
        "code": "public static long readScrValueFromPack(ParsableByteArray packetBuffer) {\n  int originalPosition = packetBuffer.getPosition();\n  if (packetBuffer.bytesLeft() < 9) {\n      \n    return C.TIME_UNSET;\n  }\n  byte[] scrBytes = new byte[9];\n  packetBuffer.readBytes(scrBytes,  0, scrBytes.length);\n  packetBuffer.setPosition(originalPosition);\n  if (!checkMarkerBits(scrBytes)) {\n    return C.TIME_UNSET;\n  }\n  return readScrValueFromPackHeader(scrBytes);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "scr",
            "value",
            "read",
            "from",
            "the",
            "next",
            "pack",
            "in",
            "the",
            "stream",
            "given",
            "the",
            "buffer",
            "at",
            "the",
            "pack",
            "header",
            "start",
            "position",
            "just",
            "behind",
            "the",
            "pack",
            "start",
            "code"
        ]
    },
    {
        "id": 2083,
        "code": "private static long readScrValueFromPackHeader(byte[] scrBytes) {\n  return ((scrBytes[0] & 0b00111000L) >> 3) << 30\n      | (scrBytes[0] & 0b00000011L) << 28\n      | (scrBytes[1] & 0xFFL) << 20\n      | ((scrBytes[2] & 0b11111000L) >> 3) << 15\n      | (scrBytes[2] & 0b00000011L) << 13\n      | (scrBytes[3] & 0xFFL) << 5\n      | (scrBytes[4] & 0b11111000L) >> 3;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "value",
            "of",
            "scr",
            "base",
            "0",
            "bits",
            "in",
            "big",
            "endian",
            "order",
            "from",
            "the",
            "ps",
            "pack",
            "header",
            "ignoring",
            "the",
            "marker",
            "bits"
        ]
    },
    {
        "id": 2084,
        "code": "public boolean isDurationReadFinished() {\n  return isDurationRead;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "a",
            "ts",
            "duration",
            "has",
            "been",
            "read"
        ]
    },
    {
        "id": 2085,
        "code": "public @Extractor.ReadResult int readDuration(\n    ExtractorInput input, PositionHolder seekPositionHolder, int pcrPid) throws IOException {\n  if (pcrPid <= 0) {\n    return finishReadDuration(input);\n  }\n  if (!isLastPcrValueRead) {\n    return readLastPcrValue(input, seekPositionHolder, pcrPid);\n  }\n  if (lastPcrValue == C.TIME_UNSET) {\n    return finishReadDuration(input);\n  }\n  if (!isFirstPcrValueRead) {\n    return readFirstPcrValue(input, seekPositionHolder, pcrPid);\n  }\n  if (firstPcrValue == C.TIME_UNSET) {\n    return finishReadDuration(input);\n  }\n\n  long minPcrPositionUs = pcrTimestampAdjuster.adjustTsTimestamp(firstPcrValue);\n  long maxPcrPositionUs = pcrTimestampAdjuster.adjustTsTimestamp(lastPcrValue);\n  durationUs = maxPcrPositionUs - minPcrPositionUs;\n  if (durationUs < 0) {\n    Log.w(TAG, \"Invalid duration: \" + durationUs + \". Using TIME_UNSET instead.\");\n    durationUs = C.TIME_UNSET;\n  }\n  return finishReadDuration(input);\n}",
        "summary_tokens": [
            "reads",
            "a",
            "ts",
            "duration",
            "from",
            "the",
            "input",
            "using",
            "the",
            "given",
            "pcr",
            "pid"
        ]
    },
    {
        "id": 2086,
        "code": "public long getDurationUs() {\n  return durationUs;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "duration",
            "last",
            "read",
            "from",
            "read",
            "duration",
            "extractor",
            "input",
            "position",
            "holder",
            "int"
        ]
    },
    {
        "id": 2087,
        "code": "public TimestampAdjuster getPcrTimestampAdjuster() {\n  return pcrTimestampAdjuster;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "timestamp",
            "adjuster",
            "that",
            "this",
            "class",
            "uses",
            "to",
            "adjust",
            "timestamps",
            "read",
            "from",
            "the",
            "input",
            "ts",
            "stream"
        ]
    },
    {
        "id": 2088,
        "code": "public static boolean isStartOfTsPacket(byte[] data, int start, int limit, int searchPosition) {\n  int consecutiveSyncByteCount = 0;\n  for (int i = -4; i <= 4; i++) {\n    int currentPosition = searchPosition + i * TsExtractor.TS_PACKET_SIZE;\n    if (currentPosition < start\n        || currentPosition >= limit\n        || data[currentPosition] != TsExtractor.TS_SYNC_BYTE) {\n      consecutiveSyncByteCount = 0;\n    } else if (++consecutiveSyncByteCount == 5) {\n      return true;\n    }\n  }\n  return false;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "a",
            "ts",
            "packet",
            "starts",
            "at",
            "search",
            "position",
            "according",
            "to",
            "the",
            "mpeg",
            "ts",
            "synchronization",
            "recommendations"
        ]
    },
    {
        "id": 2089,
        "code": "public static int findSyncBytePosition(byte[] data, int startPosition, int limitPosition) {\n  int position = startPosition;\n  while (position < limitPosition && data[position] != TsExtractor.TS_SYNC_BYTE) {\n    position++;\n  }\n  return position;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "position",
            "of",
            "the",
            "first",
            "ts",
            "sync",
            "byte",
            "within",
            "the",
            "range",
            "start",
            "position",
            "limit",
            "position",
            "from",
            "the",
            "provided",
            "data",
            "array",
            "or",
            "returns",
            "limit",
            "position",
            "if",
            "sync",
            "byte",
            "could",
            "not",
            "be",
            "found"
        ]
    },
    {
        "id": 2090,
        "code": "public static long readPcrFromPacket(\n    ParsableByteArray packetBuffer, int startOfPacket, int pcrPid) {\n  packetBuffer.setPosition(startOfPacket);\n  if (packetBuffer.bytesLeft() < 5) {\n      \n    return C.TIME_UNSET;\n  }\n    \n  int tsPacketHeader = packetBuffer.readInt();\n  if ((tsPacketHeader & 0x800000) != 0) {\n      \n    return C.TIME_UNSET;\n  }\n  int pid = (tsPacketHeader & 0x1FFF00) >> 8;\n  if (pid != pcrPid) {\n    return C.TIME_UNSET;\n  }\n  boolean adaptationFieldExists = (tsPacketHeader & 0x20) != 0;\n  if (!adaptationFieldExists) {\n    return C.TIME_UNSET;\n  }\n\n  int adaptationFieldLength = packetBuffer.readUnsignedByte();\n  if (adaptationFieldLength >= 7 && packetBuffer.bytesLeft() >= 7) {\n    int flags = packetBuffer.readUnsignedByte();\n    boolean pcrFlagSet = (flags & 0x10) == 0x10;\n    if (pcrFlagSet) {\n      byte[] pcrBytes = new byte[6];\n      packetBuffer.readBytes(pcrBytes,  0, pcrBytes.length);\n      return readPcrValueFromPcrBytes(pcrBytes);\n    }\n  }\n  return C.TIME_UNSET;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "pcr",
            "value",
            "read",
            "from",
            "a",
            "given",
            "ts",
            "packet"
        ]
    },
    {
        "id": 2091,
        "code": "private static long readPcrValueFromPcrBytes(byte[] pcrBytes) {\n  return (pcrBytes[0] & 0xFFL) << 25\n      | (pcrBytes[1] & 0xFFL) << 17\n      | (pcrBytes[2] & 0xFFL) << 9\n      | (pcrBytes[3] & 0xFFL) << 1\n      | (pcrBytes[4] & 0xFFL) >> 7;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "value",
            "of",
            "pcr",
            "base",
            "first",
            "0",
            "bits",
            "in",
            "big",
            "endian",
            "order",
            "from",
            "the",
            "pcr",
            "bytes"
        ]
    },
    {
        "id": 2092,
        "code": "public static boolean checkFileType(ExtractorInput input) throws IOException {\n  ParsableByteArray scratch = new ParsableByteArray(ChunkHeader.SIZE_IN_BYTES);\n  ChunkHeader chunkHeader = ChunkHeader.peek(input, scratch);\n  if (chunkHeader.id != WavUtil.RIFF_FOURCC && chunkHeader.id != WavUtil.RF64_FOURCC) {\n    return false;\n  }\n\n  input.peekFully(scratch.getData(), 0, 4);\n  scratch.setPosition(0);\n  int formType = scratch.readInt();\n  if (formType != WavUtil.WAVE_FOURCC) {\n    Log.e(TAG, \"Unsupported form type: \" + formType);\n    return false;\n  }\n\n  return true;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "given",
            "input",
            "starts",
            "with",
            "a",
            "riff",
            "or",
            "rf",
            "0",
            "chunk",
            "header",
            "followed",
            "by",
            "a",
            "wave",
            "tag"
        ]
    },
    {
        "id": 2093,
        "code": "public static long readRf64SampleDataSize(ExtractorInput input) throws IOException {\n  ParsableByteArray scratch = new ParsableByteArray(ChunkHeader.SIZE_IN_BYTES);\n  ChunkHeader chunkHeader = ChunkHeader.peek(input, scratch);\n  if (chunkHeader.id != WavUtil.DS64_FOURCC) {\n    input.resetPeekPosition();\n    return C.LENGTH_UNSET;\n  }\n  input.advancePeekPosition(8); \n  scratch.setPosition(0);\n  input.peekFully(scratch.getData(), 0, 8);\n  long sampleDataSize = scratch.readLittleEndianLong();\n  input.skipFully(ChunkHeader.SIZE_IN_BYTES + (int) chunkHeader.size);\n  return sampleDataSize;\n}",
        "summary_tokens": [
            "reads",
            "the",
            "ds",
            "0",
            "chunk",
            "defined",
            "in",
            "ebu",
            "tech",
            "0",
            "0",
            "if",
            "present"
        ]
    },
    {
        "id": 2094,
        "code": "public static WavFormat readFormat(ExtractorInput input) throws IOException {\n    \n  ParsableByteArray scratch = new ParsableByteArray(16);\n    \n  ChunkHeader chunkHeader = skipToChunk( WavUtil.FMT_FOURCC, input, scratch);\n  Assertions.checkState(chunkHeader.size >= 16);\n  input.peekFully(scratch.getData(), 0, 16);\n  scratch.setPosition(0);\n  int audioFormatType = scratch.readLittleEndianUnsignedShort();\n  int numChannels = scratch.readLittleEndianUnsignedShort();\n  int frameRateHz = scratch.readLittleEndianUnsignedIntToInt();\n  int averageBytesPerSecond = scratch.readLittleEndianUnsignedIntToInt();\n  int blockSize = scratch.readLittleEndianUnsignedShort();\n  int bitsPerSample = scratch.readLittleEndianUnsignedShort();\n\n  int bytesLeft = (int) chunkHeader.size - 16;\n  byte[] extraData;\n  if (bytesLeft > 0) {\n    extraData = new byte[bytesLeft];\n    input.peekFully(extraData, 0, bytesLeft);\n  } else {\n    extraData = Util.EMPTY_BYTE_ARRAY;\n  }\n\n  input.skipFully((int) (input.getPeekPosition() - input.getPosition()));\n  return new WavFormat(\n      audioFormatType,\n      numChannels,\n      frameRateHz,\n      averageBytesPerSecond,\n      blockSize,\n      bitsPerSample,\n      extraData);\n}",
        "summary_tokens": [
            "reads",
            "and",
            "returns",
            "a",
            "wav",
            "format"
        ]
    },
    {
        "id": 2095,
        "code": "public static Pair<Long, Long> skipToSampleData(ExtractorInput input) throws IOException {\n    \n  input.resetPeekPosition();\n\n  ParsableByteArray scratch = new ParsableByteArray(ChunkHeader.SIZE_IN_BYTES);\n    \n  ChunkHeader chunkHeader = skipToChunk( WavUtil.DATA_FOURCC, input, scratch);\n    \n  input.skipFully(ChunkHeader.SIZE_IN_BYTES);\n\n  long dataStartPosition = input.getPosition();\n  return Pair.create(dataStartPosition, chunkHeader.size);\n}",
        "summary_tokens": [
            "skips",
            "to",
            "the",
            "data",
            "in",
            "the",
            "given",
            "wav",
            "input",
            "stream",
            "and",
            "returns",
            "its",
            "start",
            "position",
            "and",
            "size"
        ]
    },
    {
        "id": 2096,
        "code": "private static ChunkHeader skipToChunk(\n    int chunkId, ExtractorInput input, ParsableByteArray scratch) throws IOException {\n  ChunkHeader chunkHeader = ChunkHeader.peek(input, scratch);\n  while (chunkHeader.id != chunkId) {\n    Log.w(TAG, \"Ignoring unknown WAV chunk: \" + chunkHeader.id);\n    long bytesToSkip = ChunkHeader.SIZE_IN_BYTES + chunkHeader.size;\n    if (bytesToSkip > Integer.MAX_VALUE) {\n      throw ParserException.createForUnsupportedContainerFeature(\n          \"Chunk is too large (~2GB+) to skip; id: \" + chunkHeader.id);\n    }\n    input.skipFully((int) bytesToSkip);\n    chunkHeader = ChunkHeader.peek(input, scratch);\n  }\n  return chunkHeader;\n}",
        "summary_tokens": [
            "skips",
            "to",
            "the",
            "chunk",
            "header",
            "corresponding",
            "to",
            "the",
            "chunk",
            "id",
            "provided"
        ]
    },
    {
        "id": 2097,
        "code": "public byte[] encode(EventMessage eventMessage) {\n  byteArrayOutputStream.reset();\n  try {\n    writeNullTerminatedString(dataOutputStream, eventMessage.schemeIdUri);\n    String nonNullValue = eventMessage.value != null ? eventMessage.value : \"\";\n    writeNullTerminatedString(dataOutputStream, nonNullValue);\n    dataOutputStream.writeLong(eventMessage.durationMs);\n    dataOutputStream.writeLong(eventMessage.id);\n    dataOutputStream.write(eventMessage.messageData);\n    dataOutputStream.flush();\n    return byteArrayOutputStream.toByteArray();\n  } catch (IOException e) {\n      \n    throw new RuntimeException(e);\n  }\n}",
        "summary_tokens": [
            "encodes",
            "an",
            "event",
            "message",
            "to",
            "a",
            "byte",
            "array",
            "that",
            "can",
            "be",
            "decoded",
            "by",
            "event",
            "message",
            "decoder"
        ]
    },
    {
        "id": 2098,
        "code": "public static PictureFrame fromPictureBlock(ParsableByteArray pictureBlock) {\n  int pictureType = pictureBlock.readInt();\n  int mimeTypeLength = pictureBlock.readInt();\n  String mimeType = pictureBlock.readString(mimeTypeLength, Charsets.US_ASCII);\n  int descriptionLength = pictureBlock.readInt();\n  String description = pictureBlock.readString(descriptionLength);\n  int width = pictureBlock.readInt();\n  int height = pictureBlock.readInt();\n  int depth = pictureBlock.readInt();\n  int colors = pictureBlock.readInt();\n  int pictureDataLength = pictureBlock.readInt();\n  byte[] pictureData = new byte[pictureDataLength];\n  pictureBlock.readBytes(pictureData, 0, pictureDataLength);\n\n  return new PictureFrame(\n      pictureType, mimeType, description, width, height, depth, colors, pictureData);\n}",
        "summary_tokens": [
            "parses",
            "a",
            "metadata",
            "block",
            "picture",
            "into",
            "a",
            "picture",
            "frame",
            "instance"
        ]
    },
    {
        "id": 2099,
        "code": "public static IcyHeaders parse(Map<String, List<String>> responseHeaders) {\n  boolean icyHeadersPresent = false;\n  int bitrate = Format.NO_VALUE;\n  String genre = null;\n  String name = null;\n  String url = null;\n  boolean isPublic = false;\n  int metadataInterval = C.LENGTH_UNSET;\n\n  List<String> headers = responseHeaders.get(RESPONSE_HEADER_BITRATE);\n  if (headers != null) {\n    String bitrateHeader = headers.get(0);\n    try {\n      bitrate = Integer.parseInt(bitrateHeader) * 1000;\n      if (bitrate > 0) {\n        icyHeadersPresent = true;\n      } else {\n        Log.w(TAG, \"Invalid bitrate: \" + bitrateHeader);\n        bitrate = Format.NO_VALUE;\n      }\n    } catch (NumberFormatException e) {\n      Log.w(TAG, \"Invalid bitrate header: \" + bitrateHeader);\n    }\n  }\n  headers = responseHeaders.get(RESPONSE_HEADER_GENRE);\n  if (headers != null) {\n    genre = headers.get(0);\n    icyHeadersPresent = true;\n  }\n  headers = responseHeaders.get(RESPONSE_HEADER_NAME);\n  if (headers != null) {\n    name = headers.get(0);\n    icyHeadersPresent = true;\n  }\n  headers = responseHeaders.get(RESPONSE_HEADER_URL);\n  if (headers != null) {\n    url = headers.get(0);\n    icyHeadersPresent = true;\n  }\n  headers = responseHeaders.get(RESPONSE_HEADER_PUB);\n  if (headers != null) {\n    isPublic = headers.get(0).equals(\"1\");\n    icyHeadersPresent = true;\n  }\n  headers = responseHeaders.get(RESPONSE_HEADER_METADATA_INTERVAL);\n  if (headers != null) {\n    String metadataIntervalHeader = headers.get(0);\n    try {\n      metadataInterval = Integer.parseInt(metadataIntervalHeader);\n      if (metadataInterval > 0) {\n        icyHeadersPresent = true;\n      } else {\n        Log.w(TAG, \"Invalid metadata interval: \" + metadataIntervalHeader);\n        metadataInterval = C.LENGTH_UNSET;\n      }\n    } catch (NumberFormatException e) {\n      Log.w(TAG, \"Invalid metadata interval: \" + metadataIntervalHeader);\n    }\n  }\n  return icyHeadersPresent\n      ? new IcyHeaders(bitrate, genre, name, url, isPublic, metadataInterval)\n      : null;\n}",
        "summary_tokens": [
            "parses",
            "icy",
            "headers",
            "from",
            "response",
            "headers"
        ]
    },
    {
        "id": 2100,
        "code": "public int getSubFrameCount() {\n  return subFrames.length;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "sub",
            "frames"
        ]
    },
    {
        "id": 2101,
        "code": "public Id3Frame getSubFrame(int index) {\n  return subFrames[index];\n}",
        "summary_tokens": [
            "returns",
            "the",
            "sub",
            "frame",
            "at",
            "index"
        ]
    },
    {
        "id": 2102,
        "code": "public int getSubFrameCount() {\n  return subFrames.length;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "sub",
            "frames"
        ]
    },
    {
        "id": 2103,
        "code": "public Id3Frame getSubFrame(int index) {\n  return subFrames[index];\n}",
        "summary_tokens": [
            "returns",
            "the",
            "sub",
            "frame",
            "at",
            "index"
        ]
    },
    {
        "id": 2104,
        "code": "public Metadata decode(byte[] data, int size) {\n  List<Id3Frame> id3Frames = new ArrayList<>();\n  ParsableByteArray id3Data = new ParsableByteArray(data, size);\n\n  @Nullable Id3Header id3Header = decodeHeader(id3Data);\n  if (id3Header == null) {\n    return null;\n  }\n\n  int startPosition = id3Data.getPosition();\n  int frameHeaderSize = id3Header.majorVersion == 2 ? 6 : 10;\n  int framesSize = id3Header.framesSize;\n  if (id3Header.isUnsynchronized) {\n    framesSize = removeUnsynchronization(id3Data, id3Header.framesSize);\n  }\n  id3Data.setLimit(startPosition + framesSize);\n\n  boolean unsignedIntFrameSizeHack = false;\n  if (!validateFrames(id3Data, id3Header.majorVersion, frameHeaderSize, false)) {\n    if (id3Header.majorVersion == 4 && validateFrames(id3Data, 4, frameHeaderSize, true)) {\n      unsignedIntFrameSizeHack = true;\n    } else {\n      Log.w(TAG, \"Failed to validate ID3 tag with majorVersion=\" + id3Header.majorVersion);\n      return null;\n    }\n  }\n\n  while (id3Data.bytesLeft() >= frameHeaderSize) {\n    @Nullable\n    Id3Frame frame =\n        decodeFrame(\n            id3Header.majorVersion,\n            id3Data,\n            unsignedIntFrameSizeHack,\n            frameHeaderSize,\n            framePredicate);\n    if (frame != null) {\n      id3Frames.add(frame);\n    }\n  }\n\n  return new Metadata(id3Frames);\n}",
        "summary_tokens": [
            "decodes",
            "id",
            "0",
            "tags"
        ]
    },
    {
        "id": 2105,
        "code": "private static Id3Header decodeHeader(ParsableByteArray data) {\n  if (data.bytesLeft() < ID3_HEADER_LENGTH) {\n    Log.w(TAG, \"Data too short to be an ID3 tag\");\n    return null;\n  }\n\n  int id = data.readUnsignedInt24();\n  if (id != ID3_TAG) {\n    Log.w(TAG, \"Unexpected first three bytes of ID3 tag header: 0x\" + String.format(\"%06X\", id));\n    return null;\n  }\n\n  int majorVersion = data.readUnsignedByte();\n  data.skipBytes(1); \n  int flags = data.readUnsignedByte();\n  int framesSize = data.readSynchSafeInt();\n\n  if (majorVersion == 2) {\n    boolean isCompressed = (flags & 0x40) != 0;\n    if (isCompressed) {\n      Log.w(TAG, \"Skipped ID3 tag with majorVersion=2 and undefined compression scheme\");\n      return null;\n    }\n  } else if (majorVersion == 3) {\n    boolean hasExtendedHeader = (flags & 0x40) != 0;\n    if (hasExtendedHeader) {\n      int extendedHeaderSize = data.readInt(); \n      data.skipBytes(extendedHeaderSize);\n      framesSize -= (extendedHeaderSize + 4);\n    }\n  } else if (majorVersion == 4) {\n    boolean hasExtendedHeader = (flags & 0x40) != 0;\n    if (hasExtendedHeader) {\n      int extendedHeaderSize = data.readSynchSafeInt(); \n      data.skipBytes(extendedHeaderSize - 4);\n      framesSize -= extendedHeaderSize;\n    }\n    boolean hasFooter = (flags & 0x10) != 0;\n    if (hasFooter) {\n      framesSize -= 10;\n    }\n  } else {\n    Log.w(TAG, \"Skipped ID3 tag with unsupported majorVersion=\" + majorVersion);\n    return null;\n  }\n\n    \n  boolean isUnsynchronized = majorVersion < 4 && (flags & 0x80) != 0;\n  return new Id3Header(majorVersion, isUnsynchronized, framesSize);\n}",
        "summary_tokens": [
            "data",
            "a",
            "parsable",
            "byte",
            "array",
            "from",
            "which",
            "the",
            "header",
            "should",
            "be",
            "read"
        ]
    },
    {
        "id": 2106,
        "code": "private static int removeUnsynchronization(ParsableByteArray data, int length) {\n  byte[] bytes = data.getData();\n  int startPosition = data.getPosition();\n  for (int i = startPosition; i + 1 < startPosition + length; i++) {\n    if ((bytes[i] & 0xFF) == 0xFF && bytes[i + 1] == 0x00) {\n      int relativePosition = i - startPosition;\n      System.arraycopy(bytes, i + 2, bytes, i + 1, length - relativePosition - 2);\n      length--;\n    }\n  }\n  return length;\n}",
        "summary_tokens": [
            "performs",
            "in",
            "place",
            "removal",
            "of",
            "unsynchronization",
            "for",
            "length",
            "bytes",
            "starting",
            "from",
            "parsable",
            "byte",
            "array",
            "get",
            "position"
        ]
    },
    {
        "id": 2107,
        "code": "private static String getCharsetName(int encodingByte) {\n  switch (encodingByte) {\n    case ID3_TEXT_ENCODING_UTF_16:\n      return \"UTF-16\";\n    case ID3_TEXT_ENCODING_UTF_16BE:\n      return \"UTF-16BE\";\n    case ID3_TEXT_ENCODING_UTF_8:\n      return \"UTF-8\";\n    case ID3_TEXT_ENCODING_ISO_8859_1:\n    default:\n      return \"ISO-8859-1\";\n  }\n}",
        "summary_tokens": [
            "maps",
            "encoding",
            "byte",
            "from",
            "id",
            "0",
            "v",
            "0",
            "frame",
            "to",
            "a",
            "charset"
        ]
    },
    {
        "id": 2108,
        "code": "private static byte[] copyOfRangeIfValid(byte[] data, int from, int to) {\n  if (to <= from) {\n      \n    return Util.EMPTY_BYTE_ARRAY;\n  }\n  return Arrays.copyOfRange(data, from, to);\n}",
        "summary_tokens": [
            "copies",
            "the",
            "specified",
            "range",
            "of",
            "an",
            "array",
            "or",
            "returns",
            "a",
            "zero",
            "length",
            "array",
            "if",
            "the",
            "range",
            "is",
            "invalid"
        ]
    },
    {
        "id": 2109,
        "code": "private static String decodeStringIfValid(byte[] data, int from, int to, String charsetName)\n    throws UnsupportedEncodingException {\n  if (to <= from || to > data.length) {\n    return \"\";\n  }\n  return new String(data, from, to - from, charsetName);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "string",
            "obtained",
            "by",
            "decoding",
            "the",
            "specified",
            "range",
            "of",
            "data",
            "using",
            "the",
            "specified",
            "charset",
            "name"
        ]
    },
    {
        "id": 2110,
        "code": " static long parseSpliceTime(ParsableByteArray sectionData, long ptsAdjustment) {\n  long firstByte = sectionData.readUnsignedByte();\n  long ptsTime = C.TIME_UNSET;\n  if ((firstByte & 0x80) != 0 ) {\n      \n    ptsTime = (firstByte & 0x01) << 32 | sectionData.readUnsignedInt();\n    ptsTime += ptsAdjustment;\n    ptsTime &= 0x1FFFFFFFFL;\n  }\n  return ptsTime;\n}",
        "summary_tokens": [
            "parses",
            "pts",
            "time",
            "from",
            "splice",
            "time",
            "defined",
            "in",
            "section",
            "0"
        ]
    },
    {
        "id": 2111,
        "code": "public ImmutableList<Cue> decode(byte[] bytes) {\n  Parcel parcel = Parcel.obtain();\n  parcel.unmarshall(bytes, 0, bytes.length);\n  parcel.setDataPosition(0);\n  Bundle bundle = parcel.readBundle(Bundle.class.getClassLoader());\n  parcel.recycle();\n  ArrayList<Bundle> bundledCues =\n      Assertions.checkNotNull(bundle.getParcelableArrayList(BUNDLED_CUES));\n\n  return BundleableUtil.fromBundleList(Cue.CREATOR, bundledCues);\n}",
        "summary_tokens": [
            "decodes",
            "byte",
            "array",
            "into",
            "list",
            "of",
            "cue",
            "objects"
        ]
    },
    {
        "id": 2112,
        "code": "public byte[] encode(List<Cue> cues) {\n  ArrayList<Bundle> bundledCues = BundleableUtil.toBundleArrayList(cues);\n  Bundle allCuesBundle = new Bundle();\n  allCuesBundle.putParcelableArrayList(CueDecoder.BUNDLED_CUES, bundledCues);\n  Parcel parcel = Parcel.obtain();\n  parcel.writeBundle(allCuesBundle);\n  byte[] bytes = parcel.marshall();\n  parcel.recycle();\n\n  return bytes;\n}",
        "summary_tokens": [
            "encodes",
            "an",
            "list",
            "of",
            "cue",
            "to",
            "a",
            "byte",
            "array",
            "that",
            "can",
            "be",
            "decoded",
            "by",
            "cue",
            "decoder"
        ]
    },
    {
        "id": 2113,
        "code": "public void release() {\n  if (state == STATE_RELEASED) {\n    return;\n  }\n  subtitleDecoder.release();\n  state = STATE_RELEASED;\n}",
        "summary_tokens": [
            "releases",
            "the",
            "extractor",
            "s",
            "resources",
            "including",
            "the",
            "subtitle",
            "decoder"
        ]
    },
    {
        "id": 2114,
        "code": "private boolean skipInput(ExtractorInput input) throws IOException {\n  return input.skip(\n          input.getLength() != C.LENGTH_UNSET\n              ? Ints.checkedCast(input.getLength())\n              : DEFAULT_BUFFER_SIZE)\n      == C.RESULT_END_OF_INPUT;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "input",
            "has",
            "been",
            "fully",
            "skipped"
        ]
    },
    {
        "id": 2115,
        "code": "private boolean readFromInput(ExtractorInput input) throws IOException {\n  if (subtitleData.capacity() == bytesRead) {\n    subtitleData.ensureCapacity(bytesRead + DEFAULT_BUFFER_SIZE);\n  }\n  int readResult =\n      input.read(subtitleData.getData(), bytesRead, subtitleData.capacity() - bytesRead);\n  if (readResult != C.RESULT_END_OF_INPUT) {\n    bytesRead += readResult;\n  }\n  long inputLength = input.getLength();\n  return (inputLength != C.LENGTH_UNSET && bytesRead == inputLength)\n      || readResult == C.RESULT_END_OF_INPUT;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "reading",
            "has",
            "been",
            "finished"
        ]
    },
    {
        "id": 2116,
        "code": "private void decode() throws IOException {\n  try {\n    @Nullable SubtitleInputBuffer inputBuffer = subtitleDecoder.dequeueInputBuffer();\n    while (inputBuffer == null) {\n      Thread.sleep(5);\n      inputBuffer = subtitleDecoder.dequeueInputBuffer();\n    }\n    inputBuffer.ensureSpaceForWrite(bytesRead);\n    inputBuffer.data.put(subtitleData.getData(),  0, bytesRead);\n    inputBuffer.data.limit(bytesRead);\n    subtitleDecoder.queueInputBuffer(inputBuffer);\n    @Nullable SubtitleOutputBuffer outputBuffer = subtitleDecoder.dequeueOutputBuffer();\n    while (outputBuffer == null) {\n      Thread.sleep(5);\n      outputBuffer = subtitleDecoder.dequeueOutputBuffer();\n    }\n    for (int i = 0; i < outputBuffer.getEventTimeCount(); i++) {\n      List<Cue> cues = outputBuffer.getCues(outputBuffer.getEventTime(i));\n      byte[] cuesSample = cueEncoder.encode(cues);\n      timestamps.add(outputBuffer.getEventTime(i));\n      samples.add(new ParsableByteArray(cuesSample));\n    }\n    outputBuffer.release();\n  } catch (InterruptedException e) {\n    Thread.currentThread().interrupt();\n    throw new InterruptedIOException();\n  } catch (SubtitleDecoderException e) {\n    throw ParserException.createForMalformedContainer(\"SubtitleDecoder failed.\", e);\n  }\n}",
        "summary_tokens": [
            "decodes",
            "the",
            "subtitle",
            "data",
            "and",
            "stores",
            "the",
            "samples",
            "in",
            "the",
            "memory",
            "of",
            "the",
            "extractor"
        ]
    },
    {
        "id": 2117,
        "code": "public void setContent(long timeUs, Subtitle subtitle, long subsampleOffsetUs) {\n  this.timeUs = timeUs;\n  this.subtitle = subtitle;\n  this.subsampleOffsetUs =\n      subsampleOffsetUs == Format.OFFSET_SAMPLE_RELATIVE ? this.timeUs : subsampleOffsetUs;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "content",
            "of",
            "the",
            "output",
            "buffer",
            "consisting",
            "of",
            "a",
            "subtitle",
            "and",
            "associated",
            "metadata"
        ]
    },
    {
        "id": 2118,
        "code": "public List<Cue> decode(byte[] data, int limit) {\n    \n  ParsableBitArray dataBitArray = new ParsableBitArray(data, limit);\n  while (dataBitArray.bitsLeft() >= 48 \n      && dataBitArray.readBits(8) == 0x0F) {\n    parseSubtitlingSegment(dataBitArray, subtitleService);\n  }\n\n  @Nullable PageComposition pageComposition = subtitleService.pageComposition;\n  if (pageComposition == null) {\n    return Collections.emptyList();\n  }\n\n    \n  DisplayDefinition displayDefinition =\n      subtitleService.displayDefinition != null\n          ? subtitleService.displayDefinition\n          : defaultDisplayDefinition;\n  if (bitmap == null\n      || displayDefinition.width + 1 != bitmap.getWidth()\n      || displayDefinition.height + 1 != bitmap.getHeight()) {\n    bitmap =\n        Bitmap.createBitmap(\n            displayDefinition.width + 1, displayDefinition.height + 1, Bitmap.Config.ARGB_8888);\n    canvas.setBitmap(bitmap);\n  }\n\n    \n  List<Cue> cues = new ArrayList<>();\n  SparseArray<PageRegion> pageRegions = pageComposition.regions;\n  for (int i = 0; i < pageRegions.size(); i++) {\n      \n    canvas.save();\n    PageRegion pageRegion = pageRegions.valueAt(i);\n    int regionId = pageRegions.keyAt(i);\n    RegionComposition regionComposition = subtitleService.regions.get(regionId);\n\n      \n    int baseHorizontalAddress =\n        pageRegion.horizontalAddress + displayDefinition.horizontalPositionMinimum;\n    int baseVerticalAddress =\n        pageRegion.verticalAddress + displayDefinition.verticalPositionMinimum;\n    int clipRight =\n        min(\n            baseHorizontalAddress + regionComposition.width,\n            displayDefinition.horizontalPositionMaximum);\n    int clipBottom =\n        min(\n            baseVerticalAddress + regionComposition.height,\n            displayDefinition.verticalPositionMaximum);\n    canvas.clipRect(baseHorizontalAddress, baseVerticalAddress, clipRight, clipBottom);\n    ClutDefinition clutDefinition = subtitleService.cluts.get(regionComposition.clutId);\n    if (clutDefinition == null) {\n      clutDefinition = subtitleService.ancillaryCluts.get(regionComposition.clutId);\n      if (clutDefinition == null) {\n        clutDefinition = defaultClutDefinition;\n      }\n    }\n\n    SparseArray<RegionObject> regionObjects = regionComposition.regionObjects;\n    for (int j = 0; j < regionObjects.size(); j++) {\n      int objectId = regionObjects.keyAt(j);\n      RegionObject regionObject = regionObjects.valueAt(j);\n      ObjectData objectData = subtitleService.objects.get(objectId);\n      if (objectData == null) {\n        objectData = subtitleService.ancillaryObjects.get(objectId);\n      }\n      if (objectData != null) {\n        @Nullable Paint paint = objectData.nonModifyingColorFlag ? null : defaultPaint;\n        paintPixelDataSubBlocks(\n            objectData,\n            clutDefinition,\n            regionComposition.depth,\n            baseHorizontalAddress + regionObject.horizontalPosition,\n            baseVerticalAddress + regionObject.verticalPosition,\n            paint,\n            canvas);\n      }\n    }\n\n    if (regionComposition.fillFlag) {\n      int color;\n      if (regionComposition.depth == REGION_DEPTH_8_BIT) {\n        color = clutDefinition.clutEntries8Bit[regionComposition.pixelCode8Bit];\n      } else if (regionComposition.depth == REGION_DEPTH_4_BIT) {\n        color = clutDefinition.clutEntries4Bit[regionComposition.pixelCode4Bit];\n      } else {\n        color = clutDefinition.clutEntries2Bit[regionComposition.pixelCode2Bit];\n      }\n      fillRegionPaint.setColor(color);\n      canvas.drawRect(\n          baseHorizontalAddress,\n          baseVerticalAddress,\n          baseHorizontalAddress + regionComposition.width,\n          baseVerticalAddress + regionComposition.height,\n          fillRegionPaint);\n    }\n\n    cues.add(\n        new Cue.Builder()\n            .setBitmap(\n                Bitmap.createBitmap(\n                    bitmap,\n                    baseHorizontalAddress,\n                    baseVerticalAddress,\n                    regionComposition.width,\n                    regionComposition.height))\n            .setPosition((float) baseHorizontalAddress / displayDefinition.width)\n            .setPositionAnchor(Cue.ANCHOR_TYPE_START)\n            .setLine(\n                (float) baseVerticalAddress / displayDefinition.height, Cue.LINE_TYPE_FRACTION)\n            .setLineAnchor(Cue.ANCHOR_TYPE_START)\n            .setSize((float) regionComposition.width / displayDefinition.width)\n            .setBitmapHeight((float) regionComposition.height / displayDefinition.height)\n            .build());\n\n    canvas.drawColor(Color.TRANSPARENT, PorterDuff.Mode.CLEAR);\n      \n    canvas.restore();\n  }\n\n  return Collections.unmodifiableList(cues);\n}",
        "summary_tokens": [
            "decodes",
            "a",
            "subtitling",
            "packet",
            "returning",
            "a",
            "list",
            "of",
            "parsed",
            "cue",
            "s"
        ]
    },
    {
        "id": 2119,
        "code": "private static void parseSubtitlingSegment(ParsableBitArray data, SubtitleService service) {\n  int segmentType = data.readBits(8);\n  int pageId = data.readBits(16);\n  int dataFieldLength = data.readBits(16);\n  int dataFieldLimit = data.getBytePosition() + dataFieldLength;\n\n  if ((dataFieldLength * 8) > data.bitsLeft()) {\n    Log.w(TAG, \"Data field length exceeds limit\");\n      \n    data.skipBits(data.bitsLeft());\n    return;\n  }\n\n  switch (segmentType) {\n    case SEGMENT_TYPE_DISPLAY_DEFINITION:\n      if (pageId == service.subtitlePageId) {\n        service.displayDefinition = parseDisplayDefinition(data);\n      }\n      break;\n    case SEGMENT_TYPE_PAGE_COMPOSITION:\n      if (pageId == service.subtitlePageId) {\n        @Nullable PageComposition current = service.pageComposition;\n        PageComposition pageComposition = parsePageComposition(data, dataFieldLength);\n        if (pageComposition.state != PAGE_STATE_NORMAL) {\n          service.pageComposition = pageComposition;\n          service.regions.clear();\n          service.cluts.clear();\n          service.objects.clear();\n        } else if (current != null && current.version != pageComposition.version) {\n          service.pageComposition = pageComposition;\n        }\n      }\n      break;\n    case SEGMENT_TYPE_REGION_COMPOSITION:\n      @Nullable PageComposition pageComposition = service.pageComposition;\n      if (pageId == service.subtitlePageId && pageComposition != null) {\n        RegionComposition regionComposition = parseRegionComposition(data, dataFieldLength);\n        if (pageComposition.state == PAGE_STATE_NORMAL) {\n          @Nullable\n          RegionComposition existingRegionComposition = service.regions.get(regionComposition.id);\n          if (existingRegionComposition != null) {\n            regionComposition.mergeFrom(existingRegionComposition);\n          }\n        }\n        service.regions.put(regionComposition.id, regionComposition);\n      }\n      break;\n    case SEGMENT_TYPE_CLUT_DEFINITION:\n      if (pageId == service.subtitlePageId) {\n        ClutDefinition clutDefinition = parseClutDefinition(data, dataFieldLength);\n        service.cluts.put(clutDefinition.id, clutDefinition);\n      } else if (pageId == service.ancillaryPageId) {\n        ClutDefinition clutDefinition = parseClutDefinition(data, dataFieldLength);\n        service.ancillaryCluts.put(clutDefinition.id, clutDefinition);\n      }\n      break;\n    case SEGMENT_TYPE_OBJECT_DATA:\n      if (pageId == service.subtitlePageId) {\n        ObjectData objectData = parseObjectData(data);\n        service.objects.put(objectData.id, objectData);\n      } else if (pageId == service.ancillaryPageId) {\n        ObjectData objectData = parseObjectData(data);\n        service.ancillaryObjects.put(objectData.id, objectData);\n      }\n      break;\n    default:\n        \n      break;\n  }\n\n    \n  data.skipBytes(dataFieldLimit - data.getBytePosition());\n}",
        "summary_tokens": [
            "parses",
            "a",
            "subtitling",
            "segment",
            "as",
            "defined",
            "by",
            "etsi",
            "en",
            "0",
            "0",
            "0"
        ]
    },
    {
        "id": 2120,
        "code": "private static DisplayDefinition parseDisplayDefinition(ParsableBitArray data) {\n  data.skipBits(4); \n  boolean displayWindowFlag = data.readBit();\n  data.skipBits(3); \n  int width = data.readBits(16);\n  int height = data.readBits(16);\n\n  int horizontalPositionMinimum;\n  int horizontalPositionMaximum;\n  int verticalPositionMinimum;\n  int verticalPositionMaximum;\n  if (displayWindowFlag) {\n    horizontalPositionMinimum = data.readBits(16);\n    horizontalPositionMaximum = data.readBits(16);\n    verticalPositionMinimum = data.readBits(16);\n    verticalPositionMaximum = data.readBits(16);\n  } else {\n    horizontalPositionMinimum = 0;\n    horizontalPositionMaximum = width;\n    verticalPositionMinimum = 0;\n    verticalPositionMaximum = height;\n  }\n\n  return new DisplayDefinition(\n      width,\n      height,\n      horizontalPositionMinimum,\n      horizontalPositionMaximum,\n      verticalPositionMinimum,\n      verticalPositionMaximum);\n}",
        "summary_tokens": [
            "parses",
            "a",
            "display",
            "definition",
            "segment",
            "as",
            "defined",
            "by",
            "etsi",
            "en",
            "0",
            "0",
            "0"
        ]
    },
    {
        "id": 2121,
        "code": "private static PageComposition parsePageComposition(ParsableBitArray data, int length) {\n  int timeoutSecs = data.readBits(8);\n  int version = data.readBits(4);\n  int state = data.readBits(2);\n  data.skipBits(2);\n  int remainingLength = length - 2;\n\n  SparseArray<PageRegion> regions = new SparseArray<>();\n  while (remainingLength > 0) {\n    int regionId = data.readBits(8);\n    data.skipBits(8); \n    int regionHorizontalAddress = data.readBits(16);\n    int regionVerticalAddress = data.readBits(16);\n    remainingLength -= 6;\n    regions.put(regionId, new PageRegion(regionHorizontalAddress, regionVerticalAddress));\n  }\n\n  return new PageComposition(timeoutSecs, version, state, regions);\n}",
        "summary_tokens": [
            "parses",
            "a",
            "page",
            "composition",
            "segment",
            "as",
            "defined",
            "by",
            "etsi",
            "en",
            "0",
            "0",
            "0"
        ]
    },
    {
        "id": 2122,
        "code": "private static RegionComposition parseRegionComposition(ParsableBitArray data, int length) {\n  int id = data.readBits(8);\n  data.skipBits(4); \n  boolean fillFlag = data.readBit();\n  data.skipBits(3); \n  int width = data.readBits(16);\n  int height = data.readBits(16);\n  int levelOfCompatibility = data.readBits(3);\n  int depth = data.readBits(3);\n  data.skipBits(2); \n  int clutId = data.readBits(8);\n  int pixelCode8Bit = data.readBits(8);\n  int pixelCode4Bit = data.readBits(4);\n  int pixelCode2Bit = data.readBits(2);\n  data.skipBits(2); \n  int remainingLength = length - 10;\n\n  SparseArray<RegionObject> regionObjects = new SparseArray<>();\n  while (remainingLength > 0) {\n    int objectId = data.readBits(16);\n    int objectType = data.readBits(2);\n    int objectProvider = data.readBits(2);\n    int objectHorizontalPosition = data.readBits(12);\n    data.skipBits(4); \n    int objectVerticalPosition = data.readBits(12);\n    remainingLength -= 6;\n\n    int foregroundPixelCode = 0;\n    int backgroundPixelCode = 0;\n    if (objectType == 0x01 || objectType == 0x02) { \n      foregroundPixelCode = data.readBits(8);\n      backgroundPixelCode = data.readBits(8);\n      remainingLength -= 2;\n    }\n\n    regionObjects.put(\n        objectId,\n        new RegionObject(\n            objectType,\n            objectProvider,\n            objectHorizontalPosition,\n            objectVerticalPosition,\n            foregroundPixelCode,\n            backgroundPixelCode));\n  }\n\n  return new RegionComposition(\n      id,\n      fillFlag,\n      width,\n      height,\n      levelOfCompatibility,\n      depth,\n      clutId,\n      pixelCode8Bit,\n      pixelCode4Bit,\n      pixelCode2Bit,\n      regionObjects);\n}",
        "summary_tokens": [
            "parses",
            "a",
            "region",
            "composition",
            "segment",
            "as",
            "defined",
            "by",
            "etsi",
            "en",
            "0",
            "0",
            "0"
        ]
    },
    {
        "id": 2123,
        "code": "private static ClutDefinition parseClutDefinition(ParsableBitArray data, int length) {\n  int clutId = data.readBits(8);\n  data.skipBits(8); \n  int remainingLength = length - 2;\n\n  int[] clutEntries2Bit = generateDefault2BitClutEntries();\n  int[] clutEntries4Bit = generateDefault4BitClutEntries();\n  int[] clutEntries8Bit = generateDefault8BitClutEntries();\n\n  while (remainingLength > 0) {\n    int entryId = data.readBits(8);\n    int entryFlags = data.readBits(8);\n    remainingLength -= 2;\n\n    int[] clutEntries;\n    if ((entryFlags & 0x80) != 0) {\n      clutEntries = clutEntries2Bit;\n    } else if ((entryFlags & 0x40) != 0) {\n      clutEntries = clutEntries4Bit;\n    } else {\n      clutEntries = clutEntries8Bit;\n    }\n\n    int y;\n    int cr;\n    int cb;\n    int t;\n    if ((entryFlags & 0x01) != 0) {\n      y = data.readBits(8);\n      cr = data.readBits(8);\n      cb = data.readBits(8);\n      t = data.readBits(8);\n      remainingLength -= 4;\n    } else {\n      y = data.readBits(6) << 2;\n      cr = data.readBits(4) << 4;\n      cb = data.readBits(4) << 4;\n      t = data.readBits(2) << 6;\n      remainingLength -= 2;\n    }\n\n    if (y == 0x00) {\n      cr = 0x00;\n      cb = 0x00;\n      t = 0xFF;\n    }\n\n    int a = (byte) (0xFF - (t & 0xFF));\n    int r = (int) (y + (1.40200 * (cr - 128)));\n    int g = (int) (y - (0.34414 * (cb - 128)) - (0.71414 * (cr - 128)));\n    int b = (int) (y + (1.77200 * (cb - 128)));\n    clutEntries[entryId] =\n        getColor(\n            a,\n            Util.constrainValue(r, 0, 255),\n            Util.constrainValue(g, 0, 255),\n            Util.constrainValue(b, 0, 255));\n  }\n\n  return new ClutDefinition(clutId, clutEntries2Bit, clutEntries4Bit, clutEntries8Bit);\n}",
        "summary_tokens": [
            "parses",
            "a",
            "clut",
            "definition",
            "segment",
            "as",
            "defined",
            "by",
            "etsi",
            "en",
            "0",
            "0",
            "0"
        ]
    },
    {
        "id": 2124,
        "code": "private static ObjectData parseObjectData(ParsableBitArray data) {\n  int objectId = data.readBits(16);\n  data.skipBits(4); \n  int objectCodingMethod = data.readBits(2);\n  boolean nonModifyingColorFlag = data.readBit();\n  data.skipBits(1); \n\n  byte[] topFieldData = Util.EMPTY_BYTE_ARRAY;\n  byte[] bottomFieldData = Util.EMPTY_BYTE_ARRAY;\n\n  if (objectCodingMethod == OBJECT_CODING_STRING) {\n    int numberOfCodes = data.readBits(8);\n      \n    data.skipBits(numberOfCodes * 16); \n  } else if (objectCodingMethod == OBJECT_CODING_PIXELS) {\n    int topFieldDataLength = data.readBits(16);\n    int bottomFieldDataLength = data.readBits(16);\n    if (topFieldDataLength > 0) {\n      topFieldData = new byte[topFieldDataLength];\n      data.readBytes(topFieldData, 0, topFieldDataLength);\n    }\n    if (bottomFieldDataLength > 0) {\n      bottomFieldData = new byte[bottomFieldDataLength];\n      data.readBytes(bottomFieldData, 0, bottomFieldDataLength);\n    } else {\n      bottomFieldData = topFieldData;\n    }\n  }\n\n  return new ObjectData(objectId, nonModifyingColorFlag, topFieldData, bottomFieldData);\n}",
        "summary_tokens": [
            "parses",
            "an",
            "object",
            "data",
            "segment",
            "as",
            "defined",
            "by",
            "etsi",
            "en",
            "0",
            "0",
            "0"
        ]
    },
    {
        "id": 2125,
        "code": "private static void paintPixelDataSubBlocks(\n    ObjectData objectData,\n    ClutDefinition clutDefinition,\n    int regionDepth,\n    int horizontalAddress,\n    int verticalAddress,\n    @Nullable Paint paint,\n    Canvas canvas) {\n  int[] clutEntries;\n  if (regionDepth == REGION_DEPTH_8_BIT) {\n    clutEntries = clutDefinition.clutEntries8Bit;\n  } else if (regionDepth == REGION_DEPTH_4_BIT) {\n    clutEntries = clutDefinition.clutEntries4Bit;\n  } else {\n    clutEntries = clutDefinition.clutEntries2Bit;\n  }\n  paintPixelDataSubBlock(\n      objectData.topFieldData,\n      clutEntries,\n      regionDepth,\n      horizontalAddress,\n      verticalAddress,\n      paint,\n      canvas);\n  paintPixelDataSubBlock(\n      objectData.bottomFieldData,\n      clutEntries,\n      regionDepth,\n      horizontalAddress,\n      verticalAddress + 1,\n      paint,\n      canvas);\n}",
        "summary_tokens": [
            "draws",
            "a",
            "pixel",
            "data",
            "sub",
            "block",
            "as",
            "defined",
            "by",
            "etsi",
            "en",
            "0",
            "0",
            "0"
        ]
    },
    {
        "id": 2126,
        "code": "private static void paintPixelDataSubBlock(\n    byte[] pixelData,\n    int[] clutEntries,\n    int regionDepth,\n    int horizontalAddress,\n    int verticalAddress,\n    @Nullable Paint paint,\n    Canvas canvas) {\n  ParsableBitArray data = new ParsableBitArray(pixelData);\n  int column = horizontalAddress;\n  int line = verticalAddress;\n  @Nullable byte[] clutMapTable2To4 = null;\n  @Nullable byte[] clutMapTable2To8 = null;\n  @Nullable byte[] clutMapTable4To8 = null;\n\n  while (data.bitsLeft() != 0) {\n    int dataType = data.readBits(8);\n    switch (dataType) {\n      case DATA_TYPE_2BP_CODE_STRING:\n        @Nullable byte[] clutMapTable2ToX;\n        if (regionDepth == REGION_DEPTH_8_BIT) {\n          clutMapTable2ToX = clutMapTable2To8 == null ? defaultMap2To8 : clutMapTable2To8;\n        } else if (regionDepth == REGION_DEPTH_4_BIT) {\n          clutMapTable2ToX = clutMapTable2To4 == null ? defaultMap2To4 : clutMapTable2To4;\n        } else {\n          clutMapTable2ToX = null;\n        }\n        column =\n            paint2BitPixelCodeString(\n                data, clutEntries, clutMapTable2ToX, column, line, paint, canvas);\n        data.byteAlign();\n        break;\n      case DATA_TYPE_4BP_CODE_STRING:\n        @Nullable byte[] clutMapTable4ToX;\n        if (regionDepth == REGION_DEPTH_8_BIT) {\n          clutMapTable4ToX = clutMapTable4To8 == null ? defaultMap4To8 : clutMapTable4To8;\n        } else {\n          clutMapTable4ToX = null;\n        }\n        column =\n            paint4BitPixelCodeString(\n                data, clutEntries, clutMapTable4ToX, column, line, paint, canvas);\n        data.byteAlign();\n        break;\n      case DATA_TYPE_8BP_CODE_STRING:\n        column =\n            paint8BitPixelCodeString(\n                data, clutEntries,  null, column, line, paint, canvas);\n        break;\n      case DATA_TYPE_24_TABLE_DATA:\n        clutMapTable2To4 = buildClutMapTable(4, 4, data);\n        break;\n      case DATA_TYPE_28_TABLE_DATA:\n        clutMapTable2To8 = buildClutMapTable(4, 8, data);\n        break;\n      case DATA_TYPE_48_TABLE_DATA:\n        clutMapTable4To8 = buildClutMapTable(16, 8, data);\n        break;\n      case DATA_TYPE_END_LINE:\n        column = horizontalAddress;\n        line += 2;\n        break;\n      default:\n          \n        break;\n    }\n  }\n}",
        "summary_tokens": [
            "draws",
            "a",
            "pixel",
            "data",
            "sub",
            "block",
            "as",
            "defined",
            "by",
            "etsi",
            "en",
            "0",
            "0",
            "0"
        ]
    },
    {
        "id": 2127,
        "code": "private static int paint2BitPixelCodeString(\n    ParsableBitArray data,\n    int[] clutEntries,\n    @Nullable byte[] clutMapTable,\n    int column,\n    int line,\n    @Nullable Paint paint,\n    Canvas canvas) {\n  boolean endOfPixelCodeString = false;\n  do {\n    int runLength = 0;\n    int clutIndex = 0;\n    int peek = data.readBits(2);\n    if (peek != 0x00) {\n      runLength = 1;\n      clutIndex = peek;\n    } else if (data.readBit()) {\n      runLength = 3 + data.readBits(3);\n      clutIndex = data.readBits(2);\n    } else if (data.readBit()) {\n      runLength = 1;\n    } else {\n      switch (data.readBits(2)) {\n        case 0x00:\n          endOfPixelCodeString = true;\n          break;\n        case 0x01:\n          runLength = 2;\n          break;\n        case 0x02:\n          runLength = 12 + data.readBits(4);\n          clutIndex = data.readBits(2);\n          break;\n        case 0x03:\n          runLength = 29 + data.readBits(8);\n          clutIndex = data.readBits(2);\n          break;\n      }\n    }\n\n    if (runLength != 0 && paint != null) {\n      paint.setColor(clutEntries[clutMapTable != null ? clutMapTable[clutIndex] : clutIndex]);\n      canvas.drawRect(column, line, column + runLength, line + 1, paint);\n    }\n\n    column += runLength;\n  } while (!endOfPixelCodeString);\n\n  return column;\n}",
        "summary_tokens": [
            "paint",
            "a",
            "0",
            "bit",
            "pixel",
            "code",
            "string",
            "as",
            "defined",
            "by",
            "etsi",
            "en",
            "0",
            "0",
            "0"
        ]
    },
    {
        "id": 2128,
        "code": "private static int paint4BitPixelCodeString(\n    ParsableBitArray data,\n    int[] clutEntries,\n    @Nullable byte[] clutMapTable,\n    int column,\n    int line,\n    @Nullable Paint paint,\n    Canvas canvas) {\n  boolean endOfPixelCodeString = false;\n  do {\n    int runLength = 0;\n    int clutIndex = 0;\n    int peek = data.readBits(4);\n    if (peek != 0x00) {\n      runLength = 1;\n      clutIndex = peek;\n    } else if (!data.readBit()) {\n      peek = data.readBits(3);\n      if (peek != 0x00) {\n        runLength = 2 + peek;\n        clutIndex = 0x00;\n      } else {\n        endOfPixelCodeString = true;\n      }\n    } else if (!data.readBit()) {\n      runLength = 4 + data.readBits(2);\n      clutIndex = data.readBits(4);\n    } else {\n      switch (data.readBits(2)) {\n        case 0x00:\n          runLength = 1;\n          break;\n        case 0x01:\n          runLength = 2;\n          break;\n        case 0x02:\n          runLength = 9 + data.readBits(4);\n          clutIndex = data.readBits(4);\n          break;\n        case 0x03:\n          runLength = 25 + data.readBits(8);\n          clutIndex = data.readBits(4);\n          break;\n      }\n    }\n\n    if (runLength != 0 && paint != null) {\n      paint.setColor(clutEntries[clutMapTable != null ? clutMapTable[clutIndex] : clutIndex]);\n      canvas.drawRect(column, line, column + runLength, line + 1, paint);\n    }\n\n    column += runLength;\n  } while (!endOfPixelCodeString);\n\n  return column;\n}",
        "summary_tokens": [
            "paint",
            "a",
            "0",
            "bit",
            "pixel",
            "code",
            "string",
            "as",
            "defined",
            "by",
            "etsi",
            "en",
            "0",
            "0",
            "0"
        ]
    },
    {
        "id": 2129,
        "code": "private static int paint8BitPixelCodeString(\n    ParsableBitArray data,\n    int[] clutEntries,\n    @Nullable byte[] clutMapTable,\n    int column,\n    int line,\n    @Nullable Paint paint,\n    Canvas canvas) {\n  boolean endOfPixelCodeString = false;\n  do {\n    int runLength = 0;\n    int clutIndex = 0;\n    int peek = data.readBits(8);\n    if (peek != 0x00) {\n      runLength = 1;\n      clutIndex = peek;\n    } else {\n      if (!data.readBit()) {\n        peek = data.readBits(7);\n        if (peek != 0x00) {\n          runLength = peek;\n          clutIndex = 0x00;\n        } else {\n          endOfPixelCodeString = true;\n        }\n      } else {\n        runLength = data.readBits(7);\n        clutIndex = data.readBits(8);\n      }\n    }\n\n    if (runLength != 0 && paint != null) {\n      paint.setColor(clutEntries[clutMapTable != null ? clutMapTable[clutIndex] : clutIndex]);\n      canvas.drawRect(column, line, column + runLength, line + 1, paint);\n    }\n    column += runLength;\n  } while (!endOfPixelCodeString);\n\n  return column;\n}",
        "summary_tokens": [
            "paint",
            "an",
            "0",
            "bit",
            "pixel",
            "code",
            "string",
            "as",
            "defined",
            "by",
            "etsi",
            "en",
            "0",
            "0",
            "0"
        ]
    },
    {
        "id": 2130,
        "code": "private void parseHeader(ParsableByteArray data) {\n  @Nullable String currentLine;\n  while ((currentLine = data.readLine()) != null) {\n    if (\"[Script Info]\".equalsIgnoreCase(currentLine)) {\n      parseScriptInfo(data);\n    } else if (\"[V4+ Styles]\".equalsIgnoreCase(currentLine)) {\n      styles = parseStyles(data);\n    } else if (\"[V4 Styles]\".equalsIgnoreCase(currentLine)) {\n      Log.i(TAG, \"[V4 Styles] are not supported\");\n    } else if (\"[Events]\".equalsIgnoreCase(currentLine)) {\n        \n      return;\n    }\n  }\n}",
        "summary_tokens": [
            "parses",
            "the",
            "header",
            "of",
            "the",
            "subtitle"
        ]
    },
    {
        "id": 2131,
        "code": "private void parseScriptInfo(ParsableByteArray data) {\n  @Nullable String currentLine;\n  while ((currentLine = data.readLine()) != null\n      && (data.bytesLeft() == 0 || data.peekUnsignedByte() != '[')) {\n    String[] infoNameAndValue = currentLine.split(\":\");\n    if (infoNameAndValue.length != 2) {\n      continue;\n    }\n    switch (Ascii.toLowerCase(infoNameAndValue[0].trim())) {\n      case \"playresx\":\n        try {\n          screenWidth = Float.parseFloat(infoNameAndValue[1].trim());\n        } catch (NumberFormatException e) {\n            \n        }\n        break;\n      case \"playresy\":\n        try {\n          screenHeight = Float.parseFloat(infoNameAndValue[1].trim());\n        } catch (NumberFormatException e) {\n            \n        }\n        break;\n    }\n  }\n}",
        "summary_tokens": [
            "parse",
            "the",
            "script",
            "info",
            "section"
        ]
    },
    {
        "id": 2132,
        "code": "private static Map<String, SsaStyle> parseStyles(ParsableByteArray data) {\n  Map<String, SsaStyle> styles = new LinkedHashMap<>();\n  @Nullable SsaStyle.Format formatInfo = null;\n  @Nullable String currentLine;\n  while ((currentLine = data.readLine()) != null\n      && (data.bytesLeft() == 0 || data.peekUnsignedByte() != '[')) {\n    if (currentLine.startsWith(FORMAT_LINE_PREFIX)) {\n      formatInfo = SsaStyle.Format.fromFormatLine(currentLine);\n    } else if (currentLine.startsWith(STYLE_LINE_PREFIX)) {\n      if (formatInfo == null) {\n        Log.w(TAG, \"Skipping 'Style:' line before 'Format:' line: \" + currentLine);\n        continue;\n      }\n      @Nullable SsaStyle style = SsaStyle.fromStyleLine(currentLine, formatInfo);\n      if (style != null) {\n        styles.put(style.name, style);\n      }\n    }\n  }\n  return styles;\n}",
        "summary_tokens": [
            "parse",
            "the",
            "v",
            "0",
            "styles",
            "section"
        ]
    },
    {
        "id": 2133,
        "code": "private void parseEventBody(ParsableByteArray data, List<List<Cue>> cues, List<Long> cueTimesUs) {\n  @Nullable\n  SsaDialogueFormat format = haveInitializationData ? dialogueFormatFromInitializationData : null;\n  @Nullable String currentLine;\n  while ((currentLine = data.readLine()) != null) {\n    if (currentLine.startsWith(FORMAT_LINE_PREFIX)) {\n      format = SsaDialogueFormat.fromFormatLine(currentLine);\n    } else if (currentLine.startsWith(DIALOGUE_LINE_PREFIX)) {\n      if (format == null) {\n        Log.w(TAG, \"Skipping dialogue line before complete format: \" + currentLine);\n        continue;\n      }\n      parseDialogueLine(currentLine, format, cues, cueTimesUs);\n    }\n  }\n}",
        "summary_tokens": [
            "parses",
            "the",
            "event",
            "body",
            "of",
            "the",
            "subtitle"
        ]
    },
    {
        "id": 2134,
        "code": "private void parseDialogueLine(\n    String dialogueLine, SsaDialogueFormat format, List<List<Cue>> cues, List<Long> cueTimesUs) {\n  Assertions.checkArgument(dialogueLine.startsWith(DIALOGUE_LINE_PREFIX));\n  String[] lineValues =\n      dialogueLine.substring(DIALOGUE_LINE_PREFIX.length()).split(\",\", format.length);\n  if (lineValues.length != format.length) {\n    Log.w(TAG, \"Skipping dialogue line with fewer columns than format: \" + dialogueLine);\n    return;\n  }\n\n  long startTimeUs = parseTimecodeUs(lineValues[format.startTimeIndex]);\n  if (startTimeUs == C.TIME_UNSET) {\n    Log.w(TAG, \"Skipping invalid timing: \" + dialogueLine);\n    return;\n  }\n\n  long endTimeUs = parseTimecodeUs(lineValues[format.endTimeIndex]);\n  if (endTimeUs == C.TIME_UNSET) {\n    Log.w(TAG, \"Skipping invalid timing: \" + dialogueLine);\n    return;\n  }\n\n  @Nullable\n  SsaStyle style =\n      styles != null && format.styleIndex != C.INDEX_UNSET\n          ? styles.get(lineValues[format.styleIndex].trim())\n          : null;\n  String rawText = lineValues[format.textIndex];\n  SsaStyle.Overrides styleOverrides = SsaStyle.Overrides.parseFromDialogue(rawText);\n  String text =\n      SsaStyle.Overrides.stripStyleOverrides(rawText)\n          .replace(\"\\\\N\", \"\\n\")\n          .replace(\"\\\\n\", \"\\n\")\n          .replace(\"\\\\h\", \"\\u00A0\");\n  Cue cue = createCue(text, style, styleOverrides, screenWidth, screenHeight);\n\n  int startTimeIndex = addCuePlacerholderByTime(startTimeUs, cueTimesUs, cues);\n  int endTimeIndex = addCuePlacerholderByTime(endTimeUs, cueTimesUs, cues);\n    \n  for (int i = startTimeIndex; i < endTimeIndex; i++) {\n    cues.get(i).add(cue);\n  }\n}",
        "summary_tokens": [
            "parses",
            "a",
            "dialogue",
            "line"
        ]
    },
    {
        "id": 2135,
        "code": "private static long parseTimecodeUs(String timeString) {\n  Matcher matcher = SSA_TIMECODE_PATTERN.matcher(timeString.trim());\n  if (!matcher.matches()) {\n    return C.TIME_UNSET;\n  }\n  long timestampUs =\n      Long.parseLong(castNonNull(matcher.group(1))) * 60 * 60 * C.MICROS_PER_SECOND;\n  timestampUs += Long.parseLong(castNonNull(matcher.group(2))) * 60 * C.MICROS_PER_SECOND;\n  timestampUs += Long.parseLong(castNonNull(matcher.group(3))) * C.MICROS_PER_SECOND;\n  timestampUs += Long.parseLong(castNonNull(matcher.group(4))) * 10000; \n  return timestampUs;\n}",
        "summary_tokens": [
            "parses",
            "an",
            "ssa",
            "timecode",
            "string"
        ]
    },
    {
        "id": 2136,
        "code": "private static int addCuePlacerholderByTime(\n    long timeUs, List<Long> sortedCueTimesUs, List<List<Cue>> cues) {\n  int insertionIndex = 0;\n  for (int i = sortedCueTimesUs.size() - 1; i >= 0; i--) {\n    if (sortedCueTimesUs.get(i) == timeUs) {\n      return i;\n    }\n\n    if (sortedCueTimesUs.get(i) < timeUs) {\n      insertionIndex = i + 1;\n      break;\n    }\n  }\n  sortedCueTimesUs.add(insertionIndex, timeUs);\n    \n  cues.add(\n      insertionIndex,\n      insertionIndex == 0 ? new ArrayList<>() : new ArrayList<>(cues.get(insertionIndex - 1)));\n  return insertionIndex;\n}",
        "summary_tokens": [
            "searches",
            "for",
            "time",
            "us",
            "in",
            "sorted",
            "cue",
            "times",
            "us",
            "inserting",
            "it",
            "if",
            "it",
            "s",
            "not",
            "found",
            "and",
            "returns",
            "the",
            "index"
        ]
    },
    {
        "id": 2137,
        "code": "public static SsaDialogueFormat fromFormatLine(String formatLine) {\n  int startTimeIndex = C.INDEX_UNSET;\n  int endTimeIndex = C.INDEX_UNSET;\n  int styleIndex = C.INDEX_UNSET;\n  int textIndex = C.INDEX_UNSET;\n  Assertions.checkArgument(formatLine.startsWith(FORMAT_LINE_PREFIX));\n  String[] keys = TextUtils.split(formatLine.substring(FORMAT_LINE_PREFIX.length()), \",\");\n  for (int i = 0; i < keys.length; i++) {\n    switch (Ascii.toLowerCase(keys[i].trim())) {\n      case \"start\":\n        startTimeIndex = i;\n        break;\n      case \"end\":\n        endTimeIndex = i;\n        break;\n      case \"style\":\n        styleIndex = i;\n        break;\n      case \"text\":\n        textIndex = i;\n        break;\n    }\n  }\n  return (startTimeIndex != C.INDEX_UNSET\n          && endTimeIndex != C.INDEX_UNSET\n          && textIndex != C.INDEX_UNSET)\n      ? new SsaDialogueFormat(startTimeIndex, endTimeIndex, styleIndex, textIndex, keys.length)\n      : null;\n}",
        "summary_tokens": [
            "parses",
            "the",
            "format",
            "info",
            "from",
            "a",
            "format",
            "line",
            "in",
            "the",
            "events",
            "section"
        ]
    },
    {
        "id": 2138,
        "code": "public static Integer parseColor(String ssaColorExpression) {\n    \n    \n  long abgr;\n  try {\n    abgr =\n        ssaColorExpression.startsWith(\"&H\")\n              \n            ? Long.parseLong(ssaColorExpression.substring(2),  16)\n              \n            : Long.parseLong(ssaColorExpression);\n      \n    checkArgument(abgr <= 0xFFFFFFFFL);\n  } catch (IllegalArgumentException e) {\n    Log.w(TAG, \"Failed to parse color expression: '\" + ssaColorExpression + \"'\", e);\n    return null;\n  }\n    \n  int a = Ints.checkedCast(((abgr >> 24) & 0xFF) ^ 0xFF); \n  int b = Ints.checkedCast((abgr >> 16) & 0xFF);\n  int g = Ints.checkedCast((abgr >> 8) & 0xFF);\n  int r = Ints.checkedCast(abgr & 0xFF);\n  return Color.argb(a, r, g, b);\n}",
        "summary_tokens": [
            "parses",
            "a",
            "ssa",
            "v",
            "0",
            "color",
            "expression"
        ]
    },
    {
        "id": 2139,
        "code": "private String processLine(String line, ArrayList<String> tags) {\n  line = line.trim();\n\n  int removedCharacterCount = 0;\n  StringBuilder processedLine = new StringBuilder(line);\n  Matcher matcher = SUBRIP_TAG_PATTERN.matcher(line);\n  while (matcher.find()) {\n    String tag = matcher.group();\n    tags.add(tag);\n    int start = matcher.start() - removedCharacterCount;\n    int tagLength = tag.length();\n    processedLine.replace(start,  start + tagLength,  \"\");\n    removedCharacterCount += tagLength;\n  }\n\n  return processedLine.toString();\n}",
        "summary_tokens": [
            "trims",
            "and",
            "removes",
            "tags",
            "from",
            "the",
            "given",
            "line"
        ]
    },
    {
        "id": 2140,
        "code": "private Cue buildCue(Spanned text, @Nullable String alignmentTag) {\n  Cue.Builder cue = new Cue.Builder().setText(text);\n  if (alignmentTag == null) {\n    return cue.build();\n  }\n\n    \n  switch (alignmentTag) {\n    case ALIGN_BOTTOM_LEFT:\n    case ALIGN_MID_LEFT:\n    case ALIGN_TOP_LEFT:\n      cue.setPositionAnchor(Cue.ANCHOR_TYPE_START);\n      break;\n    case ALIGN_BOTTOM_RIGHT:\n    case ALIGN_MID_RIGHT:\n    case ALIGN_TOP_RIGHT:\n      cue.setPositionAnchor(Cue.ANCHOR_TYPE_END);\n      break;\n    case ALIGN_BOTTOM_MID:\n    case ALIGN_MID_MID:\n    case ALIGN_TOP_MID:\n    default:\n      cue.setPositionAnchor(Cue.ANCHOR_TYPE_MIDDLE);\n      break;\n  }\n\n    \n  switch (alignmentTag) {\n    case ALIGN_BOTTOM_LEFT:\n    case ALIGN_BOTTOM_MID:\n    case ALIGN_BOTTOM_RIGHT:\n      cue.setLineAnchor(Cue.ANCHOR_TYPE_END);\n      break;\n    case ALIGN_TOP_LEFT:\n    case ALIGN_TOP_MID:\n    case ALIGN_TOP_RIGHT:\n      cue.setLineAnchor(Cue.ANCHOR_TYPE_START);\n      break;\n    case ALIGN_MID_LEFT:\n    case ALIGN_MID_MID:\n    case ALIGN_MID_RIGHT:\n    default:\n      cue.setLineAnchor(Cue.ANCHOR_TYPE_MIDDLE);\n      break;\n  }\n\n  return cue.setPosition(getFractionalPositionForAnchorType(cue.getPositionAnchor()))\n      .setLine(getFractionalPositionForAnchorType(cue.getLineAnchor()), Cue.LINE_TYPE_FRACTION)\n      .build();\n}",
        "summary_tokens": [
            "build",
            "a",
            "cue",
            "based",
            "on",
            "the",
            "given",
            "text",
            "and",
            "alignment",
            "tag"
        ]
    },
    {
        "id": 2141,
        "code": "public static TextEmphasis parse(@Nullable String value) {\n  if (value == null) {\n    return null;\n  }\n\n  String parsingValue = Ascii.toLowerCase(value.trim());\n  if (parsingValue.isEmpty()) {\n    return null;\n  }\n\n  return parseWords(ImmutableSet.copyOf(TextUtils.split(parsingValue, WHITESPACE_PATTERN)));\n}",
        "summary_tokens": [
            "parses",
            "a",
            "ttml",
            "a",
            "href",
            "https",
            "www"
        ]
    },
    {
        "id": 2142,
        "code": "private static TtmlRegion parseRegionAttributes(\n    XmlPullParser xmlParser, CellResolution cellResolution, @Nullable TtsExtent ttsExtent) {\n  @Nullable String regionId = XmlPullParserUtil.getAttributeValue(xmlParser, TtmlNode.ATTR_ID);\n  if (regionId == null) {\n    return null;\n  }\n\n  float position;\n  float line;\n\n  @Nullable\n  String regionOrigin = XmlPullParserUtil.getAttributeValue(xmlParser, TtmlNode.ATTR_TTS_ORIGIN);\n  if (regionOrigin != null) {\n    Matcher originPercentageMatcher = PERCENTAGE_COORDINATES.matcher(regionOrigin);\n    Matcher originPixelMatcher = PIXEL_COORDINATES.matcher(regionOrigin);\n    if (originPercentageMatcher.matches()) {\n      try {\n        position =\n            Float.parseFloat(Assertions.checkNotNull(originPercentageMatcher.group(1))) / 100f;\n        line = Float.parseFloat(Assertions.checkNotNull(originPercentageMatcher.group(2))) / 100f;\n      } catch (NumberFormatException e) {\n        Log.w(TAG, \"Ignoring region with malformed origin: \" + regionOrigin);\n        return null;\n      }\n    } else if (originPixelMatcher.matches()) {\n      if (ttsExtent == null) {\n        Log.w(TAG, \"Ignoring region with missing tts:extent: \" + regionOrigin);\n        return null;\n      }\n      try {\n        int width = Integer.parseInt(Assertions.checkNotNull(originPixelMatcher.group(1)));\n        int height = Integer.parseInt(Assertions.checkNotNull(originPixelMatcher.group(2)));\n          \n        position = width / (float) ttsExtent.width;\n        line = height / (float) ttsExtent.height;\n      } catch (NumberFormatException e) {\n        Log.w(TAG, \"Ignoring region with malformed origin: \" + regionOrigin);\n        return null;\n      }\n    } else {\n      Log.w(TAG, \"Ignoring region with unsupported origin: \" + regionOrigin);\n      return null;\n    }\n  } else {\n    Log.w(TAG, \"Ignoring region without an origin\");\n    return null;\n      \n      \n      \n      \n      \n  }\n\n  float width;\n  float height;\n  @Nullable\n  String regionExtent = XmlPullParserUtil.getAttributeValue(xmlParser, TtmlNode.ATTR_TTS_EXTENT);\n  if (regionExtent != null) {\n    Matcher extentPercentageMatcher = PERCENTAGE_COORDINATES.matcher(regionExtent);\n    Matcher extentPixelMatcher = PIXEL_COORDINATES.matcher(regionExtent);\n    if (extentPercentageMatcher.matches()) {\n      try {\n        width =\n            Float.parseFloat(Assertions.checkNotNull(extentPercentageMatcher.group(1))) / 100f;\n        height =\n            Float.parseFloat(Assertions.checkNotNull(extentPercentageMatcher.group(2))) / 100f;\n      } catch (NumberFormatException e) {\n        Log.w(TAG, \"Ignoring region with malformed extent: \" + regionOrigin);\n        return null;\n      }\n    } else if (extentPixelMatcher.matches()) {\n      if (ttsExtent == null) {\n        Log.w(TAG, \"Ignoring region with missing tts:extent: \" + regionOrigin);\n        return null;\n      }\n      try {\n        int extentWidth = Integer.parseInt(Assertions.checkNotNull(extentPixelMatcher.group(1)));\n        int extentHeight = Integer.parseInt(Assertions.checkNotNull(extentPixelMatcher.group(2)));\n          \n        width = extentWidth / (float) ttsExtent.width;\n        height = extentHeight / (float) ttsExtent.height;\n      } catch (NumberFormatException e) {\n        Log.w(TAG, \"Ignoring region with malformed extent: \" + regionOrigin);\n        return null;\n      }\n    } else {\n      Log.w(TAG, \"Ignoring region with unsupported extent: \" + regionOrigin);\n      return null;\n    }\n  } else {\n    Log.w(TAG, \"Ignoring region without an extent\");\n    return null;\n      \n      \n      \n      \n      \n  }\n\n  @Cue.AnchorType int lineAnchor = Cue.ANCHOR_TYPE_START;\n  @Nullable\n  String displayAlign =\n      XmlPullParserUtil.getAttributeValue(xmlParser, TtmlNode.ATTR_TTS_DISPLAY_ALIGN);\n  if (displayAlign != null) {\n    switch (Ascii.toLowerCase(displayAlign)) {\n      case \"center\":\n        lineAnchor = Cue.ANCHOR_TYPE_MIDDLE;\n        line += height / 2;\n        break;\n      case \"after\":\n        lineAnchor = Cue.ANCHOR_TYPE_END;\n        line += height;\n        break;\n      default:\n          \n        break;\n    }\n  }\n\n  float regionTextHeight = 1.0f / cellResolution.rows;\n\n  @Cue.VerticalType int verticalType = Cue.TYPE_UNSET;\n  @Nullable\n  String writingDirection =\n      XmlPullParserUtil.getAttributeValue(xmlParser, TtmlNode.ATTR_TTS_WRITING_MODE);\n  if (writingDirection != null) {\n    switch (Ascii.toLowerCase(writingDirection)) {\n          \n      case TtmlNode.VERTICAL:\n      case TtmlNode.VERTICAL_LR:\n        verticalType = Cue.VERTICAL_TYPE_LR;\n        break;\n      case TtmlNode.VERTICAL_RL:\n        verticalType = Cue.VERTICAL_TYPE_RL;\n        break;\n      default:\n          \n        break;\n    }\n  }\n  return new TtmlRegion(\n      regionId,\n      position,\n      line,\n       Cue.LINE_TYPE_FRACTION,\n      lineAnchor,\n      width,\n      height,\n       Cue.TEXT_SIZE_TYPE_FRACTIONAL_IGNORE_PADDING,\n       regionTextHeight,\n      verticalType);\n}",
        "summary_tokens": [
            "parses",
            "a",
            "region",
            "declaration"
        ]
    },
    {
        "id": 2143,
        "code": "private static float parseShear(String expression) {\n  Matcher matcher = SIGNED_PERCENTAGE.matcher(expression);\n  if (!matcher.matches()) {\n    Log.w(TAG, \"Invalid value for shear: \" + expression);\n    return TtmlStyle.UNSPECIFIED_SHEAR;\n  }\n  try {\n    String percentage = Assertions.checkNotNull(matcher.group(1));\n    float value = Float.parseFloat(percentage);\n      \n      \n      \n    value = max(-100f, value);\n    value = min(100f, value);\n    return value;\n  } catch (NumberFormatException e) {\n    Log.w(TAG, \"Failed to parse shear: \" + expression, e);\n    return TtmlStyle.UNSPECIFIED_SHEAR;\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "parsed",
            "shear",
            "percentage",
            "between",
            "0"
        ]
    },
    {
        "id": 2144,
        "code": "private static long parseTimeExpression(String time, FrameAndTickRate frameAndTickRate)\n    throws SubtitleDecoderException {\n  Matcher matcher = CLOCK_TIME.matcher(time);\n  if (matcher.matches()) {\n    String hours = Assertions.checkNotNull(matcher.group(1));\n    double durationSeconds = Long.parseLong(hours) * 3600;\n    String minutes = Assertions.checkNotNull(matcher.group(2));\n    durationSeconds += Long.parseLong(minutes) * 60;\n    String seconds = Assertions.checkNotNull(matcher.group(3));\n    durationSeconds += Long.parseLong(seconds);\n    @Nullable String fraction = matcher.group(4);\n    durationSeconds += (fraction != null) ? Double.parseDouble(fraction) : 0;\n    @Nullable String frames = matcher.group(5);\n    durationSeconds +=\n        (frames != null) ? Long.parseLong(frames) / frameAndTickRate.effectiveFrameRate : 0;\n    @Nullable String subframes = matcher.group(6);\n    durationSeconds +=\n        (subframes != null)\n            ? ((double) Long.parseLong(subframes))\n                / frameAndTickRate.subFrameRate\n                / frameAndTickRate.effectiveFrameRate\n            : 0;\n    return (long) (durationSeconds * C.MICROS_PER_SECOND);\n  }\n  matcher = OFFSET_TIME.matcher(time);\n  if (matcher.matches()) {\n    String timeValue = Assertions.checkNotNull(matcher.group(1));\n    double offsetSeconds = Double.parseDouble(timeValue);\n    String unit = Assertions.checkNotNull(matcher.group(2));\n    switch (unit) {\n      case \"h\":\n        offsetSeconds *= 3600;\n        break;\n      case \"m\":\n        offsetSeconds *= 60;\n        break;\n      case \"s\":\n          \n        break;\n      case \"ms\":\n        offsetSeconds /= 1000;\n        break;\n      case \"f\":\n        offsetSeconds /= frameAndTickRate.effectiveFrameRate;\n        break;\n      case \"t\":\n        offsetSeconds /= frameAndTickRate.tickRate;\n        break;\n    }\n    return (long) (offsetSeconds * C.MICROS_PER_SECOND);\n  }\n  throw new SubtitleDecoderException(\"Malformed time expression: \" + time);\n}",
        "summary_tokens": [
            "parses",
            "a",
            "time",
            "expression",
            "returning",
            "the",
            "parsed",
            "timestamp"
        ]
    },
    {
        "id": 2145,
        "code": " static void endParagraph(SpannableStringBuilder builder) {\n  int position = builder.length() - 1;\n  while (position >= 0 && builder.charAt(position) == ' ') {\n    position--;\n  }\n  if (position >= 0 && builder.charAt(position) != '\\n') {\n    builder.append('\\n');\n  }\n}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "end",
            "of",
            "a",
            "paragraph",
            "is",
            "encountered"
        ]
    },
    {
        "id": 2146,
        "code": " static String applyTextElementSpacePolicy(String in) {\n    \n  String out = in.replaceAll(\"\\r\\n\", \"\\n\");\n    \n    \n  out = out.replaceAll(\" *\\n *\", \"\\n\");\n    \n  out = out.replaceAll(\"\\n\", \" \");\n    \n  out = out.replaceAll(\"[ \\t\\\\x0B\\f\\r]+\", \" \");\n  return out;\n}",
        "summary_tokens": [
            "applies",
            "the",
            "appropriate",
            "space",
            "policy",
            "to",
            "the",
            "given",
            "text",
            "element"
        ]
    },
    {
        "id": 2147,
        "code": "public @StyleFlags int getStyle() {\n  if (bold == UNSPECIFIED && italic == UNSPECIFIED) {\n    return UNSPECIFIED;\n  }\n  return (bold == ON ? STYLE_BOLD : STYLE_NORMAL) | (italic == ON ? STYLE_ITALIC : STYLE_NORMAL);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "style",
            "or",
            "unspecified",
            "when",
            "no",
            "style",
            "information",
            "is",
            "given"
        ]
    },
    {
        "id": 2148,
        "code": "public TtmlStyle chain(@Nullable TtmlStyle ancestor) {\n  return inherit(ancestor, true);\n}",
        "summary_tokens": [
            "chains",
            "this",
            "style",
            "to",
            "referential",
            "style"
        ]
    },
    {
        "id": 2149,
        "code": "public TtmlStyle inherit(@Nullable TtmlStyle ancestor) {\n  return inherit(ancestor, false);\n}",
        "summary_tokens": [
            "inherits",
            "from",
            "an",
            "ancestor",
            "style"
        ]
    },
    {
        "id": 2150,
        "code": "public boolean getTextCombine() {\n  return textCombine == ON;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "the",
            "source",
            "entity",
            "has",
            "tts",
            "text",
            "combine",
            "all"
        ]
    },
    {
        "id": 2151,
        "code": "public List<WebvttCssStyle> parseBlock(ParsableByteArray input) {\n  stringBuilder.setLength(0);\n  int initialInputPosition = input.getPosition();\n  skipStyleBlock(input);\n  styleInput.reset(input.getData(), input.getPosition());\n  styleInput.setPosition(initialInputPosition);\n\n  List<WebvttCssStyle> styles = new ArrayList<>();\n  String selector;\n  while ((selector = parseSelector(styleInput, stringBuilder)) != null) {\n    if (!RULE_START.equals(parseNextToken(styleInput, stringBuilder))) {\n      return styles;\n    }\n    WebvttCssStyle style = new WebvttCssStyle();\n    applySelectorToStyle(style, selector);\n    String token = null;\n    boolean blockEndFound = false;\n    while (!blockEndFound) {\n      int position = styleInput.getPosition();\n      token = parseNextToken(styleInput, stringBuilder);\n      blockEndFound = token == null || RULE_END.equals(token);\n      if (!blockEndFound) {\n        styleInput.setPosition(position);\n        parseStyleDeclaration(styleInput, style, stringBuilder);\n      }\n    }\n      \n    if (RULE_END.equals(token)) {\n      styles.add(style);\n    }\n  }\n  return styles;\n}",
        "summary_tokens": [
            "takes",
            "a",
            "css",
            "style",
            "block",
            "and",
            "consumes",
            "up",
            "to",
            "the",
            "first",
            "empty",
            "line"
        ]
    },
    {
        "id": 2152,
        "code": "private static String parseSelector(ParsableByteArray input, StringBuilder stringBuilder) {\n  skipWhitespaceAndComments(input);\n  if (input.bytesLeft() < 5) {\n    return null;\n  }\n  String cueSelector = input.readString(5);\n  if (!\"::cue\".equals(cueSelector)) {\n    return null;\n  }\n  int position = input.getPosition();\n  String token = parseNextToken(input, stringBuilder);\n  if (token == null) {\n    return null;\n  }\n  if (RULE_START.equals(token)) {\n    input.setPosition(position);\n    return \"\";\n  }\n  String target = null;\n  if (\"(\".equals(token)) {\n    target = readCueTarget(input);\n  }\n  token = parseNextToken(input, stringBuilder);\n  if (!\")\".equals(token)) {\n    return null;\n  }\n  return target;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "string",
            "containing",
            "the",
            "selector"
        ]
    },
    {
        "id": 2153,
        "code": "private static String readCueTarget(ParsableByteArray input) {\n  int position = input.getPosition();\n  int limit = input.limit();\n  boolean cueTargetEndFound = false;\n  while (position < limit && !cueTargetEndFound) {\n    char c = (char) input.getData()[position++];\n    cueTargetEndFound = c == ')';\n  }\n  return input.readString(--position - input.getPosition()).trim();\n    \n}",
        "summary_tokens": [
            "reads",
            "the",
            "contents",
            "of",
            "cue",
            "and",
            "returns",
            "it",
            "as",
            "a",
            "string"
        ]
    },
    {
        "id": 2154,
        "code": "private void applySelectorToStyle(WebvttCssStyle style, String selector) {\n  if (\"\".equals(selector)) {\n    return; \n  }\n  int voiceStartIndex = selector.indexOf('[');\n  if (voiceStartIndex != -1) {\n    Matcher matcher = VOICE_NAME_PATTERN.matcher(selector.substring(voiceStartIndex));\n    if (matcher.matches()) {\n      style.setTargetVoice(Assertions.checkNotNull(matcher.group(1)));\n    }\n    selector = selector.substring(0, voiceStartIndex);\n  }\n  String[] classDivision = Util.split(selector, \"\\\\.\");\n  String tagAndIdDivision = classDivision[0];\n  int idPrefixIndex = tagAndIdDivision.indexOf('#');\n  if (idPrefixIndex != -1) {\n    style.setTargetTagName(tagAndIdDivision.substring(0, idPrefixIndex));\n    style.setTargetId(tagAndIdDivision.substring(idPrefixIndex + 1)); \n  } else {\n    style.setTargetTagName(tagAndIdDivision);\n  }\n  if (classDivision.length > 1) {\n    style.setTargetClasses(Util.nullSafeArrayCopyOfRange(classDivision, 1, classDivision.length));\n  }\n}",
        "summary_tokens": [
            "sets",
            "the",
            "target",
            "of",
            "a",
            "webvtt",
            "css",
            "style",
            "by",
            "splitting",
            "a",
            "selector",
            "of",
            "the",
            "form",
            "cue",
            "tag",
            "id"
        ]
    },
    {
        "id": 2155,
        "code": "public int getSpecificityScore(\n    @Nullable String id, @Nullable String tag, Set<String> classes, @Nullable String voice) {\n  if (targetId.isEmpty()\n      && targetTag.isEmpty()\n      && targetClasses.isEmpty()\n      && targetVoice.isEmpty()) {\n      \n      \n    return TextUtils.isEmpty(tag) ? 1 : 0;\n  }\n  int score = 0;\n  score = updateScoreForMatch(score, targetId, id, 0x40000000);\n  score = updateScoreForMatch(score, targetTag, tag, 2);\n  score = updateScoreForMatch(score, targetVoice, voice, 4);\n  if (score == -1 || !classes.containsAll(targetClasses)) {\n    return 0;\n  } else {\n    score += targetClasses.size() * 4;\n  }\n  return score;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "value",
            "in",
            "a",
            "score",
            "system",
            "compliant",
            "with",
            "the",
            "css",
            "specificity",
            "rules"
        ]
    },
    {
        "id": 2156,
        "code": "public @StyleFlags int getStyle() {\n  if (bold == UNSPECIFIED && italic == UNSPECIFIED) {\n    return UNSPECIFIED;\n  }\n  return (bold == ON ? STYLE_BOLD : STYLE_NORMAL) | (italic == ON ? STYLE_ITALIC : STYLE_NORMAL);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "style",
            "or",
            "unspecified",
            "when",
            "no",
            "style",
            "information",
            "is",
            "given"
        ]
    },
    {
        "id": 2157,
        "code": "public static WebvttCueInfo parseCue(ParsableByteArray webvttData, List<WebvttCssStyle> styles) {\n  @Nullable String firstLine = webvttData.readLine();\n  if (firstLine == null) {\n    return null;\n  }\n  Matcher cueHeaderMatcher = WebvttCueParser.CUE_HEADER_PATTERN.matcher(firstLine);\n  if (cueHeaderMatcher.matches()) {\n      \n    return parseCue(null, cueHeaderMatcher, webvttData, styles);\n  }\n    \n  @Nullable String secondLine = webvttData.readLine();\n  if (secondLine == null) {\n    return null;\n  }\n  cueHeaderMatcher = WebvttCueParser.CUE_HEADER_PATTERN.matcher(secondLine);\n  if (cueHeaderMatcher.matches()) {\n      \n    return parseCue(firstLine.trim(), cueHeaderMatcher, webvttData, styles);\n  }\n  return null;\n}",
        "summary_tokens": [
            "parses",
            "the",
            "next",
            "valid",
            "web",
            "vtt",
            "cue",
            "in",
            "a",
            "parsable",
            "array",
            "including",
            "timestamps",
            "settings",
            "and",
            "text"
        ]
    },
    {
        "id": 2158,
        "code": " static Cue.Builder parseCueSettingsList(String cueSettingsList) {\n  WebvttCueInfoBuilder builder = new WebvttCueInfoBuilder();\n  parseCueSettingsList(cueSettingsList, builder);\n  return builder.toCueBuilder();\n}",
        "summary_tokens": [
            "parses",
            "a",
            "string",
            "containing",
            "a",
            "list",
            "of",
            "cue",
            "settings"
        ]
    },
    {
        "id": 2159,
        "code": " static Cue newCueForText(CharSequence text) {\n  WebvttCueInfoBuilder infoBuilder = new WebvttCueInfoBuilder();\n  infoBuilder.text = text;\n  return infoBuilder.toCueBuilder().build();\n}",
        "summary_tokens": [
            "create",
            "a",
            "new",
            "cue",
            "containing",
            "text",
            "and",
            "with",
            "web",
            "vtt",
            "default",
            "values"
        ]
    },
    {
        "id": 2160,
        "code": " static SpannedString parseCueText(\n    @Nullable String id, String markup, List<WebvttCssStyle> styles) {\n  SpannableStringBuilder spannedText = new SpannableStringBuilder();\n  ArrayDeque<StartTag> startTagStack = new ArrayDeque<>();\n  int pos = 0;\n  List<Element> nestedElements = new ArrayList<>();\n  while (pos < markup.length()) {\n    char curr = markup.charAt(pos);\n    switch (curr) {\n      case CHAR_LESS_THAN:\n        if (pos + 1 >= markup.length()) {\n          pos++;\n          break; \n        }\n        int ltPos = pos;\n        boolean isClosingTag = markup.charAt(ltPos + 1) == CHAR_SLASH;\n        pos = findEndOfTag(markup, ltPos + 1);\n        boolean isVoidTag = markup.charAt(pos - 2) == CHAR_SLASH;\n        String fullTagExpression =\n            markup.substring(ltPos + (isClosingTag ? 2 : 1), isVoidTag ? pos - 2 : pos - 1);\n        if (fullTagExpression.trim().isEmpty()) {\n          continue;\n        }\n        String tagName = getTagName(fullTagExpression);\n        if (!isSupportedTag(tagName)) {\n          continue;\n        }\n        if (isClosingTag) {\n          StartTag startTag;\n          do {\n            if (startTagStack.isEmpty()) {\n              break;\n            }\n            startTag = startTagStack.pop();\n            applySpansForTag(id, startTag, nestedElements, spannedText, styles);\n            if (!startTagStack.isEmpty()) {\n              nestedElements.add(new Element(startTag, spannedText.length()));\n            } else {\n              nestedElements.clear();\n            }\n          } while (!startTag.name.equals(tagName));\n        } else if (!isVoidTag) {\n          startTagStack.push(StartTag.buildStartTag(fullTagExpression, spannedText.length()));\n        }\n        break;\n      case CHAR_AMPERSAND:\n        int semiColonEndIndex = markup.indexOf(CHAR_SEMI_COLON, pos + 1);\n        int spaceEndIndex = markup.indexOf(CHAR_SPACE, pos + 1);\n        int entityEndIndex =\n            semiColonEndIndex == -1\n                ? spaceEndIndex\n                : (spaceEndIndex == -1\n                    ? semiColonEndIndex\n                    : min(semiColonEndIndex, spaceEndIndex));\n        if (entityEndIndex != -1) {\n          applyEntity(markup.substring(pos + 1, entityEndIndex), spannedText);\n          if (entityEndIndex == spaceEndIndex) {\n            spannedText.append(\" \");\n          }\n          pos = entityEndIndex + 1;\n        } else {\n          spannedText.append(curr);\n          pos++;\n        }\n        break;\n      default:\n        spannedText.append(curr);\n        pos++;\n        break;\n    }\n  }\n    \n  while (!startTagStack.isEmpty()) {\n    applySpansForTag(id, startTagStack.pop(), nestedElements, spannedText, styles);\n  }\n  applySpansForTag(\n      id,\n      StartTag.buildWholeCueVirtualTag(),\n       Collections.emptyList(),\n      spannedText,\n      styles);\n  return SpannedString.valueOf(spannedText);\n}",
        "summary_tokens": [
            "parses",
            "the",
            "text",
            "payload",
            "of",
            "a",
            "web",
            "vtt",
            "cue",
            "and",
            "returns",
            "it",
            "as",
            "a",
            "styled",
            "spanned",
            "string"
        ]
    },
    {
        "id": 2161,
        "code": "private static int findEndOfTag(String markup, int startPos) {\n  int index = markup.indexOf(CHAR_GREATER_THAN, startPos);\n  return index == -1 ? markup.length() : index + 1;\n}",
        "summary_tokens": [
            "find",
            "end",
            "of",
            "tag",
            "gt"
        ]
    },
    {
        "id": 2162,
        "code": "private static void applyDefaultColors(\n    SpannableStringBuilder text, Set<String> classes, int start, int end) {\n  for (String className : classes) {\n    if (DEFAULT_TEXT_COLORS.containsKey(className)) {\n      int color = DEFAULT_TEXT_COLORS.get(className);\n      text.setSpan(new ForegroundColorSpan(color), start, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);\n    } else if (DEFAULT_BACKGROUND_COLORS.containsKey(className)) {\n      int color = DEFAULT_BACKGROUND_COLORS.get(className);\n      text.setSpan(new BackgroundColorSpan(color), start, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);\n    }\n  }\n}",
        "summary_tokens": [
            "adds",
            "foreground",
            "color",
            "span",
            "s",
            "and",
            "background",
            "color",
            "span",
            "s",
            "to",
            "text",
            "for",
            "entries",
            "in",
            "classes",
            "that",
            "match",
            "web",
            "vtt",
            "s",
            "a",
            "href",
            "https",
            "www"
        ]
    },
    {
        "id": 2163,
        "code": "private static String getTagName(String tagExpression) {\n  tagExpression = tagExpression.trim();\n  Assertions.checkArgument(!tagExpression.isEmpty());\n  return Util.splitAtFirst(tagExpression, \"[ \\\\.]\")[0];\n}",
        "summary_tokens": [
            "returns",
            "the",
            "tag",
            "name",
            "for",
            "the",
            "given",
            "tag",
            "contents"
        ]
    },
    {
        "id": 2164,
        "code": "private static int getNextEvent(ParsableByteArray parsableWebvttData) {\n  int foundEvent = EVENT_NONE;\n  int currentInputPosition = 0;\n  while (foundEvent == EVENT_NONE) {\n    currentInputPosition = parsableWebvttData.getPosition();\n    String line = parsableWebvttData.readLine();\n    if (line == null) {\n      foundEvent = EVENT_END_OF_FILE;\n    } else if (STYLE_START.equals(line)) {\n      foundEvent = EVENT_STYLE_BLOCK;\n    } else if (line.startsWith(COMMENT_START)) {\n      foundEvent = EVENT_COMMENT;\n    } else {\n      foundEvent = EVENT_CUE;\n    }\n  }\n  parsableWebvttData.setPosition(currentInputPosition);\n  return foundEvent;\n}",
        "summary_tokens": [
            "positions",
            "the",
            "input",
            "right",
            "before",
            "the",
            "next",
            "event",
            "and",
            "returns",
            "the",
            "kind",
            "of",
            "event",
            "found"
        ]
    },
    {
        "id": 2165,
        "code": "public static void validateWebvttHeaderLine(ParsableByteArray input) throws ParserException {\n  int startPosition = input.getPosition();\n  if (!isWebvttHeaderLine(input)) {\n    input.setPosition(startPosition);\n    throw ParserException.createForMalformedContainer(\n        \"Expected WEBVTT. Got \" + input.readLine(),  null);\n  }\n}",
        "summary_tokens": [
            "reads",
            "and",
            "validates",
            "the",
            "first",
            "line",
            "of",
            "a",
            "web",
            "vtt",
            "file"
        ]
    },
    {
        "id": 2166,
        "code": "public static boolean isWebvttHeaderLine(ParsableByteArray input) {\n  @Nullable String line = input.readLine();\n  return line != null && line.startsWith(WEBVTT_HEADER);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "given",
            "input",
            "is",
            "the",
            "first",
            "line",
            "of",
            "a",
            "web",
            "vtt",
            "file"
        ]
    },
    {
        "id": 2167,
        "code": "public static long parseTimestampUs(String timestamp) throws NumberFormatException {\n  long value = 0;\n  String[] parts = Util.splitAtFirst(timestamp, \"\\\\.\");\n  String[] subparts = Util.split(parts[0], \":\");\n  for (String subpart : subparts) {\n    value = (value * 60) + Long.parseLong(subpart);\n  }\n  value *= 1000;\n  if (parts.length == 2) {\n    value += Long.parseLong(parts[1]);\n  }\n  return value * 1000;\n}",
        "summary_tokens": [
            "parses",
            "a",
            "web",
            "vtt",
            "timestamp"
        ]
    },
    {
        "id": 2168,
        "code": "public static float parsePercentage(String s) throws NumberFormatException {\n  if (!s.endsWith(\"%\")) {\n    throw new NumberFormatException(\"Percentages must end with %\");\n  }\n  return Float.parseFloat(s.substring(0, s.length() - 1)) / 100;\n}",
        "summary_tokens": [
            "parses",
            "a",
            "percentage",
            "string"
        ]
    },
    {
        "id": 2169,
        "code": "public static Matcher findNextCueHeader(ParsableByteArray input) {\n  @Nullable String line;\n  while ((line = input.readLine()) != null) {\n    if (COMMENT.matcher(line).matches()) {\n        \n      while ((line = input.readLine()) != null && !line.isEmpty()) {}\n    } else {\n      Matcher cueHeaderMatcher = WebvttCueParser.CUE_HEADER_PATTERN.matcher(line);\n      if (cueHeaderMatcher.matches()) {\n        return cueHeaderMatcher;\n      }\n    }\n  }\n  return null;\n}",
        "summary_tokens": [
            "reads",
            "lines",
            "up",
            "to",
            "and",
            "including",
            "the",
            "next",
            "web",
            "vtt",
            "cue",
            "header"
        ]
    },
    {
        "id": 2170,
        "code": "public static int unescapeStream(byte[] data, int limit) {\n  synchronized (scratchEscapePositionsLock) {\n    int position = 0;\n    int scratchEscapeCount = 0;\n    while (position < limit) {\n      position = findNextUnescapeIndex(data, position, limit);\n      if (position < limit) {\n        if (scratchEscapePositions.length <= scratchEscapeCount) {\n            \n          scratchEscapePositions =\n              Arrays.copyOf(scratchEscapePositions, scratchEscapePositions.length * 2);\n        }\n        scratchEscapePositions[scratchEscapeCount++] = position;\n        position += 3;\n      }\n    }\n\n    int unescapedLength = limit - scratchEscapeCount;\n    int escapedPosition = 0; \n    int unescapedPosition = 0; \n    for (int i = 0; i < scratchEscapeCount; i++) {\n      int nextEscapePosition = scratchEscapePositions[i];\n      int copyLength = nextEscapePosition - escapedPosition;\n      System.arraycopy(data, escapedPosition, data, unescapedPosition, copyLength);\n      unescapedPosition += copyLength;\n      data[unescapedPosition++] = 0;\n      data[unescapedPosition++] = 0;\n      escapedPosition += copyLength + 3;\n    }\n\n    int remainingLength = unescapedLength - unescapedPosition;\n    System.arraycopy(data, escapedPosition, data, unescapedPosition, remainingLength);\n    return unescapedLength;\n  }\n}",
        "summary_tokens": [
            "unescapes",
            "data",
            "up",
            "to",
            "the",
            "specified",
            "limit",
            "replacing",
            "occurrences",
            "of",
            "0",
            "0",
            "0",
            "with",
            "0",
            "0"
        ]
    },
    {
        "id": 2171,
        "code": "public static void discardToSps(ByteBuffer data) {\n  int length = data.position();\n  int consecutiveZeros = 0;\n  int offset = 0;\n  while (offset + 1 < length) {\n    int value = data.get(offset) & 0xFF;\n    if (consecutiveZeros == 3) {\n      if (value == 1 && (data.get(offset + 1) & 0x1F) == H264_NAL_UNIT_TYPE_SPS) {\n          \n        ByteBuffer offsetData = data.duplicate();\n        offsetData.position(offset - 3);\n        offsetData.limit(length);\n        data.position(0);\n        data.put(offsetData);\n        return;\n      }\n    } else if (value == 0) {\n      consecutiveZeros++;\n    }\n    if (value != 0) {\n      consecutiveZeros = 0;\n    }\n    offset++;\n  }\n    \n  data.clear();\n}",
        "summary_tokens": [
            "discards",
            "data",
            "from",
            "the",
            "buffer",
            "up",
            "to",
            "the",
            "first",
            "sps",
            "where",
            "data"
        ]
    },
    {
        "id": 2172,
        "code": "public static boolean isNalUnitSei(@Nullable String mimeType, byte nalUnitHeaderFirstByte) {\n  return (MimeTypes.VIDEO_H264.equals(mimeType)\n          && (nalUnitHeaderFirstByte & 0x1F) == H264_NAL_UNIT_TYPE_SEI)\n      || (MimeTypes.VIDEO_H265.equals(mimeType)\n          && ((nalUnitHeaderFirstByte & 0x7E) >> 1) == H265_NAL_UNIT_TYPE_PREFIX_SEI);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "nal",
            "unit",
            "with",
            "the",
            "specified",
            "header",
            "contains",
            "supplemental",
            "enhancement",
            "information"
        ]
    },
    {
        "id": 2173,
        "code": "public static int getNalUnitType(byte[] data, int offset) {\n  return data[offset + 3] & 0x1F;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "type",
            "of",
            "the",
            "nal",
            "unit",
            "in",
            "data",
            "that",
            "starts",
            "at",
            "offset"
        ]
    },
    {
        "id": 2174,
        "code": "public static int getH265NalUnitType(byte[] data, int offset) {\n  return (data[offset + 3] & 0x7E) >> 1;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "type",
            "of",
            "the",
            "h"
        ]
    },
    {
        "id": 2175,
        "code": "public static SpsData parseSpsNalUnit(byte[] nalData, int nalOffset, int nalLimit) {\n  return parseSpsNalUnitPayload(nalData, nalOffset + 1, nalLimit);\n}",
        "summary_tokens": [
            "parses",
            "a",
            "sps",
            "nal",
            "unit",
            "using",
            "the",
            "syntax",
            "defined",
            "in",
            "itu",
            "t",
            "recommendation",
            "h"
        ]
    },
    {
        "id": 2176,
        "code": "public static SpsData parseSpsNalUnitPayload(byte[] nalData, int nalOffset, int nalLimit) {\n  ParsableNalUnitBitArray data = new ParsableNalUnitBitArray(nalData, nalOffset, nalLimit);\n  int profileIdc = data.readBits(8);\n  int constraintsFlagsAndReservedZero2Bits = data.readBits(8);\n  int levelIdc = data.readBits(8);\n  int seqParameterSetId = data.readUnsignedExpGolombCodedInt();\n\n  int chromaFormatIdc = 1; \n  boolean separateColorPlaneFlag = false;\n  if (profileIdc == 100\n      || profileIdc == 110\n      || profileIdc == 122\n      || profileIdc == 244\n      || profileIdc == 44\n      || profileIdc == 83\n      || profileIdc == 86\n      || profileIdc == 118\n      || profileIdc == 128\n      || profileIdc == 138) {\n    chromaFormatIdc = data.readUnsignedExpGolombCodedInt();\n    if (chromaFormatIdc == 3) {\n      separateColorPlaneFlag = data.readBit();\n    }\n    data.readUnsignedExpGolombCodedInt(); \n    data.readUnsignedExpGolombCodedInt(); \n    data.skipBit(); \n    boolean seqScalingMatrixPresentFlag = data.readBit();\n    if (seqScalingMatrixPresentFlag) {\n      int limit = (chromaFormatIdc != 3) ? 8 : 12;\n      for (int i = 0; i < limit; i++) {\n        boolean seqScalingListPresentFlag = data.readBit();\n        if (seqScalingListPresentFlag) {\n          skipScalingList(data, i < 6 ? 16 : 64);\n        }\n      }\n    }\n  }\n\n  int frameNumLength = data.readUnsignedExpGolombCodedInt() + 4; \n  int picOrderCntType = data.readUnsignedExpGolombCodedInt();\n  int picOrderCntLsbLength = 0;\n  boolean deltaPicOrderAlwaysZeroFlag = false;\n  if (picOrderCntType == 0) {\n      \n    picOrderCntLsbLength = data.readUnsignedExpGolombCodedInt() + 4;\n  } else if (picOrderCntType == 1) {\n    deltaPicOrderAlwaysZeroFlag = data.readBit(); \n    data.readSignedExpGolombCodedInt(); \n    data.readSignedExpGolombCodedInt(); \n    long numRefFramesInPicOrderCntCycle = data.readUnsignedExpGolombCodedInt();\n    for (int i = 0; i < numRefFramesInPicOrderCntCycle; i++) {\n      data.readUnsignedExpGolombCodedInt(); \n    }\n  }\n  int maxNumRefFrames = data.readUnsignedExpGolombCodedInt(); \n  data.skipBit(); \n\n  int picWidthInMbs = data.readUnsignedExpGolombCodedInt() + 1;\n  int picHeightInMapUnits = data.readUnsignedExpGolombCodedInt() + 1;\n  boolean frameMbsOnlyFlag = data.readBit();\n  int frameHeightInMbs = (2 - (frameMbsOnlyFlag ? 1 : 0)) * picHeightInMapUnits;\n  if (!frameMbsOnlyFlag) {\n    data.skipBit(); \n  }\n\n  data.skipBit(); \n  int frameWidth = picWidthInMbs * 16;\n  int frameHeight = frameHeightInMbs * 16;\n  boolean frameCroppingFlag = data.readBit();\n  if (frameCroppingFlag) {\n    int frameCropLeftOffset = data.readUnsignedExpGolombCodedInt();\n    int frameCropRightOffset = data.readUnsignedExpGolombCodedInt();\n    int frameCropTopOffset = data.readUnsignedExpGolombCodedInt();\n    int frameCropBottomOffset = data.readUnsignedExpGolombCodedInt();\n    int cropUnitX;\n    int cropUnitY;\n    if (chromaFormatIdc == 0) {\n      cropUnitX = 1;\n      cropUnitY = 2 - (frameMbsOnlyFlag ? 1 : 0);\n    } else {\n      int subWidthC = (chromaFormatIdc == 3) ? 1 : 2;\n      int subHeightC = (chromaFormatIdc == 1) ? 2 : 1;\n      cropUnitX = subWidthC;\n      cropUnitY = subHeightC * (2 - (frameMbsOnlyFlag ? 1 : 0));\n    }\n    frameWidth -= (frameCropLeftOffset + frameCropRightOffset) * cropUnitX;\n    frameHeight -= (frameCropTopOffset + frameCropBottomOffset) * cropUnitY;\n  }\n\n  float pixelWidthHeightRatio = 1;\n  boolean vuiParametersPresentFlag = data.readBit();\n  if (vuiParametersPresentFlag) {\n    boolean aspectRatioInfoPresentFlag = data.readBit();\n    if (aspectRatioInfoPresentFlag) {\n      int aspectRatioIdc = data.readBits(8);\n      if (aspectRatioIdc == NalUnitUtil.EXTENDED_SAR) {\n        int sarWidth = data.readBits(16);\n        int sarHeight = data.readBits(16);\n        if (sarWidth != 0 && sarHeight != 0) {\n          pixelWidthHeightRatio = (float) sarWidth / sarHeight;\n        }\n      } else if (aspectRatioIdc < NalUnitUtil.ASPECT_RATIO_IDC_VALUES.length) {\n        pixelWidthHeightRatio = NalUnitUtil.ASPECT_RATIO_IDC_VALUES[aspectRatioIdc];\n      } else {\n        Log.w(TAG, \"Unexpected aspect_ratio_idc value: \" + aspectRatioIdc);\n      }\n    }\n  }\n\n  return new SpsData(\n      profileIdc,\n      constraintsFlagsAndReservedZero2Bits,\n      levelIdc,\n      seqParameterSetId,\n      maxNumRefFrames,\n      frameWidth,\n      frameHeight,\n      pixelWidthHeightRatio,\n      separateColorPlaneFlag,\n      frameMbsOnlyFlag,\n      frameNumLength,\n      picOrderCntType,\n      picOrderCntLsbLength,\n      deltaPicOrderAlwaysZeroFlag);\n}",
        "summary_tokens": [
            "parses",
            "a",
            "sps",
            "nal",
            "unit",
            "payload",
            "excluding",
            "the",
            "nal",
            "unit",
            "header",
            "using",
            "the",
            "syntax",
            "defined",
            "in",
            "itu",
            "t",
            "recommendation",
            "h"
        ]
    },
    {
        "id": 2177,
        "code": "public static PpsData parsePpsNalUnit(byte[] nalData, int nalOffset, int nalLimit) {\n  return parsePpsNalUnitPayload(nalData, nalOffset + 1, nalLimit);\n}",
        "summary_tokens": [
            "parses",
            "a",
            "pps",
            "nal",
            "unit",
            "using",
            "the",
            "syntax",
            "defined",
            "in",
            "itu",
            "t",
            "recommendation",
            "h"
        ]
    },
    {
        "id": 2178,
        "code": "public static PpsData parsePpsNalUnitPayload(byte[] nalData, int nalOffset, int nalLimit) {\n  ParsableNalUnitBitArray data = new ParsableNalUnitBitArray(nalData, nalOffset, nalLimit);\n  int picParameterSetId = data.readUnsignedExpGolombCodedInt();\n  int seqParameterSetId = data.readUnsignedExpGolombCodedInt();\n  data.skipBit(); \n  boolean bottomFieldPicOrderInFramePresentFlag = data.readBit();\n  return new PpsData(picParameterSetId, seqParameterSetId, bottomFieldPicOrderInFramePresentFlag);\n}",
        "summary_tokens": [
            "parses",
            "a",
            "pps",
            "nal",
            "unit",
            "payload",
            "excluding",
            "the",
            "nal",
            "unit",
            "header",
            "using",
            "the",
            "syntax",
            "defined",
            "in",
            "itu",
            "t",
            "recommendation",
            "h"
        ]
    },
    {
        "id": 2179,
        "code": "public static int findNalUnit(\n    byte[] data, int startOffset, int endOffset, boolean[] prefixFlags) {\n  int length = endOffset - startOffset;\n\n  Assertions.checkState(length >= 0);\n  if (length == 0) {\n    return endOffset;\n  }\n\n  if (prefixFlags[0]) {\n    clearPrefixFlags(prefixFlags);\n    return startOffset - 3;\n  } else if (length > 1 && prefixFlags[1] && data[startOffset] == 1) {\n    clearPrefixFlags(prefixFlags);\n    return startOffset - 2;\n  } else if (length > 2\n      && prefixFlags[2]\n      && data[startOffset] == 0\n      && data[startOffset + 1] == 1) {\n    clearPrefixFlags(prefixFlags);\n    return startOffset - 1;\n  }\n\n  int limit = endOffset - 1;\n    \n    \n  for (int i = startOffset + 2; i < limit; i += 3) {\n    if ((data[i] & 0xFE) != 0) {\n        \n        \n    } else if (data[i - 2] == 0 && data[i - 1] == 0 && data[i] == 1) {\n      clearPrefixFlags(prefixFlags);\n      return i - 2;\n    } else {\n        \n        \n      i -= 2;\n    }\n  }\n\n    \n  prefixFlags[0] =\n      length > 2\n          ? (data[endOffset - 3] == 0 && data[endOffset - 2] == 0 && data[endOffset - 1] == 1)\n          : length == 2\n              ? (prefixFlags[2] && data[endOffset - 2] == 0 && data[endOffset - 1] == 1)\n              : (prefixFlags[1] && data[endOffset - 1] == 1);\n    \n  prefixFlags[1] =\n      length > 1\n          ? data[endOffset - 2] == 0 && data[endOffset - 1] == 0\n          : prefixFlags[2] && data[endOffset - 1] == 0;\n    \n  prefixFlags[2] = data[endOffset - 1] == 0;\n\n  return endOffset;\n}",
        "summary_tokens": [
            "finds",
            "the",
            "first",
            "nal",
            "unit",
            "in",
            "data"
        ]
    },
    {
        "id": 2180,
        "code": "public static void clearPrefixFlags(boolean[] prefixFlags) {\n  prefixFlags[0] = false;\n  prefixFlags[1] = false;\n  prefixFlags[2] = false;\n}",
        "summary_tokens": [
            "clears",
            "prefix",
            "flags",
            "as",
            "used",
            "by",
            "find",
            "nal",
            "unit",
            "byte",
            "int",
            "int",
            "boolean"
        ]
    },
    {
        "id": 2181,
        "code": "private static void skipShortTermReferencePictureSets(ParsableNalUnitBitArray bitArray) {\n  int numShortTermRefPicSets = bitArray.readUnsignedExpGolombCodedInt();\n    \n    \n    \n    \n  int previousNumNegativePics = C.INDEX_UNSET;\n  int previousNumPositivePics = C.INDEX_UNSET;\n  int[] previousDeltaPocS0 = new int[0];\n  int[] previousDeltaPocS1 = new int[0];\n  for (int stRpsIdx = 0; stRpsIdx < numShortTermRefPicSets; stRpsIdx++) {\n    int numNegativePics;\n    int numPositivePics;\n    int[] deltaPocS0;\n    int[] deltaPocS1;\n\n    boolean interRefPicSetPredictionFlag = stRpsIdx != 0 && bitArray.readBit();\n    if (interRefPicSetPredictionFlag) {\n      int previousNumDeltaPocs = previousNumNegativePics + previousNumPositivePics;\n\n      int deltaRpsSign = bitArray.readBit() ? 1 : 0;\n      int absDeltaRps = bitArray.readUnsignedExpGolombCodedInt() + 1;\n      int deltaRps = (1 - 2 * deltaRpsSign) * absDeltaRps;\n\n      boolean[] useDeltaFlags = new boolean[previousNumDeltaPocs + 1];\n      for (int j = 0; j <= previousNumDeltaPocs; j++) {\n        if (!bitArray.readBit()) { \n          useDeltaFlags[j] = bitArray.readBit();\n        } else {\n            \n          useDeltaFlags[j] = true;\n        }\n      }\n\n        \n        \n      int i = 0;\n      deltaPocS0 = new int[previousNumDeltaPocs + 1];\n      deltaPocS1 = new int[previousNumDeltaPocs + 1];\n      for (int j = previousNumPositivePics - 1; j >= 0; j--) {\n        int dPoc = previousDeltaPocS1[j] + deltaRps;\n        if (dPoc < 0 && useDeltaFlags[previousNumNegativePics + j]) {\n          deltaPocS0[i++] = dPoc;\n        }\n      }\n      if (deltaRps < 0 && useDeltaFlags[previousNumDeltaPocs]) {\n        deltaPocS0[i++] = deltaRps;\n      }\n      for (int j = 0; j < previousNumNegativePics; j++) {\n        int dPoc = previousDeltaPocS0[j] + deltaRps;\n        if (dPoc < 0 && useDeltaFlags[j]) {\n          deltaPocS0[i++] = dPoc;\n        }\n      }\n      numNegativePics = i;\n      deltaPocS0 = Arrays.copyOf(deltaPocS0, numNegativePics);\n\n      i = 0;\n      for (int j = previousNumNegativePics - 1; j >= 0; j--) {\n        int dPoc = previousDeltaPocS0[j] + deltaRps;\n        if (dPoc > 0 && useDeltaFlags[j]) {\n          deltaPocS1[i++] = dPoc;\n        }\n      }\n      if (deltaRps > 0 && useDeltaFlags[previousNumDeltaPocs]) {\n        deltaPocS1[i++] = deltaRps;\n      }\n      for (int j = 0; j < previousNumPositivePics; j++) {\n        int dPoc = previousDeltaPocS1[j] + deltaRps;\n        if (dPoc > 0 && useDeltaFlags[previousNumNegativePics + j]) {\n          deltaPocS1[i++] = dPoc;\n        }\n      }\n      numPositivePics = i;\n      deltaPocS1 = Arrays.copyOf(deltaPocS1, numPositivePics);\n    } else {\n      numNegativePics = bitArray.readUnsignedExpGolombCodedInt();\n      numPositivePics = bitArray.readUnsignedExpGolombCodedInt();\n      deltaPocS0 = new int[numNegativePics];\n      for (int i = 0; i < numNegativePics; i++) {\n        deltaPocS0[i] = bitArray.readUnsignedExpGolombCodedInt() + 1;\n        bitArray.skipBit(); \n      }\n      deltaPocS1 = new int[numPositivePics];\n      for (int i = 0; i < numPositivePics; i++) {\n        deltaPocS1[i] = bitArray.readUnsignedExpGolombCodedInt() + 1;\n        bitArray.skipBit(); \n      }\n    }\n    previousNumNegativePics = numNegativePics;\n    previousNumPositivePics = numPositivePics;\n    previousDeltaPocS0 = deltaPocS0;\n    previousDeltaPocS1 = deltaPocS1;\n  }\n}",
        "summary_tokens": [
            "skips",
            "any",
            "short",
            "term",
            "reference",
            "picture",
            "sets",
            "contained",
            "in",
            "a",
            "sps"
        ]
    },
    {
        "id": 2182,
        "code": "public void reset(byte[] data, int offset, int limit) {\n  this.data = data;\n  byteOffset = offset;\n  byteLimit = limit;\n  bitOffset = 0;\n  assertValidOffset();\n}",
        "summary_tokens": [
            "resets",
            "the",
            "wrapped",
            "data",
            "limit",
            "and",
            "offset"
        ]
    },
    {
        "id": 2183,
        "code": "public void skipBit() {\n  if (++bitOffset == 8) {\n    bitOffset = 0;\n    byteOffset += shouldSkipByte(byteOffset + 1) ? 2 : 1;\n  }\n  assertValidOffset();\n}",
        "summary_tokens": [
            "skips",
            "a",
            "single",
            "bit"
        ]
    },
    {
        "id": 2184,
        "code": "public void skipBits(int numBits) {\n  int oldByteOffset = byteOffset;\n  int numBytes = numBits / 8;\n  byteOffset += numBytes;\n  bitOffset += numBits - (numBytes * 8);\n  if (bitOffset > 7) {\n    byteOffset++;\n    bitOffset -= 8;\n  }\n  for (int i = oldByteOffset + 1; i <= byteOffset; i++) {\n    if (shouldSkipByte(i)) {\n        \n      byteOffset++;\n      i += 2;\n    }\n  }\n  assertValidOffset();\n}",
        "summary_tokens": [
            "skips",
            "bits",
            "and",
            "moves",
            "current",
            "reading",
            "position",
            "forward"
        ]
    },
    {
        "id": 2185,
        "code": "public boolean canReadBits(int numBits) {\n  int oldByteOffset = byteOffset;\n  int numBytes = numBits / 8;\n  int newByteOffset = byteOffset + numBytes;\n  int newBitOffset = bitOffset + numBits - (numBytes * 8);\n  if (newBitOffset > 7) {\n    newByteOffset++;\n    newBitOffset -= 8;\n  }\n  for (int i = oldByteOffset + 1; i <= newByteOffset && newByteOffset < byteLimit; i++) {\n    if (shouldSkipByte(i)) {\n        \n      newByteOffset++;\n      i += 2;\n    }\n  }\n  return newByteOffset < byteLimit || (newByteOffset == byteLimit && newBitOffset == 0);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "it",
            "s",
            "possible",
            "to",
            "read",
            "n",
            "bits",
            "starting",
            "from",
            "the",
            "current",
            "offset"
        ]
    },
    {
        "id": 2186,
        "code": "public boolean readBit() {\n  boolean returnValue = (data[byteOffset] & (0x80 >> bitOffset)) != 0;\n  skipBit();\n  return returnValue;\n}",
        "summary_tokens": [
            "reads",
            "a",
            "single",
            "bit"
        ]
    },
    {
        "id": 2187,
        "code": "public int readBits(int numBits) {\n  int returnValue = 0;\n  bitOffset += numBits;\n  while (bitOffset > 8) {\n    bitOffset -= 8;\n    returnValue |= (data[byteOffset] & 0xFF) << bitOffset;\n    byteOffset += shouldSkipByte(byteOffset + 1) ? 2 : 1;\n  }\n  returnValue |= (data[byteOffset] & 0xFF) >> (8 - bitOffset);\n  returnValue &= 0xFFFFFFFF >>> (32 - numBits);\n  if (bitOffset == 8) {\n    bitOffset = 0;\n    byteOffset += shouldSkipByte(byteOffset + 1) ? 2 : 1;\n  }\n  assertValidOffset();\n  return returnValue;\n}",
        "summary_tokens": [
            "reads",
            "up",
            "to",
            "0",
            "bits"
        ]
    },
    {
        "id": 2188,
        "code": "public boolean canReadExpGolombCodedNum() {\n  int initialByteOffset = byteOffset;\n  int initialBitOffset = bitOffset;\n  int leadingZeros = 0;\n  while (byteOffset < byteLimit && !readBit()) {\n    leadingZeros++;\n  }\n  boolean hitLimit = byteOffset == byteLimit;\n  byteOffset = initialByteOffset;\n  bitOffset = initialBitOffset;\n  return !hitLimit && canReadBits(leadingZeros * 2 + 1);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "it",
            "is",
            "possible",
            "to",
            "read",
            "an",
            "exp",
            "golomb",
            "coded",
            "integer",
            "starting",
            "from",
            "the",
            "current",
            "offset"
        ]
    },
    {
        "id": 2189,
        "code": "public int readUnsignedExpGolombCodedInt() {\n  return readExpGolombCodeNum();\n}",
        "summary_tokens": [
            "reads",
            "an",
            "unsigned",
            "exp",
            "golomb",
            "coded",
            "format",
            "integer"
        ]
    },
    {
        "id": 2190,
        "code": "public int readSignedExpGolombCodedInt() {\n  int codeNum = readExpGolombCodeNum();\n  return ((codeNum % 2) == 0 ? -1 : 1) * ((codeNum + 1) / 2);\n}",
        "summary_tokens": [
            "reads",
            "an",
            "signed",
            "exp",
            "golomb",
            "coded",
            "format",
            "integer"
        ]
    },
    {
        "id": 2191,
        "code": "public static AvcConfig parse(ParsableByteArray data) throws ParserException {\n  try {\n    data.skipBytes(4); \n    int nalUnitLengthFieldLength = (data.readUnsignedByte() & 0x3) + 1;\n    if (nalUnitLengthFieldLength == 3) {\n      throw new IllegalStateException();\n    }\n    List<byte[]> initializationData = new ArrayList<>();\n    int numSequenceParameterSets = data.readUnsignedByte() & 0x1F;\n    for (int j = 0; j < numSequenceParameterSets; j++) {\n      initializationData.add(buildNalUnitForChild(data));\n    }\n    int numPictureParameterSets = data.readUnsignedByte();\n    for (int j = 0; j < numPictureParameterSets; j++) {\n      initializationData.add(buildNalUnitForChild(data));\n    }\n\n    int width = Format.NO_VALUE;\n    int height = Format.NO_VALUE;\n    float pixelWidthHeightRatio = 1;\n    @Nullable String codecs = null;\n    if (numSequenceParameterSets > 0) {\n      byte[] sps = initializationData.get(0);\n      SpsData spsData =\n          NalUnitUtil.parseSpsNalUnit(\n              initializationData.get(0), nalUnitLengthFieldLength, sps.length);\n      width = spsData.width;\n      height = spsData.height;\n      pixelWidthHeightRatio = spsData.pixelWidthHeightRatio;\n      codecs =\n          CodecSpecificDataUtil.buildAvcCodecString(\n              spsData.profileIdc, spsData.constraintsFlagsAndReservedZero2Bits, spsData.levelIdc);\n    }\n\n    return new AvcConfig(\n        initializationData,\n        nalUnitLengthFieldLength,\n        width,\n        height,\n        pixelWidthHeightRatio,\n        codecs);\n  } catch (ArrayIndexOutOfBoundsException e) {\n    throw ParserException.createForMalformedContainer(\"Error parsing AVC config\", e);\n  }\n}",
        "summary_tokens": [
            "parses",
            "avc",
            "configuration",
            "data"
        ]
    },
    {
        "id": 2192,
        "code": "public static DolbyVisionConfig parse(ParsableByteArray data) {\n  data.skipBytes(2); \n  int profileData = data.readUnsignedByte();\n  int dvProfile = (profileData >> 1);\n  int dvLevel = ((profileData & 0x1) << 5) | ((data.readUnsignedByte() >> 3) & 0x1F);\n  String codecsPrefix;\n  if (dvProfile == 4 || dvProfile == 5 || dvProfile == 7) {\n    codecsPrefix = \"dvhe\";\n  } else if (dvProfile == 8) {\n    codecsPrefix = \"hev1\";\n  } else if (dvProfile == 9) {\n    codecsPrefix = \"avc3\";\n  } else {\n    return null;\n  }\n  String codecs = codecsPrefix + \".0\" + dvProfile + (dvLevel < 10 ? \".0\" : \".\") + dvLevel;\n  return new DolbyVisionConfig(dvProfile, dvLevel, codecs);\n}",
        "summary_tokens": [
            "parses",
            "dolby",
            "vision",
            "configuration",
            "data"
        ]
    },
    {
        "id": 2193,
        "code": "public static HevcConfig parse(ParsableByteArray data) throws ParserException {\n  try {\n    data.skipBytes(21); \n    int lengthSizeMinusOne = data.readUnsignedByte() & 0x03;\n\n      \n    int numberOfArrays = data.readUnsignedByte();\n    int csdLength = 0;\n    int csdStartPosition = data.getPosition();\n    for (int i = 0; i < numberOfArrays; i++) {\n      data.skipBytes(1); \n      int numberOfNalUnits = data.readUnsignedShort();\n      for (int j = 0; j < numberOfNalUnits; j++) {\n        int nalUnitLength = data.readUnsignedShort();\n        csdLength += 4 + nalUnitLength; \n        data.skipBytes(nalUnitLength);\n      }\n    }\n\n      \n    data.setPosition(csdStartPosition);\n    byte[] buffer = new byte[csdLength];\n    int bufferPosition = 0;\n    int width = Format.NO_VALUE;\n    int height = Format.NO_VALUE;\n    float pixelWidthHeightRatio = 1;\n    @Nullable String codecs = null;\n    for (int i = 0; i < numberOfArrays; i++) {\n      int nalUnitType = data.readUnsignedByte() & 0x7F; \n      int numberOfNalUnits = data.readUnsignedShort();\n      for (int j = 0; j < numberOfNalUnits; j++) {\n        int nalUnitLength = data.readUnsignedShort();\n        System.arraycopy(\n            NalUnitUtil.NAL_START_CODE,\n            0,\n            buffer,\n            bufferPosition,\n            NalUnitUtil.NAL_START_CODE.length);\n        bufferPosition += NalUnitUtil.NAL_START_CODE.length;\n        System.arraycopy(\n            data.getData(), data.getPosition(), buffer, bufferPosition, nalUnitLength);\n        if (nalUnitType == SPS_NAL_UNIT_TYPE && j == 0) {\n          NalUnitUtil.H265SpsData spsData =\n              NalUnitUtil.parseH265SpsNalUnit(\n                  buffer, bufferPosition, bufferPosition + nalUnitLength);\n          width = spsData.width;\n          height = spsData.height;\n          pixelWidthHeightRatio = spsData.pixelWidthHeightRatio;\n          codecs =\n              CodecSpecificDataUtil.buildHevcCodecString(\n                  spsData.generalProfileSpace,\n                  spsData.generalTierFlag,\n                  spsData.generalProfileIdc,\n                  spsData.generalProfileCompatibilityFlags,\n                  spsData.constraintBytes,\n                  spsData.generalLevelIdc);\n        }\n        bufferPosition += nalUnitLength;\n        data.skipBytes(nalUnitLength);\n      }\n    }\n\n    List<byte[]> initializationData =\n        csdLength == 0 ? Collections.emptyList() : Collections.singletonList(buffer);\n    return new HevcConfig(\n        initializationData, lengthSizeMinusOne + 1, width, height, pixelWidthHeightRatio, codecs);\n  } catch (ArrayIndexOutOfBoundsException e) {\n    throw ParserException.createForMalformedContainer(\"Error parsing HEVC config\", e);\n  }\n}",
        "summary_tokens": [
            "parses",
            "hevc",
            "configuration",
            "data"
        ]
    },
    {
        "id": 2194,
        "code": "private static ExtractorInput createTestInput(int... data) {\n  return new FakeExtractorInput.Builder()\n      .setData(TestUtil.createByteArray(data))\n      .setSimulateUnknownLength(true)\n      .build();\n}",
        "summary_tokens": [
            "helper",
            "to",
            "build",
            "an",
            "extractor",
            "input",
            "from",
            "byte",
            "data"
        ]
    },
    {
        "id": 2195,
        "code": "public void mp4SampleWithMdatTooLong() throws Exception {\n  ExtractorAsserts.assertBehavior(\n      Mp4Extractor::new, \"media/mp4/sample_mdat_too_long.mp4\", simulationConfig);\n}",
        "summary_tokens": [
            "test",
            "case",
            "for",
            "https",
            "github"
        ]
    },
    {
        "id": 2196,
        "code": "public void mp4Sample18ByteNclxColr() throws Exception {\n  ExtractorAsserts.assertBehavior(\n      Mp4Extractor::new, \"media/mp4/sample_18byte_nclx_colr.mp4\", simulationConfig);\n}",
        "summary_tokens": [
            "test",
            "case",
            "for",
            "https",
            "github"
        ]
    },
    {
        "id": 2197,
        "code": "public void vorbisWithGapBeforeSecondPage() throws Exception {\n  ExtractorAsserts.assertBehavior(\n      OggExtractor::new, \"media/ogg/bear_vorbis_gap.ogg\", simulationConfig);\n}",
        "summary_tokens": [
            "ensure",
            "the",
            "extractor",
            "can",
            "handle",
            "non",
            "contiguous",
            "pages",
            "by",
            "using",
            "a",
            "file",
            "with",
            "0",
            "bytes",
            "of",
            "garbage",
            "data",
            "before",
            "the",
            "start",
            "of",
            "the",
            "second",
            "page"
        ]
    },
    {
        "id": 2198,
        "code": "public void vorbisWithPacketSpanningBetweenPages() throws Exception {\n  ExtractorAsserts.assertBehavior(\n      OggExtractor::new, \"media/ogg/bear_vorbis_with_large_metadata.ogg\", simulationConfig);\n}",
        "summary_tokens": [
            "use",
            "some",
            "very",
            "large",
            "vorbis",
            "comment",
            "metadata",
            "to",
            "create",
            "a",
            "packet",
            "that",
            "is",
            "larger",
            "than",
            "a",
            "single",
            "ogg",
            "page"
        ]
    },
    {
        "id": 2199,
        "code": "private int seekToTimeUs(\n    PsExtractor psExtractor, SeekMap seekMap, long seekTimeUs, FakeTrackOutput trackOutput)\n    throws IOException {\n  int numSampleBeforeSeek = trackOutput.getSampleCount();\n  SeekMap.SeekPoints seekPoints = seekMap.getSeekPoints(seekTimeUs);\n\n  long initialSeekLoadPosition = seekPoints.first.position;\n  psExtractor.seek(initialSeekLoadPosition, seekTimeUs);\n\n  positionHolder.position = C.POSITION_UNSET;\n  ExtractorInput extractorInput = getExtractorInputFromPosition(initialSeekLoadPosition);\n  int extractorReadResult = Extractor.RESULT_CONTINUE;\n  while (true) {\n    try {\n        \n      while (extractorReadResult == Extractor.RESULT_CONTINUE\n          && trackOutput.getSampleCount() == numSampleBeforeSeek) {\n        extractorReadResult = psExtractor.read(extractorInput, positionHolder);\n      }\n    } finally {\n      DataSourceUtil.closeQuietly(dataSource);\n    }\n\n    if (extractorReadResult == Extractor.RESULT_SEEK) {\n      extractorInput = getExtractorInputFromPosition(positionHolder.position);\n      extractorReadResult = Extractor.RESULT_CONTINUE;\n    } else if (extractorReadResult == Extractor.RESULT_END_OF_INPUT) {\n      return -1;\n    } else if (trackOutput.getSampleCount() > numSampleBeforeSeek) {\n        \n      return numSampleBeforeSeek;\n    }\n  }\n}",
        "summary_tokens": [
            "seeks",
            "to",
            "the",
            "given",
            "seek",
            "time",
            "and",
            "keeps",
            "reading",
            "from",
            "input",
            "until",
            "we",
            "can",
            "extract",
            "at",
            "least",
            "one",
            "frame",
            "from",
            "the",
            "seek",
            "position",
            "or",
            "until",
            "end",
            "of",
            "input",
            "is",
            "reached"
        ]
    },
    {
        "id": 2200,
        "code": "private void insertTableSection(int offset, byte tableId, int sectionLength) {\n  packetPayload[offset++] = tableId;\n  packetPayload[offset++] = (byte) ((sectionLength >> 8) & 0x0F);\n  packetPayload[offset] = (byte) (sectionLength & 0xFF);\n}",
        "summary_tokens": [
            "inserts",
            "a",
            "private",
            "section",
            "header",
            "to",
            "packet",
            "payload"
        ]
    },
    {
        "id": 2201,
        "code": "private static byte[] createByteArray(int... bytes) {\n  byte[] byteArray = new byte[bytes.length];\n  for (int i = 0; i < byteArray.length; i++) {\n    Assertions.checkState(0x00 <= bytes[i] && bytes[i] <= 0xFF);\n    byteArray[i] = (byte) bytes[i];\n  }\n  return byteArray;\n}",
        "summary_tokens": [
            "converts",
            "an",
            "array",
            "of",
            "integers",
            "in",
            "the",
            "range",
            "0",
            "0",
            "into",
            "an",
            "equivalent",
            "byte",
            "array"
        ]
    },
    {
        "id": 2202,
        "code": "private static MetadataInputBuffer createMetadataInputBuffer(byte[] data) {\n  MetadataInputBuffer buffer = new MetadataInputBuffer();\n  buffer.data = ByteBuffer.allocate(data.length).put(data);\n  buffer.data.flip();\n  return buffer;\n}",
        "summary_tokens": [
            "create",
            "a",
            "new",
            "metadata",
            "input",
            "buffer",
            "and",
            "copy",
            "data",
            "into",
            "the",
            "backing",
            "byte",
            "buffer"
        ]
    },
    {
        "id": 2203,
        "code": "private static byte[] createByteArray(int... bytes) {\n  byte[] byteArray = new byte[bytes.length];\n  for (int i = 0; i < byteArray.length; i++) {\n    Assertions.checkState(0x00 <= bytes[i] && bytes[i] <= 0xFF);\n    byteArray[i] = (byte) bytes[i];\n  }\n  return byteArray;\n}",
        "summary_tokens": [
            "converts",
            "an",
            "array",
            "of",
            "integers",
            "in",
            "the",
            "range",
            "0",
            "0",
            "into",
            "an",
            "equivalent",
            "byte",
            "array"
        ]
    },
    {
        "id": 2204,
        "code": "private static MetadataInputBuffer createMetadataInputBuffer(byte[] data) {\n  MetadataInputBuffer buffer = new MetadataInputBuffer();\n  buffer.data = ByteBuffer.allocate(data.length).put(data);\n  buffer.data.flip();\n  return buffer;\n}",
        "summary_tokens": [
            "create",
            "a",
            "new",
            "metadata",
            "input",
            "buffer",
            "and",
            "copy",
            "data",
            "into",
            "the",
            "backing",
            "byte",
            "buffer"
        ]
    },
    {
        "id": 2205,
        "code": "private static byte[] createByteArray(int... bytes) {\n  byte[] byteArray = new byte[bytes.length];\n  for (int i = 0; i < byteArray.length; i++) {\n    Assertions.checkState(0x00 <= bytes[i] && bytes[i] <= 0xFF);\n    byteArray[i] = (byte) bytes[i];\n  }\n  return byteArray;\n}",
        "summary_tokens": [
            "converts",
            "an",
            "array",
            "of",
            "integers",
            "in",
            "the",
            "range",
            "0",
            "0",
            "into",
            "an",
            "equivalent",
            "byte",
            "array"
        ]
    },
    {
        "id": 2206,
        "code": "private static MetadataInputBuffer createMetadataInputBuffer(byte[] data) {\n  MetadataInputBuffer buffer = new MetadataInputBuffer();\n  buffer.data = ByteBuffer.allocate(data.length).put(data);\n  buffer.data.flip();\n  return buffer;\n}",
        "summary_tokens": [
            "create",
            "a",
            "new",
            "metadata",
            "input",
            "buffer",
            "and",
            "copy",
            "data",
            "into",
            "the",
            "backing",
            "byte",
            "buffer"
        ]
    },
    {
        "id": 2207,
        "code": "public void testFilled() {\n  String value = \"filled\";\n  @Nullable TextEmphasis textEmphasis = parse(value);\n  assertWithMessage(\"Text Emphasis must exist\").that(textEmphasis).isNotNull();\n  assertWithMessage(\"markShape\")\n      .that(textEmphasis.markShape)\n      .isEqualTo(TextEmphasisSpan.MARK_SHAPE_CIRCLE);\n  assertWithMessage(\"markFill\")\n      .that(textEmphasis.markFill)\n      .isEqualTo(TextEmphasisSpan.MARK_FILL_FILLED);\n  assertWithMessage(\"position\")\n      .that(textEmphasis.position)\n      .isEqualTo(TextEmphasis.POSITION_OUTSIDE);\n}",
        "summary_tokens": [
            "if",
            "only",
            "filled",
            "or",
            "open",
            "is",
            "specified",
            "then",
            "it",
            "is",
            "equivalent",
            "to",
            "filled",
            "circle",
            "and",
            "open",
            "circle",
            "respectively"
        ]
    },
    {
        "id": 2208,
        "code": "public void testDotBefore() {\n  String value = \"dot before\";\n  @Nullable TextEmphasis textEmphasis = parse(value);\n  assertWithMessage(\"Text Emphasis must exist\").that(textEmphasis).isNotNull();\n  assertWithMessage(\"markShape\")\n      .that(textEmphasis.markShape)\n      .isEqualTo(TextEmphasisSpan.MARK_SHAPE_DOT);\n  assertWithMessage(\"markFill\")\n      .that(textEmphasis.markFill)\n      .isEqualTo(TextEmphasisSpan.MARK_FILL_FILLED);\n  assertWithMessage(\"position\")\n      .that(textEmphasis.position)\n      .isEqualTo(TextAnnotation.POSITION_BEFORE);\n}",
        "summary_tokens": [
            "if",
            "only",
            "circle",
            "dot",
            "or",
            "sesame",
            "is",
            "specified",
            "then",
            "it",
            "is",
            "equivalent",
            "to",
            "filled",
            "circle",
            "filled",
            "dot",
            "and",
            "filled",
            "sesame",
            "respectively"
        ]
    },
    {
        "id": 2209,
        "code": "public void lime() throws IOException, SubtitleDecoderException {\n  TtmlSubtitle subtitle = getSubtitle(INLINE_ATTRIBUTES_TTML_FILE);\n\n  assertThat(subtitle.getEventTimeCount()).isEqualTo(4);\n\n  Spanned spanned = getOnlyCueTextAtTimeUs(subtitle, 20_000_000);\n  assertThat(spanned.toString()).isEqualTo(\"text 2\");\n  assertThat(spanned).hasTypefaceSpanBetween(0, spanned.length()).withFamily(\"sansSerif\");\n  assertThat(spanned).hasItalicSpanBetween(0, spanned.length());\n  assertThat(spanned).hasStrikethroughSpanBetween(0, spanned.length());\n  assertThat(spanned).hasBackgroundColorSpanBetween(0, spanned.length()).withColor(0xFF00FFFF);\n  assertThat(spanned).hasForegroundColorSpanBetween(0, spanned.length()).withColor(0xFF00FF00);\n}",
        "summary_tokens": [
            "regression",
            "test",
            "for",
            "devices",
            "on",
            "jelly",
            "bean",
            "where",
            "some",
            "named",
            "colors",
            "are",
            "not",
            "correctly",
            "defined",
            "on",
            "framework",
            "level"
        ]
    },
    {
        "id": 2210,
        "code": "public void decodeWithStyl_startTooLarge_noSpanAdded() throws Exception {\n  Tx3gDecoder decoder = new Tx3gDecoder(ImmutableList.of());\n  byte[] bytes =\n      TestUtil.getByteArray(\n          ApplicationProvider.getApplicationContext(), SAMPLE_WITH_STYL_START_TOO_LARGE);\n\n  Subtitle subtitle = decoder.decode(bytes, bytes.length, false);\n  SpannedString text = new SpannedString(subtitle.getCues(0).get(0).text);\n\n  assertThat(text.toString()).isEqualTo(\"CC \ud83d\ude42\");\n  assertThat(text).hasNoSpans();\n  assertFractionalLinePosition(subtitle.getCues(0).get(0), 0.85f);\n}",
        "summary_tokens": [
            "the",
            "0",
            "byte",
            "sample",
            "contains",
            "a",
            "0",
            "byte",
            "emoji"
        ]
    },
    {
        "id": 2211,
        "code": "public void decodeWithStyl_endTooLarge_clippedToEndOfText() throws Exception {\n  Tx3gDecoder decoder = new Tx3gDecoder(ImmutableList.of());\n  byte[] bytes =\n      TestUtil.getByteArray(\n          ApplicationProvider.getApplicationContext(), SAMPLE_WITH_STYL_END_TOO_LARGE);\n\n  Subtitle subtitle = decoder.decode(bytes, bytes.length, false);\n  SpannedString text = new SpannedString(subtitle.getCues(0).get(0).text);\n\n  assertThat(text.toString()).isEqualTo(\"CC \ud83d\ude42\");\n  assertThat(text).hasBoldItalicSpanBetween(0, 5);\n  assertThat(text).hasUnderlineSpanBetween(0, 5);\n  assertThat(text).hasForegroundColorSpanBetween(0, 5).withColor(Color.GREEN);\n  assertFractionalLinePosition(subtitle.getCues(0).get(0), 0.85f);\n}",
        "summary_tokens": [
            "the",
            "0",
            "byte",
            "sample",
            "contains",
            "a",
            "0",
            "byte",
            "emoji"
        ]
    },
    {
        "id": 2212,
        "code": "private void assertMp4WebvttSubtitleEquals(Subtitle subtitle, Cue... expectedCues) {\n  assertThat(subtitle.getEventTimeCount()).isEqualTo(1);\n  assertThat(subtitle.getEventTime(0)).isEqualTo(0);\n  List<Cue> subtitleCues = subtitle.getCues(0);\n  assertThat(subtitleCues).hasSize(expectedCues.length);\n  for (int i = 0; i < subtitleCues.size(); i++) {\n    assertCuesEqual(expectedCues[i], subtitleCues.get(i));\n  }\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "the",
            "subtitle",
            "s",
            "cues",
            "which",
            "are",
            "all",
            "part",
            "of",
            "the",
            "event",
            "at",
            "t",
            "0",
            "are",
            "equal",
            "to",
            "the",
            "expected",
            "cues"
        ]
    },
    {
        "id": 2213,
        "code": "private void assertCuesEqual(Cue expected, Cue actual) {\n  expect.withMessage(\"Cue.line\").that(actual.line).isEqualTo(expected.line);\n  expect.withMessage(\"Cue.lineAnchor\").that(actual.lineAnchor).isEqualTo(expected.lineAnchor);\n  expect.withMessage(\"Cue.lineType\").that(actual.lineType).isEqualTo(expected.lineType);\n  expect.withMessage(\"Cue.position\").that(actual.position).isEqualTo(expected.position);\n  expect\n      .withMessage(\"Cue.positionAnchor\")\n      .that(actual.positionAnchor)\n      .isEqualTo(expected.positionAnchor);\n  expect.withMessage(\"Cue.size\").that(actual.size).isEqualTo(expected.size);\n  expect.withMessage(\"Cue.text\").that(actual.text.toString()).isEqualTo(expected.text.toString());\n  expect\n      .withMessage(\"Cue.textAlignment\")\n      .that(actual.textAlignment)\n      .isEqualTo(expected.textAlignment);\n\n  assertThat(expect.hasFailures()).isFalse();\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "two",
            "cues",
            "are",
            "equal"
        ]
    },
    {
        "id": 2214,
        "code": "public void parseH265SpsNalUnitPayload_exoghi_10316() {\n  byte[] spsNalUnitPayload =\n      new byte[] {\n        1, 2, 32, 0, 0, 3, 0, -112, 0, 0, 3, 0, 0, 3, 0, -106, -96, 1, -32, 32, 2, 28, 77, -98,\n        87, -110, 66, -111, -123, 22, 74, -86, -53, -101, -98, -68, -28, 9, 119, -21, -103, 120,\n        -16, 22, -95, 34, 1, 54, -62, 0, 0, 7, -46, 0, 0, -69, -127, -12, 85, -17, 126, 0, -29,\n        -128, 28, 120, 1, -57, 0, 56, -15\n      };\n\n  NalUnitUtil.H265SpsData spsData =\n      NalUnitUtil.parseH265SpsNalUnitPayload(spsNalUnitPayload, 0, spsNalUnitPayload.length);\n\n  assertThat(spsData.constraintBytes).isEqualTo(new int[] {144, 0, 0, 0, 0, 0});\n  assertThat(spsData.generalLevelIdc).isEqualTo(150);\n  assertThat(spsData.generalProfileCompatibilityFlags).isEqualTo(4);\n  assertThat(spsData.generalProfileIdc).isEqualTo(2);\n  assertThat(spsData.generalProfileSpace).isEqualTo(0);\n  assertThat(spsData.generalTierFlag).isFalse();\n  assertThat(spsData.height).isEqualTo(2160);\n  assertThat(spsData.pixelWidthHeightRatio).isEqualTo(1);\n  assertThat(spsData.seqParameterSetId).isEqualTo(0);\n  assertThat(spsData.width).isEqualTo(3840);\n}",
        "summary_tokens": [
            "regression",
            "test",
            "for",
            "https",
            "github"
        ]
    },
    {
        "id": 2215,
        "code": "private static byte[] createByteArray(int... bytes) {\n  byte[] byteArray = new byte[bytes.length];\n  for (int i = 0; i < byteArray.length; i++) {\n    Assertions.checkState(0x00 <= bytes[i] && bytes[i] <= 0xFF);\n    byteArray[i] = (byte) bytes[i];\n  }\n  return byteArray;\n}",
        "summary_tokens": [
            "converts",
            "an",
            "array",
            "of",
            "integers",
            "in",
            "the",
            "range",
            "0",
            "0",
            "into",
            "an",
            "equivalent",
            "byte",
            "array"
        ]
    },
    {
        "id": 2216,
        "code": "private static byte[] createByteArray(int... bytes) {\n  byte[] byteArray = new byte[bytes.length];\n  for (int i = 0; i < byteArray.length; i++) {\n    Assertions.checkState(0x00 <= bytes[i] && bytes[i] <= 0xFF);\n    byteArray[i] = (byte) bytes[i];\n  }\n  return byteArray;\n}",
        "summary_tokens": [
            "converts",
            "an",
            "array",
            "of",
            "integers",
            "in",
            "the",
            "range",
            "0",
            "0",
            "into",
            "an",
            "equivalent",
            "byte",
            "array"
        ]
    },
    {
        "id": 2217,
        "code": "private static boolean isFmp4Variant(Format format) {\n  Metadata metadata = format.metadata;\n  if (metadata == null) {\n    return false;\n  }\n  for (int i = 0; i < metadata.length(); i++) {\n    Metadata.Entry entry = metadata.get(i);\n    if (entry instanceof HlsTrackMetadataEntry) {\n      return !((HlsTrackMetadataEntry) entry).variantInfos.isEmpty();\n    }\n  }\n  return false;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "this",
            "format",
            "represents",
            "a",
            "variant",
            "track",
            "i"
        ]
    },
    {
        "id": 2218,
        "code": "public byte[] get(@Nullable Uri uri) {\n  if (uri == null) {\n    return null;\n  }\n  return backingMap.get(uri);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "encryption",
            "key",
            "cached",
            "against",
            "this",
            "uri",
            "or",
            "null",
            "if",
            "uri",
            "is",
            "null",
            "or",
            "not",
            "present",
            "in",
            "the",
            "cache"
        ]
    },
    {
        "id": 2219,
        "code": "public byte[] put(Uri uri, byte[] encryptionKey) {\n  return backingMap.put(Assertions.checkNotNull(uri), Assertions.checkNotNull(encryptionKey));\n}",
        "summary_tokens": [
            "inserts",
            "an",
            "entry",
            "into",
            "the",
            "cache"
        ]
    },
    {
        "id": 2220,
        "code": "public boolean containsUri(Uri uri) {\n  return backingMap.containsKey(Assertions.checkNotNull(uri));\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "uri",
            "is",
            "present",
            "in",
            "the",
            "cache"
        ]
    },
    {
        "id": 2221,
        "code": "public byte[] remove(Uri uri) {\n  return backingMap.remove(Assertions.checkNotNull(uri));\n}",
        "summary_tokens": [
            "removes",
            "uri",
            "from",
            "the",
            "cache"
        ]
    },
    {
        "id": 2222,
        "code": "public static HlsMediaChunk createInstance(\n    HlsExtractorFactory extractorFactory,\n    DataSource dataSource,\n    Format format,\n    long startOfPlaylistInPeriodUs,\n    HlsMediaPlaylist mediaPlaylist,\n    HlsChunkSource.SegmentBaseHolder segmentBaseHolder,\n    Uri playlistUrl,\n    @Nullable List<Format> muxedCaptionFormats,\n    @C.SelectionReason int trackSelectionReason,\n    @Nullable Object trackSelectionData,\n    boolean isMasterTimestampSource,\n    TimestampAdjusterProvider timestampAdjusterProvider,\n    @Nullable HlsMediaChunk previousChunk,\n    @Nullable byte[] mediaSegmentKey,\n    @Nullable byte[] initSegmentKey,\n    boolean shouldSpliceIn,\n    PlayerId playerId) {\n    \n  HlsMediaPlaylist.SegmentBase mediaSegment = segmentBaseHolder.segmentBase;\n  DataSpec dataSpec =\n      new DataSpec.Builder()\n          .setUri(UriUtil.resolveToUri(mediaPlaylist.baseUri, mediaSegment.url))\n          .setPosition(mediaSegment.byteRangeOffset)\n          .setLength(mediaSegment.byteRangeLength)\n          .setFlags(segmentBaseHolder.isPreload ? FLAG_MIGHT_NOT_USE_FULL_NETWORK_SPEED : 0)\n          .build();\n  boolean mediaSegmentEncrypted = mediaSegmentKey != null;\n  @Nullable\n  byte[] mediaSegmentIv =\n      mediaSegmentEncrypted\n          ? getEncryptionIvArray(Assertions.checkNotNull(mediaSegment.encryptionIV))\n          : null;\n  DataSource mediaDataSource = buildDataSource(dataSource, mediaSegmentKey, mediaSegmentIv);\n\n    \n  HlsMediaPlaylist.Segment initSegment = mediaSegment.initializationSegment;\n  DataSpec initDataSpec = null;\n  boolean initSegmentEncrypted = false;\n  @Nullable DataSource initDataSource = null;\n  if (initSegment != null) {\n    initSegmentEncrypted = initSegmentKey != null;\n    @Nullable\n    byte[] initSegmentIv =\n        initSegmentEncrypted\n            ? getEncryptionIvArray(Assertions.checkNotNull(initSegment.encryptionIV))\n            : null;\n    Uri initSegmentUri = UriUtil.resolveToUri(mediaPlaylist.baseUri, initSegment.url);\n    initDataSpec =\n        new DataSpec(initSegmentUri, initSegment.byteRangeOffset, initSegment.byteRangeLength);\n    initDataSource = buildDataSource(dataSource, initSegmentKey, initSegmentIv);\n  }\n\n  long segmentStartTimeInPeriodUs = startOfPlaylistInPeriodUs + mediaSegment.relativeStartTimeUs;\n  long segmentEndTimeInPeriodUs = segmentStartTimeInPeriodUs + mediaSegment.durationUs;\n  int discontinuitySequenceNumber =\n      mediaPlaylist.discontinuitySequence + mediaSegment.relativeDiscontinuitySequence;\n\n  @Nullable HlsMediaChunkExtractor previousExtractor = null;\n  Id3Decoder id3Decoder;\n  ParsableByteArray scratchId3Data;\n\n  if (previousChunk != null) {\n    boolean isSameInitData =\n        initDataSpec == previousChunk.initDataSpec\n            || (initDataSpec != null\n                && previousChunk.initDataSpec != null\n                && initDataSpec.uri.equals(previousChunk.initDataSpec.uri)\n                && initDataSpec.position == previousChunk.initDataSpec.position);\n    boolean isFollowingChunk =\n        playlistUrl.equals(previousChunk.playlistUrl) && previousChunk.loadCompleted;\n    id3Decoder = previousChunk.id3Decoder;\n    scratchId3Data = previousChunk.scratchId3Data;\n    previousExtractor =\n        isSameInitData\n                && isFollowingChunk\n                && !previousChunk.extractorInvalidated\n                && previousChunk.discontinuitySequenceNumber == discontinuitySequenceNumber\n            ? previousChunk.extractor\n            : null;\n  } else {\n    id3Decoder = new Id3Decoder();\n    scratchId3Data = new ParsableByteArray(Id3Decoder.ID3_HEADER_LENGTH);\n  }\n  return new HlsMediaChunk(\n      extractorFactory,\n      mediaDataSource,\n      dataSpec,\n      format,\n      mediaSegmentEncrypted,\n      initDataSource,\n      initDataSpec,\n      initSegmentEncrypted,\n      playlistUrl,\n      muxedCaptionFormats,\n      trackSelectionReason,\n      trackSelectionData,\n      segmentStartTimeInPeriodUs,\n      segmentEndTimeInPeriodUs,\n      segmentBaseHolder.mediaSequence,\n      segmentBaseHolder.partIndex,\n       !segmentBaseHolder.isPreload,\n      discontinuitySequenceNumber,\n      mediaSegment.hasGapTag,\n      isMasterTimestampSource,\n       timestampAdjusterProvider.getAdjuster(discontinuitySequenceNumber),\n      mediaSegment.drmInitData,\n      previousExtractor,\n      id3Decoder,\n      scratchId3Data,\n      shouldSpliceIn,\n      playerId);\n}",
        "summary_tokens": [
            "creates",
            "a",
            "new",
            "instance"
        ]
    },
    {
        "id": 2223,
        "code": "public static boolean shouldSpliceIn(\n    @Nullable HlsMediaChunk previousChunk,\n    Uri playlistUrl,\n    HlsMediaPlaylist mediaPlaylist,\n    HlsChunkSource.SegmentBaseHolder segmentBaseHolder,\n    long startOfPlaylistInPeriodUs) {\n  if (previousChunk == null) {\n      \n    return false;\n  }\n  if (playlistUrl.equals(previousChunk.playlistUrl) && previousChunk.loadCompleted) {\n      \n      \n    return false;\n  }\n    \n    \n  long segmentStartTimeInPeriodUs =\n      startOfPlaylistInPeriodUs + segmentBaseHolder.segmentBase.relativeStartTimeUs;\n  return !isIndependent(segmentBaseHolder, mediaPlaylist)\n      || segmentStartTimeInPeriodUs < previousChunk.endTimeUs;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "samples",
            "of",
            "a",
            "new",
            "hls",
            "media",
            "chunk",
            "should",
            "be",
            "spliced",
            "into",
            "existing",
            "samples"
        ]
    },
    {
        "id": 2224,
        "code": "public void init(HlsSampleStreamWrapper output, ImmutableList<Integer> sampleQueueWriteIndices) {\n  this.output = output;\n  this.sampleQueueFirstSampleIndices = sampleQueueWriteIndices;\n}",
        "summary_tokens": [
            "initializes",
            "the",
            "chunk",
            "for",
            "loading"
        ]
    },
    {
        "id": 2225,
        "code": "public int getFirstSampleIndex(int sampleQueueIndex) {\n  Assertions.checkState(!shouldSpliceIn);\n  if (sampleQueueIndex >= sampleQueueFirstSampleIndices.size()) {\n      \n    return 0;\n  }\n  return sampleQueueFirstSampleIndices.get(sampleQueueIndex);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "first",
            "sample",
            "index",
            "of",
            "this",
            "chunk",
            "in",
            "the",
            "specified",
            "sample",
            "queue",
            "in",
            "the",
            "output"
        ]
    },
    {
        "id": 2226,
        "code": "public void invalidateExtractor() {\n  extractorInvalidated = true;\n}",
        "summary_tokens": [
            "prevents",
            "the",
            "extractor",
            "from",
            "being",
            "reused",
            "by",
            "a",
            "following",
            "media",
            "chunk"
        ]
    },
    {
        "id": 2227,
        "code": "public boolean isPublished() {\n  return isPublished;\n}",
        "summary_tokens": [
            "whether",
            "the",
            "chunk",
            "is",
            "a",
            "published",
            "chunk",
            "as",
            "opposed",
            "to",
            "a",
            "preload",
            "hint",
            "that",
            "may",
            "change",
            "when",
            "the",
            "playlist",
            "updates"
        ]
    },
    {
        "id": 2228,
        "code": "public void publish() {\n  isPublished = true;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "publish",
            "flag",
            "of",
            "the",
            "media",
            "chunk",
            "to",
            "indicate",
            "that",
            "it",
            "is",
            "not",
            "based",
            "on",
            "a",
            "part",
            "that",
            "is",
            "a",
            "preload",
            "hint",
            "in",
            "the",
            "playlist"
        ]
    },
    {
        "id": 2229,
        "code": "private void feedDataToExtractor(\n    DataSource dataSource,\n    DataSpec dataSpec,\n    boolean dataIsEncrypted,\n    boolean initializeTimestampAdjuster)\n    throws IOException {\n    \n    \n    \n    \n  DataSpec loadDataSpec;\n  boolean skipLoadedBytes;\n  if (dataIsEncrypted) {\n    loadDataSpec = dataSpec;\n    skipLoadedBytes = nextLoadPosition != 0;\n  } else {\n    loadDataSpec = dataSpec.subrange(nextLoadPosition);\n    skipLoadedBytes = false;\n  }\n  try {\n    ExtractorInput input =\n        prepareExtraction(dataSource, loadDataSpec, initializeTimestampAdjuster);\n    if (skipLoadedBytes) {\n      input.skipFully(nextLoadPosition);\n    }\n    try {\n      while (!loadCanceled && extractor.read(input)) {}\n    } catch (EOFException e) {\n      if ((trackFormat.roleFlags & C.ROLE_FLAG_TRICK_PLAY) != 0) {\n          \n          \n        extractor.onTruncatedSegmentParsed();\n      } else {\n        throw e;\n      }\n    } finally {\n      nextLoadPosition = (int) (input.getPosition() - dataSpec.position);\n    }\n  } finally {\n    DataSourceUtil.closeQuietly(dataSource);\n  }\n}",
        "summary_tokens": [
            "attempts",
            "to",
            "feed",
            "the",
            "given",
            "data",
            "spec",
            "to",
            "this"
        ]
    },
    {
        "id": 2230,
        "code": "private long peekId3PrivTimestamp(ExtractorInput input) throws IOException {\n  input.resetPeekPosition();\n  try {\n    scratchId3Data.reset(Id3Decoder.ID3_HEADER_LENGTH);\n    input.peekFully(scratchId3Data.getData(), 0, Id3Decoder.ID3_HEADER_LENGTH);\n  } catch (EOFException e) {\n      \n    return C.TIME_UNSET;\n  }\n  int id = scratchId3Data.readUnsignedInt24();\n  if (id != Id3Decoder.ID3_TAG) {\n    return C.TIME_UNSET;\n  }\n  scratchId3Data.skipBytes(3); \n  int id3Size = scratchId3Data.readSynchSafeInt();\n  int requiredCapacity = id3Size + Id3Decoder.ID3_HEADER_LENGTH;\n  if (requiredCapacity > scratchId3Data.capacity()) {\n    byte[] data = scratchId3Data.getData();\n    scratchId3Data.reset(requiredCapacity);\n    System.arraycopy(data, 0, scratchId3Data.getData(), 0, Id3Decoder.ID3_HEADER_LENGTH);\n  }\n  input.peekFully(scratchId3Data.getData(), Id3Decoder.ID3_HEADER_LENGTH, id3Size);\n  Metadata metadata = id3Decoder.decode(scratchId3Data.getData(), id3Size);\n  if (metadata == null) {\n    return C.TIME_UNSET;\n  }\n  int metadataLength = metadata.length();\n  for (int i = 0; i < metadataLength; i++) {\n    Metadata.Entry frame = metadata.get(i);\n    if (frame instanceof PrivFrame) {\n      PrivFrame privFrame = (PrivFrame) frame;\n      if (PRIV_TIMESTAMP_FRAME_OWNER.equals(privFrame.owner)) {\n        System.arraycopy(\n            privFrame.privateData, 0, scratchId3Data.getData(), 0, 8 );\n        scratchId3Data.setPosition(0);\n        scratchId3Data.setLimit(8);\n          \n          \n        return scratchId3Data.readLong() & 0x1FFFFFFFFL;\n      }\n    }\n  }\n  return C.TIME_UNSET;\n}",
        "summary_tokens": [
            "peek",
            "the",
            "presentation",
            "timestamp",
            "of",
            "the",
            "first",
            "sample",
            "in",
            "the",
            "chunk",
            "from",
            "an",
            "id",
            "0",
            "priv",
            "as",
            "defined",
            "in",
            "the",
            "hls",
            "spec",
            "version",
            "0",
            "section",
            "0"
        ]
    },
    {
        "id": 2231,
        "code": "private static DataSource buildDataSource(\n    DataSource dataSource,\n    @Nullable byte[] fullSegmentEncryptionKey,\n    @Nullable byte[] encryptionIv) {\n  if (fullSegmentEncryptionKey != null) {\n    Assertions.checkNotNull(encryptionIv);\n    return new Aes128DataSource(dataSource, fullSegmentEncryptionKey, encryptionIv);\n  }\n  return dataSource;\n}",
        "summary_tokens": [
            "if",
            "the",
            "segment",
            "is",
            "fully",
            "encrypted",
            "returns",
            "an",
            "aes",
            "0",
            "data",
            "source",
            "that",
            "wraps",
            "the",
            "original",
            "in",
            "order",
            "to",
            "decrypt",
            "the",
            "loaded",
            "data"
        ]
    },
    {
        "id": 2232,
        "code": "private void buildAndPrepareMainSampleStreamWrapper(\n    HlsMultivariantPlaylist multivariantPlaylist,\n    long positionUs,\n    List<HlsSampleStreamWrapper> sampleStreamWrappers,\n    List<int[]> manifestUrlIndicesPerWrapper,\n    Map<String, DrmInitData> overridingDrmInitData) {\n  int[] variantTypes = new int[multivariantPlaylist.variants.size()];\n  int videoVariantCount = 0;\n  int audioVariantCount = 0;\n  for (int i = 0; i < multivariantPlaylist.variants.size(); i++) {\n    Variant variant = multivariantPlaylist.variants.get(i);\n    Format format = variant.format;\n    if (format.height > 0 || Util.getCodecsOfType(format.codecs, C.TRACK_TYPE_VIDEO) != null) {\n      variantTypes[i] = C.TRACK_TYPE_VIDEO;\n      videoVariantCount++;\n    } else if (Util.getCodecsOfType(format.codecs, C.TRACK_TYPE_AUDIO) != null) {\n      variantTypes[i] = C.TRACK_TYPE_AUDIO;\n      audioVariantCount++;\n    } else {\n      variantTypes[i] = C.TRACK_TYPE_UNKNOWN;\n    }\n  }\n  boolean useVideoVariantsOnly = false;\n  boolean useNonAudioVariantsOnly = false;\n  int selectedVariantsCount = variantTypes.length;\n  if (videoVariantCount > 0) {\n      \n      \n      \n    useVideoVariantsOnly = true;\n    selectedVariantsCount = videoVariantCount;\n  } else if (audioVariantCount < variantTypes.length) {\n      \n      \n    useNonAudioVariantsOnly = true;\n    selectedVariantsCount = variantTypes.length - audioVariantCount;\n  }\n  Uri[] selectedPlaylistUrls = new Uri[selectedVariantsCount];\n  Format[] selectedPlaylistFormats = new Format[selectedVariantsCount];\n  int[] selectedVariantIndices = new int[selectedVariantsCount];\n  int outIndex = 0;\n  for (int i = 0; i < multivariantPlaylist.variants.size(); i++) {\n    if ((!useVideoVariantsOnly || variantTypes[i] == C.TRACK_TYPE_VIDEO)\n        && (!useNonAudioVariantsOnly || variantTypes[i] != C.TRACK_TYPE_AUDIO)) {\n      Variant variant = multivariantPlaylist.variants.get(i);\n      selectedPlaylistUrls[outIndex] = variant.url;\n      selectedPlaylistFormats[outIndex] = variant.format;\n      selectedVariantIndices[outIndex++] = i;\n    }\n  }\n  String codecs = selectedPlaylistFormats[0].codecs;\n  int numberOfVideoCodecs = Util.getCodecCountOfType(codecs, C.TRACK_TYPE_VIDEO);\n  int numberOfAudioCodecs = Util.getCodecCountOfType(codecs, C.TRACK_TYPE_AUDIO);\n  boolean codecsStringAllowsChunklessPreparation =\n      (numberOfAudioCodecs == 1\n              || (numberOfAudioCodecs == 0 && multivariantPlaylist.audios.isEmpty()))\n          && numberOfVideoCodecs <= 1\n          && numberOfAudioCodecs + numberOfVideoCodecs > 0;\n  @C.TrackType\n  int trackType =\n      !useVideoVariantsOnly && numberOfAudioCodecs > 0\n          ? C.TRACK_TYPE_AUDIO\n          : C.TRACK_TYPE_DEFAULT;\n  String sampleStreamWrapperUid = \"main\";\n  HlsSampleStreamWrapper sampleStreamWrapper =\n      buildSampleStreamWrapper(\n          sampleStreamWrapperUid,\n          trackType,\n          selectedPlaylistUrls,\n          selectedPlaylistFormats,\n          multivariantPlaylist.muxedAudioFormat,\n          multivariantPlaylist.muxedCaptionFormats,\n          overridingDrmInitData,\n          positionUs);\n  sampleStreamWrappers.add(sampleStreamWrapper);\n  manifestUrlIndicesPerWrapper.add(selectedVariantIndices);\n  if (allowChunklessPreparation && codecsStringAllowsChunklessPreparation) {\n    List<TrackGroup> muxedTrackGroups = new ArrayList<>();\n    if (numberOfVideoCodecs > 0) {\n      Format[] videoFormats = new Format[selectedVariantsCount];\n      for (int i = 0; i < videoFormats.length; i++) {\n        videoFormats[i] = deriveVideoFormat(selectedPlaylistFormats[i]);\n      }\n      muxedTrackGroups.add(new TrackGroup(sampleStreamWrapperUid, videoFormats));\n\n      if (numberOfAudioCodecs > 0\n          && (multivariantPlaylist.muxedAudioFormat != null\n              || multivariantPlaylist.audios.isEmpty())) {\n        muxedTrackGroups.add(\n            new TrackGroup(\n                 sampleStreamWrapperUid + \":audio\",\n                deriveAudioFormat(\n                    selectedPlaylistFormats[0],\n                    multivariantPlaylist.muxedAudioFormat,\n                     false)));\n      }\n      List<Format> ccFormats = multivariantPlaylist.muxedCaptionFormats;\n      if (ccFormats != null) {\n        for (int i = 0; i < ccFormats.size(); i++) {\n          String ccId = sampleStreamWrapperUid + \":cc:\" + i;\n          muxedTrackGroups.add(new TrackGroup(ccId, ccFormats.get(i)));\n        }\n      }\n    } else  {\n        \n      Format[] audioFormats = new Format[selectedVariantsCount];\n      for (int i = 0; i < audioFormats.length; i++) {\n        audioFormats[i] =\n            deriveAudioFormat(\n                 selectedPlaylistFormats[i],\n                multivariantPlaylist.muxedAudioFormat,\n                 true);\n      }\n      muxedTrackGroups.add(new TrackGroup(sampleStreamWrapperUid, audioFormats));\n    }\n\n    TrackGroup id3TrackGroup =\n        new TrackGroup(\n             sampleStreamWrapperUid + \":id3\",\n            new Format.Builder()\n                .setId(\"ID3\")\n                .setSampleMimeType(MimeTypes.APPLICATION_ID3)\n                .build());\n    muxedTrackGroups.add(id3TrackGroup);\n\n    sampleStreamWrapper.prepareWithMultivariantPlaylistInfo(\n        muxedTrackGroups.toArray(new TrackGroup[0]),\n         0,\n         muxedTrackGroups.indexOf(id3TrackGroup));\n  }\n}",
        "summary_tokens": [
            "this",
            "method",
            "creates",
            "and",
            "starts",
            "preparation",
            "of",
            "the",
            "main",
            "hls",
            "sample",
            "stream",
            "wrapper"
        ]
    },
    {
        "id": 2233,
        "code": "private static long getTargetLiveOffsetUs(HlsMediaPlaylist playlist, long liveEdgeOffsetUs) {\n  HlsMediaPlaylist.ServerControl serverControl = playlist.serverControl;\n  long targetOffsetUs;\n  if (playlist.startOffsetUs != C.TIME_UNSET) {\n    targetOffsetUs = playlist.durationUs - playlist.startOffsetUs;\n  } else if (serverControl.partHoldBackUs != C.TIME_UNSET\n      && playlist.partTargetDurationUs != C.TIME_UNSET) {\n      \n    targetOffsetUs = serverControl.partHoldBackUs;\n  } else if (serverControl.holdBackUs != C.TIME_UNSET) {\n    targetOffsetUs = serverControl.holdBackUs;\n  } else {\n      \n    targetOffsetUs = 3 * playlist.targetDurationUs;\n  }\n  return targetOffsetUs + liveEdgeOffsetUs;\n}",
        "summary_tokens": [
            "gets",
            "the",
            "target",
            "live",
            "offset",
            "in",
            "microseconds",
            "for",
            "a",
            "live",
            "playlist"
        ]
    },
    {
        "id": 2234,
        "code": "private static HlsMediaPlaylist.Segment findClosestPrecedingSegment(\n    List<HlsMediaPlaylist.Segment> segments, long positionUs) {\n  int segmentIndex =\n      Util.binarySearchFloor(\n          segments, positionUs,  true,  true);\n  return segments.get(segmentIndex);\n}",
        "summary_tokens": [
            "gets",
            "the",
            "segment",
            "that",
            "contains",
            "position",
            "us",
            "or",
            "the",
            "last",
            "segment",
            "if",
            "the",
            "position",
            "is",
            "beyond",
            "the",
            "segments",
            "list"
        ]
    },
    {
        "id": 2235,
        "code": "public TimestampAdjuster getAdjuster(int discontinuitySequence) {\n  @Nullable TimestampAdjuster adjuster = timestampAdjusters.get(discontinuitySequence);\n  if (adjuster == null) {\n    adjuster = new TimestampAdjuster(MODE_SHARED);\n    timestampAdjusters.put(discontinuitySequence, adjuster);\n  }\n  return adjuster;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "timestamp",
            "adjuster",
            "suitable",
            "for",
            "adjusting",
            "the",
            "pts",
            "timestamps",
            "contained",
            "in",
            "a",
            "chunk",
            "with",
            "a",
            "given",
            "discontinuity",
            "sequence"
        ]
    },
    {
        "id": 2236,
        "code": "private boolean isVariantUrl(Uri playlistUrl) {\n  List<Variant> variants = multivariantPlaylist.variants;\n  for (int i = 0; i < variants.size(); i++) {\n    if (playlistUrl.equals(variants.get(i).url)) {\n      return true;\n    }\n  }\n  return false;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "any",
            "of",
            "the",
            "variants",
            "in",
            "the",
            "multivariant",
            "playlist",
            "have",
            "the",
            "specified",
            "playlist",
            "url"
        ]
    },
    {
        "id": 2237,
        "code": "private void onPlaylistUpdated(Uri url, HlsMediaPlaylist newSnapshot) {\n  if (url.equals(primaryMediaPlaylistUrl)) {\n    if (primaryMediaPlaylistSnapshot == null) {\n        \n      isLive = !newSnapshot.hasEndTag;\n      initialStartTimeUs = newSnapshot.startTimeUs;\n    }\n    primaryMediaPlaylistSnapshot = newSnapshot;\n    primaryPlaylistListener.onPrimaryPlaylistRefreshed(newSnapshot);\n  }\n  for (PlaylistEventListener listener : listeners) {\n    listener.onPlaylistChanged();\n  }\n}",
        "summary_tokens": [
            "called",
            "by",
            "the",
            "bundles",
            "when",
            "a",
            "snapshot",
            "changes"
        ]
    },
    {
        "id": 2238,
        "code": "public boolean isNewerThan(@Nullable HlsMediaPlaylist other) {\n  if (other == null || mediaSequence > other.mediaSequence) {\n    return true;\n  }\n  if (mediaSequence < other.mediaSequence) {\n    return false;\n  }\n    \n  int segmentCountDifference = segments.size() - other.segments.size();\n  if (segmentCountDifference != 0) {\n    return segmentCountDifference > 0;\n  }\n  int partCount = trailingParts.size();\n  int otherPartCount = other.trailingParts.size();\n  return partCount > otherPartCount\n      || (partCount == otherPartCount && hasEndTag && !other.hasEndTag);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "this",
            "playlist",
            "is",
            "newer",
            "than",
            "other"
        ]
    },
    {
        "id": 2239,
        "code": "public long getEndTimeUs() {\n  return startTimeUs + durationUs;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "result",
            "of",
            "adding",
            "the",
            "duration",
            "of",
            "the",
            "playlist",
            "to",
            "its",
            "start",
            "time"
        ]
    },
    {
        "id": 2240,
        "code": "public HlsMediaPlaylist copyWith(long startTimeUs, int discontinuitySequence) {\n  return new HlsMediaPlaylist(\n      playlistType,\n      baseUri,\n      tags,\n      startOffsetUs,\n      preciseStart,\n      startTimeUs,\n       true,\n      discontinuitySequence,\n      mediaSequence,\n      version,\n      targetDurationUs,\n      partTargetDurationUs,\n      hasIndependentSegments,\n      hasEndTag,\n      hasProgramDateTime,\n      protectionSchemes,\n      segments,\n      trailingParts,\n      serverControl,\n      renditionReports);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "playlist",
            "identical",
            "to",
            "this",
            "one",
            "except",
            "for",
            "the",
            "start",
            "time",
            "the",
            "discontinuity",
            "sequence",
            "and",
            "has",
            "discontinuity",
            "sequence",
            "values"
        ]
    },
    {
        "id": 2241,
        "code": "public HlsMediaPlaylist copyWithEndTag() {\n  if (this.hasEndTag) {\n    return this;\n  }\n  return new HlsMediaPlaylist(\n      playlistType,\n      baseUri,\n      tags,\n      startOffsetUs,\n      preciseStart,\n      startTimeUs,\n      hasDiscontinuitySequence,\n      discontinuitySequence,\n      mediaSequence,\n      version,\n      targetDurationUs,\n      partTargetDurationUs,\n      hasIndependentSegments,\n       true,\n      hasProgramDateTime,\n      protectionSchemes,\n      segments,\n      trailingParts,\n      serverControl,\n      renditionReports);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "playlist",
            "identical",
            "to",
            "this",
            "one",
            "except",
            "that",
            "an",
            "end",
            "tag",
            "is",
            "added"
        ]
    },
    {
        "id": 2242,
        "code": "public static HlsMultivariantPlaylist createSingleVariantMultivariantPlaylist(String variantUrl) {\n  List<Variant> variant =\n      Collections.singletonList(Variant.createMediaPlaylistVariantUrl(Uri.parse(variantUrl)));\n  return new HlsMultivariantPlaylist(\n       \"\",\n       Collections.emptyList(),\n      variant,\n       Collections.emptyList(),\n       Collections.emptyList(),\n       Collections.emptyList(),\n       Collections.emptyList(),\n       null,\n       null,\n       false,\n       Collections.emptyMap(),\n       Collections.emptyList());\n}",
        "summary_tokens": [
            "creates",
            "a",
            "playlist",
            "with",
            "a",
            "single",
            "variant"
        ]
    },
    {
        "id": 2243,
        "code": "public void updatingElementDoesntChangeAgeForRemoval() {\n  FullSegmentEncryptionKeyCache cache = new FullSegmentEncryptionKeyCache( 2);\n\n  cache.put(firstUri, encryptionKey);\n  cache.put(secondUri, new byte[] {1, 2, 3, 4});\n    \n  cache.put(firstUri, new byte[] {10, 11, 12, 12});\n  cache.put(Uri.parse(\"www.nest.com\"), new byte[] {1, 2, 3, 4});\n\n    \n  assertThat(cache.containsUri(firstUri)).isFalse();\n  assertThat(cache.containsUri(secondUri)).isTrue();\n}",
        "summary_tokens": [
            "elements",
            "need",
            "to",
            "be",
            "removed",
            "and",
            "reinserted",
            "rather",
            "than",
            "just",
            "updated",
            "to",
            "change",
            "their",
            "position",
            "in",
            "the",
            "removal",
            "queue"
        ]
    },
    {
        "id": 2244,
        "code": "private static Timeline prepareAndWaitForTimeline(HlsMediaSource mediaSource)\n    throws TimeoutException {\n  AtomicReference<Timeline> receivedTimeline = new AtomicReference<>();\n  mediaSource.prepareSource(\n      (source, timeline) -> receivedTimeline.set(timeline),\n       null,\n      PlayerId.UNSET);\n  runMainLooperUntil(() -> receivedTimeline.get() != null);\n  return receivedTimeline.get();\n}",
        "summary_tokens": [
            "prepares",
            "the",
            "media",
            "source",
            "and",
            "waits",
            "until",
            "the",
            "timeline",
            "is",
            "updated"
        ]
    },
    {
        "id": 2245,
        "code": "public ImmutableMap<String, String> getFmtpParametersAsMap() {\n  @Nullable String fmtpAttributeValue = attributes.get(ATTR_FMTP);\n  if (fmtpAttributeValue == null) {\n    return ImmutableMap.of();\n  }\n\n    \n  String[] fmtpComponents = Util.splitAtFirst(fmtpAttributeValue, \" \");\n  checkArgument(fmtpComponents.length == 2, fmtpAttributeValue);\n\n    \n    \n    \n  String[] parameters = fmtpComponents[1].split(\";\\\\s?\",  0);\n  ImmutableMap.Builder<String, String> formatParametersBuilder = new ImmutableMap.Builder<>();\n  for (String parameter : parameters) {\n      \n    String[] parameterPair = Util.splitAtFirst(parameter, \"=\");\n    formatParametersBuilder.put(parameterPair[0], parameterPair[1]);\n  }\n  return formatParametersBuilder.buildOrThrow();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "fmtp",
            "attribute",
            "as",
            "a",
            "map",
            "of",
            "fmtp",
            "parameter",
            "names",
            "to",
            "values",
            "or",
            "an",
            "empty",
            "map",
            "if",
            "the",
            "media",
            "description",
            "does",
            "not",
            "contain",
            "any",
            "fmtp",
            "attribute"
        ]
    },
    {
        "id": 2246,
        "code": "public void setTimestamp(long timestamp) {\n  if (timestamp != C.TIME_UNSET) {\n    if (!checkNotNull(extractor).hasReadFirstRtpPacket()) {\n      extractor.setFirstTimestamp(timestamp);\n    }\n  }\n}",
        "summary_tokens": [
            "sets",
            "the",
            "timestamp",
            "of",
            "an",
            "rtp",
            "packet",
            "to",
            "arrive"
        ]
    },
    {
        "id": 2247,
        "code": "public void setSequenceNumber(int sequenceNumber) {\n  if (!checkNotNull(extractor).hasReadFirstRtpPacket()) {\n    extractor.setFirstSequenceNumber(sequenceNumber);\n  }\n}",
        "summary_tokens": [
            "sets",
            "the",
            "timestamp",
            "of",
            "an",
            "rtp",
            "packet",
            "to",
            "arrive"
        ]
    },
    {
        "id": 2248,
        "code": "public void resetForSeek() {\n  checkNotNull(extractor).preSeek();\n}",
        "summary_tokens": [
            "signals",
            "when",
            "performing",
            "an",
            "rtsp",
            "seek",
            "that",
            "involves",
            "rtsp",
            "message",
            "exchange"
        ]
    },
    {
        "id": 2249,
        "code": "public void seekToUs(long positionUs, long nextRtpTimestamp) {\n  pendingSeekPositionUs = positionUs;\n  this.nextRtpTimestamp = nextRtpTimestamp;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "correct",
            "start",
            "position",
            "and",
            "rtp",
            "timestamp",
            "after",
            "a",
            "successful",
            "rtsp",
            "seek"
        ]
    },
    {
        "id": 2250,
        "code": "public void setFirstTimestamp(long firstTimestamp) {\n  this.firstTimestamp = firstTimestamp;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "timestamp",
            "of",
            "the",
            "first",
            "rtp",
            "packet",
            "to",
            "arrive"
        ]
    },
    {
        "id": 2251,
        "code": "public void setFirstSequenceNumber(int firstSequenceNumber) {\n  this.firstSequenceNumber = firstSequenceNumber;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "sequence",
            "number",
            "of",
            "the",
            "first",
            "rtp",
            "packet",
            "to",
            "arrive"
        ]
    },
    {
        "id": 2252,
        "code": "public boolean hasReadFirstRtpPacket() {\n  return firstPacketRead;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "first",
            "rtp",
            "packet",
            "is",
            "processed"
        ]
    },
    {
        "id": 2253,
        "code": "public void preSeek() {\n  synchronized (lock) {\n    isSeekPending = true;\n  }\n}",
        "summary_tokens": [
            "signals",
            "when",
            "performing",
            "an",
            "rtsp",
            "seek",
            "that",
            "involves",
            "rtsp",
            "message",
            "exchange"
        ]
    },
    {
        "id": 2254,
        "code": "private static long getCutoffTimeMs(long packetArrivalTimeMs) {\n    \n    \n  return packetArrivalTimeMs - 30;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "cutoff",
            "time",
            "of",
            "waiting",
            "for",
            "an",
            "out",
            "of",
            "order",
            "packet"
        ]
    },
    {
        "id": 2255,
        "code": "public static int getNextSequenceNumber(int sequenceNumber) {\n  return IntMath.mod(sequenceNumber + 1, MAX_SEQUENCE_NUMBER + 1);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "next",
            "sequence",
            "number",
            "of",
            "the",
            "sequence",
            "number"
        ]
    },
    {
        "id": 2256,
        "code": "public static int getPreviousSequenceNumber(int sequenceNumber) {\n  return IntMath.mod(sequenceNumber - 1, MAX_SEQUENCE_NUMBER + 1);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "previous",
            "sequence",
            "number",
            "from",
            "the",
            "sequence",
            "number"
        ]
    },
    {
        "id": 2257,
        "code": "public static RtpPacket parse(byte[] buffer, int length) {\n  return parse(new ParsableByteArray(buffer, length));\n}",
        "summary_tokens": [
            "creates",
            "an",
            "rtp",
            "packet",
            "from",
            "a",
            "byte",
            "array"
        ]
    },
    {
        "id": 2258,
        "code": "public int writeToBuffer(byte[] target, int offset, int length) {\n  int packetLength = MIN_HEADER_SIZE + (CSRC_SIZE * csrcCount) + payloadData.length;\n  if (length < packetLength || target.length - offset < packetLength) {\n    return C.LENGTH_UNSET;\n  }\n\n  ByteBuffer buffer = ByteBuffer.wrap(target, offset, length);\n  byte firstByte =\n      (byte)\n          ((version << 6)\n              | ((padding ? 1 : 0) << 5)\n              | ((extension ? 1 : 0) << 4)\n              | (csrcCount & 0xF));\n  byte secondByte = (byte) (((marker ? 1 : 0) << 7) | (payloadType & 0x7F));\n  buffer\n      .put(firstByte)\n      .put(secondByte)\n      .putShort((short) sequenceNumber)\n      .putInt((int) timestamp)\n      .putInt(ssrc)\n      .put(csrc)\n      .put(payloadData);\n  return packetLength;\n}",
        "summary_tokens": [
            "writes",
            "the",
            "data",
            "in",
            "an",
            "rtp",
            "packet",
            "to",
            "a",
            "target",
            "buffer"
        ]
    },
    {
        "id": 2259,
        "code": "public synchronized boolean offer(RtpPacket packet, long receivedTimestampMs) {\n  if (packetQueue.size() >= QUEUE_SIZE_THRESHOLD_FOR_RESET) {\n    throw new IllegalStateException(\n        \"Queue size limit of \" + QUEUE_SIZE_THRESHOLD_FOR_RESET + \" reached.\");\n  }\n\n  int packetSequenceNumber = packet.sequenceNumber;\n  if (!started) {\n    reset();\n    lastDequeuedSequenceNumber = RtpPacket.getPreviousSequenceNumber(packetSequenceNumber);\n    started = true;\n    addToQueue(new RtpPacketContainer(packet, receivedTimestampMs));\n    return true;\n  }\n\n  int expectedSequenceNumber = RtpPacket.getNextSequenceNumber(lastReceivedSequenceNumber);\n    \n  int sequenceNumberShift =\n      calculateSequenceNumberShift(packetSequenceNumber, expectedSequenceNumber);\n  if (abs(sequenceNumberShift) < MAX_SEQUENCE_LEAP_ALLOWED) {\n    if (calculateSequenceNumberShift(packetSequenceNumber, lastDequeuedSequenceNumber) > 0) {\n        \n      addToQueue(new RtpPacketContainer(packet, receivedTimestampMs));\n      return true;\n    }\n  } else {\n      \n    lastDequeuedSequenceNumber = RtpPacket.getPreviousSequenceNumber(packetSequenceNumber);\n    packetQueue.clear();\n    addToQueue(new RtpPacketContainer(packet, receivedTimestampMs));\n    return true;\n  }\n  return false;\n}",
        "summary_tokens": [
            "offer",
            "one",
            "packet",
            "to",
            "the",
            "reordering",
            "queue"
        ]
    },
    {
        "id": 2260,
        "code": "public synchronized RtpPacket poll(long cutoffTimestampMs) {\n  if (packetQueue.isEmpty()) {\n    return null;\n  }\n\n  RtpPacketContainer packetContainer = packetQueue.first();\n  int packetSequenceNumber = packetContainer.packet.sequenceNumber;\n\n  if (packetSequenceNumber == RtpPacket.getNextSequenceNumber(lastDequeuedSequenceNumber)\n      || cutoffTimestampMs >= packetContainer.receivedTimestampMs) {\n    packetQueue.pollFirst();\n    lastDequeuedSequenceNumber = packetSequenceNumber;\n    return packetContainer.packet;\n  }\n\n  return null;\n}",
        "summary_tokens": [
            "polls",
            "an",
            "rtp",
            "packet",
            "from",
            "the",
            "queue"
        ]
    },
    {
        "id": 2261,
        "code": "private static int calculateSequenceNumberShift(int sequenceNumber, int previousSequenceNumber) {\n  int sequenceShift = sequenceNumber - previousSequenceNumber;\n  if (abs(sequenceShift) > MAX_SEQUENCE_LEAP_ALLOWED) {\n    int shift =\n        min(sequenceNumber, previousSequenceNumber)\n            - max(sequenceNumber, previousSequenceNumber)\n            + RtpPacket.MAX_SEQUENCE_NUMBER;\n      \n      \n      \n    if (shift < MAX_SEQUENCE_LEAP_ALLOWED) {\n      return sequenceNumber < previousSequenceNumber\n          ?  shift\n          :  -shift;\n    }\n  }\n  return sequenceShift;\n}",
        "summary_tokens": [
            "calculates",
            "the",
            "sequence",
            "number",
            "shift",
            "accounting",
            "for",
            "wrapping",
            "around"
        ]
    },
    {
        "id": 2262,
        "code": "public static boolean isFormatSupported(MediaDescription mediaDescription) {\n  switch (Ascii.toUpperCase(mediaDescription.rtpMapAttribute.mediaEncoding)) {\n    case RTP_MEDIA_AC3:\n    case RTP_MEDIA_AMR:\n    case RTP_MEDIA_AMR_WB:\n    case RTP_MEDIA_H263_1998:\n    case RTP_MEDIA_H263_2000:\n    case RTP_MEDIA_H264:\n    case RTP_MEDIA_H265:\n    case RTP_MEDIA_MPEG4_VIDEO:\n    case RTP_MEDIA_MPEG4_GENERIC:\n    case RTP_MEDIA_OPUS:\n    case RTP_MEDIA_PCM_L8:\n    case RTP_MEDIA_PCM_L16:\n    case RTP_MEDIA_PCMA:\n    case RTP_MEDIA_PCMU:\n    case RTP_MEDIA_VP8:\n    case RTP_MEDIA_VP9:\n      return true;\n    default:\n      return false;\n  }\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "format",
            "of",
            "a",
            "media",
            "description",
            "is",
            "supported"
        ]
    },
    {
        "id": 2263,
        "code": "public static String getMimeTypeFromRtpMediaType(String mediaType) {\n  switch (Ascii.toUpperCase(mediaType)) {\n    case RTP_MEDIA_AC3:\n      return MimeTypes.AUDIO_AC3;\n    case RTP_MEDIA_AMR:\n      return MimeTypes.AUDIO_AMR_NB;\n    case RTP_MEDIA_AMR_WB:\n      return MimeTypes.AUDIO_AMR_WB;\n    case RTP_MEDIA_MPEG4_GENERIC:\n      return MimeTypes.AUDIO_AAC;\n    case RTP_MEDIA_OPUS:\n      return MimeTypes.AUDIO_OPUS;\n    case RTP_MEDIA_PCM_L8:\n    case RTP_MEDIA_PCM_L16:\n      return MimeTypes.AUDIO_RAW;\n    case RTP_MEDIA_PCMA:\n      return MimeTypes.AUDIO_ALAW;\n    case RTP_MEDIA_PCMU:\n      return MimeTypes.AUDIO_MLAW;\n    case RTP_MEDIA_H263_1998:\n    case RTP_MEDIA_H263_2000:\n      return MimeTypes.VIDEO_H263;\n    case RTP_MEDIA_H264:\n      return MimeTypes.VIDEO_H264;\n    case RTP_MEDIA_H265:\n      return MimeTypes.VIDEO_H265;\n    case RTP_MEDIA_MPEG4_VIDEO:\n      return MimeTypes.VIDEO_MP4V;\n    case RTP_MEDIA_VP8:\n      return MimeTypes.VIDEO_VP8;\n    case RTP_MEDIA_VP9:\n      return MimeTypes.VIDEO_VP9;\n    default:\n      throw new IllegalArgumentException(mediaType);\n  }\n}",
        "summary_tokens": [
            "gets",
            "the",
            "mime",
            "type",
            "that",
            "is",
            "associated",
            "with",
            "the",
            "rtp",
            "media",
            "type"
        ]
    },
    {
        "id": 2264,
        "code": "public static @C.PcmEncoding int getRawPcmEncodingType(String mediaEncoding) {\n  checkArgument(\n      mediaEncoding.equals(RTP_MEDIA_PCM_L8) || mediaEncoding.equals(RTP_MEDIA_PCM_L16));\n  return mediaEncoding.equals(RtpPayloadFormat.RTP_MEDIA_PCM_L8)\n      ? C.ENCODING_PCM_8BIT\n      : C.ENCODING_PCM_16BIT_BIG_ENDIAN;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "pcm",
            "encoding",
            "type",
            "for",
            "media",
            "encoding"
        ]
    },
    {
        "id": 2265,
        "code": "public static DataSpec getIncomingRtpDataSpec(int portNumber) {\n  return new DataSpec(\n      Uri.parse(Util.formatInvariant(\"%s:%d\", RTP_ANY_INCOMING_IPV4, portNumber)));\n}",
        "summary_tokens": [
            "returns",
            "the",
            "data",
            "spec",
            "with",
            "the",
            "uri",
            "for",
            "incoming",
            "rtp",
            "connection"
        ]
    },
    {
        "id": 2266,
        "code": "public String getAuthorizationHeaderValue(\n    RtspAuthUserInfo authUserInfo, Uri uri, @RtspRequest.Method int requestMethod)\n    throws ParserException {\n  switch (authenticationMechanism) {\n    case BASIC:\n      return getBasicAuthorizationHeaderValue(authUserInfo);\n    case DIGEST:\n      return getDigestAuthorizationHeaderValue(authUserInfo, uri, requestMethod);\n    default:\n      throw ParserException.createForManifestWithUnsupportedFeature(\n           null, new UnsupportedOperationException());\n  }\n}",
        "summary_tokens": [
            "gets",
            "the",
            "string",
            "value",
            "for",
            "rtsp",
            "headers",
            "authorization",
            "header"
        ]
    },
    {
        "id": 2267,
        "code": "public void start() throws IOException {\n  try {\n    messageChannel.open(getSocket(uri));\n  } catch (IOException e) {\n    Util.closeQuietly(messageChannel);\n    throw e;\n  }\n  messageSender.sendOptionsRequest(uri, sessionId);\n}",
        "summary_tokens": [
            "starts",
            "the",
            "client",
            "and",
            "sends",
            "an",
            "options",
            "request"
        ]
    },
    {
        "id": 2268,
        "code": "public @RtspState int getState() {\n  return rtspState;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "current",
            "rtsp",
            "state",
            "rtsp",
            "state"
        ]
    },
    {
        "id": 2269,
        "code": "public void setupSelectedTracks(List<RtpLoadInfo> loadInfos) {\n  pendingSetupRtpLoadInfos.addAll(loadInfos);\n  continueSetupRtspTrack();\n}",
        "summary_tokens": [
            "triggers",
            "rtsp",
            "setup",
            "requests",
            "after",
            "track",
            "selection"
        ]
    },
    {
        "id": 2270,
        "code": "public void startPlayback(long offsetMs) {\n  messageSender.sendPlayRequest(uri, offsetMs, checkNotNull(sessionId));\n}",
        "summary_tokens": [
            "starts",
            "rtsp",
            "playback",
            "by",
            "sending",
            "rtsp",
            "play",
            "request"
        ]
    },
    {
        "id": 2271,
        "code": "public void seekToUs(long positionUs) {\n    \n    \n  if (rtspState == RTSP_STATE_PLAYING && !hasPendingPauseRequest) {\n    messageSender.sendPauseRequest(uri, checkNotNull(sessionId));\n  }\n  pendingSeekPositionUs = positionUs;\n}",
        "summary_tokens": [
            "seeks",
            "to",
            "a",
            "specific",
            "time",
            "using",
            "rtsp"
        ]
    },
    {
        "id": 2272,
        "code": "public void retryWithRtpTcp() {\n  try {\n    close();\n    messageChannel = new RtspMessageChannel(new MessageListener());\n    messageChannel.open(getSocket(uri));\n    sessionId = null;\n    receivedAuthorizationRequest = false;\n    rtspAuthenticationInfo = null;\n  } catch (IOException e) {\n    playbackEventListener.onPlaybackError(new RtspPlaybackException(e));\n  }\n}",
        "summary_tokens": [
            "sets",
            "up",
            "a",
            "new",
            "playback",
            "session",
            "using",
            "tcp",
            "as",
            "rtp",
            "lower",
            "transport"
        ]
    },
    {
        "id": 2273,
        "code": "public void registerInterleavedDataChannel(\n    int channel, InterleavedBinaryDataListener interleavedBinaryDataListener) {\n  messageChannel.registerInterleavedBinaryDataListener(channel, interleavedBinaryDataListener);\n}",
        "summary_tokens": [
            "registers",
            "an",
            "interleaved",
            "binary",
            "data",
            "listener",
            "to",
            "receive",
            "rtsp",
            "interleaved",
            "data"
        ]
    },
    {
        "id": 2274,
        "code": "private Socket getSocket(Uri uri) throws IOException {\n  checkArgument(uri.getHost() != null);\n  int rtspPort = uri.getPort() > 0 ? uri.getPort() : DEFAULT_RTSP_PORT;\n  return socketFactory.createSocket(checkNotNull(uri.getHost()), rtspPort);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "socket",
            "that",
            "is",
            "connected",
            "to",
            "the",
            "uri"
        ]
    },
    {
        "id": 2275,
        "code": "private static boolean serverSupportsDescribe(List<Integer> serverSupportedMethods) {\n  return serverSupportedMethods.isEmpty() || serverSupportedMethods.contains(METHOD_DESCRIBE);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "rtsp",
            "server",
            "supports",
            "the",
            "describe",
            "method"
        ]
    },
    {
        "id": 2276,
        "code": "private static ImmutableList<RtspMediaTrack> buildTrackList(\n    SessionDescription sessionDescription, Uri uri) {\n  ImmutableList.Builder<RtspMediaTrack> trackListBuilder = new ImmutableList.Builder<>();\n  for (int i = 0; i < sessionDescription.mediaDescriptionList.size(); i++) {\n    MediaDescription mediaDescription = sessionDescription.mediaDescriptionList.get(i);\n      \n    if (RtpPayloadFormat.isFormatSupported(mediaDescription)) {\n      trackListBuilder.add(new RtspMediaTrack(mediaDescription, uri));\n    }\n  }\n  return trackListBuilder.build();\n}",
        "summary_tokens": [
            "gets",
            "the",
            "included",
            "rtsp",
            "media",
            "track",
            "rtsp",
            "media",
            "tracks",
            "from",
            "a",
            "session",
            "description"
        ]
    },
    {
        "id": 2277,
        "code": "public Builder buildUpon() {\n  ImmutableListMultimap.Builder<String, String> namesAndValuesBuilder =\n      new ImmutableListMultimap.Builder<>();\n  namesAndValuesBuilder.putAll(namesAndValues);\n  return new Builder(namesAndValuesBuilder);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "builder",
            "initialized",
            "with",
            "the",
            "values",
            "of",
            "this",
            "instance"
        ]
    },
    {
        "id": 2278,
        "code": "public ImmutableListMultimap<String, String> asMultiMap() {\n  return namesAndValues;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "map",
            "that",
            "associates",
            "header",
            "names",
            "to",
            "the",
            "list",
            "of",
            "values",
            "associated",
            "with",
            "the",
            "corresponding",
            "header",
            "name"
        ]
    },
    {
        "id": 2279,
        "code": "public String get(String headerName) {\n  ImmutableList<String> headerValues = values(headerName);\n  if (headerValues.isEmpty()) {\n    return null;\n  }\n  return Iterables.getLast(headerValues);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "most",
            "recent",
            "header",
            "value",
            "mapped",
            "to",
            "the",
            "argument",
            "null",
            "if",
            "the",
            "header",
            "name",
            "is",
            "not",
            "recorded"
        ]
    },
    {
        "id": 2280,
        "code": "public ImmutableList<String> values(String headerName) {\n  return namesAndValues.get(convertToStandardHeaderName(headerName));\n}",
        "summary_tokens": [
            "returns",
            "a",
            "list",
            "of",
            "header",
            "values",
            "mapped",
            "to",
            "the",
            "argument",
            "in",
            "the",
            "addition",
            "order"
        ]
    },
    {
        "id": 2281,
        "code": "public void release() {\n  for (int i = 0; i < rtspLoaderWrappers.size(); i++) {\n    rtspLoaderWrappers.get(i).release();\n  }\n  Util.closeQuietly(rtspClient);\n  released = true;\n}",
        "summary_tokens": [
            "releases",
            "the",
            "rtsp",
            "media",
            "period"
        ]
    },
    {
        "id": 2282,
        "code": "private boolean seekInsideBufferUs(long positionUs) {\n  for (int i = 0; i < rtspLoaderWrappers.size(); i++) {\n    SampleQueue sampleQueue = rtspLoaderWrappers.get(i).sampleQueue;\n    if (!sampleQueue.seekTo(positionUs,  false)) {\n      return false;\n    }\n  }\n  return true;\n}",
        "summary_tokens": [
            "attempts",
            "to",
            "seek",
            "to",
            "the",
            "specified",
            "position",
            "within",
            "the",
            "sample",
            "queues"
        ]
    },
    {
        "id": 2283,
        "code": "private static byte[] getInitializationDataFromParameterSet(String parameterSet) {\n  byte[] decodedParameterNalData = Base64.decode(parameterSet, Base64.DEFAULT);\n  byte[] decodedParameterNalUnit =\n      new byte[decodedParameterNalData.length + NAL_START_CODE.length];\n  System.arraycopy(\n      NAL_START_CODE,\n       0,\n      decodedParameterNalUnit,\n       0,\n      NAL_START_CODE.length);\n  System.arraycopy(\n      decodedParameterNalData,\n       0,\n      decodedParameterNalUnit,\n       NAL_START_CODE.length,\n      decodedParameterNalData.length);\n  return decodedParameterNalUnit;\n}",
        "summary_tokens": [
            "returns",
            "h",
            "0",
            "h",
            "0",
            "initialization",
            "data",
            "from",
            "the",
            "rtp",
            "parameter",
            "set"
        ]
    },
    {
        "id": 2284,
        "code": "private static Uri extractTrackUri(Uri sessionUri, String controlAttributeString) {\n  Uri controlAttributeUri = Uri.parse(controlAttributeString);\n  if (controlAttributeUri.isAbsolute()) {\n    return controlAttributeUri;\n  } else if (controlAttributeString.equals(GENERIC_CONTROL_ATTR)) {\n    return sessionUri;\n  } else {\n    return sessionUri.buildUpon().appendEncodedPath(controlAttributeString).build();\n  }\n}",
        "summary_tokens": [
            "extracts",
            "the",
            "track",
            "uri"
        ]
    },
    {
        "id": 2285,
        "code": "public void open(Socket socket) throws IOException {\n  this.socket = socket;\n  sender = new Sender(socket.getOutputStream());\n\n  receiverLoader.startLoading(\n      new Receiver(socket.getInputStream()),\n      new LoaderCallbackImpl(),\n       0);\n}",
        "summary_tokens": [
            "opens",
            "the",
            "message",
            "channel",
            "to",
            "send",
            "and",
            "receive",
            "rtsp",
            "messages"
        ]
    },
    {
        "id": 2286,
        "code": "public void close() throws IOException {\n    \n    \n  if (closed) {\n    return;\n  }\n  try {\n    if (sender != null) {\n      sender.close();\n    }\n    receiverLoader.release();\n\n    if (socket != null) {\n      socket.close();\n    }\n  } finally {\n    closed = true;\n  }\n}",
        "summary_tokens": [
            "closes",
            "the",
            "rtsp",
            "message",
            "channel"
        ]
    },
    {
        "id": 2287,
        "code": "public void send(List<String> message) {\n  checkStateNotNull(sender);\n  sender.send(message);\n}",
        "summary_tokens": [
            "sends",
            "a",
            "serialized",
            "rtsp",
            "message"
        ]
    },
    {
        "id": 2288,
        "code": "public void registerInterleavedBinaryDataListener(\n    int channel, InterleavedBinaryDataListener listener) {\n  interleavedBinaryDataListeners.put(channel, listener);\n}",
        "summary_tokens": [
            "registers",
            "an",
            "interleaved",
            "binary",
            "data",
            "listener",
            "to",
            "receive",
            "rtsp",
            "interleaved",
            "data"
        ]
    },
    {
        "id": 2289,
        "code": "public static ImmutableList<String> serializeRequest(RtspRequest request) {\n  checkArgument(request.headers.get(RtspHeaders.CSEQ) != null);\n\n  ImmutableList.Builder<String> builder = new ImmutableList.Builder<>();\n    \n  builder.add(\n      Util.formatInvariant(\n          \"%s %s %s\", toMethodString(request.method), request.uri, RTSP_VERSION));\n\n  ImmutableListMultimap<String, String> headers = request.headers.asMultiMap();\n  for (String headerName : headers.keySet()) {\n    ImmutableList<String> headerValuesForName = headers.get(headerName);\n    for (int i = 0; i < headerValuesForName.size(); i++) {\n      builder.add(Util.formatInvariant(\"%s: %s\", headerName, headerValuesForName.get(i)));\n    }\n  }\n    \n  builder.add(\"\");\n  builder.add(request.messageBody);\n  return builder.build();\n}",
        "summary_tokens": [
            "serializes",
            "an",
            "rtsp",
            "request",
            "to",
            "an",
            "immutable",
            "list",
            "of",
            "strings"
        ]
    },
    {
        "id": 2290,
        "code": "public static ImmutableList<String> serializeResponse(RtspResponse response) {\n  checkArgument(response.headers.get(RtspHeaders.CSEQ) != null);\n\n  ImmutableList.Builder<String> builder = new ImmutableList.Builder<>();\n    \n  builder.add(\n      Util.formatInvariant(\n          \"%s %s %s\", RTSP_VERSION, response.status, getRtspStatusReasonPhrase(response.status)));\n\n  ImmutableListMultimap<String, String> headers = response.headers.asMultiMap();\n  for (String headerName : headers.keySet()) {\n    ImmutableList<String> headerValuesForName = headers.get(headerName);\n    for (int i = 0; i < headerValuesForName.size(); i++) {\n      builder.add(Util.formatInvariant(\"%s: %s\", headerName, headerValuesForName.get(i)));\n    }\n  }\n    \n  builder.add(\"\");\n  builder.add(response.messageBody);\n  return builder.build();\n}",
        "summary_tokens": [
            "serializes",
            "an",
            "rtsp",
            "response",
            "to",
            "an",
            "immutable",
            "list",
            "of",
            "strings"
        ]
    },
    {
        "id": 2291,
        "code": "public static byte[] convertMessageToByteArray(List<String> message) {\n  return Joiner.on(CRLF).join(message).getBytes(RtspMessageChannel.CHARSET);\n}",
        "summary_tokens": [
            "converts",
            "an",
            "rtsp",
            "message",
            "to",
            "a",
            "byte",
            "array"
        ]
    },
    {
        "id": 2292,
        "code": "public static Uri removeUserInfo(Uri uri) {\n  if (uri.getUserInfo() == null) {\n    return uri;\n  }\n\n    \n  String authorityWithUserInfo = checkNotNull(uri.getAuthority());\n  checkArgument(authorityWithUserInfo.contains(\"@\"));\n  String authority = Util.split(authorityWithUserInfo, \"@\")[1];\n  return uri.buildUpon().encodedAuthority(authority).build();\n}",
        "summary_tokens": [
            "removes",
            "the",
            "user",
            "info",
            "from",
            "the",
            "supplied",
            "uri"
        ]
    },
    {
        "id": 2293,
        "code": "public static RtspAuthUserInfo parseUserInfo(Uri uri) {\n  @Nullable String userInfo = uri.getUserInfo();\n  if (userInfo == null) {\n    return null;\n  }\n  if (userInfo.contains(\":\")) {\n    String[] userInfoStrings = Util.splitAtFirst(userInfo, \":\");\n    return new RtspAuthUserInfo(userInfoStrings[0], userInfoStrings[1]);\n  }\n  return null;\n}",
        "summary_tokens": [
            "parses",
            "the",
            "user",
            "info",
            "encapsulated",
            "in",
            "the",
            "rtsp",
            "uri"
        ]
    },
    {
        "id": 2294,
        "code": "public static byte[] getStringBytes(String s) {\n  return s.getBytes(RtspMessageChannel.CHARSET);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "byte",
            "array",
            "representation",
            "of",
            "a",
            "string",
            "using",
            "rtsp",
            "s",
            "character",
            "encoding"
        ]
    },
    {
        "id": 2295,
        "code": "public static String toMethodString(@RtspRequest.Method int method) {\n  switch (method) {\n    case METHOD_ANNOUNCE:\n      return \"ANNOUNCE\";\n    case METHOD_DESCRIBE:\n      return \"DESCRIBE\";\n    case METHOD_GET_PARAMETER:\n      return \"GET_PARAMETER\";\n    case METHOD_OPTIONS:\n      return \"OPTIONS\";\n    case METHOD_PAUSE:\n      return \"PAUSE\";\n    case METHOD_PLAY:\n      return \"PLAY\";\n    case METHOD_PLAY_NOTIFY:\n      return \"PLAY_NOTIFY\";\n    case METHOD_RECORD:\n      return \"RECORD\";\n    case METHOD_REDIRECT:\n      return \"REDIRECT\";\n    case METHOD_SETUP:\n      return \"SETUP\";\n    case METHOD_SET_PARAMETER:\n      return \"SET_PARAMETER\";\n    case METHOD_TEARDOWN:\n      return \"TEARDOWN\";\n    case METHOD_UNSET:\n    default:\n      throw new IllegalStateException();\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "corresponding",
            "string",
            "representation",
            "of",
            "the",
            "rtsp",
            "request"
        ]
    },
    {
        "id": 2296,
        "code": "public static RtspResponse parseResponse(List<String> lines) {\n  Matcher statusLineMatcher = STATUS_LINE_PATTERN.matcher(lines.get(0));\n  checkArgument(statusLineMatcher.matches());\n\n  int statusCode = Integer.parseInt(checkNotNull(statusLineMatcher.group(1)));\n    \n  int messageBodyOffset = lines.indexOf(\"\");\n  checkArgument(messageBodyOffset > 0);\n\n  List<String> headerLines = lines.subList(1, messageBodyOffset);\n  RtspHeaders headers = new RtspHeaders.Builder().addAll(headerLines).build();\n\n  String messageBody = Joiner.on(CRLF).join(lines.subList(messageBodyOffset + 1, lines.size()));\n  return new RtspResponse(statusCode, headers, messageBody);\n}",
        "summary_tokens": [
            "parses",
            "lines",
            "of",
            "a",
            "received",
            "rtsp",
            "response",
            "into",
            "an",
            "rtsp",
            "response",
            "instance"
        ]
    },
    {
        "id": 2297,
        "code": "public static RtspRequest parseRequest(List<String> lines) {\n  Matcher requestMatcher = REQUEST_LINE_PATTERN.matcher(lines.get(0));\n  checkArgument(requestMatcher.matches());\n\n  @RtspRequest.Method int method = parseMethodString(checkNotNull(requestMatcher.group(1)));\n  Uri requestUri = Uri.parse(checkNotNull(requestMatcher.group(2)));\n    \n  int messageBodyOffset = lines.indexOf(\"\");\n  checkArgument(messageBodyOffset > 0);\n\n  List<String> headerLines = lines.subList(1, messageBodyOffset);\n  RtspHeaders headers = new RtspHeaders.Builder().addAll(headerLines).build();\n\n  String messageBody = Joiner.on(CRLF).join(lines.subList(messageBodyOffset + 1, lines.size()));\n  return new RtspRequest(requestUri, method, headers, messageBody);\n}",
        "summary_tokens": [
            "parses",
            "lines",
            "of",
            "a",
            "received",
            "rtsp",
            "request",
            "into",
            "an",
            "rtsp",
            "request",
            "instance"
        ]
    },
    {
        "id": 2298,
        "code": "public static boolean isRtspStartLine(String line) {\n  return REQUEST_LINE_PATTERN.matcher(line).matches()\n      || STATUS_LINE_PATTERN.matcher(line).matches();\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "line",
            "is",
            "a",
            "valid",
            "rtsp",
            "start",
            "line"
        ]
    },
    {
        "id": 2299,
        "code": "public static boolean isRtspResponse(List<String> lines) {\n  return STATUS_LINE_PATTERN.matcher(lines.get(0)).matches();\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "rtsp",
            "message",
            "is",
            "an",
            "rtsp",
            "response"
        ]
    },
    {
        "id": 2300,
        "code": "public static String[] splitRtspMessageBody(String body) {\n  return Util.split(body, body.contains(CRLF) ? CRLF : LF);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "lines",
            "in",
            "an",
            "rtsp",
            "message",
            "body",
            "split",
            "by",
            "the",
            "line",
            "terminator",
            "used",
            "in",
            "body"
        ]
    },
    {
        "id": 2301,
        "code": "public static long parseContentLengthHeader(String line) throws ParserException {\n  try {\n    Matcher matcher = CONTENT_LENGTH_HEADER_PATTERN.matcher(line);\n    if (matcher.find()) {\n      return Long.parseLong(checkNotNull(matcher.group(1)));\n    } else {\n      return C.LENGTH_UNSET;\n    }\n  } catch (NumberFormatException e) {\n    throw ParserException.createForMalformedManifest(line, e);\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "length",
            "in",
            "bytes",
            "if",
            "the",
            "line",
            "contains",
            "a",
            "content",
            "length",
            "header",
            "otherwise",
            "c",
            "length",
            "unset"
        ]
    },
    {
        "id": 2302,
        "code": "public static ImmutableList<Integer> parsePublicHeader(@Nullable String publicHeader) {\n  if (publicHeader == null) {\n    return ImmutableList.of();\n  }\n\n  ImmutableList.Builder<Integer> methodListBuilder = new ImmutableList.Builder<>();\n  for (String method : Util.split(publicHeader, \",\\\\s?\")) {\n    methodListBuilder.add(parseMethodString(method));\n  }\n  return methodListBuilder.build();\n}",
        "summary_tokens": [
            "parses",
            "the",
            "rtsp",
            "public",
            "header",
            "into",
            "a",
            "list",
            "of",
            "rtsp",
            "methods"
        ]
    },
    {
        "id": 2303,
        "code": "public static RtspSessionHeader parseSessionHeader(String headerValue) throws ParserException {\n  Matcher matcher = SESSION_HEADER_PATTERN.matcher(headerValue);\n  if (!matcher.matches()) {\n    throw ParserException.createForMalformedManifest(headerValue,  null);\n  }\n\n  String sessionId = checkNotNull(matcher.group(1));\n    \n  long timeoutMs = DEFAULT_RTSP_TIMEOUT_MS;\n  @Nullable String timeoutString;\n  if ((timeoutString = matcher.group(2)) != null) {\n    try {\n      timeoutMs = Integer.parseInt(timeoutString) * C.MILLIS_PER_SECOND;\n    } catch (NumberFormatException e) {\n      throw ParserException.createForMalformedManifest(headerValue, e);\n    }\n  }\n\n  return new RtspSessionHeader(sessionId, timeoutMs);\n}",
        "summary_tokens": [
            "parses",
            "a",
            "session",
            "header",
            "in",
            "an",
            "rtsp",
            "message",
            "to",
            "rtsp",
            "session",
            "header"
        ]
    },
    {
        "id": 2304,
        "code": "public static RtspAuthenticationInfo parseWwwAuthenticateHeader(String headerValue)\n    throws ParserException {\n  Matcher matcher = WWW_AUTHENTICATION_HEADER_DIGEST_PATTERN.matcher(headerValue);\n  if (matcher.find()) {\n    return new RtspAuthenticationInfo(\n        RtspAuthenticationInfo.DIGEST,\n         checkNotNull(matcher.group(1)),\n         checkNotNull(matcher.group(3)),\n         nullToEmpty(matcher.group(4)));\n  }\n  matcher = WWW_AUTHENTICATION_HEADER_BASIC_PATTERN.matcher(headerValue);\n  if (matcher.matches()) {\n    return new RtspAuthenticationInfo(\n        RtspAuthenticationInfo.BASIC,\n         checkNotNull(matcher.group(1)),\n         \"\",\n         \"\");\n  }\n  throw ParserException.createForMalformedManifest(\n      \"Invalid WWW-Authenticate header \" + headerValue,  null);\n}",
        "summary_tokens": [
            "parses",
            "a",
            "www",
            "authenticate",
            "header"
        ]
    },
    {
        "id": 2305,
        "code": "public static void checkManifestExpression(boolean expression, @Nullable String message)\n    throws ParserException {\n  if (!expression) {\n    throw ParserException.createForMalformedManifest(message,  null);\n  }\n}",
        "summary_tokens": [
            "throws",
            "parser",
            "exception",
            "create",
            "for",
            "malformed",
            "manifest",
            "parser",
            "exception",
            "if",
            "expression",
            "evaluates",
            "to",
            "false"
        ]
    },
    {
        "id": 2306,
        "code": "public static int parseInt(String intString) throws ParserException {\n  try {\n    return Integer.parseInt(intString);\n  } catch (NumberFormatException e) {\n    throw ParserException.createForMalformedManifest(intString, e);\n  }\n}",
        "summary_tokens": [
            "parses",
            "the",
            "string",
            "argument",
            "as",
            "an",
            "integer",
            "wraps",
            "the",
            "potential",
            "number",
            "format",
            "exception",
            "in",
            "parser",
            "exception"
        ]
    },
    {
        "id": 2307,
        "code": "public static RtspSessionTiming parseTiming(String sdpRangeAttribute) throws ParserException {\n  long startTimeMs;\n  long stopTimeMs;\n  Matcher matcher = NPT_RANGE_PATTERN.matcher(sdpRangeAttribute);\n  checkManifestExpression(matcher.matches(),  sdpRangeAttribute);\n\n  @Nullable String startTimeString = matcher.group(1);\n  checkManifestExpression(startTimeString != null,  sdpRangeAttribute);\n  if (castNonNull(startTimeString).equals(\"now\")) {\n    startTimeMs = LIVE_START_TIME;\n  } else {\n    startTimeMs = (long) (Float.parseFloat(startTimeString) * C.MILLIS_PER_SECOND);\n  }\n\n  @Nullable String stopTimeString = matcher.group(2);\n  if (stopTimeString != null) {\n    try {\n      stopTimeMs = (long) (Float.parseFloat(stopTimeString) * C.MILLIS_PER_SECOND);\n    } catch (NumberFormatException e) {\n      throw ParserException.createForMalformedManifest(stopTimeString, e);\n    }\n    checkManifestExpression(stopTimeMs >= startTimeMs,  sdpRangeAttribute);\n  } else {\n    stopTimeMs = C.TIME_UNSET;\n  }\n\n  return new RtspSessionTiming(startTimeMs, stopTimeMs);\n}",
        "summary_tokens": [
            "parses",
            "an",
            "sdp",
            "range",
            "attribute",
            "rfc",
            "0",
            "section",
            "0"
        ]
    },
    {
        "id": 2308,
        "code": "public static String getOffsetStartTimeTiming(long offsetStartTimeMs) {\n  double offsetStartTimeSec = (double) offsetStartTimeMs / C.MILLIS_PER_SECOND;\n  return Util.formatInvariant(START_TIMING_NTP_FORMAT, offsetStartTimeSec);\n}",
        "summary_tokens": [
            "gets",
            "a",
            "range",
            "rtsp",
            "header",
            "for",
            "an",
            "rtsp",
            "play",
            "request"
        ]
    },
    {
        "id": 2309,
        "code": "public boolean isLive() {\n  return stopTimeMs == C.TIME_UNSET;\n}",
        "summary_tokens": [
            "tests",
            "whether",
            "the",
            "timing",
            "is",
            "live"
        ]
    },
    {
        "id": 2310,
        "code": "public long getDurationMs() {\n  return stopTimeMs - startTimeMs;\n}",
        "summary_tokens": [
            "gets",
            "the",
            "session",
            "duration",
            "in",
            "milliseconds"
        ]
    },
    {
        "id": 2311,
        "code": "public static ImmutableList<RtspTrackTiming> parseTrackTiming(\n    String rtpInfoString, Uri sessionUri) throws ParserException {\n\n  ImmutableList.Builder<RtspTrackTiming> listBuilder = new ImmutableList.Builder<>();\n  for (String perTrackTimingString : Util.split(rtpInfoString, \",\")) {\n    long rtpTime = C.TIME_UNSET;\n    int sequenceNumber = C.INDEX_UNSET;\n    @Nullable Uri uri = null;\n\n    for (String attributePair : Util.split(perTrackTimingString, \";\")) {\n      try {\n        String[] attributes = Util.splitAtFirst(attributePair, \"=\");\n        String attributeName = attributes[0];\n        String attributeValue = attributes[1];\n\n        switch (attributeName) {\n          case \"url\":\n            uri = resolveUri( attributeValue, sessionUri);\n            break;\n          case \"seq\":\n            sequenceNumber = Integer.parseInt(attributeValue);\n            break;\n          case \"rtptime\":\n            rtpTime = Long.parseLong(attributeValue);\n            break;\n          default:\n            throw ParserException.createForMalformedManifest(attributeName,  null);\n        }\n      } catch (Exception e) {\n        throw ParserException.createForMalformedManifest(attributePair, e);\n      }\n    }\n\n    if (uri == null\n        || uri.getScheme() == null \n        || (sequenceNumber == C.INDEX_UNSET && rtpTime == C.TIME_UNSET)) {\n      throw ParserException.createForMalformedManifest(perTrackTimingString,  null);\n    }\n\n    listBuilder.add(new RtspTrackTiming(rtpTime, sequenceNumber, uri));\n  }\n  return listBuilder.build();\n}",
        "summary_tokens": [
            "parses",
            "the",
            "rtp",
            "info",
            "header",
            "into",
            "a",
            "list",
            "of",
            "rtsp",
            "track",
            "timing",
            "rtsp",
            "track",
            "timings"
        ]
    },
    {
        "id": 2312,
        "code": " static Uri resolveUri(String urlString, Uri sessionUri) {\n  checkArgument(checkNotNull(sessionUri.getScheme()).equals(\"rtsp\"));\n\n  Uri uri = Uri.parse(urlString);\n  if (uri.isAbsolute()) {\n    return uri;\n  }\n\n    \n  uri = Uri.parse(\"rtsp://\" + urlString);\n  String sessionUriString = sessionUri.toString();\n\n  String host = checkNotNull(uri.getHost());\n  if (host.equals(sessionUri.getHost())) {\n      \n    return uri;\n  }\n\n  return sessionUriString.endsWith(\"/\")\n      ? UriUtil.resolveToUri(sessionUriString, urlString)\n      : UriUtil.resolveToUri(sessionUriString + \"/\", urlString);\n}",
        "summary_tokens": [
            "resolves",
            "the",
            "input",
            "string",
            "to",
            "always",
            "be",
            "an",
            "absolute",
            "url",
            "with",
            "rtp",
            "info",
            "headers"
        ]
    },
    {
        "id": 2313,
        "code": "public static SessionDescription parse(String sdpString) throws ParserException {\n  SessionDescription.Builder sessionDescriptionBuilder = new SessionDescription.Builder();\n  @Nullable MediaDescription.Builder mediaDescriptionBuilder = null;\n\n    \n  for (String line : RtspMessageUtil.splitRtspMessageBody(sdpString)) {\n    if (\"\".equals(line)) {\n      continue;\n    }\n\n    Matcher matcher = SDP_LINE_PATTERN.matcher(line);\n    if (!matcher.matches()) {\n      throw ParserException.createForMalformedManifest(\n          \"Malformed SDP line: \" + line,  null);\n    }\n\n    String sdpType = checkNotNull(matcher.group(1));\n    String sdpValue = checkNotNull(matcher.group(2));\n\n    switch (sdpType) {\n      case VERSION_TYPE:\n        if (!SUPPORTED_SDP_VERSION.equals(sdpValue)) {\n          throw ParserException.createForMalformedManifest(\n              String.format(\"SDP version %s is not supported.\", sdpValue),  null);\n        }\n        break;\n\n      case ORIGIN_TYPE:\n        sessionDescriptionBuilder.setOrigin(sdpValue);\n        break;\n\n      case SESSION_TYPE:\n        sessionDescriptionBuilder.setSessionName(sdpValue);\n        break;\n\n      case INFORMATION_TYPE:\n        if (mediaDescriptionBuilder == null) {\n          sessionDescriptionBuilder.setSessionInfo(sdpValue);\n        } else {\n          mediaDescriptionBuilder.setMediaTitle(sdpValue);\n        }\n        break;\n\n      case URI_TYPE:\n        sessionDescriptionBuilder.setUri(Uri.parse(sdpValue));\n        break;\n\n      case EMAIL_TYPE:\n        sessionDescriptionBuilder.setEmailAddress(sdpValue);\n        break;\n\n      case PHONE_NUMBER_TYPE:\n        sessionDescriptionBuilder.setPhoneNumber(sdpValue);\n        break;\n\n      case CONNECTION_TYPE:\n        if (mediaDescriptionBuilder == null) {\n          sessionDescriptionBuilder.setConnection(sdpValue);\n        } else {\n          mediaDescriptionBuilder.setConnection(sdpValue);\n        }\n        break;\n\n      case BANDWIDTH_TYPE:\n        String[] bandwidthComponents = Util.split(sdpValue, \":\\\\s?\");\n        checkArgument(bandwidthComponents.length == 2);\n        int bitrateKbps = Integer.parseInt(bandwidthComponents[1]);\n\n          \n        if (mediaDescriptionBuilder == null) {\n          sessionDescriptionBuilder.setBitrate(bitrateKbps * 1000);\n        } else {\n          mediaDescriptionBuilder.setBitrate(bitrateKbps * 1000);\n        }\n        break;\n\n      case TIMING_TYPE:\n        sessionDescriptionBuilder.setTiming(sdpValue);\n        break;\n\n      case KEY_TYPE:\n        if (mediaDescriptionBuilder == null) {\n          sessionDescriptionBuilder.setKey(sdpValue);\n        } else {\n          mediaDescriptionBuilder.setKey(sdpValue);\n        }\n        break;\n\n      case ATTRIBUTE_TYPE:\n        matcher = ATTRIBUTE_PATTERN.matcher(sdpValue);\n        if (!matcher.matches()) {\n          throw ParserException.createForMalformedManifest(\n              \"Malformed Attribute line: \" + line,  null);\n        }\n\n        String attributeName = checkNotNull(matcher.group(1));\n          \n        String attributeValue = nullToEmpty(matcher.group(2));\n\n        if (mediaDescriptionBuilder == null) {\n          sessionDescriptionBuilder.addAttribute(attributeName, attributeValue);\n        } else {\n          mediaDescriptionBuilder.addAttribute(attributeName, attributeValue);\n        }\n        break;\n\n      case MEDIA_TYPE:\n        if (mediaDescriptionBuilder != null) {\n          addMediaDescriptionToSession(sessionDescriptionBuilder, mediaDescriptionBuilder);\n        }\n        mediaDescriptionBuilder = parseMediaDescriptionLine(sdpValue);\n        break;\n      case REPEAT_TYPE:\n      case ZONE_TYPE:\n      default:\n          \n    }\n  }\n\n  if (mediaDescriptionBuilder != null) {\n    addMediaDescriptionToSession(sessionDescriptionBuilder, mediaDescriptionBuilder);\n  }\n\n  try {\n    return sessionDescriptionBuilder.build();\n  } catch (IllegalArgumentException | IllegalStateException e) {\n    throw ParserException.createForMalformedManifest( null, e);\n  }\n}",
        "summary_tokens": [
            "parses",
            "a",
            "string",
            "based",
            "sdp",
            "message",
            "into",
            "session",
            "description"
        ]
    },
    {
        "id": 2314,
        "code": "private static long toSampleTimeUs(\n    long startTimeOffsetUs, long rtpTimestamp, long firstReceivedRtpTimestamp, int sampleRate) {\n  return startTimeOffsetUs\n      + Util.scaleLargeTimestamp(\n          rtpTimestamp - firstReceivedRtpTimestamp,\n           C.MICROS_PER_SECOND,\n           sampleRate);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "correct",
            "sample",
            "time",
            "from",
            "rtp",
            "timestamp",
            "accounting",
            "for",
            "the",
            "aac",
            "sampling",
            "rate"
        ]
    },
    {
        "id": 2315,
        "code": "private void maybeOutputSampleMetadata() {\n  if (numBytesPendingMetadataOutput > 0) {\n    outputSampleMetadataForFragmentedPackets();\n  }\n}",
        "summary_tokens": [
            "checks",
            "and",
            "outputs",
            "sample",
            "metadata",
            "if",
            "the",
            "last",
            "packet",
            "of",
            "a",
            "series",
            "of",
            "fragmented",
            "packets",
            "is",
            "lost"
        ]
    },
    {
        "id": 2316,
        "code": "private static long toSampleTimeUs(\n    long startTimeOffsetUs, long rtpTimestamp, long firstReceivedRtpTimestamp, int sampleRate) {\n  return startTimeOffsetUs\n      + Util.scaleLargeTimestamp(\n          rtpTimestamp - firstReceivedRtpTimestamp,\n           C.MICROS_PER_SECOND,\n           sampleRate);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "correct",
            "sample",
            "time",
            "from",
            "rtp",
            "timestamp",
            "accounting",
            "for",
            "the",
            "ac",
            "0",
            "sampling",
            "rate"
        ]
    },
    {
        "id": 2317,
        "code": "private static long toSampleTimeUs(\n    long startTimeOffsetUs, long rtpTimestamp, long firstReceivedRtpTimestamp, int sampleRate) {\n  return startTimeOffsetUs\n      + Util.scaleLargeTimestamp(\n          rtpTimestamp - firstReceivedRtpTimestamp,\n           C.MICROS_PER_SECOND,\n           sampleRate);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "correct",
            "sample",
            "time",
            "from",
            "rtp",
            "timestamp",
            "accounting",
            "for",
            "the",
            "amr",
            "sampling",
            "rate"
        ]
    },
    {
        "id": 2318,
        "code": "private void parseVopHeader(ParsableByteArray data, boolean gotResolution) {\n    \n    \n  int currentPosition = data.getPosition();\n\n    \n  long shortVideoHeader = data.readUnsignedInt();\n  if (((shortVideoHeader >> 10) & 0x3F) == 0x20) {\n    int header = data.peekUnsignedByte();\n    int vopType = ((header >> 1) & 0x1);\n    if (!gotResolution && vopType == I_VOP) {\n        \n      int sourceFormat = ((header >> 2) & 0x07);\n      if (sourceFormat == 1) {\n        width = 128;\n        height = 96;\n      } else {\n        width = 176 << (sourceFormat - 2);\n        height = 144 << (sourceFormat - 2);\n      }\n    }\n    data.setPosition(currentPosition);\n    isKeyFrame = vopType == I_VOP;\n    return;\n  }\n  data.setPosition(currentPosition);\n  isKeyFrame = false;\n}",
        "summary_tokens": [
            "parses",
            "and",
            "set",
            "vop",
            "coding",
            "type",
            "and",
            "resolution"
        ]
    },
    {
        "id": 2319,
        "code": "private void processSingleNalUnitPacket(ParsableByteArray data) {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n  int numBytesInData = data.bytesLeft();\n  fragmentedSampleSizeBytes += writeStartCode();\n  trackOutput.sampleData(data, numBytesInData);\n  fragmentedSampleSizeBytes += numBytesInData;\n\n  int nalHeaderType = data.getData()[0] & 0x1F;\n  bufferFlags = getBufferFlagsFromNalType(nalHeaderType);\n}",
        "summary_tokens": [
            "processes",
            "single",
            "nal",
            "unit",
            "packet",
            "rfc",
            "0",
            "section",
            "0"
        ]
    },
    {
        "id": 2320,
        "code": "private void processSingleTimeAggregationPacket(ParsableByteArray data) {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    \n    \n  data.readUnsignedByte();\n\n    \n  int nalUnitLength;\n  while (data.bytesLeft() > 4) {\n    nalUnitLength = data.readUnsignedShort();\n    fragmentedSampleSizeBytes += writeStartCode();\n    trackOutput.sampleData(data, nalUnitLength);\n    fragmentedSampleSizeBytes += nalUnitLength;\n  }\n\n    \n  bufferFlags = 0;\n}",
        "summary_tokens": [
            "processes",
            "stap",
            "type",
            "a",
            "packet",
            "rfc",
            "0",
            "section",
            "0"
        ]
    },
    {
        "id": 2321,
        "code": "private void processFragmentationUnitPacket(ParsableByteArray data, int packetSequenceNumber) {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n  int fuIndicator = data.getData()[0];\n  int fuHeader = data.getData()[1];\n  int nalHeader = (fuIndicator & 0xE0) | (fuHeader & 0x1F);\n  boolean isFirstFuPacket = (fuHeader & 0x80) > 0;\n  boolean isLastFuPacket = (fuHeader & 0x40) > 0;\n\n  if (isFirstFuPacket) {\n      \n    fragmentedSampleSizeBytes += writeStartCode();\n\n      \n      \n    data.getData()[1] = (byte) nalHeader;\n    fuScratchBuffer.reset(data.getData());\n    fuScratchBuffer.setPosition(1);\n  } else {\n      \n    int expectedSequenceNumber = RtpPacket.getNextSequenceNumber(previousSequenceNumber);\n    if (packetSequenceNumber != expectedSequenceNumber) {\n      Log.w(\n          TAG,\n          Util.formatInvariant(\n              \"Received RTP packet with unexpected sequence number. Expected: %d; received: %d.\"\n                  + \" Dropping packet.\",\n              expectedSequenceNumber, packetSequenceNumber));\n      return;\n    }\n\n      \n    fuScratchBuffer.reset(data.getData());\n    fuScratchBuffer.setPosition(FU_PAYLOAD_OFFSET);\n  }\n\n  int fragmentSize = fuScratchBuffer.bytesLeft();\n  trackOutput.sampleData(fuScratchBuffer, fragmentSize);\n  fragmentedSampleSizeBytes += fragmentSize;\n\n  if (isLastFuPacket) {\n    bufferFlags = getBufferFlagsFromNalType(nalHeader & 0x1F);\n  }\n}",
        "summary_tokens": [
            "processes",
            "fragmentation",
            "unit",
            "type",
            "a",
            "packet",
            "rfc",
            "0",
            "section",
            "0"
        ]
    },
    {
        "id": 2322,
        "code": "private void processSingleNalUnitPacket(ParsableByteArray data) {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n  int numBytesInData = data.bytesLeft();\n  fragmentedSampleSizeBytes += writeStartCode();\n  trackOutput.sampleData(data, numBytesInData);\n  fragmentedSampleSizeBytes += numBytesInData;\n\n  int nalHeaderType = (data.getData()[0] >> 1) & 0x3F;\n  bufferFlags = getBufferFlagsFromNalType(nalHeaderType);\n}",
        "summary_tokens": [
            "processes",
            "single",
            "nal",
            "unit",
            "packet",
            "rfc",
            "0",
            "section",
            "0"
        ]
    },
    {
        "id": 2323,
        "code": "private void processFragmentationUnitPacket(ParsableByteArray data, int packetSequenceNumber)\n    throws ParserException {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n  if (data.getData().length < 3) {\n    throw ParserException.createForMalformedManifest(\"Malformed FU header.\",  null);\n  }\n  int tid = (data.getData()[1] & 0x7);\n  int fuHeader = data.getData()[2];\n  int nalUnitType = fuHeader & 0x3F;\n  boolean isFirstFuPacket = (fuHeader & 0x80) > 0;\n  boolean isLastFuPacket = (fuHeader & 0x40) > 0;\n\n  if (isFirstFuPacket) {\n      \n    fragmentedSampleSizeBytes += writeStartCode();\n\n      \n      \n      \n      \n      \n    data.getData()[1] = (byte) ((nalUnitType << 1) & 0x7F);\n    data.getData()[2] = (byte) tid;\n    fuScratchBuffer.reset(data.getData());\n    fuScratchBuffer.setPosition(1);\n  } else {\n      \n    int expectedSequenceNumber = (previousSequenceNumber + 1) % RtpPacket.MAX_SEQUENCE_NUMBER;\n    if (packetSequenceNumber != expectedSequenceNumber) {\n      Log.w(\n          TAG,\n          Util.formatInvariant(\n              \"Received RTP packet with unexpected sequence number. Expected: %d; received: %d.\"\n                  + \" Dropping packet.\",\n              expectedSequenceNumber, packetSequenceNumber));\n      return;\n    }\n\n      \n    fuScratchBuffer.reset(data.getData());\n    fuScratchBuffer.setPosition(FU_PAYLOAD_OFFSET);\n  }\n\n  int fragmentSize = fuScratchBuffer.bytesLeft();\n  trackOutput.sampleData(fuScratchBuffer, fragmentSize);\n  fragmentedSampleSizeBytes += fragmentSize;\n\n  if (isLastFuPacket) {\n    bufferFlags = getBufferFlagsFromNalType(nalUnitType);\n  }\n}",
        "summary_tokens": [
            "processes",
            "fragmentation",
            "unit",
            "packet",
            "rfc",
            "0",
            "section",
            "0"
        ]
    },
    {
        "id": 2324,
        "code": "private static @C.BufferFlags int getBufferFlagsFromVop(ParsableByteArray data) {\n    \n  byte[] inputData = data.getData();\n  byte[] startCode = new byte[] {0x0, 0x0, 0x1, (byte) 0xB6};\n  int vopStartCodePos = Bytes.indexOf(inputData, startCode);\n  if (vopStartCodePos != -1) {\n    data.setPosition(vopStartCodePos + 4);\n    int vopType = data.peekUnsignedByte() >> 6;\n    return vopType == I_VOP ? C.BUFFER_FLAG_KEY_FRAME : 0;\n  }\n  return 0;\n}",
        "summary_tokens": [
            "returns",
            "vop",
            "video",
            "object",
            "plane",
            "coding",
            "type"
        ]
    },
    {
        "id": 2325,
        "code": "private static void validateOpusIdHeader(ParsableByteArray data) {\n  int currPosition = data.getPosition();\n  int sampleSize = data.limit();\n  checkArgument(sampleSize > 18, \"ID Header has insufficient data\");\n  String header = data.readString(8);\n    \n  checkArgument(header.equals(\"OpusHead\"), \"ID Header missing\");\n  checkArgument(data.readUnsignedByte() == 1, \"version number must always be 1\");\n  data.setPosition(currPosition);\n}",
        "summary_tokens": [
            "validates",
            "the",
            "opus",
            "id",
            "header",
            "at",
            "data",
            "s",
            "current",
            "position",
            "throws",
            "illegal",
            "argument",
            "exception",
            "if",
            "the",
            "header",
            "is",
            "invalid"
        ]
    },
    {
        "id": 2326,
        "code": "private static long toSampleTimeUs(\n    long startTimeOffsetUs, long rtpTimestamp, long firstReceivedRtpTimestamp) {\n  return startTimeOffsetUs\n      + Util.scaleLargeTimestamp(\n          rtpTimestamp - firstReceivedRtpTimestamp,\n           C.MICROS_PER_SECOND,\n           MEDIA_CLOCK_FREQUENCY);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "correct",
            "sample",
            "time",
            "from",
            "rtp",
            "timestamp",
            "accounting",
            "for",
            "the",
            "opus",
            "sampling",
            "rate"
        ]
    },
    {
        "id": 2327,
        "code": "private static long toSampleUs(\n    long startTimeOffsetUs, long rtpTimestamp, long firstReceivedRtpTimestamp, int clockRate) {\n  return startTimeOffsetUs\n      + Util.scaleLargeTimestamp(\n          rtpTimestamp - firstReceivedRtpTimestamp,\n           C.MICROS_PER_SECOND,\n           clockRate);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "correct",
            "sample",
            "time",
            "from",
            "rtp",
            "timestamp",
            "accounting",
            "for",
            "the",
            "given",
            "clock",
            "rate"
        ]
    },
    {
        "id": 2328,
        "code": "private boolean validateVp8Descriptor(ParsableByteArray payload, int packetSequenceNumber) {\n    \n  int header = payload.readUnsignedByte();\n    \n    \n  if ((header & 0x10) == 0x10 && (header & 0x07) == 0) {\n    if (gotFirstPacketOfVp8Frame && fragmentedSampleSizeBytes > 0) {\n        \n      outputSampleMetadataForFragmentedPackets();\n    }\n    gotFirstPacketOfVp8Frame = true;\n  } else if (gotFirstPacketOfVp8Frame) {\n      \n    int expectedSequenceNumber = RtpPacket.getNextSequenceNumber(previousSequenceNumber);\n    if (packetSequenceNumber < expectedSequenceNumber) {\n      Log.w(\n          TAG,\n          Util.formatInvariant(\n              \"Received RTP packet with unexpected sequence number. Expected: %d; received: %d.\"\n                  + \" Dropping packet.\",\n              expectedSequenceNumber, packetSequenceNumber));\n      return false;\n    }\n  } else {\n    Log.w(TAG, \"RTP packet is not the start of a new VP8 partition, skipping.\");\n    return false;\n  }\n\n    \n  if ((header & 0x80) != 0) {\n    int xHeader = payload.readUnsignedByte();\n\n      \n    if ((xHeader & 0x80) != 0) {\n      int iHeader = payload.readUnsignedByte();\n        \n      if ((iHeader & 0x80) != 0) {\n        payload.skipBytes(1);\n      }\n    }\n\n      \n    if ((xHeader & 0x40) != 0) {\n      payload.skipBytes(1);\n    }\n\n      \n    if ((xHeader & 0x20) != 0 || (xHeader & 0x10) != 0) {\n      payload.skipBytes(1);\n    }\n  }\n  return true;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "and",
            "sets",
            "the",
            "parsable",
            "byte",
            "array",
            "get",
            "position",
            "payload"
        ]
    },
    {
        "id": 2329,
        "code": "private void outputSampleMetadataForFragmentedPackets() {\n  checkNotNull(trackOutput)\n      .sampleMetadata(\n          fragmentedSampleTimeUs,\n          isKeyFrame ? C.BUFFER_FLAG_KEY_FRAME : 0,\n          fragmentedSampleSizeBytes,\n           0,\n           null);\n  fragmentedSampleSizeBytes = 0;\n  fragmentedSampleTimeUs = C.TIME_UNSET;\n  gotFirstPacketOfVp8Frame = false;\n}",
        "summary_tokens": [
            "outputs",
            "sample",
            "metadata",
            "of",
            "the",
            "received",
            "fragmented",
            "packets"
        ]
    },
    {
        "id": 2330,
        "code": "private boolean validateVp9Descriptor(ParsableByteArray payload, int packetSequenceNumber) {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n  int header = payload.readUnsignedByte();\n  if (!gotFirstPacketOfVP9Frame) {\n    if ((header & 0x08) == 0) {\n      Log.w(\n          TAG,\n          \"First payload octet of the RTP packet is not the beginning of a new VP9 partition,\"\n              + \" Dropping current packet.\");\n      return false;\n    }\n    gotFirstPacketOfVP9Frame = true;\n  } else {\n      \n    int expectedSequenceNumber = RtpPacket.getNextSequenceNumber(previousSequenceNumber);\n    if (packetSequenceNumber != expectedSequenceNumber) {\n      Log.w(\n          TAG,\n          Util.formatInvariant(\n              \"Received RTP packet with unexpected sequence number. Expected: %d; received: %d.\"\n                  + \" Dropping packet.\",\n              expectedSequenceNumber, packetSequenceNumber));\n      return false;\n    }\n  }\n\n    \n  if ((header & 0x80) != 0) {\n    int optionalHeader = payload.readUnsignedByte();\n      \n    if ((optionalHeader & 0x80) != 0) {\n      if (payload.bytesLeft() < 1) {\n        return false;\n      }\n    }\n  }\n\n    \n  checkArgument((header & 0x10) == 0, \"VP9 flexible mode is not supported.\");\n\n    \n  if ((header & 0x20) != 0) {\n    payload.skipBytes(1);\n    if (payload.bytesLeft() < 1) {\n      return false;\n    }\n      \n    if ((header & 0x10) == 0) {\n      payload.skipBytes(1);\n    }\n  }\n\n    \n  if ((header & 0x02) != 0) {\n    int scalabilityStructure = payload.readUnsignedByte();\n    int spatialLayersCount = (scalabilityStructure >> 5) & 0x7;\n\n      \n    if ((scalabilityStructure & 0x10) != 0) {\n      int scalabilityStructureCount = spatialLayersCount + 1;\n      if (payload.bytesLeft() < scalabilityStructureCount * SCALABILITY_STRUCTURE_SIZE) {\n        return false;\n      }\n      for (int index = 0; index < scalabilityStructureCount; index++) {\n        width = payload.readUnsignedShort();\n        height = payload.readUnsignedShort();\n      }\n    }\n\n      \n    if ((scalabilityStructure & 0x08) != 0) {\n        \n      int numOfPicInPictureGroup = payload.readUnsignedByte();\n      if (payload.bytesLeft() < numOfPicInPictureGroup) {\n        return false;\n      }\n\n      for (int picIndex = 0; picIndex < numOfPicInPictureGroup; picIndex++) {\n        int picture = payload.readUnsignedShort();\n        int referenceIndices = (picture & 0x0C) >> 2;\n        if (payload.bytesLeft() < referenceIndices) {\n          return false;\n        }\n          \n        payload.skipBytes(referenceIndices);\n      }\n    }\n  }\n  return true;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "and",
            "sets",
            "the",
            "parsable",
            "byte",
            "array",
            "get",
            "position",
            "payload"
        ]
    },
    {
        "id": 2331,
        "code": "public static RtpPacketStreamDump parse(String jsonString) throws ParserException {\n  try {\n    JSONObject jsonObject = new JSONObject(jsonString);\n    String trackName = jsonObject.getString(\"trackName\");\n    int firstSequenceNumber = jsonObject.getInt(\"firstSequenceNumber\");\n    long firstTimestamp = jsonObject.getLong(\"firstTimestamp\");\n    long transmissionIntervalMs = jsonObject.getLong(\"transmitIntervalMs\");\n    String mediaDescription = jsonObject.getString(\"mediaDescription\");\n\n    ImmutableList.Builder<String> packetsBuilder = new ImmutableList.Builder<>();\n    JSONArray jsonPackets = jsonObject.getJSONArray(\"packets\");\n    for (int i = 0; i < jsonPackets.length(); i++) {\n      packetsBuilder.add(jsonPackets.getString(i));\n    }\n\n    return new RtpPacketStreamDump(\n        trackName,\n        firstSequenceNumber,\n        firstTimestamp,\n        transmissionIntervalMs,\n        mediaDescription,\n        packetsBuilder.build());\n  } catch (JSONException e) {\n    throw ParserException.createForMalformedManifest( null, e);\n  }\n}",
        "summary_tokens": [
            "parses",
            "a",
            "json",
            "string",
            "into",
            "an",
            "rtp",
            "packet",
            "stream",
            "dump"
        ]
    },
    {
        "id": 2332,
        "code": "public void startTransmitting(InterleavedBinaryDataListener binaryDataListener) {\n  if (isTransmitting) {\n    return;\n  }\n\n  this.binaryDataListener = binaryDataListener;\n  packetIndex = 0;\n  isTransmitting = true;\n  transmissionHandler.post(this::transmitNextPacket);\n}",
        "summary_tokens": [
            "starts",
            "transmitting",
            "binary",
            "data",
            "to",
            "the",
            "interleaved",
            "binary",
            "data",
            "listener"
        ]
    },
    {
        "id": 2333,
        "code": "private void stopTransmitting() {\n  if (!isTransmitting) {\n    return;\n  }\n\n  signalEndOfStream();\n  transmissionHandler.removeCallbacksAndMessages( null);\n  isTransmitting = false;\n}",
        "summary_tokens": [
            "stops",
            "transmitting",
            "if",
            "transmitting",
            "has",
            "started"
        ]
    },
    {
        "id": 2334,
        "code": "public static RtpPacketStreamDump readRtpPacketStreamDump(String filepath) throws IOException {\n  return RtpPacketStreamDump.parse(\n      TestUtil.getString(ApplicationProvider.getApplicationContext(), filepath));\n}",
        "summary_tokens": [
            "parses",
            "and",
            "returns",
            "an",
            "rtp",
            "packet",
            "stream",
            "dump",
            "from",
            "the",
            "file",
            "identified",
            "by",
            "filepath"
        ]
    },
    {
        "id": 2335,
        "code": "public static RtspResponse newDescribeResponseWithSdpMessage(\n    String sessionDescription, List<RtpPacketStreamDump> rtpPacketStreamDumps, Uri requestedUri) {\n\n  StringBuilder sdpMessageBuilder = new StringBuilder(sessionDescription);\n  for (RtpPacketStreamDump rtpPacketStreamDump : rtpPacketStreamDumps) {\n    sdpMessageBuilder.append(rtpPacketStreamDump.mediaDescription).append(\"\\r\\n\");\n  }\n  String sdpMessage = sdpMessageBuilder.toString();\n\n  return new RtspResponse(\n      200,\n      new RtspHeaders.Builder()\n          .add(RtspHeaders.CONTENT_BASE, requestedUri.toString())\n          .add(\n              RtspHeaders.CONTENT_LENGTH,\n              String.valueOf(sdpMessage.getBytes(RtspMessageChannel.CHARSET).length))\n          .build(),\n       sdpMessage);\n}",
        "summary_tokens": [
            "returns",
            "an",
            "rtsp",
            "response",
            "with",
            "a",
            "sdp",
            "message",
            "body"
        ]
    },
    {
        "id": 2336,
        "code": "public static Uri getTestUri(int serverRtspPortNumber) {\n  return Uri.parse(Util.formatInvariant(TEST_BASE_URI, serverRtspPortNumber));\n}",
        "summary_tokens": [
            "returns",
            "the",
            "test",
            "rtsp",
            "uri"
        ]
    },
    {
        "id": 2337,
        "code": "public static Uri getTestUriWithUserInfo(\n    String username, String password, int serverRtspPortNumber) {\n  return Uri.parse(\n      Util.formatInvariant(\n          TEST_BASE_URI_WITH_USER_INFO, username, password, serverRtspPortNumber));\n}",
        "summary_tokens": [
            "returns",
            "the",
            "test",
            "rtsp",
            "uri",
            "with",
            "user",
            "info"
        ]
    },
    {
        "id": 2338,
        "code": "public static SsManifest createSsManifest(StreamElement... streamElements) {\n  return new SsManifest(\n      TEST_MAJOR_VERSION,\n      TEST_MINOR_VERSION,\n      TEST_TIMESCALE,\n      TEST_DURATION,\n      TEST_DVR_WINDOW_LENGTH,\n      TEST_LOOKAHEAD_COUNT,\n      TEST_IS_LIVE,\n      TEST_PROTECTION_ELEMENT,\n      streamElements);\n}",
        "summary_tokens": [
            "creates",
            "test",
            "manifest",
            "with",
            "the",
            "given",
            "stream",
            "elements"
        ]
    },
    {
        "id": 2339,
        "code": "public static StreamElement createStreamElement(\n    String name, @C.TrackType int trackType, Format... formats) {\n  return new StreamElement(\n      TEST_BASE_URI,\n      TEST_CHUNK_TEMPLATE,\n      trackType,\n      TEST_SUB_TYPE,\n      TEST_TIMESCALE,\n      name,\n      TEST_MAX_WIDTH,\n      TEST_MAX_HEIGHT,\n      TEST_MAX_WIDTH,\n      TEST_MAX_HEIGHT,\n      TEST_LANGUAGE,\n      formats,\n       Collections.emptyList(),\n       0);\n}",
        "summary_tokens": [
            "creates",
            "test",
            "video",
            "stream",
            "element",
            "with",
            "the",
            "given",
            "name",
            "track",
            "type",
            "and",
            "formats"
        ]
    },
    {
        "id": 2340,
        "code": "public void parseSmoothStreamingManifest() throws Exception {\n  SsManifestParser parser = new SsManifestParser();\n  parser.parse(\n      Uri.parse(\"https://example.com/test.ismc\"),\n      TestUtil.getInputStream(ApplicationProvider.getApplicationContext(), SAMPLE_ISMC_1));\n  parser.parse(\n      Uri.parse(\"https://example.com/test.ismc\"),\n      TestUtil.getInputStream(ApplicationProvider.getApplicationContext(), SAMPLE_ISMC_2));\n}",
        "summary_tokens": [
            "simple",
            "test",
            "to",
            "ensure",
            "the",
            "sample",
            "manifests",
            "parse",
            "without",
            "any",
            "exceptions",
            "being",
            "thrown"
        ]
    },
    {
        "id": 2341,
        "code": "public static void recordTestSkipped(Context context, String testId, String reason)\n    throws JSONException, IOException {\n  Log.i(TAG, testId + \": \" + reason);\n  JSONObject testJson = new JSONObject();\n  testJson.put(\"skipReason\", reason);\n\n  writeTestSummaryToFile(context, testId, testJson);\n}",
        "summary_tokens": [
            "log",
            "in",
            "logcat",
            "and",
            "in",
            "an",
            "analysis",
            "file",
            "that",
            "this",
            "test",
            "was",
            "skipped"
        ]
    },
    {
        "id": 2342,
        "code": "public static JSONObject getDeviceDetailsAsJsonObject() throws JSONException {\n  return new JSONObject()\n      .put(\"manufacturer\", Build.MANUFACTURER)\n      .put(\"model\", Build.MODEL)\n      .put(\"sdkVersion\", Build.VERSION.SDK_INT)\n      .put(\"fingerprint\", Build.FINGERPRINT);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "jsonobject",
            "containing",
            "device",
            "specific",
            "details",
            "from",
            "build",
            "including",
            "manufacturer",
            "model",
            "sdk",
            "version",
            "and",
            "build",
            "fingerprint"
        ]
    },
    {
        "id": 2343,
        "code": "public static JSONObject exceptionAsJsonObject(Exception exception) throws JSONException {\n  JSONObject exceptionJson = new JSONObject();\n  exceptionJson.put(\"message\", exception.getMessage());\n  exceptionJson.put(\"type\", exception.getClass());\n  if (exception instanceof TransformationException) {\n    exceptionJson.put(\"errorCode\", ((TransformationException) exception).errorCode);\n  }\n  exceptionJson.put(\"stackTrace\", Log.getThrowableString(exception));\n  return exceptionJson;\n}",
        "summary_tokens": [
            "converts",
            "an",
            "exception",
            "to",
            "a",
            "jsonobject"
        ]
    },
    {
        "id": 2344,
        "code": "public static void writeTestSummaryToFile(Context context, String testId, JSONObject testJson)\n    throws IOException, JSONException {\n  testJson.put(\"testId\", testId).put(\"device\", getDeviceDetailsAsJsonObject());\n\n  String analysisContents = testJson.toString( 2);\n\n    \n  for (String line : Util.split(analysisContents, \"\\n\")) {\n    Log.i(TAG, testId + \": \" + line);\n  }\n\n  File analysisFile = createExternalCacheFile(context,  testId + \"-result.txt\");\n  try (FileWriter fileWriter = new FileWriter(analysisFile)) {\n    fileWriter.write(analysisContents);\n  }\n}",
        "summary_tokens": [
            "writes",
            "the",
            "summary",
            "of",
            "a",
            "test",
            "run",
            "to",
            "the",
            "application",
            "cache",
            "file"
        ]
    },
    {
        "id": 2345,
        "code": "public static boolean skipAndLogIfInsufficientCodecSupport(\n    Context context, String testId, Format decodingFormat, @Nullable Format encodingFormat)\n    throws IOException, JSONException {\n  boolean canDecode = false;\n  @Nullable MediaCodecUtil.DecoderQueryException queryException = null;\n  try {\n    canDecode = canDecode(decodingFormat);\n  } catch (MediaCodecUtil.DecoderQueryException e) {\n    queryException = e;\n  }\n\n  boolean canEncode = encodingFormat == null || canEncode(encodingFormat);\n\n  if (canDecode && canEncode) {\n    return false;\n  }\n\n  StringBuilder skipReasonBuilder = new StringBuilder();\n  if (!canDecode) {\n    skipReasonBuilder.append(\"Cannot decode \").append(decodingFormat).append('\\n');\n    if (queryException != null) {\n      skipReasonBuilder.append(queryException).append('\\n');\n    }\n  }\n  if (!canEncode) {\n    skipReasonBuilder.append(\"Cannot encode \").append(encodingFormat);\n  }\n  recordTestSkipped(context, testId, skipReasonBuilder.toString());\n  return true;\n}",
        "summary_tokens": [
            "checks",
            "whether",
            "the",
            "test",
            "should",
            "be",
            "skipped",
            "because",
            "the",
            "device",
            "is",
            "incapable",
            "of",
            "decoding",
            "and",
            "encoding",
            "the",
            "given",
            "formats"
        ]
    },
    {
        "id": 2346,
        "code": "public static Format getFormatForTestFile(String uri) {\n  switch (uri) {\n    case MP4_ASSET_URI_STRING:\n      return MP4_ASSET_FORMAT;\n    case MP4_ASSET_WITH_INCREASING_TIMESTAMPS_URI_STRING:\n      return MP4_ASSET_WITH_INCREASING_TIMESTAMPS_FORMAT;\n    case MP4_ASSET_WITH_INCREASING_TIMESTAMPS_320W_240H_15S_URI_STRING:\n      return MP4_ASSET_WITH_INCREASING_TIMESTAMPS_320W_240H_15S_FORMAT;\n    case MP4_ASSET_SEF_URI_STRING:\n      return MP4_ASSET_SEF_FORMAT;\n    case MP4_REMOTE_10_SECONDS_URI_STRING:\n      return MP4_REMOTE_10_SECONDS_FORMAT;\n    case MP4_REMOTE_H264_MP3_URI_STRING:\n      return MP4_REMOTE_H264_MP3_FORMAT;\n    case MP4_REMOTE_4K60_PORTRAIT_URI_STRING:\n      return MP4_REMOTE_4K60_PORTRAIT_FORMAT;\n    case MP4_REMOTE_1280W_720H_5_SECOND_HIGHMOTION:\n      return MP4_REMOTE_1280W_720H_5_SECOND_HIGHMOTION_FORMAT;\n    case MP4_REMOTE_1440W_1440H_5_SECOND_HIGHMOTION:\n      return MP4_REMOTE_1440W_1440H_5_SECOND_HIGHMOTION_FORMAT;\n    case MP4_REMOTE_1920W_1080H_5_SECOND_HIGHMOTION:\n      return MP4_REMOTE_1920W_1080H_5_SECOND_HIGHMOTION_FORMAT;\n    case MP4_REMOTE_3840W_2160H_5_SECOND_HIGHMOTION:\n      return MP4_REMOTE_3840W_2160H_5_SECOND_HIGHMOTION_FORMAT;\n    case MP4_REMOTE_1280W_720H_30_SECOND_HIGHMOTION:\n      return MP4_REMOTE_1280W_720H_30_SECOND_HIGHMOTION_FORMAT;\n    case MP4_REMOTE_1920W_1080H_30_SECOND_HIGHMOTION:\n      return MP4_REMOTE_1920W_1080H_30_SECOND_HIGHMOTION_FORMAT;\n    case MP4_REMOTE_3840W_2160H_32_SECOND_HIGHMOTION:\n      return MP4_REMOTE_3840W_2160H_32_SECOND_HIGHMOTION_FORMAT;\n    default:\n      throw new IllegalArgumentException(\"The format for the given uri is not found.\");\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "format",
            "of",
            "the",
            "given",
            "test",
            "asset"
        ]
    },
    {
        "id": 2347,
        "code": "private static boolean canEncode(Format format) {\n  String mimeType = checkNotNull(format.sampleMimeType);\n  ImmutableList<android.media.MediaCodecInfo> supportedEncoders =\n      EncoderUtil.getSupportedEncoders(mimeType);\n  if (supportedEncoders.isEmpty()) {\n    return false;\n  }\n\n  android.media.MediaCodecInfo encoder = supportedEncoders.get(0);\n  boolean sizeSupported =\n      EncoderUtil.isSizeSupported(encoder, mimeType, format.width, format.height);\n  boolean bitrateSupported =\n      format.averageBitrate == Format.NO_VALUE\n          || EncoderUtil.getSupportedBitrateRange(encoder, mimeType)\n              .contains(format.averageBitrate);\n  return sizeSupported && bitrateSupported;\n}",
        "summary_tokens": [
            "checks",
            "whether",
            "the",
            "top",
            "ranked",
            "encoder",
            "from",
            "encoder",
            "util",
            "get",
            "supported",
            "encoders",
            "supports",
            "the",
            "given",
            "resolution",
            "and",
            "format",
            "average",
            "bitrate",
            "bitrate"
        ]
    },
    {
        "id": 2348,
        "code": " static File createExternalCacheFile(Context context, String fileName)\n    throws IOException {\n  File file = new File(context.getExternalCacheDir(), fileName);\n  checkState(!file.exists() || file.delete(), \"Could not delete file: \" + file.getAbsolutePath());\n  checkState(file.createNewFile(), \"Could not create file: \" + file.getAbsolutePath());\n  return file;\n}",
        "summary_tokens": [
            "creates",
            "a",
            "file",
            "of",
            "the",
            "file",
            "name",
            "in",
            "the",
            "application",
            "cache",
            "directory"
        ]
    },
    {
        "id": 2349,
        "code": "public static Bitmap readBitmap(String assetString) throws IOException {\n  Bitmap bitmap;\n  try (InputStream inputStream = getApplicationContext().getAssets().open(assetString)) {\n    bitmap = BitmapFactory.decodeStream(inputStream);\n  }\n  return bitmap;\n}",
        "summary_tokens": [
            "reads",
            "a",
            "bitmap",
            "from",
            "the",
            "specified",
            "asset",
            "location"
        ]
    },
    {
        "id": 2350,
        "code": "public static Bitmap createArgb8888BitmapFromRgba8888Image(Image image) {\n  int width = image.getWidth();\n  int height = image.getHeight();\n  assertThat(image.getPlanes()).hasLength(1);\n  assertThat(image.getFormat()).isEqualTo(PixelFormat.RGBA_8888);\n  Image.Plane plane = image.getPlanes()[0];\n  ByteBuffer buffer = plane.getBuffer();\n  int[] colors = new int[width * height];\n  for (int y = 0; y < height; y++) {\n    for (int x = 0; x < width; x++) {\n      int offset = y * plane.getRowStride() + x * plane.getPixelStride();\n      int r = buffer.get(offset) & 0xFF;\n      int g = buffer.get(offset + 1) & 0xFF;\n      int b = buffer.get(offset + 2) & 0xFF;\n      int a = buffer.get(offset + 3) & 0xFF;\n      colors[y * width + x] = Color.argb(a, r, g, b);\n    }\n  }\n  return Bitmap.createBitmap(colors, width, height, Bitmap.Config.ARGB_8888);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "bitmap",
            "with",
            "the",
            "same",
            "information",
            "as",
            "the",
            "provided",
            "alpha",
            "red",
            "green",
            "blue",
            "0",
            "bits",
            "per",
            "component",
            "image"
        ]
    },
    {
        "id": 2351,
        "code": "public static float getAveragePixelAbsoluteDifferenceArgb8888(\n    Bitmap expected, Bitmap actual, @Nullable String testId) {\n  int width = actual.getWidth();\n  int height = actual.getHeight();\n  assertThat(width).isEqualTo(expected.getWidth());\n  assertThat(height).isEqualTo(expected.getHeight());\n  assertThat(actual.getConfig()).isEqualTo(Bitmap.Config.ARGB_8888);\n  long sumMaximumAbsoluteDifferences = 0;\n    \n    \n    \n  Bitmap differencesBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);\n  for (int y = 0; y < height; y++) {\n    for (int x = 0; x < width; x++) {\n      int actualColor = actual.getPixel(x, y);\n      int expectedColor = expected.getPixel(x, y);\n\n      int alphaDifference = abs(Color.alpha(actualColor) - Color.alpha(expectedColor));\n      int redDifference = abs(Color.red(actualColor) - Color.red(expectedColor));\n      int blueDifference = abs(Color.blue(actualColor) - Color.blue(expectedColor));\n      int greenDifference = abs(Color.green(actualColor) - Color.green(expectedColor));\n      differencesBitmap.setPixel(x, y, Color.rgb(redDifference, blueDifference, greenDifference));\n\n      int maximumAbsoluteDifference = 0;\n      maximumAbsoluteDifference = max(maximumAbsoluteDifference, alphaDifference);\n      maximumAbsoluteDifference = max(maximumAbsoluteDifference, redDifference);\n      maximumAbsoluteDifference = max(maximumAbsoluteDifference, blueDifference);\n      maximumAbsoluteDifference = max(maximumAbsoluteDifference, greenDifference);\n\n      sumMaximumAbsoluteDifferences += maximumAbsoluteDifference;\n    }\n  }\n  if (testId != null) {\n    maybeSaveTestBitmapToCacheDirectory(testId, \"diff\", differencesBitmap);\n  }\n  return (float) sumMaximumAbsoluteDifferences / (width * height);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "average",
            "difference",
            "between",
            "the",
            "expected",
            "and",
            "actual",
            "bitmaps",
            "calculated",
            "using",
            "the",
            "maximum",
            "difference",
            "across",
            "all",
            "color",
            "channels",
            "for",
            "each",
            "pixel",
            "then",
            "divided",
            "by",
            "the",
            "total",
            "number",
            "of",
            "pixels",
            "in",
            "the",
            "image"
        ]
    },
    {
        "id": 2352,
        "code": "public static void maybeSaveTestBitmapToCacheDirectory(\n    String testId, String bitmapLabel, Bitmap bitmap) {\n  File file =\n      new File(\n          getApplicationContext().getExternalCacheDir(), testId + \"_\" + bitmapLabel + \".png\");\n  try (FileOutputStream outputStream = new FileOutputStream(file)) {\n    bitmap.compress(Bitmap.CompressFormat.PNG,  100, outputStream);\n  } catch (IOException e) {\n    Log.e(TAG, \"Could not write Bitmap to file path: \" + file.getAbsolutePath(), e);\n  }\n}",
        "summary_tokens": [
            "tries",
            "to",
            "save",
            "the",
            "bitmap",
            "to",
            "the",
            "context",
            "get",
            "cache",
            "dir",
            "cache",
            "directory",
            "as",
            "a",
            "png"
        ]
    },
    {
        "id": 2353,
        "code": "public static Bitmap createArgb8888BitmapFromCurrentGlFramebuffer(int width, int height) {\n  ByteBuffer rgba8888Buffer = ByteBuffer.allocateDirect(width * height * 4);\n  GLES20.glReadPixels(\n      0, 0, width, height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, rgba8888Buffer);\n  GlUtil.checkGlError();\n  Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);\n    \n    \n    \n  bitmap.copyPixelsFromBuffer(rgba8888Buffer);\n    \n  return flipBitmapVertically(bitmap);\n}",
        "summary_tokens": [
            "creates",
            "a",
            "bitmap",
            "with",
            "the",
            "values",
            "of",
            "the",
            "current",
            "open",
            "gl",
            "framebuffer"
        ]
    },
    {
        "id": 2354,
        "code": "public static int createGlTextureFromBitmap(Bitmap bitmap) {\n  int texId = GlUtil.createTexture(bitmap.getWidth(), bitmap.getHeight());\n    \n    \n  GLUtils.texImage2D(GLES20.GL_TEXTURE_2D, 0, flipBitmapVertically(bitmap), 0);\n  GlUtil.checkGlError();\n  return texId;\n}",
        "summary_tokens": [
            "creates",
            "a",
            "gles",
            "0",
            "gl",
            "texture",
            "0",
            "d",
            "0",
            "dimensional",
            "open",
            "gl",
            "texture",
            "with",
            "the",
            "bitmap",
            "s",
            "contents"
        ]
    },
    {
        "id": 2355,
        "code": "private void setUpAndPrepareFirstFrame(float pixelWidthHeightRatio, GlEffect... effects)\n    throws Exception {\n  setUpAndPrepareFirstFrame(pixelWidthHeightRatio, asList(effects));\n}",
        "summary_tokens": [
            "set",
            "up",
            "and",
            "prepare",
            "the",
            "first",
            "frame",
            "from",
            "an",
            "input",
            "video",
            "as",
            "well",
            "as",
            "relevant",
            "test",
            "infrastructure"
        ]
    },
    {
        "id": 2356,
        "code": "public static double calculate(\n    Context context, String referenceVideoPath, String distortedVideoPath)\n    throws IOException, InterruptedException {\n  VideoDecodingWrapper referenceDecodingWrapper =\n      new VideoDecodingWrapper(context, referenceVideoPath, DEFAULT_COMPARISON_INTERVAL);\n  VideoDecodingWrapper distortedDecodingWrapper =\n      new VideoDecodingWrapper(context, distortedVideoPath, DEFAULT_COMPARISON_INTERVAL);\n  @Nullable byte[] referenceLumaBuffer = null;\n  @Nullable byte[] distortedLumaBuffer = null;\n  double accumulatedSsim = 0.0;\n  int comparedImagesCount = 0;\n  try {\n    while (true) {\n      @Nullable Image referenceImage = referenceDecodingWrapper.runUntilComparisonFrameOrEnded();\n      @Nullable Image distortedImage = distortedDecodingWrapper.runUntilComparisonFrameOrEnded();\n      if (referenceImage == null) {\n        assertThat(distortedImage).isNull();\n        break;\n      }\n      checkNotNull(distortedImage);\n\n      int width = referenceImage.getWidth();\n      int height = referenceImage.getHeight();\n\n      assertThat(distortedImage.getWidth()).isEqualTo(width);\n      assertThat(distortedImage.getHeight()).isEqualTo(height);\n\n      if (referenceLumaBuffer == null || referenceLumaBuffer.length != width * height) {\n        referenceLumaBuffer = new byte[width * height];\n      }\n      if (distortedLumaBuffer == null || distortedLumaBuffer.length != width * height) {\n        distortedLumaBuffer = new byte[width * height];\n      }\n      try {\n        accumulatedSsim +=\n            MssimCalculator.calculate(\n                extractLumaChannelBuffer(referenceImage, referenceLumaBuffer),\n                extractLumaChannelBuffer(distortedImage, distortedLumaBuffer),\n                width,\n                height);\n      } finally {\n        referenceImage.close();\n        distortedImage.close();\n      }\n      comparedImagesCount++;\n    }\n  } finally {\n    referenceDecodingWrapper.close();\n    distortedDecodingWrapper.close();\n  }\n  assertWithMessage(\"Input had no frames.\").that(comparedImagesCount).isGreaterThan(0);\n  return accumulatedSsim / comparedImagesCount;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "mean",
            "ssim",
            "score",
            "between",
            "the",
            "reference",
            "and",
            "the",
            "distorted",
            "video"
        ]
    },
    {
        "id": 2357,
        "code": "private static byte[] extractLumaChannelBuffer(Image image, byte[] lumaChannelBuffer) {\n    \n    \n  Image.Plane[] imagePlanes = image.getPlanes();\n  assertThat(imagePlanes).hasLength(DECODED_IMAGE_CHANNEL_COUNT);\n  Image.Plane lumaPlane = imagePlanes[0];\n  int rowStride = lumaPlane.getRowStride();\n  int pixelStride = lumaPlane.getPixelStride();\n  int width = image.getWidth();\n  int height = image.getHeight();\n  ByteBuffer lumaByteBuffer = lumaPlane.getBuffer();\n  for (int y = 0; y < height; y++) {\n    for (int x = 0; x < width; x++) {\n      lumaChannelBuffer[y * width + x] = lumaByteBuffer.get(y * rowStride + x * pixelStride);\n    }\n  }\n  return lumaChannelBuffer;\n}",
        "summary_tokens": [
            "extracts",
            "sets",
            "and",
            "returns",
            "the",
            "buffer",
            "of",
            "the",
            "luma",
            "y",
            "channel",
            "of",
            "the",
            "image"
        ]
    },
    {
        "id": 2358,
        "code": "public JSONObject asJsonObject() throws JSONException {\n  JSONObject jsonObject = new JSONObject();\n  if (transformationResult.durationMs != C.LENGTH_UNSET) {\n    jsonObject.put(\"durationMs\", transformationResult.durationMs);\n  }\n  if (transformationResult.fileSizeBytes != C.LENGTH_UNSET) {\n    jsonObject.put(\"fileSizeBytes\", transformationResult.fileSizeBytes);\n  }\n  if (transformationResult.averageAudioBitrate != C.RATE_UNSET_INT) {\n    jsonObject.put(\"averageAudioBitrate\", transformationResult.averageAudioBitrate);\n  }\n  if (transformationResult.averageVideoBitrate != C.RATE_UNSET_INT) {\n    jsonObject.put(\"averageVideoBitrate\", transformationResult.averageVideoBitrate);\n  }\n  if (transformationResult.videoFrameCount > 0) {\n    jsonObject.put(\"videoFrameCount\", transformationResult.videoFrameCount);\n  }\n  if (throughputFps != C.RATE_UNSET) {\n    jsonObject.put(\"throughputFps\", throughputFps);\n  }\n  if (elapsedTimeMs != C.TIME_UNSET) {\n    jsonObject.put(\"elapsedTimeMs\", elapsedTimeMs);\n  }\n  if (ssim != TransformationTestResult.SSIM_UNSET) {\n    jsonObject.put(\"ssim\", ssim);\n  }\n  if (analysisException != null) {\n    jsonObject.put(\"analysisException\", AndroidTestUtil.exceptionAsJsonObject(analysisException));\n  }\n  return jsonObject;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "jsonobject",
            "representing",
            "all",
            "the",
            "values",
            "in",
            "this"
        ]
    },
    {
        "id": 2359,
        "code": "private boolean feedEncoderFromDecoder() throws TransformationException {\n  if (!encoder.maybeDequeueInputBuffer(encoderInputBuffer)) {\n    return false;\n  }\n\n  if (decoder.isEnded()) {\n    queueEndOfStreamToEncoder();\n    return false;\n  }\n\n  @Nullable ByteBuffer decoderOutputBuffer = decoder.getOutputBuffer();\n  if (decoderOutputBuffer == null) {\n    return false;\n  }\n\n  feedEncoder(decoderOutputBuffer);\n  if (!decoderOutputBuffer.hasRemaining()) {\n    decoder.releaseOutputBuffer( false);\n  }\n  return true;\n}",
        "summary_tokens": [
            "attempts",
            "to",
            "pass",
            "decoder",
            "output",
            "data",
            "to",
            "the",
            "encoder",
            "and",
            "returns",
            "whether",
            "it",
            "may",
            "be",
            "possible",
            "to",
            "pass",
            "more",
            "data",
            "immediately",
            "by",
            "calling",
            "this",
            "method",
            "again"
        ]
    },
    {
        "id": 2360,
        "code": "private boolean feedEncoderFromProcessor() throws TransformationException {\n  if (!encoder.maybeDequeueInputBuffer(encoderInputBuffer)) {\n    return false;\n  }\n\n  if (!processorOutputBuffer.hasRemaining()) {\n    processorOutputBuffer = speedChangingAudioProcessor.getOutput();\n    if (!processorOutputBuffer.hasRemaining()) {\n      if (decoder.isEnded() && speedChangingAudioProcessor.isEnded()) {\n        queueEndOfStreamToEncoder();\n      }\n      return false;\n    }\n  }\n\n  feedEncoder(processorOutputBuffer);\n  return true;\n}",
        "summary_tokens": [
            "attempts",
            "to",
            "pass",
            "audio",
            "processor",
            "output",
            "data",
            "to",
            "the",
            "encoder",
            "and",
            "returns",
            "whether",
            "it",
            "may",
            "be",
            "possible",
            "to",
            "pass",
            "more",
            "data",
            "immediately",
            "by",
            "calling",
            "this",
            "method",
            "again"
        ]
    },
    {
        "id": 2361,
        "code": "private boolean feedProcessorFromDecoder() throws TransformationException {\n    \n    \n  if (processorOutputBuffer.hasRemaining()\n      || speedChangingAudioProcessor.getOutput().hasRemaining()) {\n    return false;\n  }\n\n  if (decoder.isEnded()) {\n    speedChangingAudioProcessor.queueEndOfStream();\n    return false;\n  }\n  checkState(!speedChangingAudioProcessor.isEnded());\n\n  @Nullable ByteBuffer decoderOutputBuffer = decoder.getOutputBuffer();\n  if (decoderOutputBuffer == null) {\n    return false;\n  }\n\n  speedChangingAudioProcessor.queueInput(decoderOutputBuffer);\n  if (!decoderOutputBuffer.hasRemaining()) {\n    decoder.releaseOutputBuffer( false);\n  }\n  return true;\n}",
        "summary_tokens": [
            "attempts",
            "to",
            "process",
            "decoder",
            "output",
            "data",
            "and",
            "returns",
            "whether",
            "it",
            "may",
            "be",
            "possible",
            "to",
            "process",
            "more",
            "data",
            "immediately",
            "by",
            "calling",
            "this",
            "method",
            "again"
        ]
    },
    {
        "id": 2362,
        "code": "private void feedEncoder(ByteBuffer inputBuffer) throws TransformationException {\n  ByteBuffer encoderInputBufferData = checkNotNull(encoderInputBuffer.data);\n  int bufferLimit = inputBuffer.limit();\n  inputBuffer.limit(min(bufferLimit, inputBuffer.position() + encoderInputBufferData.capacity()));\n  encoderInputBufferData.put(inputBuffer);\n  encoderInputBuffer.timeUs = nextEncoderInputBufferTimeUs;\n  computeNextEncoderInputBufferTimeUs(\n       encoderInputBufferData.position(),\n      encoderInputAudioFormat.bytesPerFrame,\n      encoderInputAudioFormat.sampleRate);\n  encoderInputBuffer.setFlags(0);\n  encoderInputBuffer.flip();\n  inputBuffer.limit(bufferLimit);\n  encoder.queueInputBuffer(encoderInputBuffer);\n}",
        "summary_tokens": [
            "feeds",
            "as",
            "much",
            "data",
            "as",
            "possible",
            "between",
            "the",
            "current",
            "position",
            "and",
            "limit",
            "of",
            "the",
            "specified",
            "byte",
            "buffer",
            "to",
            "the",
            "encoder",
            "and",
            "advances",
            "its",
            "position",
            "by",
            "the",
            "number",
            "of",
            "bytes",
            "fed"
        ]
    },
    {
        "id": 2363,
        "code": "default int getMaxPendingFrameCount() {\n  return UNLIMITED_PENDING_FRAME_COUNT;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "maximum",
            "number",
            "of",
            "frames",
            "that",
            "may",
            "be",
            "pending",
            "in",
            "the",
            "output",
            "codec",
            "at",
            "a",
            "time",
            "or",
            "unlimited",
            "pending",
            "frame",
            "count",
            "if",
            "it",
            "s",
            "not",
            "necessary",
            "to",
            "enforce",
            "a",
            "limit"
        ]
    },
    {
        "id": 2364,
        "code": "private boolean maybeDequeueOutputBuffer(boolean setOutputBuffer) throws TransformationException {\n  if (outputBufferIndex >= 0) {\n    return true;\n  }\n  if (outputStreamEnded) {\n    return false;\n  }\n\n  try {\n    outputBufferIndex = mediaCodec.dequeueOutputBuffer(outputBufferInfo,  0);\n  } catch (RuntimeException e) {\n    throw createTransformationException(e);\n  }\n  if (outputBufferIndex < 0) {\n    if (outputBufferIndex == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n      outputFormat = getFormat(mediaCodec.getOutputFormat());\n    }\n    return false;\n  }\n  if ((outputBufferInfo.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {\n    outputStreamEnded = true;\n    if (outputBufferInfo.size == 0) {\n      releaseOutputBuffer( false);\n      return false;\n    }\n  }\n  if ((outputBufferInfo.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) != 0) {\n      \n    releaseOutputBuffer( false);\n    return false;\n  }\n\n  if (setOutputBuffer) {\n    try {\n      outputBuffer = checkNotNull(mediaCodec.getOutputBuffer(outputBufferIndex));\n    } catch (RuntimeException e) {\n      throw createTransformationException(e);\n    }\n    outputBuffer.position(outputBufferInfo.offset);\n    outputBuffer.limit(outputBufferInfo.offset + outputBufferInfo.size);\n  }\n  return true;\n}",
        "summary_tokens": [
            "attempts",
            "to",
            "dequeue",
            "an",
            "output",
            "buffer",
            "if",
            "there",
            "is",
            "no",
            "output",
            "buffer",
            "pending"
        ]
    },
    {
        "id": 2365,
        "code": "private static VideoEncoderQueryResult findEncoderWithClosestFormatSupport(\n    Format requestedFormat,\n    VideoEncoderSettings videoEncoderSettings,\n    EncoderSelector encoderSelector,\n    List<String> allowedMimeTypes,\n    boolean enableFallback) {\n  String requestedMimeType = requestedFormat.sampleMimeType;\n  @Nullable\n  String mimeType = findFallbackMimeType(encoderSelector, requestedMimeType, allowedMimeTypes);\n  if (mimeType == null || (!enableFallback && !requestedMimeType.equals(mimeType))) {\n    return null;\n  }\n\n  List<MediaCodecInfo> encodersForMimeType = encoderSelector.selectEncoderInfos(mimeType);\n  if (encodersForMimeType.isEmpty()) {\n    return null;\n  }\n  if (!enableFallback) {\n    return new VideoEncoderQueryResult(\n        encodersForMimeType.get(0), requestedFormat, videoEncoderSettings);\n  }\n\n  ImmutableList<MediaCodecInfo> filteredEncoders =\n      filterEncodersByResolution(\n          encodersForMimeType, mimeType, requestedFormat.width, requestedFormat.height);\n  if (filteredEncoders.isEmpty()) {\n    return null;\n  }\n    \n  Size finalResolution =\n      checkNotNull(\n          EncoderUtil.getSupportedResolution(\n              filteredEncoders.get(0), mimeType, requestedFormat.width, requestedFormat.height));\n\n  int requestedBitrate =\n      videoEncoderSettings.bitrate != VideoEncoderSettings.NO_VALUE\n          ? videoEncoderSettings.bitrate\n          : getSuggestedBitrate(\n              finalResolution.getWidth(), finalResolution.getHeight(), requestedFormat.frameRate);\n  filteredEncoders = filterEncodersByBitrate(filteredEncoders, mimeType, requestedBitrate);\n  if (filteredEncoders.isEmpty()) {\n    return null;\n  }\n\n  filteredEncoders =\n      filterEncodersByBitrateMode(filteredEncoders, mimeType, videoEncoderSettings.bitrateMode);\n  if (filteredEncoders.isEmpty()) {\n    return null;\n  }\n\n  MediaCodecInfo pickedEncoder = filteredEncoders.get(0);\n  int closestSupportedBitrate =\n      EncoderUtil.getSupportedBitrateRange(pickedEncoder, mimeType).clamp(requestedBitrate);\n  VideoEncoderSettings.Builder supportedEncodingSettingBuilder =\n      videoEncoderSettings.buildUpon().setBitrate(closestSupportedBitrate);\n\n  if (videoEncoderSettings.profile == VideoEncoderSettings.NO_VALUE\n      || videoEncoderSettings.level == VideoEncoderSettings.NO_VALUE\n      || videoEncoderSettings.level\n          > EncoderUtil.findHighestSupportedEncodingLevel(\n              pickedEncoder, mimeType, videoEncoderSettings.profile)) {\n    supportedEncodingSettingBuilder.setEncodingProfileLevel(\n        VideoEncoderSettings.NO_VALUE, VideoEncoderSettings.NO_VALUE);\n  }\n\n  Format supportedEncoderFormat =\n      requestedFormat\n          .buildUpon()\n          .setSampleMimeType(mimeType)\n          .setWidth(finalResolution.getWidth())\n          .setHeight(finalResolution.getHeight())\n          .setAverageBitrate(closestSupportedBitrate)\n          .build();\n  return new VideoEncoderQueryResult(\n      pickedEncoder, supportedEncoderFormat, supportedEncodingSettingBuilder.build());\n}",
        "summary_tokens": [
            "finds",
            "an",
            "media",
            "codec",
            "info",
            "encoder",
            "that",
            "supports",
            "the",
            "requested",
            "format",
            "most",
            "closely"
        ]
    },
    {
        "id": 2366,
        "code": "private static ImmutableList<MediaCodecInfo> filterEncodersByResolution(\n    List<MediaCodecInfo> encoders, String mimeType, int requestedWidth, int requestedHeight) {\n  return filterEncoders(\n      encoders,\n       (encoderInfo) -> {\n        @Nullable\n        Size closestSupportedResolution =\n            EncoderUtil.getSupportedResolution(\n                encoderInfo, mimeType, requestedWidth, requestedHeight);\n        if (closestSupportedResolution == null) {\n            \n          return Integer.MAX_VALUE;\n        }\n        return abs(\n            requestedWidth * requestedHeight\n                - closestSupportedResolution.getWidth() * closestSupportedResolution.getHeight());\n      },\n       \"resolution\");\n}",
        "summary_tokens": [
            "returns",
            "a",
            "list",
            "of",
            "encoders",
            "that",
            "support",
            "the",
            "requested",
            "resolution",
            "most",
            "closely"
        ]
    },
    {
        "id": 2367,
        "code": "private static ImmutableList<MediaCodecInfo> filterEncodersByBitrate(\n    List<MediaCodecInfo> encoders, String mimeType, int requestedBitrate) {\n  return filterEncoders(\n      encoders,\n       (encoderInfo) -> {\n        int achievableBitrate =\n            EncoderUtil.getSupportedBitrateRange(encoderInfo, mimeType).clamp(requestedBitrate);\n        return abs(achievableBitrate - requestedBitrate);\n      },\n       \"bitrate\");\n}",
        "summary_tokens": [
            "returns",
            "a",
            "list",
            "of",
            "encoders",
            "that",
            "support",
            "the",
            "requested",
            "bitrate",
            "most",
            "closely"
        ]
    },
    {
        "id": 2368,
        "code": "private static ImmutableList<MediaCodecInfo> filterEncodersByBitrateMode(\n    List<MediaCodecInfo> encoders, String mimeType, int requestedBitrateMode) {\n  return filterEncoders(\n      encoders,\n       (encoderInfo) ->\n          EncoderUtil.isBitrateModeSupported(encoderInfo, mimeType, requestedBitrateMode)\n              ? 0\n              : Integer.MAX_VALUE, \n       \"bitrate mode\");\n}",
        "summary_tokens": [
            "returns",
            "a",
            "list",
            "of",
            "encoders",
            "that",
            "support",
            "the",
            "requested",
            "bitrate",
            "mode"
        ]
    },
    {
        "id": 2369,
        "code": "private static void adjustMediaFormatForH264EncoderSettings(\n    MediaFormat mediaFormat, MediaCodecInfo encoderInfo) {\n    \n    \n  String mimeType = MimeTypes.VIDEO_H264;\n  if (Util.SDK_INT >= 29) {\n    int expectedEncodingProfile = MediaCodecInfo.CodecProfileLevel.AVCProfileHigh;\n    int supportedEncodingLevel =\n        EncoderUtil.findHighestSupportedEncodingLevel(\n            encoderInfo, mimeType, expectedEncodingProfile);\n    if (supportedEncodingLevel != EncoderUtil.LEVEL_UNSET) {\n        \n      mediaFormat.setInteger(MediaFormat.KEY_PROFILE, expectedEncodingProfile);\n      mediaFormat.setInteger(MediaFormat.KEY_LEVEL, supportedEncodingLevel);\n      mediaFormat.setInteger(MediaFormat.KEY_MAX_B_FRAMES, 1);\n    }\n  } else if (Util.SDK_INT >= 26) {\n    int expectedEncodingProfile = MediaCodecInfo.CodecProfileLevel.AVCProfileHigh;\n    int supportedEncodingLevel =\n        EncoderUtil.findHighestSupportedEncodingLevel(\n            encoderInfo, mimeType, expectedEncodingProfile);\n    if (supportedEncodingLevel != EncoderUtil.LEVEL_UNSET) {\n        \n        \n        \n      mediaFormat.setInteger(MediaFormat.KEY_PROFILE, expectedEncodingProfile);\n      mediaFormat.setInteger(MediaFormat.KEY_LEVEL, supportedEncodingLevel);\n        \n        \n      mediaFormat.setInteger(MediaFormat.KEY_LATENCY, 1);\n    }\n  } else if (Util.SDK_INT >= 24) {\n    int expectedEncodingProfile = MediaCodecInfo.CodecProfileLevel.AVCProfileBaseline;\n    int supportedLevel =\n        EncoderUtil.findHighestSupportedEncodingLevel(\n            encoderInfo, mimeType, expectedEncodingProfile);\n    checkState(supportedLevel != EncoderUtil.LEVEL_UNSET);\n      \n      \n    mediaFormat.setInteger(MediaFormat.KEY_PROFILE, expectedEncodingProfile);\n    mediaFormat.setInteger(MediaFormat.KEY_LEVEL, supportedLevel);\n  }\n    \n    \n}",
        "summary_tokens": [
            "applying",
            "suggested",
            "profile",
            "level",
            "settings",
            "from",
            "https",
            "developer"
        ]
    },
    {
        "id": 2370,
        "code": "private static ImmutableList<MediaCodecInfo> filterEncoders(\n    List<MediaCodecInfo> encoders, EncoderFallbackCost cost, String filterName) {\n  List<MediaCodecInfo> filteredEncoders = new ArrayList<>(encoders.size());\n\n  int minGap = Integer.MAX_VALUE;\n  for (int i = 0; i < encoders.size(); i++) {\n    MediaCodecInfo encoderInfo = encoders.get(i);\n    int gap = cost.getParameterSupportGap(encoderInfo);\n    if (gap == Integer.MAX_VALUE) {\n      continue;\n    }\n\n    if (gap < minGap) {\n      minGap = gap;\n      filteredEncoders.clear();\n      filteredEncoders.add(encoderInfo);\n    } else if (gap == minGap) {\n      filteredEncoders.add(encoderInfo);\n    }\n  }\n\n  List<MediaCodecInfo> removedEncoders = new ArrayList<>(encoders);\n  removedEncoders.removeAll(filteredEncoders);\n  StringBuilder stringBuilder =\n      new StringBuilder(\"Encoders removed for \").append(filterName).append(\":\\n\");\n  for (int i = 0; i < removedEncoders.size(); i++) {\n    MediaCodecInfo encoderInfo = removedEncoders.get(i);\n    stringBuilder.append(Util.formatInvariant(\"  %s\\n\", encoderInfo.getName()));\n  }\n  Log.d(TAG, stringBuilder.toString());\n\n  return ImmutableList.copyOf(filteredEncoders);\n}",
        "summary_tokens": [
            "filters",
            "a",
            "list",
            "of",
            "media",
            "codec",
            "info",
            "encoders",
            "by",
            "a",
            "encoder",
            "fallback",
            "cost",
            "cost",
            "function"
        ]
    },
    {
        "id": 2371,
        "code": "private static String findFallbackMimeType(\n    EncoderSelector encoderSelector, String requestedMimeType, List<String> allowedMimeTypes) {\n  if (mimeTypeIsSupported(encoderSelector, requestedMimeType, allowedMimeTypes)) {\n    return requestedMimeType;\n  } else if (mimeTypeIsSupported(encoderSelector, MimeTypes.VIDEO_H265, allowedMimeTypes)) {\n    return MimeTypes.VIDEO_H265;\n  } else if (mimeTypeIsSupported(encoderSelector, MimeTypes.VIDEO_H264, allowedMimeTypes)) {\n    return MimeTypes.VIDEO_H264;\n  } else {\n    for (int i = 0; i < allowedMimeTypes.size(); i++) {\n      String allowedMimeType = allowedMimeTypes.get(i);\n      if (mimeTypeIsSupported(encoderSelector, allowedMimeType, allowedMimeTypes)) {\n        return allowedMimeType;\n      }\n    }\n  }\n  return null;\n}",
        "summary_tokens": [
            "finds",
            "a",
            "mime",
            "types",
            "mime",
            "type",
            "that",
            "is",
            "supported",
            "by",
            "the",
            "encoder",
            "and",
            "in",
            "the",
            "allowed",
            "mime",
            "types"
        ]
    },
    {
        "id": 2372,
        "code": "private static int getSuggestedBitrate(int width, int height, float frameRate) {\n    \n    \n    \n  return (int) (width * height * frameRate * 0.07 * 2);\n}",
        "summary_tokens": [
            "computes",
            "the",
            "video",
            "bit",
            "rate",
            "using",
            "the",
            "kush",
            "gauge"
        ]
    },
    {
        "id": 2373,
        "code": "public int getOutputRotationDegrees() {\n  checkState(\n      outputRotationDegrees != C.LENGTH_UNSET,\n      \"configure must be called before getOutputRotationDegrees\");\n  return outputRotationDegrees;\n}",
        "summary_tokens": [
            "returns",
            "format",
            "rotation",
            "degrees",
            "for",
            "the",
            "output",
            "frame"
        ]
    },
    {
        "id": 2374,
        "code": "public static ImmutableList<MediaCodecInfo> getSupportedEncoders(String mimeType) {\n  return checkNotNull(MIME_TYPE_TO_ENCODERS.get()).get(Ascii.toLowerCase(mimeType));\n}",
        "summary_tokens": [
            "returns",
            "a",
            "list",
            "of",
            "media",
            "codec",
            "info",
            "encoders",
            "that",
            "support",
            "the",
            "given",
            "mime",
            "type",
            "or",
            "an",
            "empty",
            "list",
            "if",
            "there",
            "is",
            "none"
        ]
    },
    {
        "id": 2375,
        "code": "public static ImmutableSet<String> getSupportedVideoMimeTypes() {\n  return checkNotNull(MIME_TYPE_TO_ENCODERS.get()).keySet();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "list",
            "of",
            "video",
            "mime",
            "types",
            "mime",
            "types",
            "that",
            "can",
            "be",
            "encoded"
        ]
    },
    {
        "id": 2376,
        "code": "public static boolean isSizeSupported(\n    MediaCodecInfo encoderInfo, String mimeType, int width, int height) {\n  if (encoderInfo\n      .getCapabilitiesForType(mimeType)\n      .getVideoCapabilities()\n      .isSizeSupported(width, height)) {\n    return true;\n  }\n\n    \n    \n    \n    \n  if (width == 1920 && height == 1080) {\n    return CamcorderProfile.hasProfile(CamcorderProfile.QUALITY_1080P);\n  }\n  if (width == 3840 && height == 2160) {\n    return CamcorderProfile.hasProfile(CamcorderProfile.QUALITY_2160P);\n  }\n  return false;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "media",
            "codec",
            "info",
            "encoder",
            "supports",
            "the",
            "given",
            "resolution"
        ]
    },
    {
        "id": 2377,
        "code": "public static Range<Integer> getSupportedHeights(\n    MediaCodecInfo encoderInfo, String mimeType, int width) {\n  return encoderInfo\n      .getCapabilitiesForType(mimeType)\n      .getVideoCapabilities()\n      .getSupportedHeightsFor(width);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "range",
            "of",
            "supported",
            "heights",
            "for",
            "the",
            "given",
            "media",
            "codec",
            "info",
            "encoder",
            "mime",
            "types",
            "mime",
            "type",
            "and",
            "width"
        ]
    },
    {
        "id": 2378,
        "code": "public static Pair<Range<Integer>, Range<Integer>> getSupportedResolutionRanges(\n    MediaCodecInfo encoderInfo, String mimeType) {\n  MediaCodecInfo.VideoCapabilities videoCapabilities =\n      encoderInfo.getCapabilitiesForType(mimeType).getVideoCapabilities();\n  return Pair.create(\n      videoCapabilities.getSupportedWidths(), videoCapabilities.getSupportedHeights());\n}",
        "summary_tokens": [
            "returns",
            "a",
            "pair",
            "of",
            "supported",
            "width",
            "and",
            "height",
            "range",
            "ranges",
            "for",
            "the",
            "given",
            "media",
            "codec",
            "info",
            "encoder",
            "and",
            "mime",
            "types",
            "mime",
            "type"
        ]
    },
    {
        "id": 2379,
        "code": "public static Size getSupportedResolution(\n    MediaCodecInfo encoderInfo, String mimeType, int width, int height) {\n  MediaCodecInfo.VideoCapabilities videoEncoderCapabilities =\n      encoderInfo.getCapabilitiesForType(mimeType).getVideoCapabilities();\n  int widthAlignment = videoEncoderCapabilities.getWidthAlignment();\n  int heightAlignment = videoEncoderCapabilities.getHeightAlignment();\n\n    \n  width = alignResolution(width, widthAlignment);\n  height = alignResolution(height, heightAlignment);\n  if (isSizeSupported(encoderInfo, mimeType, width, height)) {\n    return new Size(width, height);\n  }\n\n    \n  int newWidth = alignResolution(width * 3 / 4, widthAlignment);\n  int newHeight = alignResolution(height * 3 / 4, heightAlignment);\n  if (isSizeSupported(encoderInfo, mimeType, newWidth, newHeight)) {\n    return new Size(newWidth, newHeight);\n  }\n\n    \n  newWidth = alignResolution(width * 2 / 3, widthAlignment);\n  newHeight = alignResolution(height * 2 / 3, heightAlignment);\n  if (isSizeSupported(encoderInfo, mimeType, width, height)) {\n    return new Size(newWidth, newHeight);\n  }\n\n    \n  newWidth = alignResolution(width / 2, widthAlignment);\n  newHeight = alignResolution(height / 2, heightAlignment);\n  if (isSizeSupported(encoderInfo, mimeType, newWidth, newHeight)) {\n    return new Size(newWidth, newHeight);\n  }\n\n    \n  newWidth = alignResolution(width / 3, widthAlignment);\n  newHeight = alignResolution(height / 3, heightAlignment);\n  if (isSizeSupported(encoderInfo, mimeType, newWidth, newHeight)) {\n    return new Size(newWidth, newHeight);\n  }\n\n    \n  width = videoEncoderCapabilities.getSupportedWidths().clamp(width);\n  int adjustedHeight = videoEncoderCapabilities.getSupportedHeightsFor(width).clamp(height);\n  if (adjustedHeight != height) {\n    width =\n        alignResolution((int) round((double) width * adjustedHeight / height), widthAlignment);\n    height = alignResolution(adjustedHeight, heightAlignment);\n  }\n\n  return isSizeSupported(encoderInfo, mimeType, width, height) ? new Size(width, height) : null;\n}",
        "summary_tokens": [
            "finds",
            "an",
            "media",
            "codec",
            "info",
            "encoder",
            "s",
            "supported",
            "resolution",
            "from",
            "a",
            "given",
            "resolution"
        ]
    },
    {
        "id": 2380,
        "code": "public static ImmutableSet<Integer> findSupportedEncodingProfiles(\n    MediaCodecInfo encoderInfo, String mimeType) {\n  MediaCodecInfo.CodecProfileLevel[] profileLevels =\n      encoderInfo.getCapabilitiesForType(mimeType).profileLevels;\n  ImmutableSet.Builder<Integer> supportedProfilesBuilder = new ImmutableSet.Builder<>();\n  for (MediaCodecInfo.CodecProfileLevel profileLevel : profileLevels) {\n    supportedProfilesBuilder.add(profileLevel.profile);\n  }\n  return supportedProfilesBuilder.build();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "immutable",
            "set",
            "set",
            "of",
            "supported",
            "media",
            "codec",
            "info"
        ]
    },
    {
        "id": 2381,
        "code": "public static int findHighestSupportedEncodingLevel(\n    MediaCodecInfo encoderInfo, String mimeType, int profile) {\n    \n  MediaCodecInfo.CodecProfileLevel[] profileLevels =\n      encoderInfo.getCapabilitiesForType(mimeType).profileLevels;\n\n  int maxSupportedLevel = LEVEL_UNSET;\n  for (MediaCodecInfo.CodecProfileLevel profileLevel : profileLevels) {\n    if (profileLevel.profile == profile) {\n      maxSupportedLevel = max(maxSupportedLevel, profileLevel.level);\n    }\n  }\n  return maxSupportedLevel;\n}",
        "summary_tokens": [
            "finds",
            "the",
            "highest",
            "supported",
            "encoding",
            "level",
            "given",
            "a",
            "profile"
        ]
    },
    {
        "id": 2382,
        "code": "public static String findCodecForFormat(MediaFormat format, boolean isDecoder) {\n  MediaCodecList mediaCodecList = new MediaCodecList(MediaCodecList.ALL_CODECS);\n    \n    \n  @Nullable String frameRate = null;\n  if (Util.SDK_INT == 21 && format.containsKey(MediaFormat.KEY_FRAME_RATE)) {\n    frameRate = format.getString(MediaFormat.KEY_FRAME_RATE);\n    format.setString(MediaFormat.KEY_FRAME_RATE, null);\n  }\n\n  String mediaCodecName =\n      isDecoder\n          ? mediaCodecList.findDecoderForFormat(format)\n          : mediaCodecList.findEncoderForFormat(format);\n\n  if (Util.SDK_INT == 21) {\n    MediaFormatUtil.maybeSetString(format, MediaFormat.KEY_FRAME_RATE, frameRate);\n  }\n  return mediaCodecName;\n}",
        "summary_tokens": [
            "finds",
            "a",
            "media",
            "codec",
            "that",
            "supports",
            "the",
            "media",
            "format",
            "or",
            "null",
            "if",
            "none",
            "is",
            "found"
        ]
    },
    {
        "id": 2383,
        "code": "public static Range<Integer> getSupportedBitrateRange(\n    MediaCodecInfo encoderInfo, String mimeType) {\n  return encoderInfo.getCapabilitiesForType(mimeType).getVideoCapabilities().getBitrateRange();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "range",
            "of",
            "supported",
            "bitrates",
            "for",
            "the",
            "given",
            "mime",
            "types",
            "mime",
            "type"
        ]
    },
    {
        "id": 2384,
        "code": "public static boolean isBitrateModeSupported(\n    MediaCodecInfo encoderInfo, String mimeType, int bitrateMode) {\n  return encoderInfo\n      .getCapabilitiesForType(mimeType)\n      .getEncoderCapabilities()\n      .isBitrateModeSupported(bitrateMode);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "bitrate",
            "mode",
            "is",
            "supported",
            "by",
            "the",
            "encoder"
        ]
    },
    {
        "id": 2385,
        "code": "public static ImmutableList<Integer> getSupportedColorFormats(\n    MediaCodecInfo encoderInfo, String mimeType) {\n  return ImmutableList.copyOf(\n      Ints.asList(encoderInfo.getCapabilitiesForType(mimeType).colorFormats));\n}",
        "summary_tokens": [
            "returns",
            "a",
            "immutable",
            "list",
            "list",
            "of",
            "supported",
            "media",
            "codec",
            "info"
        ]
    },
    {
        "id": 2386,
        "code": "public static boolean isHardwareAccelerated(MediaCodecInfo encoderInfo, String mimeType) {\n    \n  if (Util.SDK_INT >= 29) {\n    return Api29.isHardwareAccelerated(encoderInfo);\n  }\n    \n    \n  return !isSoftwareOnly(encoderInfo, mimeType);\n}",
        "summary_tokens": [
            "checks",
            "if",
            "a",
            "media",
            "codec",
            "info",
            "codec",
            "is",
            "hardware",
            "accelerated"
        ]
    },
    {
        "id": 2387,
        "code": "public static boolean isFeatureSupported(\n    MediaCodecInfo encoderInfo, String mimeType, String featureName) {\n  return encoderInfo.getCapabilitiesForType(mimeType).isFeatureSupported(featureName);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "a",
            "given",
            "feature",
            "is",
            "supported"
        ]
    },
    {
        "id": 2388,
        "code": "public static int getMaxSupportedInstances(MediaCodecInfo encoderInfo, String mimeType) {\n  return encoderInfo.getCapabilitiesForType(mimeType).getMaxSupportedInstances();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "max",
            "number",
            "of",
            "the",
            "supported",
            "concurrent",
            "codec",
            "instances"
        ]
    },
    {
        "id": 2389,
        "code": "private static int alignResolution(int size, int alignment) {\n    \n    \n  boolean shouldRoundDown = false;\n  if (size % 10 == 1) {\n    shouldRoundDown = true;\n  }\n  return shouldRoundDown\n      ? (int) (alignment * Math.floor((float) size / alignment))\n      : alignment * Math.round((float) size / alignment);\n}",
        "summary_tokens": [
            "align",
            "to",
            "the",
            "closest",
            "resolution",
            "that",
            "respects",
            "the",
            "encoder",
            "s",
            "supported",
            "alignment"
        ]
    },
    {
        "id": 2390,
        "code": "public void setTextureTransformMatrix(float[] textureTransformMatrix) {\n  checkStateNotNull(glProgram);\n  glProgram.setFloatsUniform(\"uTexTransform\", textureTransformMatrix);\n}",
        "summary_tokens": [
            "sets",
            "the",
            "texture",
            "transform",
            "matrix",
            "for",
            "converting",
            "an",
            "external",
            "surface",
            "texture",
            "s",
            "coordinates",
            "to",
            "sampling",
            "locations"
        ]
    },
    {
        "id": 2391,
        "code": "public void registerTrack() {\n  trackCount++;\n}",
        "summary_tokens": [
            "registers",
            "an",
            "output",
            "track"
        ]
    },
    {
        "id": 2392,
        "code": "public void onTransformationRequestFinalized(TransformationRequest transformationRequest) {\n  checkState(trackCount-- > 0);\n\n  TransformationRequest.Builder fallbackRequestBuilder =\n      fallbackTransformationRequest.buildUpon();\n  if (!Util.areEqual(\n      transformationRequest.audioMimeType, originalTransformationRequest.audioMimeType)) {\n    fallbackRequestBuilder.setAudioMimeType(transformationRequest.audioMimeType);\n  }\n  if (!Util.areEqual(\n      transformationRequest.videoMimeType, originalTransformationRequest.videoMimeType)) {\n    fallbackRequestBuilder.setVideoMimeType(transformationRequest.videoMimeType);\n  }\n  if (transformationRequest.outputHeight != originalTransformationRequest.outputHeight) {\n    fallbackRequestBuilder.setResolution(transformationRequest.outputHeight);\n  }\n  fallbackTransformationRequest = fallbackRequestBuilder.build();\n\n  if (trackCount == 0 && !originalTransformationRequest.equals(fallbackTransformationRequest)) {\n    transformerListeners.queueEvent(\n         C.INDEX_UNSET,\n        listener ->\n            listener.onFallbackApplied(\n                mediaItem, originalTransformationRequest, fallbackTransformationRequest));\n    transformerListeners.flushEvents();\n  }\n}",
        "summary_tokens": [
            "updates",
            "the",
            "fallback",
            "transformation",
            "request"
        ]
    },
    {
        "id": 2393,
        "code": "public static FrameProcessorChain create(\n    Context context,\n    Listener listener,\n    float pixelWidthHeightRatio,\n    int inputWidth,\n    int inputHeight,\n    long streamOffsetUs,\n    List<GlEffect> effects,\n    boolean enableExperimentalHdrEditing)\n    throws FrameProcessingException {\n  checkArgument(inputWidth > 0, \"inputWidth must be positive\");\n  checkArgument(inputHeight > 0, \"inputHeight must be positive\");\n\n  ExecutorService singleThreadExecutorService = Util.newSingleThreadExecutor(THREAD_NAME);\n\n  try {\n    return singleThreadExecutorService\n        .submit(\n            () ->\n                createOpenGlObjectsAndFrameProcessorChain(\n                    context,\n                    listener,\n                    pixelWidthHeightRatio,\n                    inputWidth,\n                    inputHeight,\n                    streamOffsetUs,\n                    effects,\n                    enableExperimentalHdrEditing,\n                    singleThreadExecutorService))\n        .get();\n  } catch (ExecutionException e) {\n    throw new FrameProcessingException(e);\n  } catch (InterruptedException e) {\n    Thread.currentThread().interrupt();\n    throw new FrameProcessingException(e);\n  }\n}",
        "summary_tokens": [
            "creates",
            "a",
            "new",
            "instance"
        ]
    },
    {
        "id": 2394,
        "code": "private static FrameProcessorChain createOpenGlObjectsAndFrameProcessorChain(\n    Context context,\n    Listener listener,\n    float pixelWidthHeightRatio,\n    int inputWidth,\n    int inputHeight,\n    long streamOffsetUs,\n    List<GlEffect> effects,\n    boolean enableExperimentalHdrEditing,\n    ExecutorService singleThreadExecutorService)\n    throws IOException {\n  checkState(Thread.currentThread().getName().equals(THREAD_NAME));\n\n  EGLDisplay eglDisplay = GlUtil.createEglDisplay();\n  EGLContext eglContext =\n      enableExperimentalHdrEditing\n          ? GlUtil.createEglContextEs3Rgba1010102(eglDisplay)\n          : GlUtil.createEglContext(eglDisplay);\n\n  if (GlUtil.isSurfacelessContextExtensionSupported()) {\n    GlUtil.focusEglSurface(\n        eglDisplay, eglContext, EGL14.EGL_NO_SURFACE,  1,  1);\n  } else if (enableExperimentalHdrEditing) {\n      \n    GlUtil.focusPlaceholderEglSurfaceBt2020Pq(eglContext, eglDisplay);\n  } else {\n    GlUtil.focusPlaceholderEglSurface(eglContext, eglDisplay);\n  }\n\n  ExternalTextureProcessor externalTextureProcessor =\n      new ExternalTextureProcessor(enableExperimentalHdrEditing);\n  ImmutableList<SingleFrameGlTextureProcessor> textureProcessors =\n      getTextureProcessors(externalTextureProcessor, pixelWidthHeightRatio, effects);\n\n    \n  int inputExternalTexId = GlUtil.createExternalTexture();\n  externalTextureProcessor.initialize(context, inputExternalTexId, inputWidth, inputHeight);\n\n  int[] framebuffers = new int[textureProcessors.size() - 1];\n  Size inputSize = externalTextureProcessor.getOutputSize();\n  for (int i = 1; i < textureProcessors.size(); i++) {\n    int inputTexId = GlUtil.createTexture(inputSize.getWidth(), inputSize.getHeight());\n    framebuffers[i - 1] = GlUtil.createFboForTexture(inputTexId);\n    SingleFrameGlTextureProcessor textureProcessor = textureProcessors.get(i);\n    textureProcessor.initialize(context, inputTexId, inputSize.getWidth(), inputSize.getHeight());\n    inputSize = textureProcessor.getOutputSize();\n  }\n  return new FrameProcessorChain(\n      eglDisplay,\n      eglContext,\n      singleThreadExecutorService,\n      inputExternalTexId,\n      streamOffsetUs,\n      framebuffers,\n      textureProcessors,\n      listener,\n      enableExperimentalHdrEditing);\n}",
        "summary_tokens": [
            "creates",
            "the",
            "open",
            "gl",
            "textures",
            "and",
            "framebuffers",
            "initializes",
            "the",
            "single",
            "frame",
            "gl",
            "texture",
            "processor",
            "single",
            "frame",
            "gl",
            "texture",
            "processors",
            "corresponding",
            "to",
            "the",
            "gl",
            "effect",
            "gl",
            "effects",
            "and",
            "returns",
            "a",
            "new",
            "frame",
            "processor",
            "chain"
        ]
    },
    {
        "id": 2395,
        "code": "public Size getOutputSize() {\n  return getLast(textureProcessors).getOutputSize();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "recommended",
            "output",
            "size"
        ]
    },
    {
        "id": 2396,
        "code": "public void setOutputSurface(\n    Surface outputSurface,\n    int outputWidth,\n    int outputHeight,\n    @Nullable SurfaceView debugSurfaceView) {\n    \n    \n    \n  this.outputSurface = outputSurface;\n  this.outputWidth = outputWidth;\n  this.outputHeight = outputHeight;\n\n  if (debugSurfaceView != null) {\n    debugSurfaceViewWrapper = new SurfaceViewWrapper(debugSurfaceView);\n  }\n\n  inputSurfaceTexture.setOnFrameAvailableListener(\n      surfaceTexture -> {\n        if (stopProcessing.get()) {\n            \n            \n          return;\n        }\n        try {\n          futures.add(singleThreadExecutorService.submit(this::processFrame));\n        } catch (RejectedExecutionException e) {\n          if (!stopProcessing.get()) {\n            throw e;\n          }\n        }\n      });\n}",
        "summary_tokens": [
            "sets",
            "the",
            "output",
            "surface"
        ]
    },
    {
        "id": 2397,
        "code": "public Surface getInputSurface() {\n  return inputSurface;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "input",
            "surface"
        ]
    },
    {
        "id": 2398,
        "code": "public void registerInputFrame() {\n  checkState(!inputStreamEnded);\n  pendingFrameCount.incrementAndGet();\n}",
        "summary_tokens": [
            "informs",
            "the",
            "frame",
            "processor",
            "chain",
            "that",
            "a",
            "frame",
            "will",
            "be",
            "queued",
            "to",
            "its",
            "input",
            "surface"
        ]
    },
    {
        "id": 2399,
        "code": "public int getPendingFrameCount() {\n  return pendingFrameCount.get();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "input",
            "frames",
            "that",
            "have",
            "been",
            "register",
            "input",
            "frame",
            "registered",
            "but",
            "not",
            "completely",
            "processed",
            "yet"
        ]
    },
    {
        "id": 2400,
        "code": "public void signalEndOfInputStream() {\n  inputStreamEnded = true;\n}",
        "summary_tokens": [
            "informs",
            "the",
            "frame",
            "processor",
            "chain",
            "that",
            "no",
            "further",
            "input",
            "frames",
            "should",
            "be",
            "accepted"
        ]
    },
    {
        "id": 2401,
        "code": "public boolean isEnded() {\n  return inputStreamEnded && getPendingFrameCount() == 0;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "all",
            "frames",
            "have",
            "been",
            "processed"
        ]
    },
    {
        "id": 2402,
        "code": "private void processFrame() {\n  if (stopProcessing.get()) {\n    return;\n  }\n\n  long presentationTimeUs = C.TIME_UNSET;\n  try {\n    checkState(Thread.currentThread().getName().equals(THREAD_NAME));\n\n    if (outputEglSurface == null) {\n      checkStateNotNull(outputSurface);\n      if (enableExperimentalHdrEditing) {\n          \n        outputEglSurface = GlUtil.getEglSurfaceBt2020Pq(eglDisplay, outputSurface);\n      } else {\n        outputEglSurface = GlUtil.getEglSurface(eglDisplay, outputSurface);\n      }\n    }\n\n    inputSurfaceTexture.updateTexImage();\n    long inputFrameTimeNs = inputSurfaceTexture.getTimestamp();\n      \n    presentationTimeUs = inputFrameTimeNs / 1000 - streamOffsetUs;\n    inputSurfaceTexture.getTransformMatrix(textureTransformMatrix);\n    ((ExternalTextureProcessor) textureProcessors.get(0))\n        .setTextureTransformMatrix(textureTransformMatrix);\n\n    for (int i = 0; i < textureProcessors.size() - 1; i++) {\n      if (stopProcessing.get()) {\n        return;\n      }\n\n      Size intermediateSize = textureProcessors.get(i).getOutputSize();\n      GlUtil.focusFramebuffer(\n          eglDisplay,\n          eglContext,\n          outputEglSurface,\n          framebuffers[i],\n          intermediateSize.getWidth(),\n          intermediateSize.getHeight());\n      clearOutputFrame();\n      textureProcessors.get(i).drawFrame(presentationTimeUs);\n    }\n    GlUtil.focusEglSurface(eglDisplay, eglContext, outputEglSurface, outputWidth, outputHeight);\n    clearOutputFrame();\n    getLast(textureProcessors).drawFrame(presentationTimeUs);\n\n    EGLExt.eglPresentationTimeANDROID(eglDisplay, outputEglSurface, inputFrameTimeNs);\n    EGL14.eglSwapBuffers(eglDisplay, outputEglSurface);\n\n    if (debugSurfaceViewWrapper != null) {\n      long framePresentationTimeUs = presentationTimeUs;\n      debugSurfaceViewWrapper.maybeRenderToSurfaceView(\n          () -> {\n            clearOutputFrame();\n            try {\n              getLast(textureProcessors).drawFrame(framePresentationTimeUs);\n            } catch (FrameProcessingException e) {\n              Log.d(TAG, \"Error rendering to debug preview\", e);\n            }\n          });\n    }\n\n    checkState(pendingFrameCount.getAndDecrement() > 0);\n  } catch (FrameProcessingException | RuntimeException e) {\n    if (!stopProcessing.getAndSet(true)) {\n      listener.onFrameProcessingError(\n          e instanceof FrameProcessingException\n              ? (FrameProcessingException) e\n              : new FrameProcessingException(e, presentationTimeUs));\n    }\n  }\n}",
        "summary_tokens": [
            "processes",
            "an",
            "input",
            "frame"
        ]
    },
    {
        "id": 2403,
        "code": "private void releaseTextureProcessorsAndDestroyGlContext() {\n  try {\n    for (int i = 0; i < textureProcessors.size(); i++) {\n      textureProcessors.get(i).release();\n    }\n    GlUtil.destroyEglContext(eglDisplay, eglContext);\n  } catch (RuntimeException e) {\n    listener.onFrameProcessingError(new FrameProcessingException(e));\n  }\n}",
        "summary_tokens": [
            "releases",
            "the",
            "single",
            "frame",
            "gl",
            "texture",
            "processor",
            "single",
            "frame",
            "gl",
            "texture",
            "processors",
            "and",
            "destroys",
            "the",
            "open",
            "gl",
            "context"
        ]
    },
    {
        "id": 2404,
        "code": "private static int mimeTypeToMuxerOutputFormat(String mimeType) {\n  if (mimeType.equals(MimeTypes.VIDEO_MP4)) {\n    return MediaMuxer.OutputFormat.MUXER_OUTPUT_MPEG_4;\n  } else if (SDK_INT >= 21 && mimeType.equals(MimeTypes.VIDEO_WEBM)) {\n    return MediaMuxer.OutputFormat.MUXER_OUTPUT_WEBM;\n  } else {\n    throw new IllegalArgumentException(\"Unsupported output MIME type: \" + mimeType);\n  }\n}",
        "summary_tokens": [
            "converts",
            "a",
            "mime",
            "types",
            "mime",
            "type",
            "into",
            "a",
            "media",
            "muxer"
        ]
    },
    {
        "id": 2405,
        "code": "default Size configure(int inputWidth, int inputHeight) {\n  return new Size(inputWidth, inputHeight);\n}",
        "summary_tokens": [
            "configures",
            "the",
            "input",
            "and",
            "output",
            "dimensions"
        ]
    },
    {
        "id": 2406,
        "code": "private void updateCompositeTransformationMatrixAndVisiblePolygon(long presentationTimeUs) {\n  if (!updateTransformationMatrixCache(presentationTimeUs)) {\n    return;\n  }\n\n    \n    \n  Matrix.setIdentityM(compositeTransformationMatrix,  0);\n  visiblePolygon = NDC_SQUARE;\n  for (float[] transformationMatrix : transformationMatrixCache) {\n    Matrix.multiplyMM(\n        tempResultMatrix,\n         0,\n        transformationMatrix,\n         0,\n        compositeTransformationMatrix,\n         0);\n    System.arraycopy(\n         tempResultMatrix,\n         0,\n         compositeTransformationMatrix,\n         0,\n         tempResultMatrix.length);\n    visiblePolygon =\n        MatrixUtils.clipConvexPolygonToNdcRange(\n            MatrixUtils.transformPoints(transformationMatrix, visiblePolygon));\n    if (visiblePolygon.size() < 3) {\n        \n      return;\n    }\n  }\n    \n  Matrix.invertM(\n      tempResultMatrix,  0, compositeTransformationMatrix,  0);\n  visiblePolygon = MatrixUtils.transformPoints(tempResultMatrix, visiblePolygon);\n}",
        "summary_tokens": [
            "updates",
            "composite",
            "transformation",
            "matrix",
            "and",
            "visible",
            "polygon",
            "based",
            "on",
            "the",
            "given",
            "frame",
            "timestamp"
        ]
    },
    {
        "id": 2407,
        "code": "private boolean updateTransformationMatrixCache(long presentationTimeUs) {\n  boolean matrixChanged = false;\n  for (int i = 0; i < matrixTransformations.size(); i++) {\n    float[] cachedMatrix = transformationMatrixCache[i];\n    float[] matrix = matrixTransformations.get(i).getGlMatrixArray(presentationTimeUs);\n    if (!Arrays.equals(cachedMatrix, matrix)) {\n      checkState(matrix.length == 16, \"A 4x4 transformation matrix must have 16 elements\");\n      System.arraycopy(\n           matrix,\n           0,\n           cachedMatrix,\n           0,\n           matrix.length);\n      matrixChanged = true;\n    }\n  }\n  return matrixChanged;\n}",
        "summary_tokens": [
            "updates",
            "transformation",
            "matrix",
            "cache",
            "with",
            "the",
            "transformation",
            "matrices",
            "provided",
            "by",
            "the",
            "matrix",
            "transformations",
            "for",
            "the",
            "given",
            "frame",
            "timestamp",
            "and",
            "returns",
            "whether",
            "any",
            "matrix",
            "in",
            "transformation",
            "matrix",
            "cache",
            "changed"
        ]
    },
    {
        "id": 2408,
        "code": "public static float[] getGlMatrixArray(android.graphics.Matrix matrix) {\n  float[] matrix3x3Array = new float[9];\n  matrix.getValues(matrix3x3Array);\n  float[] matrix4x4Array = getMatrix4x4Array(matrix3x3Array);\n\n    \n  float[] transposedMatrix4x4Array = new float[16];\n  Matrix.transposeM(\n      transposedMatrix4x4Array,  0, matrix4x4Array,  0);\n\n  return transposedMatrix4x4Array;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "0",
            "x",
            "0",
            "column",
            "major",
            "matrix",
            "float",
            "array",
            "from",
            "an",
            "input",
            "android"
        ]
    },
    {
        "id": 2409,
        "code": "private static float[] getMatrix4x4Array(float[] matrix3x3Array) {\n  float[] matrix4x4Array = new float[16];\n  matrix4x4Array[10] = 1;\n  for (int inputRow = 0; inputRow < 3; inputRow++) {\n    for (int inputColumn = 0; inputColumn < 3; inputColumn++) {\n      int outputRow = (inputRow == 2) ? 3 : inputRow;\n      int outputColumn = (inputColumn == 2) ? 3 : inputColumn;\n      matrix4x4Array[outputRow * 4 + outputColumn] = matrix3x3Array[inputRow * 3 + inputColumn];\n    }\n  }\n  return matrix4x4Array;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "0",
            "x",
            "0",
            "matrix",
            "array",
            "containing",
            "the",
            "0",
            "x",
            "0",
            "matrix",
            "array",
            "s",
            "contents"
        ]
    },
    {
        "id": 2410,
        "code": "public static ImmutableList<float[]> clipConvexPolygonToNdcRange(\n    ImmutableList<float[]> polygonVertices) {\n  checkArgument(polygonVertices.size() >= 3, \"A polygon must have at least 3 vertices.\");\n\n    \n    \n    \n    \n    \n    \n    \n  ImmutableList.Builder<float[]> outputVertices =\n      new ImmutableList.Builder<float[]>().addAll(polygonVertices);\n  for (float[] clippingPlane : NDC_CUBE) {\n    ImmutableList<float[]> inputVertices = outputVertices.build();\n    outputVertices = new ImmutableList.Builder<>();\n\n    for (int i = 0; i < inputVertices.size(); i++) {\n      float[] currentVertex = inputVertices.get(i);\n      float[] previousVertex =\n          inputVertices.get((inputVertices.size() + i - 1) % inputVertices.size());\n      if (isInsideClippingHalfSpace(currentVertex, clippingPlane)) {\n        if (!isInsideClippingHalfSpace(previousVertex, clippingPlane)) {\n          float[] intersectionPoint =\n              computeIntersectionPoint(\n                  clippingPlane, clippingPlane, previousVertex, currentVertex);\n          if (!Arrays.equals(currentVertex, intersectionPoint)) {\n            outputVertices.add(intersectionPoint);\n          }\n        }\n        outputVertices.add(currentVertex);\n      } else if (isInsideClippingHalfSpace(previousVertex, clippingPlane)) {\n        float[] intersection =\n            computeIntersectionPoint(clippingPlane, clippingPlane, previousVertex, currentVertex);\n        if (!Arrays.equals(previousVertex, intersection)) {\n          outputVertices.add(intersection);\n        }\n      }\n    }\n  }\n\n  return outputVertices.build();\n}",
        "summary_tokens": [
            "clips",
            "a",
            "convex",
            "polygon",
            "to",
            "normalized",
            "device",
            "coordinates",
            "0",
            "to",
            "0",
            "on",
            "x",
            "y",
            "and",
            "z",
            "axes"
        ]
    },
    {
        "id": 2411,
        "code": "private static boolean isInsideClippingHalfSpace(float[] point, float[] clippingPlane) {\n  checkArgument(clippingPlane.length == 4, \"Expecting 4 plane parameters\");\n\n  return clippingPlane[0] * point[0] + clippingPlane[1] * point[1] + clippingPlane[2] * point[2]\n      <= clippingPlane[3];\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "given",
            "point",
            "is",
            "inside",
            "the",
            "half",
            "space",
            "bounded",
            "by",
            "the",
            "clipping",
            "plane",
            "and",
            "facing",
            "away",
            "from",
            "its",
            "normal",
            "vector"
        ]
    },
    {
        "id": 2412,
        "code": "private static float[] computeIntersectionPoint(\n    float[] planePoint, float[] planeParameters, float[] linePoint1, float[] linePoint2) {\n  checkArgument(planeParameters.length == 4, \"Expecting 4 plane parameters\");\n\n    \n    \n  float lineEquationParameter =\n      ((planePoint[0] - linePoint1[0]) * planeParameters[0]\n              + (planePoint[1] - linePoint1[1]) * planeParameters[1]\n              + (planePoint[2] - linePoint1[2]) * planeParameters[2])\n          / ((linePoint2[0] - linePoint1[0]) * planeParameters[0]\n              + (linePoint2[1] - linePoint1[1]) * planeParameters[1]\n              + (linePoint2[2] - linePoint1[2]) * planeParameters[2]);\n  float x = linePoint1[0] + (linePoint2[0] - linePoint1[0]) * lineEquationParameter;\n  float y = linePoint1[1] + (linePoint2[1] - linePoint1[1]) * lineEquationParameter;\n  float z = linePoint1[2] + (linePoint2[2] - linePoint1[2]) * lineEquationParameter;\n  return new float[] {x, y, z, 1};\n}",
        "summary_tokens": [
            "returns",
            "the",
            "intersection",
            "point",
            "of",
            "the",
            "given",
            "line",
            "and",
            "plane"
        ]
    },
    {
        "id": 2413,
        "code": "public static ImmutableList<float[]> transformPoints(\n    float[] transformationMatrix, ImmutableList<float[]> points) {\n  ImmutableList.Builder<float[]> transformedPoints = new ImmutableList.Builder<>();\n  for (int i = 0; i < points.size(); i++) {\n    float[] transformedPoint = new float[4];\n    Matrix.multiplyMV(\n        transformedPoint,\n         0,\n        transformationMatrix,\n         0,\n        points.get(i),\n         0);\n      \n      \n    transformedPoint[0] /= transformedPoint[3];\n    transformedPoint[1] /= transformedPoint[3];\n    transformedPoint[2] /= transformedPoint[3];\n    transformedPoint[3] = 1;\n    transformedPoints.add(transformedPoint);\n  }\n  return transformedPoints.build();\n}",
        "summary_tokens": [
            "applies",
            "a",
            "transformation",
            "matrix",
            "to",
            "each",
            "point"
        ]
    },
    {
        "id": 2414,
        "code": "public void registerTrack() {\n  checkState(\n      trackFormatCount == 0, \"Tracks cannot be registered after track formats have been added.\");\n  trackCount++;\n}",
        "summary_tokens": [
            "registers",
            "an",
            "output",
            "track"
        ]
    },
    {
        "id": 2415,
        "code": "public boolean supportsSampleMimeType(@Nullable String mimeType) {\n  return muxerFactory.supportsSampleMimeType(mimeType, containerMimeType);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "sample",
            "mime",
            "types",
            "mime",
            "type",
            "is",
            "supported"
        ]
    },
    {
        "id": 2416,
        "code": "public ImmutableList<String> getSupportedSampleMimeTypes(@C.TrackType int trackType) {\n  return muxerFactory.getSupportedSampleMimeTypes(trackType, containerMimeType);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "supported",
            "mime",
            "types",
            "mime",
            "types",
            "for",
            "the",
            "given",
            "c"
        ]
    },
    {
        "id": 2417,
        "code": "public void addTrackFormat(Format format) throws Muxer.MuxerException {\n  checkState(trackCount > 0, \"All tracks should be registered before the formats are added.\");\n  checkState(trackFormatCount < trackCount, \"All track formats have already been added.\");\n  @Nullable String sampleMimeType = format.sampleMimeType;\n  boolean isAudio = MimeTypes.isAudio(sampleMimeType);\n  boolean isVideo = MimeTypes.isVideo(sampleMimeType);\n  checkState(isAudio || isVideo, \"Unsupported track format: \" + sampleMimeType);\n  @C.TrackType int trackType = MimeTypes.getTrackType(sampleMimeType);\n  checkState(\n      trackTypeToIndex.get(trackType,  C.INDEX_UNSET) == C.INDEX_UNSET,\n      \"There is already a track of type \" + trackType);\n\n  int trackIndex = muxer.addTrack(format);\n  trackTypeToIndex.put(trackType, trackIndex);\n  trackTypeToSampleCount.put(trackType, 0);\n  trackTypeToTimeUs.put(trackType, 0L);\n  trackTypeToBytesWritten.put(trackType, 0L);\n  trackFormatCount++;\n  if (trackFormatCount == trackCount) {\n    isReady = true;\n  }\n}",
        "summary_tokens": [
            "adds",
            "a",
            "track",
            "format",
            "to",
            "the",
            "muxer"
        ]
    },
    {
        "id": 2418,
        "code": "public boolean writeSample(\n    @C.TrackType int trackType, ByteBuffer data, boolean isKeyFrame, long presentationTimeUs)\n    throws Muxer.MuxerException {\n  int trackIndex = trackTypeToIndex.get(trackType,  C.INDEX_UNSET);\n  checkState(\n      trackIndex != C.INDEX_UNSET,\n      \"Could not write sample because there is no track of type \" + trackType);\n\n  if (!canWriteSampleOfType(trackType)) {\n    return false;\n  }\n\n  trackTypeToSampleCount.put(trackType, trackTypeToSampleCount.get(trackType) + 1);\n  trackTypeToBytesWritten.put(\n      trackType, trackTypeToBytesWritten.get(trackType) + data.remaining());\n  if (trackTypeToTimeUs.get(trackType) < presentationTimeUs) {\n    trackTypeToTimeUs.put(trackType, presentationTimeUs);\n  }\n\n  muxer.writeSampleData(trackIndex, data, isKeyFrame, presentationTimeUs);\n  previousTrackType = trackType;\n  return true;\n}",
        "summary_tokens": [
            "attempts",
            "to",
            "write",
            "a",
            "sample",
            "to",
            "the",
            "muxer"
        ]
    },
    {
        "id": 2419,
        "code": "public void endTrack(@C.TrackType int trackType) {\n  trackTypeToIndex.delete(trackType);\n}",
        "summary_tokens": [
            "notifies",
            "the",
            "muxer",
            "that",
            "all",
            "the",
            "samples",
            "have",
            "been",
            "write",
            "sample",
            "int",
            "byte",
            "buffer",
            "boolean",
            "long",
            "written",
            "for",
            "a",
            "given",
            "track"
        ]
    },
    {
        "id": 2420,
        "code": "public void release(boolean forCancellation) throws Muxer.MuxerException {\n  isReady = false;\n  muxer.release(forCancellation);\n}",
        "summary_tokens": [
            "releases",
            "any",
            "resources",
            "associated",
            "with",
            "muxing"
        ]
    },
    {
        "id": 2421,
        "code": "public int getTrackCount() {\n  return trackCount;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "register",
            "track",
            "registered",
            "tracks"
        ]
    },
    {
        "id": 2422,
        "code": "public int getTrackAverageBitrate(@C.TrackType int trackType) {\n  long trackDurationUs = trackTypeToTimeUs.get(trackType,  -1);\n  long trackBytes = trackTypeToBytesWritten.get(trackType,  -1);\n  if (trackDurationUs <= 0 || trackBytes <= 0) {\n    return C.RATE_UNSET_INT;\n  }\n    \n    \n  return (int)\n      Util.scaleLargeTimestamp(\n           trackBytes,\n           C.BITS_PER_BYTE * C.MICROS_PER_SECOND,\n           trackDurationUs);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "average",
            "bitrate",
            "of",
            "data",
            "written",
            "to",
            "the",
            "track",
            "of",
            "the",
            "provided",
            "track",
            "type",
            "or",
            "c",
            "rate",
            "unset",
            "int",
            "if",
            "there",
            "is",
            "no",
            "track",
            "data"
        ]
    },
    {
        "id": 2423,
        "code": "public int getTrackSampleCount(@C.TrackType int trackType) {\n  return trackTypeToSampleCount.get(trackType,  0);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "samples",
            "written",
            "to",
            "the",
            "track",
            "of",
            "the",
            "provided",
            "track",
            "type"
        ]
    },
    {
        "id": 2424,
        "code": "public long getDurationMs() {\n  return Util.usToMs(maxValue(trackTypeToTimeUs));\n}",
        "summary_tokens": [
            "returns",
            "the",
            "duration",
            "of",
            "the",
            "longest",
            "track",
            "in",
            "milliseconds"
        ]
    },
    {
        "id": 2425,
        "code": "private boolean canWriteSampleOfType(int trackType) {\n  long trackTimeUs = trackTypeToTimeUs.get(trackType,  C.TIME_UNSET);\n  checkState(trackTimeUs != C.TIME_UNSET);\n  if (!isReady) {\n    return false;\n  }\n  if (trackTypeToIndex.size() == 1) {\n    return true;\n  }\n  if (trackType != previousTrackType) {\n    minTrackTimeUs = minValue(trackTypeToTimeUs);\n  }\n  return trackTimeUs - minTrackTimeUs <= MAX_TRACK_WRITE_AHEAD_US;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "muxer",
            "can",
            "write",
            "a",
            "sample",
            "of",
            "the",
            "given",
            "track",
            "type"
        ]
    },
    {
        "id": 2426,
        "code": "public boolean dropOrTransformSample(ByteBuffer buffer, long bufferTimeUs) {\n  if (slowMotionData == null) {\n      \n    lastSamplePresentationTimeUs = bufferTimeUs;\n    return false;\n  }\n\n  int originalPosition = buffer.position();\n  buffer.position(originalPosition + NAL_START_CODE_LENGTH);\n  buffer.get(scratch, 0, 4); \n  int nalUnitType = scratch[0] & 0x1F;\n  boolean svcExtensionFlag = ((scratch[1] & 0xFF) >> 7) == 1;\n  checkState(\n      nalUnitType == NAL_UNIT_TYPE_PREFIX && svcExtensionFlag,\n      \"Missing SVC extension prefix NAL unit.\");\n  int layer = (scratch[3] & 0xFF) >> 5;\n  boolean shouldKeepFrame = processCurrentFrame(layer, bufferTimeUs);\n    \n    \n  lastSamplePresentationTimeUs = getCurrentFrameOutputTimeUs(bufferTimeUs);\n  if (shouldKeepFrame) {\n    buffer.position(originalPosition);\n    return false;\n  }\n  return true;\n}",
        "summary_tokens": [
            "applies",
            "slow",
            "motion",
            "flattening",
            "by",
            "either",
            "indicating",
            "that",
            "the",
            "buffer",
            "s",
            "data",
            "should",
            "be",
            "dropped",
            "or",
            "transforming",
            "it",
            "in",
            "place"
        ]
    },
    {
        "id": 2427,
        "code": "public long getSamplePresentationTimeUs() {\n  checkState(lastSamplePresentationTimeUs != C.TIME_UNSET);\n  return lastSamplePresentationTimeUs;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "new",
            "presentation",
            "time",
            "for",
            "the",
            "last",
            "sample",
            "handled",
            "via",
            "drop",
            "or",
            "transform",
            "sample",
            "byte",
            "buffer",
            "long"
        ]
    },
    {
        "id": 2428,
        "code": " boolean processCurrentFrame(int layer, long timeUs) {\n    \n  while (nextSegmentInfo != null && timeUs >= nextSegmentInfo.endTimeUs) {\n    enterNextSegment();\n  }\n\n  if (nextSegmentInfo != null && timeUs >= nextSegmentInfo.startTimeUs) {\n    enterNextSegment();\n  } else if (currentSegmentInfo != null && timeUs >= currentSegmentInfo.endTimeUs) {\n    leaveCurrentSegment();\n  }\n\n  int maxLayer = currentSegmentInfo != null ? currentSegmentInfo.maxLayer : normalSpeedMaxLayer;\n  return layer <= maxLayer || shouldKeepFrameForOutputValidity(layer, timeUs);\n}",
        "summary_tokens": [
            "processes",
            "the",
            "current",
            "frame",
            "and",
            "returns",
            "whether",
            "it",
            "should",
            "be",
            "kept"
        ]
    },
    {
        "id": 2429,
        "code": "private void enterNextSegment() {\n  if (currentSegmentInfo != null) {\n    leaveCurrentSegment();\n  }\n  currentSegmentInfo = nextSegmentInfo;\n  nextSegmentInfo =\n      segmentIterator.hasNext()\n          ? new SegmentInfo(segmentIterator.next(), inputMaxLayer, normalSpeedMaxLayer)\n          : null;\n}",
        "summary_tokens": [
            "updates",
            "the",
            "segments",
            "information",
            "so",
            "that",
            "the",
            "next",
            "segment",
            "becomes",
            "the",
            "current",
            "segment"
        ]
    },
    {
        "id": 2430,
        "code": "private void leaveCurrentSegment() {\n  frameTimeDeltaUs +=\n      (currentSegmentInfo.endTimeUs - currentSegmentInfo.startTimeUs)\n          * (currentSegmentInfo.speedDivisor - 1);\n  currentSegmentInfo = null;\n}",
        "summary_tokens": [
            "updates",
            "the",
            "segments",
            "information",
            "so",
            "that",
            "there",
            "is",
            "no",
            "current",
            "segment"
        ]
    },
    {
        "id": 2431,
        "code": "private boolean shouldKeepFrameForOutputValidity(int layer, long timeUs) {\n  if (nextSegmentInfo == null || layer >= nextSegmentInfo.maxLayer) {\n    return false;\n  }\n\n  long frameOffsetToSegmentEstimate =\n      (nextSegmentInfo.startTimeUs - timeUs) * INPUT_FRAME_RATE / C.MICROS_PER_SECOND;\n  float allowedError = 0.45f;\n  float baseMaxFrameOffsetToSegment =\n      -(1 << (inputMaxLayer - nextSegmentInfo.maxLayer)) + allowedError;\n  for (int i = 1; i < nextSegmentInfo.maxLayer; i++) {\n    if (frameOffsetToSegmentEstimate < (1 << (inputMaxLayer - i)) + baseMaxFrameOffsetToSegment) {\n      if (layer <= i) {\n        return true;\n      }\n    } else {\n      return false;\n    }\n  }\n  return false;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "frames",
            "of",
            "the",
            "next",
            "segment",
            "are",
            "based",
            "on",
            "the",
            "current",
            "frame"
        ]
    },
    {
        "id": 2432,
        "code": " long getCurrentFrameOutputTimeUs(long inputTimeUs) {\n  long outputTimeUs = inputTimeUs + frameTimeDeltaUs;\n  if (currentSegmentInfo != null) {\n    outputTimeUs +=\n        (inputTimeUs - currentSegmentInfo.startTimeUs) * (currentSegmentInfo.speedDivisor - 1);\n  }\n  return Math.round(outputTimeUs * INPUT_FRAME_RATE / captureFrameRate);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "time",
            "of",
            "the",
            "current",
            "frame",
            "in",
            "the",
            "output",
            "in",
            "microseconds"
        ]
    },
    {
        "id": 2433,
        "code": "private static MetadataInfo getMetadataInfo(@Nullable Metadata metadata) {\n  MetadataInfo metadataInfo = new MetadataInfo();\n  if (metadata == null) {\n    return metadataInfo;\n  }\n\n  for (int i = 0; i < metadata.length(); i++) {\n    Metadata.Entry entry = metadata.get(i);\n    if (entry instanceof SmtaMetadataEntry) {\n      SmtaMetadataEntry smtaMetadataEntry = (SmtaMetadataEntry) entry;\n      metadataInfo.captureFrameRate = smtaMetadataEntry.captureFrameRate;\n      metadataInfo.inputMaxLayer = smtaMetadataEntry.svcTemporalLayerCount - 1;\n    } else if (entry instanceof SlowMotionData) {\n      metadataInfo.slowMotionData = (SlowMotionData) entry;\n    }\n  }\n\n  if (metadataInfo.slowMotionData == null) {\n    return metadataInfo;\n  }\n\n  checkState(metadataInfo.inputMaxLayer != C.INDEX_UNSET, \"SVC temporal layer count not found.\");\n  checkState(metadataInfo.captureFrameRate != C.RATE_UNSET, \"Capture frame rate not found.\");\n  checkState(\n      metadataInfo.captureFrameRate % 1 == 0\n          && metadataInfo.captureFrameRate % TARGET_OUTPUT_FRAME_RATE == 0,\n      \"Invalid capture frame rate: \" + metadataInfo.captureFrameRate);\n\n  int frameCountDivisor = (int) metadataInfo.captureFrameRate / TARGET_OUTPUT_FRAME_RATE;\n  int normalSpeedMaxLayer = metadataInfo.inputMaxLayer;\n  while (normalSpeedMaxLayer >= 0) {\n    if ((frameCountDivisor & 1) == 1) {\n        \n        \n        \n      checkState(\n          frameCountDivisor >> 1 == 0,\n          \"Could not compute normal speed max SVC layer for capture frame rate  \"\n              + metadataInfo.captureFrameRate);\n      metadataInfo.normalSpeedMaxLayer = normalSpeedMaxLayer;\n      break;\n    }\n    frameCountDivisor >>= 1;\n    normalSpeedMaxLayer--;\n  }\n  return metadataInfo;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "metadata",
            "info",
            "derived",
            "from",
            "the",
            "metadata",
            "provided"
        ]
    },
    {
        "id": 2434,
        "code": "public Builder buildUpon() {\n  return new Builder(this);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "transformation",
            "request"
        ]
    },
    {
        "id": 2435,
        "code": "protected boolean ensureConfigured() throws TransformationException {\n  if (samplePipeline != null) {\n    return true;\n  }\n  FormatHolder formatHolder = getFormatHolder();\n  @ReadDataResult\n  int result = readSource(formatHolder, decoderInputBuffer,  FLAG_REQUIRE_FORMAT);\n  if (result != C.RESULT_FORMAT_READ) {\n    return false;\n  }\n  Format inputFormat = checkNotNull(formatHolder.format);\n  if (shouldPassthrough(inputFormat)) {\n    samplePipeline =\n        new PassthroughSamplePipeline(inputFormat, transformationRequest, fallbackListener);\n  } else {\n    samplePipeline =\n        new AudioTranscodingSamplePipeline(\n            inputFormat,\n            streamOffsetUs,\n            transformationRequest,\n            decoderFactory,\n            encoderFactory,\n            muxerWrapper.getSupportedSampleMimeTypes(getTrackType()),\n            fallbackListener);\n  }\n  return true;\n}",
        "summary_tokens": [
            "attempts",
            "to",
            "read",
            "the",
            "input",
            "format",
            "and",
            "to",
            "initialize",
            "the",
            "sample",
            "pipeline"
        ]
    },
    {
        "id": 2436,
        "code": "public final @Capabilities int supportsFormat(Format format) {\n  return RendererCapabilities.create(\n      MimeTypes.getTrackType(format.sampleMimeType) == getTrackType()\n          ? C.FORMAT_HANDLED\n          : C.FORMAT_UNSUPPORTED_TYPE);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "renderer",
            "supports",
            "the",
            "track",
            "type",
            "of",
            "the",
            "given",
            "format"
        ]
    },
    {
        "id": 2437,
        "code": "private boolean feedMuxerFromPipeline() throws Muxer.MuxerException, TransformationException {\n  if (!muxerWrapperTrackAdded) {\n    @Nullable Format samplePipelineOutputFormat = samplePipeline.getOutputFormat();\n    if (samplePipelineOutputFormat == null) {\n      return false;\n    }\n    muxerWrapperTrackAdded = true;\n    muxerWrapper.addTrackFormat(samplePipelineOutputFormat);\n  }\n\n  if (samplePipeline.isEnded()) {\n    muxerWrapper.endTrack(getTrackType());\n    muxerWrapperTrackEnded = true;\n    return false;\n  }\n\n  @Nullable DecoderInputBuffer samplePipelineOutputBuffer = samplePipeline.getOutputBuffer();\n  if (samplePipelineOutputBuffer == null) {\n    return false;\n  }\n\n  long samplePresentationTimeUs = samplePipelineOutputBuffer.timeUs - streamStartPositionUs;\n    \n    \n  if (!muxerWrapper.writeSample(\n      getTrackType(),\n      checkStateNotNull(samplePipelineOutputBuffer.data),\n      samplePipelineOutputBuffer.isKeyFrame(),\n      samplePresentationTimeUs)) {\n    return false;\n  }\n  samplePipeline.releaseOutputBuffer();\n  return true;\n}",
        "summary_tokens": [
            "attempts",
            "to",
            "write",
            "sample",
            "pipeline",
            "output",
            "data",
            "to",
            "the",
            "muxer"
        ]
    },
    {
        "id": 2438,
        "code": "private boolean feedPipelineFromInput() throws TransformationException {\n  @Nullable DecoderInputBuffer samplePipelineInputBuffer = samplePipeline.dequeueInputBuffer();\n  if (samplePipelineInputBuffer == null) {\n    return false;\n  }\n\n  @ReadDataResult\n  int result = readSource(getFormatHolder(), samplePipelineInputBuffer,  0);\n  switch (result) {\n    case C.RESULT_BUFFER_READ:\n      samplePipelineInputBuffer.flip();\n      if (samplePipelineInputBuffer.isEndOfStream()) {\n        samplePipeline.queueInputBuffer();\n        return false;\n      }\n      mediaClock.updateTimeForTrackType(getTrackType(), samplePipelineInputBuffer.timeUs);\n      checkStateNotNull(samplePipelineInputBuffer.data);\n      maybeQueueSampleToPipeline(samplePipelineInputBuffer);\n      return true;\n    case C.RESULT_FORMAT_READ:\n      throw new IllegalStateException(\"Format changes are not supported.\");\n    case C.RESULT_NOTHING_READ:\n    default:\n      return false;\n  }\n}",
        "summary_tokens": [
            "attempts",
            "to",
            "read",
            "input",
            "data",
            "and",
            "pass",
            "the",
            "input",
            "data",
            "to",
            "the",
            "sample",
            "pipeline"
        ]
    },
    {
        "id": 2439,
        "code": "private ExoPlaybackException wrapTransformationException(\n    TransformationException transformationException) {\n  return ExoPlaybackException.createForRenderer(\n      transformationException,\n      \"Transformer\",\n      getIndex(),\n       null,\n      C.FORMAT_HANDLED,\n       false,\n      PlaybackException.ERROR_CODE_UNSPECIFIED);\n}",
        "summary_tokens": [
            "returns",
            "an",
            "exo",
            "playback",
            "exception",
            "wrapping",
            "the",
            "transformation",
            "exception"
        ]
    },
    {
        "id": 2440,
        "code": "public void updateTimeForTrackType(@C.TrackType int trackType, long timeUs) {\n  long previousTimeUs = trackTypeToTimeUs.get(trackType,  C.TIME_UNSET);\n  if (previousTimeUs != C.TIME_UNSET && timeUs <= previousTimeUs) {\n      \n      \n    return;\n  }\n  trackTypeToTimeUs.put(trackType, timeUs);\n  if (previousTimeUs == C.TIME_UNSET || previousTimeUs == minTrackTimeUs) {\n    minTrackTimeUs = minValue(trackTypeToTimeUs);\n  }\n}",
        "summary_tokens": [
            "updates",
            "the",
            "time",
            "for",
            "a",
            "given",
            "track",
            "type"
        ]
    },
    {
        "id": 2441,
        "code": "protected boolean ensureConfigured() throws TransformationException {\n  if (samplePipeline != null) {\n    return true;\n  }\n  FormatHolder formatHolder = getFormatHolder();\n  @ReadDataResult\n  int result = readSource(formatHolder, decoderInputBuffer,  FLAG_REQUIRE_FORMAT);\n  if (result != C.RESULT_FORMAT_READ) {\n    return false;\n  }\n  Format inputFormat = checkNotNull(formatHolder.format);\n  if (shouldPassthrough(inputFormat)) {\n    samplePipeline =\n        new PassthroughSamplePipeline(inputFormat, transformationRequest, fallbackListener);\n  } else {\n    samplePipeline =\n        new VideoTranscodingSamplePipeline(\n            context,\n            inputFormat,\n            streamOffsetUs,\n            transformationRequest,\n            effects,\n            decoderFactory,\n            encoderFactory,\n            muxerWrapper.getSupportedSampleMimeTypes(getTrackType()),\n            fallbackListener,\n            frameProcessorChainListener,\n            debugViewProvider);\n  }\n  if (transformationRequest.flattenForSlowMotion) {\n    sefSlowMotionFlattener = new SefSlowMotionFlattener(inputFormat);\n  }\n  return true;\n}",
        "summary_tokens": [
            "attempts",
            "to",
            "read",
            "the",
            "input",
            "format",
            "and",
            "to",
            "initialize",
            "the",
            "sample",
            "pipeline"
        ]
    },
    {
        "id": 2442,
        "code": "protected void maybeQueueSampleToPipeline(DecoderInputBuffer inputBuffer)\n    throws TransformationException {\n  if (sefSlowMotionFlattener == null) {\n    samplePipeline.queueInputBuffer();\n    return;\n  }\n\n  ByteBuffer data = inputBuffer.data;\n  long presentationTimeUs = inputBuffer.timeUs - streamOffsetUs;\n  boolean shouldDropSample =\n      sefSlowMotionFlattener.dropOrTransformSample(data, presentationTimeUs);\n  inputBuffer.timeUs = streamOffsetUs + sefSlowMotionFlattener.getSamplePresentationTimeUs();\n  if (shouldDropSample) {\n    data.clear();\n  } else {\n    samplePipeline.queueInputBuffer();\n  }\n}",
        "summary_tokens": [
            "queues",
            "the",
            "input",
            "buffer",
            "to",
            "the",
            "sample",
            "pipeline",
            "unless",
            "it",
            "should",
            "be",
            "dropped",
            "because",
            "of",
            "slow",
            "motion",
            "flattening"
        ]
    },
    {
        "id": 2443,
        "code": "public Builder buildUpon() {\n  return new Builder(this);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "video",
            "encoder",
            "settings"
        ]
    },
    {
        "id": 2444,
        "code": "private static TransformationRequest createFallbackTransformationRequest(\n    TransformationRequest transformationRequest,\n    boolean hasOutputFormatRotation,\n    Format requestedFormat,\n    Format supportedFormat) {\n    \n    \n  if (Util.areEqual(requestedFormat.sampleMimeType, supportedFormat.sampleMimeType)\n      && (hasOutputFormatRotation\n          ? requestedFormat.width == supportedFormat.width\n          : requestedFormat.height == supportedFormat.height)) {\n    return transformationRequest;\n  }\n  return transformationRequest\n      .buildUpon()\n      .setVideoMimeType(supportedFormat.sampleMimeType)\n      .setResolution(hasOutputFormatRotation ? requestedFormat.width : requestedFormat.height)\n      .build();\n}",
        "summary_tokens": [
            "creates",
            "a",
            "fallback",
            "transformation",
            "request",
            "to",
            "execute",
            "based",
            "on",
            "device",
            "specific",
            "support"
        ]
    },
    {
        "id": 2445,
        "code": "private boolean maybeProcessDecoderOutput() throws TransformationException {\n  @Nullable MediaCodec.BufferInfo decoderOutputBufferInfo = decoder.getOutputBufferInfo();\n  if (decoderOutputBufferInfo == null) {\n    return false;\n  }\n\n  if (isDecodeOnlyBuffer(decoderOutputBufferInfo.presentationTimeUs)) {\n    decoder.releaseOutputBuffer( false);\n    return true;\n  }\n\n  if (maxPendingFrameCount != Codec.UNLIMITED_PENDING_FRAME_COUNT\n      && frameProcessorChain.getPendingFrameCount() == maxPendingFrameCount) {\n    return false;\n  }\n\n  frameProcessorChain.registerInputFrame();\n  decoder.releaseOutputBuffer( true);\n  return true;\n}",
        "summary_tokens": [
            "feeds",
            "at",
            "most",
            "one",
            "decoder",
            "output",
            "frame",
            "to",
            "the",
            "next",
            "step",
            "of",
            "the",
            "pipeline"
        ]
    },
    {
        "id": 2446,
        "code": "private static SlowMotionData.Segment createSegment(\n    int startFrameIndex, int endFrameIndex, int speedDivisor) {\n  return new SlowMotionData.Segment(\n       (int) (startFrameIndex * C.MILLIS_PER_SECOND / INPUT_FRAME_RATE),\n       (int) (endFrameIndex * C.MILLIS_PER_SECOND / INPUT_FRAME_RATE) - 1,\n      speedDivisor);\n}",
        "summary_tokens": [
            "creates",
            "a",
            "slow",
            "motion",
            "data"
        ]
    },
    {
        "id": 2447,
        "code": "private static Format createSefSlowMotionFormat(\n    int captureFrameRate, int inputMaxLayer, List<SlowMotionData.Segment> segments) {\n  SmtaMetadataEntry smtaMetadataEntry =\n      new SmtaMetadataEntry(captureFrameRate,  inputMaxLayer + 1);\n  SlowMotionData slowMotionData = new SlowMotionData(segments);\n  Metadata metadata = new Metadata(smtaMetadataEntry, slowMotionData);\n  return new Format.Builder()\n      .setSampleMimeType(MimeTypes.VIDEO_H264)\n      .setMetadata(metadata)\n      .build();\n}",
        "summary_tokens": [
            "creates",
            "a",
            "format",
            "for",
            "an",
            "sef",
            "slow",
            "motion",
            "video",
            "track"
        ]
    },
    {
        "id": 2448,
        "code": "private static List<Integer> getKeptOutputLayers(\n    SefSlowMotionFlattener sefSlowMotionFlattener, int[] layerSequence, int frameCount) {\n  List<Integer> outputLayers = new ArrayList<>();\n  for (int i = 0; i < frameCount; i++) {\n    int layer = layerSequence[i % layerSequence.length];\n    long timeUs = i * C.MICROS_PER_SECOND / INPUT_FRAME_RATE;\n    if (sefSlowMotionFlattener.processCurrentFrame(layer, timeUs)) {\n      outputLayers.add(layer);\n    }\n  }\n  return outputLayers;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "list",
            "containing",
            "the",
            "temporal",
            "svc",
            "layers",
            "of",
            "the",
            "frames",
            "that",
            "should",
            "be",
            "kept",
            "according",
            "to",
            "sef",
            "slow",
            "motion",
            "flattener",
            "process",
            "current",
            "frame",
            "int",
            "long"
        ]
    },
    {
        "id": 2449,
        "code": "private static List<Long> getOutputTimesUs(\n    SefSlowMotionFlattener sefSlowMotionFlattener, int[] layerSequence, int frameCount) {\n  List<Long> outputTimesUs = new ArrayList<>();\n  for (int i = 0; i < frameCount; i++) {\n    int layer = layerSequence[i % layerSequence.length];\n    long inputTimeUs = i * C.MICROS_PER_SECOND / INPUT_FRAME_RATE;\n    sefSlowMotionFlattener.processCurrentFrame(layer, inputTimeUs);\n    outputTimesUs.add(sefSlowMotionFlattener.getCurrentFrameOutputTimeUs(inputTimeUs));\n  }\n  return outputTimesUs;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "list",
            "containing",
            "the",
            "frame",
            "output",
            "times",
            "obtained",
            "using",
            "sef",
            "slow",
            "motion",
            "flattener",
            "get",
            "current",
            "frame",
            "output",
            "time",
            "us",
            "long"
        ]
    },
    {
        "id": 2450,
        "code": "public void setAspectRatio(float widthHeightRatio) {\n  if (this.videoAspectRatio != widthHeightRatio) {\n    this.videoAspectRatio = widthHeightRatio;\n    requestLayout();\n  }\n}",
        "summary_tokens": [
            "sets",
            "the",
            "aspect",
            "ratio",
            "that",
            "this",
            "view",
            "should",
            "satisfy"
        ]
    },
    {
        "id": 2451,
        "code": "public void setAspectRatioListener(@Nullable AspectRatioListener listener) {\n  this.aspectRatioListener = listener;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "aspect",
            "ratio",
            "listener"
        ]
    },
    {
        "id": 2452,
        "code": "public @ResizeMode int getResizeMode() {\n  return resizeMode;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "resize",
            "mode"
        ]
    },
    {
        "id": 2453,
        "code": "public void setResizeMode(@ResizeMode int resizeMode) {\n  if (this.resizeMode != resizeMode) {\n    this.resizeMode = resizeMode;\n    requestLayout();\n  }\n}",
        "summary_tokens": [
            "sets",
            "the",
            "resize",
            "mode"
        ]
    },
    {
        "id": 2454,
        "code": "private static Cue repositionVerticalCue(Cue cue) {\n  Cue.Builder cueBuilder =\n      cue.buildUpon()\n          .setPosition(Cue.DIMEN_UNSET)\n          .setPositionAnchor(Cue.TYPE_UNSET)\n          .setTextAlignment(null);\n\n  if (cue.lineType == Cue.LINE_TYPE_FRACTION) {\n    cueBuilder.setLine(1.0f - cue.line, Cue.LINE_TYPE_FRACTION);\n  } else {\n    cueBuilder.setLine(-cue.line - 1f, Cue.LINE_TYPE_NUMBER);\n  }\n  switch (cue.lineAnchor) {\n    case Cue.ANCHOR_TYPE_END:\n      cueBuilder.setLineAnchor(Cue.ANCHOR_TYPE_START);\n      break;\n    case Cue.ANCHOR_TYPE_START:\n      cueBuilder.setLineAnchor(Cue.ANCHOR_TYPE_END);\n      break;\n    case Cue.ANCHOR_TYPE_MIDDLE:\n    case Cue.TYPE_UNSET:\n    default:\n        \n  }\n  return cueBuilder.build();\n}",
        "summary_tokens": [
            "reposition",
            "a",
            "vertical",
            "cue",
            "for",
            "horizontal",
            "display"
        ]
    },
    {
        "id": 2455,
        "code": "public static CaptionStyleCompat createFromCaptionStyle(\n    CaptioningManager.CaptionStyle captionStyle) {\n  if (Util.SDK_INT >= 21) {\n    return createFromCaptionStyleV21(captionStyle);\n  } else {\n      \n      \n    return createFromCaptionStyleV19(captionStyle);\n  }\n}",
        "summary_tokens": [
            "creates",
            "a",
            "caption",
            "style",
            "compat",
            "equivalent",
            "to",
            "a",
            "provided",
            "caption",
            "style"
        ]
    },
    {
        "id": 2456,
        "code": "public void showScrubber(long showAnimationDurationMs) {\n  if (scrubberScalingAnimator.isStarted()) {\n    scrubberScalingAnimator.cancel();\n  }\n  scrubberPaddingDisabled = false;\n  scrubberScalingAnimator.setFloatValues(scrubberScale, SHOWN_SCRUBBER_SCALE);\n  scrubberScalingAnimator.setDuration(showAnimationDurationMs);\n  scrubberScalingAnimator.start();\n}",
        "summary_tokens": [
            "shows",
            "the",
            "scrubber",
            "handle",
            "with",
            "animation"
        ]
    },
    {
        "id": 2457,
        "code": "public void hideScrubber(long hideAnimationDurationMs) {\n  if (scrubberScalingAnimator.isStarted()) {\n    scrubberScalingAnimator.cancel();\n  }\n  scrubberScalingAnimator.setFloatValues(scrubberScale, HIDDEN_SCRUBBER_SCALE);\n  scrubberScalingAnimator.setDuration(hideAnimationDurationMs);\n  scrubberScalingAnimator.start();\n}",
        "summary_tokens": [
            "hides",
            "the",
            "scrubber",
            "handle",
            "with",
            "animation"
        ]
    },
    {
        "id": 2458,
        "code": "public void setPlayedColor(@ColorInt int playedColor) {\n  playedPaint.setColor(playedColor);\n  invalidate(seekBounds);\n}",
        "summary_tokens": [
            "sets",
            "the",
            "color",
            "for",
            "the",
            "portion",
            "of",
            "the",
            "time",
            "bar",
            "representing",
            "media",
            "before",
            "the",
            "playback",
            "position"
        ]
    },
    {
        "id": 2459,
        "code": "public void setScrubberColor(@ColorInt int scrubberColor) {\n  scrubberPaint.setColor(scrubberColor);\n  invalidate(seekBounds);\n}",
        "summary_tokens": [
            "sets",
            "the",
            "color",
            "for",
            "the",
            "scrubber",
            "handle"
        ]
    },
    {
        "id": 2460,
        "code": "public void setBufferedColor(@ColorInt int bufferedColor) {\n  bufferedPaint.setColor(bufferedColor);\n  invalidate(seekBounds);\n}",
        "summary_tokens": [
            "sets",
            "the",
            "color",
            "for",
            "the",
            "portion",
            "of",
            "the",
            "time",
            "bar",
            "after",
            "the",
            "current",
            "played",
            "position",
            "up",
            "to",
            "the",
            "current",
            "buffered",
            "position"
        ]
    },
    {
        "id": 2461,
        "code": "public void setUnplayedColor(@ColorInt int unplayedColor) {\n  unplayedPaint.setColor(unplayedColor);\n  invalidate(seekBounds);\n}",
        "summary_tokens": [
            "sets",
            "the",
            "color",
            "for",
            "the",
            "portion",
            "of",
            "the",
            "time",
            "bar",
            "after",
            "the",
            "current",
            "played",
            "position"
        ]
    },
    {
        "id": 2462,
        "code": "public void setAdMarkerColor(@ColorInt int adMarkerColor) {\n  adMarkerPaint.setColor(adMarkerColor);\n  invalidate(seekBounds);\n}",
        "summary_tokens": [
            "sets",
            "the",
            "color",
            "for",
            "unplayed",
            "ad",
            "markers"
        ]
    },
    {
        "id": 2463,
        "code": "public void setPlayedAdMarkerColor(@ColorInt int playedAdMarkerColor) {\n  playedAdMarkerPaint.setColor(playedAdMarkerColor);\n  invalidate(seekBounds);\n}",
        "summary_tokens": [
            "sets",
            "the",
            "color",
            "for",
            "played",
            "ad",
            "markers"
        ]
    },
    {
        "id": 2464,
        "code": "private boolean scrubIncrementally(long positionChange) {\n  if (duration <= 0) {\n    return false;\n  }\n  long previousPosition = scrubbing ? scrubPosition : position;\n  long scrubPosition = Util.constrainValue(previousPosition + positionChange, 0, duration);\n  if (scrubPosition == previousPosition) {\n    return false;\n  }\n  if (!scrubbing) {\n    startScrubbing(scrubPosition);\n  } else {\n    updateScrubbing(scrubPosition);\n  }\n  update();\n  return true;\n}",
        "summary_tokens": [
            "incrementally",
            "scrubs",
            "the",
            "position",
            "by",
            "position",
            "change"
        ]
    },
    {
        "id": 2465,
        "code": "public static String cssAllClassDescendantsSelector(String className) {\n  return \".\" + className + \",.\" + className + \" *\";\n}",
        "summary_tokens": [
            "returns",
            "a",
            "css",
            "selector",
            "that",
            "selects",
            "all",
            "elements",
            "with",
            "class",
            "class",
            "name",
            "and",
            "all",
            "their",
            "descendants"
        ]
    },
    {
        "id": 2466,
        "code": "public Player getPlayer() {\n  return player;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "player",
            "currently",
            "being",
            "controlled",
            "by",
            "this",
            "view",
            "or",
            "null",
            "if",
            "no",
            "player",
            "is",
            "set"
        ]
    },
    {
        "id": 2467,
        "code": "public void setPlayer(@Nullable Player player) {\n  Assertions.checkState(Looper.myLooper() == Looper.getMainLooper());\n  Assertions.checkArgument(\n      player == null || player.getApplicationLooper() == Looper.getMainLooper());\n  if (this.player == player) {\n    return;\n  }\n  if (this.player != null) {\n    this.player.removeListener(componentListener);\n  }\n  this.player = player;\n  if (player != null) {\n    player.addListener(componentListener);\n  }\n  updateAll();\n}",
        "summary_tokens": [
            "sets",
            "the",
            "player",
            "to",
            "control"
        ]
    },
    {
        "id": 2468,
        "code": "public void setShowMultiWindowTimeBar(boolean showMultiWindowTimeBar) {\n  this.showMultiWindowTimeBar = showMultiWindowTimeBar;\n  updateTimeline();\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "time",
            "bar",
            "should",
            "show",
            "all",
            "windows",
            "as",
            "opposed",
            "to",
            "just",
            "the",
            "current",
            "one"
        ]
    },
    {
        "id": 2469,
        "code": "public void setExtraAdGroupMarkers(\n    @Nullable long[] extraAdGroupTimesMs, @Nullable boolean[] extraPlayedAdGroups) {\n  if (extraAdGroupTimesMs == null) {\n    this.extraAdGroupTimesMs = new long[0];\n    this.extraPlayedAdGroups = new boolean[0];\n  } else {\n    extraPlayedAdGroups = Assertions.checkNotNull(extraPlayedAdGroups);\n    Assertions.checkArgument(extraAdGroupTimesMs.length == extraPlayedAdGroups.length);\n    this.extraAdGroupTimesMs = extraAdGroupTimesMs;\n    this.extraPlayedAdGroups = extraPlayedAdGroups;\n  }\n  updateTimeline();\n}",
        "summary_tokens": [
            "sets",
            "the",
            "millisecond",
            "positions",
            "of",
            "extra",
            "ad",
            "markers",
            "relative",
            "to",
            "the",
            "start",
            "of",
            "the",
            "window",
            "or",
            "timeline",
            "if",
            "in",
            "multi",
            "window",
            "mode",
            "and",
            "whether",
            "each",
            "extra",
            "ad",
            "has",
            "been",
            "played",
            "or",
            "not"
        ]
    },
    {
        "id": 2470,
        "code": "public void addVisibilityListener(VisibilityListener listener) {\n  Assertions.checkNotNull(listener);\n  visibilityListeners.add(listener);\n}",
        "summary_tokens": [
            "adds",
            "a",
            "visibility",
            "listener"
        ]
    },
    {
        "id": 2471,
        "code": "public void removeVisibilityListener(VisibilityListener listener) {\n  visibilityListeners.remove(listener);\n}",
        "summary_tokens": [
            "removes",
            "a",
            "visibility",
            "listener"
        ]
    },
    {
        "id": 2472,
        "code": "public void setProgressUpdateListener(@Nullable ProgressUpdateListener listener) {\n  this.progressUpdateListener = listener;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "progress",
            "update",
            "listener"
        ]
    },
    {
        "id": 2473,
        "code": "public void setShowRewindButton(boolean showRewindButton) {\n  this.showRewindButton = showRewindButton;\n  updateNavigation();\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "rewind",
            "button",
            "is",
            "shown"
        ]
    },
    {
        "id": 2474,
        "code": "public void setShowFastForwardButton(boolean showFastForwardButton) {\n  this.showFastForwardButton = showFastForwardButton;\n  updateNavigation();\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "fast",
            "forward",
            "button",
            "is",
            "shown"
        ]
    },
    {
        "id": 2475,
        "code": "public void setShowPreviousButton(boolean showPreviousButton) {\n  this.showPreviousButton = showPreviousButton;\n  updateNavigation();\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "previous",
            "button",
            "is",
            "shown"
        ]
    },
    {
        "id": 2476,
        "code": "public void setShowNextButton(boolean showNextButton) {\n  this.showNextButton = showNextButton;\n  updateNavigation();\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "next",
            "button",
            "is",
            "shown"
        ]
    },
    {
        "id": 2477,
        "code": "public int getShowTimeoutMs() {\n  return showTimeoutMs;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "playback",
            "controls",
            "timeout"
        ]
    },
    {
        "id": 2478,
        "code": "public void setShowTimeoutMs(int showTimeoutMs) {\n  this.showTimeoutMs = showTimeoutMs;\n  if (isVisible()) {\n      \n    hideAfterTimeout();\n  }\n}",
        "summary_tokens": [
            "sets",
            "the",
            "playback",
            "controls",
            "timeout"
        ]
    },
    {
        "id": 2479,
        "code": "public @RepeatModeUtil.RepeatToggleModes int getRepeatToggleModes() {\n  return repeatToggleModes;\n}",
        "summary_tokens": [
            "returns",
            "which",
            "repeat",
            "toggle",
            "modes",
            "are",
            "enabled"
        ]
    },
    {
        "id": 2480,
        "code": "public void setRepeatToggleModes(@RepeatModeUtil.RepeatToggleModes int repeatToggleModes) {\n  this.repeatToggleModes = repeatToggleModes;\n  if (player != null) {\n    @Player.RepeatMode int currentMode = player.getRepeatMode();\n    if (repeatToggleModes == RepeatModeUtil.REPEAT_TOGGLE_MODE_NONE\n        && currentMode != Player.REPEAT_MODE_OFF) {\n      player.setRepeatMode(Player.REPEAT_MODE_OFF);\n    } else if (repeatToggleModes == RepeatModeUtil.REPEAT_TOGGLE_MODE_ONE\n        && currentMode == Player.REPEAT_MODE_ALL) {\n      player.setRepeatMode(Player.REPEAT_MODE_ONE);\n    } else if (repeatToggleModes == RepeatModeUtil.REPEAT_TOGGLE_MODE_ALL\n        && currentMode == Player.REPEAT_MODE_ONE) {\n      player.setRepeatMode(Player.REPEAT_MODE_ALL);\n    }\n  }\n  updateRepeatModeButton();\n}",
        "summary_tokens": [
            "sets",
            "which",
            "repeat",
            "toggle",
            "modes",
            "are",
            "enabled"
        ]
    },
    {
        "id": 2481,
        "code": "public boolean getShowShuffleButton() {\n  return showShuffleButton;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "shuffle",
            "button",
            "is",
            "shown"
        ]
    },
    {
        "id": 2482,
        "code": "public void setShowShuffleButton(boolean showShuffleButton) {\n  this.showShuffleButton = showShuffleButton;\n  updateShuffleButton();\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "shuffle",
            "button",
            "is",
            "shown"
        ]
    },
    {
        "id": 2483,
        "code": "public boolean getShowVrButton() {\n  return vrButton != null && vrButton.getVisibility() == VISIBLE;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "vr",
            "button",
            "is",
            "shown"
        ]
    },
    {
        "id": 2484,
        "code": "public void setShowVrButton(boolean showVrButton) {\n  if (vrButton != null) {\n    vrButton.setVisibility(showVrButton ? VISIBLE : GONE);\n  }\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "vr",
            "button",
            "is",
            "shown"
        ]
    },
    {
        "id": 2485,
        "code": "public void setVrButtonListener(@Nullable OnClickListener onClickListener) {\n  if (vrButton != null) {\n    vrButton.setOnClickListener(onClickListener);\n    updateButton(getShowVrButton(), onClickListener != null, vrButton);\n  }\n}",
        "summary_tokens": [
            "sets",
            "listener",
            "for",
            "the",
            "vr",
            "button"
        ]
    },
    {
        "id": 2486,
        "code": "public void setTimeBarMinUpdateInterval(int minUpdateIntervalMs) {\n    \n  timeBarMinUpdateIntervalMs =\n      Util.constrainValue(minUpdateIntervalMs, 16, MAX_UPDATE_INTERVAL_MS);\n}",
        "summary_tokens": [
            "sets",
            "the",
            "minimum",
            "interval",
            "between",
            "time",
            "bar",
            "position",
            "updates"
        ]
    },
    {
        "id": 2487,
        "code": "public void show() {\n  if (!isVisible()) {\n    setVisibility(VISIBLE);\n    for (VisibilityListener visibilityListener : visibilityListeners) {\n      visibilityListener.onVisibilityChange(getVisibility());\n    }\n    updateAll();\n    requestPlayPauseFocus();\n    requestPlayPauseAccessibilityFocus();\n  }\n    \n  hideAfterTimeout();\n}",
        "summary_tokens": [
            "shows",
            "the",
            "playback",
            "controls"
        ]
    },
    {
        "id": 2488,
        "code": "public boolean isVisible() {\n  return getVisibility() == VISIBLE;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "controller",
            "is",
            "currently",
            "visible"
        ]
    },
    {
        "id": 2489,
        "code": "public boolean dispatchMediaKeyEvent(KeyEvent event) {\n  int keyCode = event.getKeyCode();\n  @Nullable Player player = this.player;\n  if (player == null || !isHandledMediaKey(keyCode)) {\n    return false;\n  }\n  if (event.getAction() == KeyEvent.ACTION_DOWN) {\n    if (keyCode == KeyEvent.KEYCODE_MEDIA_FAST_FORWARD) {\n      if (player.getPlaybackState() != Player.STATE_ENDED) {\n        player.seekForward();\n      }\n    } else if (keyCode == KeyEvent.KEYCODE_MEDIA_REWIND) {\n      player.seekBack();\n    } else if (event.getRepeatCount() == 0) {\n      switch (keyCode) {\n        case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:\n        case KeyEvent.KEYCODE_HEADSETHOOK:\n          dispatchPlayPause(player);\n          break;\n        case KeyEvent.KEYCODE_MEDIA_PLAY:\n          dispatchPlay(player);\n          break;\n        case KeyEvent.KEYCODE_MEDIA_PAUSE:\n          dispatchPause(player);\n          break;\n        case KeyEvent.KEYCODE_MEDIA_NEXT:\n          player.seekToNext();\n          break;\n        case KeyEvent.KEYCODE_MEDIA_PREVIOUS:\n          player.seekToPrevious();\n          break;\n        default:\n          break;\n      }\n    }\n  }\n  return true;\n}",
        "summary_tokens": [
            "called",
            "to",
            "process",
            "media",
            "key",
            "events"
        ]
    },
    {
        "id": 2490,
        "code": "private static boolean canShowMultiWindowTimeBar(Timeline timeline, Timeline.Window window) {\n  if (timeline.getWindowCount() > MAX_WINDOWS_FOR_MULTI_WINDOW_TIME_BAR) {\n    return false;\n  }\n  int windowCount = timeline.getWindowCount();\n  for (int i = 0; i < windowCount; i++) {\n    if (timeline.getWindow(i, window).durationUs == C.TIME_UNSET) {\n      return false;\n    }\n  }\n  return true;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "specified",
            "timeline",
            "can",
            "be",
            "shown",
            "on",
            "a",
            "multi",
            "window",
            "time",
            "bar"
        ]
    },
    {
        "id": 2491,
        "code": "public final void setUseNextAction(boolean useNextAction) {\n  if (this.useNextAction != useNextAction) {\n    this.useNextAction = useNextAction;\n    invalidate();\n  }\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "next",
            "action",
            "should",
            "be",
            "used"
        ]
    },
    {
        "id": 2492,
        "code": "public final void setUsePreviousAction(boolean usePreviousAction) {\n  if (this.usePreviousAction != usePreviousAction) {\n    this.usePreviousAction = usePreviousAction;\n    invalidate();\n  }\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "previous",
            "action",
            "should",
            "be",
            "used"
        ]
    },
    {
        "id": 2493,
        "code": "public final void setUseNextActionInCompactView(boolean useNextActionInCompactView) {\n  if (this.useNextActionInCompactView != useNextActionInCompactView) {\n    this.useNextActionInCompactView = useNextActionInCompactView;\n    if (useNextActionInCompactView) {\n      useFastForwardActionInCompactView = false;\n    }\n    invalidate();\n  }\n}",
        "summary_tokens": [
            "if",
            "set",
            "use",
            "next",
            "action",
            "use",
            "next",
            "action",
            "is",
            "true",
            "sets",
            "whether",
            "the",
            "next",
            "action",
            "should",
            "also",
            "be",
            "used",
            "in",
            "compact",
            "view"
        ]
    },
    {
        "id": 2494,
        "code": "public final void setUsePreviousActionInCompactView(boolean usePreviousActionInCompactView) {\n  if (this.usePreviousActionInCompactView != usePreviousActionInCompactView) {\n    this.usePreviousActionInCompactView = usePreviousActionInCompactView;\n    if (usePreviousActionInCompactView) {\n      useRewindActionInCompactView = false;\n    }\n    invalidate();\n  }\n}",
        "summary_tokens": [
            "if",
            "set",
            "use",
            "previous",
            "action",
            "use",
            "previous",
            "action",
            "is",
            "true",
            "sets",
            "whether",
            "the",
            "previous",
            "action",
            "should",
            "also",
            "be",
            "used",
            "in",
            "compact",
            "view"
        ]
    },
    {
        "id": 2495,
        "code": "public final void setUseFastForwardAction(boolean useFastForwardAction) {\n  if (this.useFastForwardAction != useFastForwardAction) {\n    this.useFastForwardAction = useFastForwardAction;\n    invalidate();\n  }\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "fast",
            "forward",
            "action",
            "should",
            "be",
            "used"
        ]
    },
    {
        "id": 2496,
        "code": "public final void setUseRewindAction(boolean useRewindAction) {\n  if (this.useRewindAction != useRewindAction) {\n    this.useRewindAction = useRewindAction;\n    invalidate();\n  }\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "rewind",
            "action",
            "should",
            "be",
            "used"
        ]
    },
    {
        "id": 2497,
        "code": "public final void setUseFastForwardActionInCompactView(\n    boolean useFastForwardActionInCompactView) {\n  if (this.useFastForwardActionInCompactView != useFastForwardActionInCompactView) {\n    this.useFastForwardActionInCompactView = useFastForwardActionInCompactView;\n    if (useFastForwardActionInCompactView) {\n      useNextActionInCompactView = false;\n    }\n    invalidate();\n  }\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "fast",
            "forward",
            "action",
            "should",
            "also",
            "be",
            "used",
            "in",
            "compact",
            "view"
        ]
    },
    {
        "id": 2498,
        "code": "public final void setUseRewindActionInCompactView(boolean useRewindActionInCompactView) {\n  if (this.useRewindActionInCompactView != useRewindActionInCompactView) {\n    this.useRewindActionInCompactView = useRewindActionInCompactView;\n    if (useRewindActionInCompactView) {\n      usePreviousActionInCompactView = false;\n    }\n    invalidate();\n  }\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "rewind",
            "action",
            "should",
            "also",
            "be",
            "used",
            "in",
            "compact",
            "view"
        ]
    },
    {
        "id": 2499,
        "code": "public final void setUsePlayPauseActions(boolean usePlayPauseActions) {\n  if (this.usePlayPauseActions != usePlayPauseActions) {\n    this.usePlayPauseActions = usePlayPauseActions;\n    invalidate();\n  }\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "play",
            "and",
            "pause",
            "actions",
            "should",
            "be",
            "used"
        ]
    },
    {
        "id": 2500,
        "code": "public final void setUseStopAction(boolean useStopAction) {\n  if (this.useStopAction == useStopAction) {\n    return;\n  }\n  this.useStopAction = useStopAction;\n  invalidate();\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "stop",
            "action",
            "should",
            "be",
            "used"
        ]
    },
    {
        "id": 2501,
        "code": "public final void setMediaSessionToken(MediaSessionCompat.Token token) {\n  if (!Util.areEqual(this.mediaSessionToken, token)) {\n    mediaSessionToken = token;\n    invalidate();\n  }\n}",
        "summary_tokens": [
            "sets",
            "the",
            "media",
            "session",
            "compat"
        ]
    },
    {
        "id": 2502,
        "code": "public final void setBadgeIconType(@NotificationCompat.BadgeIconType int badgeIconType) {\n  if (this.badgeIconType == badgeIconType) {\n    return;\n  }\n  switch (badgeIconType) {\n    case NotificationCompat.BADGE_ICON_NONE:\n    case NotificationCompat.BADGE_ICON_SMALL:\n    case NotificationCompat.BADGE_ICON_LARGE:\n      this.badgeIconType = badgeIconType;\n      break;\n    default:\n      throw new IllegalArgumentException();\n  }\n  invalidate();\n}",
        "summary_tokens": [
            "sets",
            "the",
            "badge",
            "icon",
            "type",
            "of",
            "the",
            "notification"
        ]
    },
    {
        "id": 2503,
        "code": "public final void setColorized(boolean colorized) {\n  if (this.colorized != colorized) {\n    this.colorized = colorized;\n    invalidate();\n  }\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "notification",
            "should",
            "be",
            "colorized"
        ]
    },
    {
        "id": 2504,
        "code": "public final void setColor(int color) {\n  if (this.color != color) {\n    this.color = color;\n    invalidate();\n  }\n}",
        "summary_tokens": [
            "sets",
            "the",
            "accent",
            "color",
            "of",
            "the",
            "notification"
        ]
    },
    {
        "id": 2505,
        "code": "public final void setPriority(@Priority int priority) {\n  if (this.priority == priority) {\n    return;\n  }\n  switch (priority) {\n    case NotificationCompat.PRIORITY_DEFAULT:\n    case NotificationCompat.PRIORITY_MAX:\n    case NotificationCompat.PRIORITY_HIGH:\n    case NotificationCompat.PRIORITY_LOW:\n    case NotificationCompat.PRIORITY_MIN:\n      this.priority = priority;\n      break;\n    default:\n      throw new IllegalArgumentException();\n  }\n  invalidate();\n}",
        "summary_tokens": [
            "sets",
            "the",
            "priority",
            "of",
            "the",
            "notification",
            "required",
            "for",
            "api",
            "0",
            "and",
            "lower"
        ]
    },
    {
        "id": 2506,
        "code": "public final void setSmallIcon(@DrawableRes int smallIconResourceId) {\n  if (this.smallIconResourceId != smallIconResourceId) {\n    this.smallIconResourceId = smallIconResourceId;\n    invalidate();\n  }\n}",
        "summary_tokens": [
            "sets",
            "the",
            "small",
            "icon",
            "of",
            "the",
            "notification",
            "which",
            "is",
            "also",
            "shown",
            "in",
            "the",
            "system",
            "status",
            "bar"
        ]
    },
    {
        "id": 2507,
        "code": "public final void setUseChronometer(boolean useChronometer) {\n  if (this.useChronometer != useChronometer) {\n    this.useChronometer = useChronometer;\n    invalidate();\n  }\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "elapsed",
            "time",
            "of",
            "the",
            "media",
            "playback",
            "should",
            "be",
            "displayed"
        ]
    },
    {
        "id": 2508,
        "code": "public final void setVisibility(@Visibility int visibility) {\n  if (this.visibility == visibility) {\n    return;\n  }\n  switch (visibility) {\n    case NotificationCompat.VISIBILITY_PRIVATE:\n    case NotificationCompat.VISIBILITY_PUBLIC:\n    case NotificationCompat.VISIBILITY_SECRET:\n      this.visibility = visibility;\n      break;\n    default:\n      throw new IllegalStateException();\n  }\n  invalidate();\n}",
        "summary_tokens": [
            "sets",
            "the",
            "visibility",
            "of",
            "the",
            "notification",
            "which",
            "determines",
            "whether",
            "and",
            "how",
            "the",
            "notification",
            "is",
            "shown",
            "when",
            "the",
            "device",
            "is",
            "in",
            "lock",
            "screen",
            "mode"
        ]
    },
    {
        "id": 2509,
        "code": "public final void invalidate() {\n  if (isNotificationStarted) {\n    postStartOrUpdateNotification();\n  }\n}",
        "summary_tokens": [
            "forces",
            "an",
            "update",
            "of",
            "the",
            "notification",
            "if",
            "already",
            "started"
        ]
    },
    {
        "id": 2510,
        "code": "protected NotificationCompat.Builder createNotification(\n    Player player,\n    @Nullable NotificationCompat.Builder builder,\n    boolean ongoing,\n    @Nullable Bitmap largeIcon) {\n  if (player.getPlaybackState() == Player.STATE_IDLE && player.getCurrentTimeline().isEmpty()) {\n    builderActions = null;\n    return null;\n  }\n\n  List<String> actionNames = getActions(player);\n  List<NotificationCompat.Action> actions = new ArrayList<>(actionNames.size());\n  for (int i = 0; i < actionNames.size(); i++) {\n    String actionName = actionNames.get(i);\n    @Nullable\n    NotificationCompat.Action action =\n        playbackActions.containsKey(actionName)\n            ? playbackActions.get(actionName)\n            : customActions.get(actionName);\n    if (action != null) {\n      actions.add(action);\n    }\n  }\n\n  if (builder == null || !actions.equals(builderActions)) {\n    builder = new NotificationCompat.Builder(context, channelId);\n    builderActions = actions;\n    for (int i = 0; i < actions.size(); i++) {\n      builder.addAction(actions.get(i));\n    }\n  }\n\n  MediaStyle mediaStyle = new MediaStyle();\n  if (mediaSessionToken != null) {\n    mediaStyle.setMediaSession(mediaSessionToken);\n  }\n  mediaStyle.setShowActionsInCompactView(getActionIndicesForCompactView(actionNames, player));\n    \n  mediaStyle.setShowCancelButton(!ongoing);\n  mediaStyle.setCancelButtonIntent(dismissPendingIntent);\n  builder.setStyle(mediaStyle);\n\n    \n  builder.setDeleteIntent(dismissPendingIntent);\n\n    \n  builder\n      .setBadgeIconType(badgeIconType)\n      .setOngoing(ongoing)\n      .setColor(color)\n      .setColorized(colorized)\n      .setSmallIcon(smallIconResourceId)\n      .setVisibility(visibility)\n      .setPriority(priority)\n      .setDefaults(defaults);\n\n    \n  if (Util.SDK_INT >= 21\n      && useChronometer\n      && player.isPlaying()\n      && !player.isPlayingAd()\n      && !player.isCurrentMediaItemDynamic()\n      && player.getPlaybackParameters().speed == 1f) {\n    builder\n        .setWhen(System.currentTimeMillis() - player.getContentPosition())\n        .setShowWhen(true)\n        .setUsesChronometer(true);\n  } else {\n    builder.setShowWhen(false).setUsesChronometer(false);\n  }\n\n    \n  builder.setContentTitle(mediaDescriptionAdapter.getCurrentContentTitle(player));\n  builder.setContentText(mediaDescriptionAdapter.getCurrentContentText(player));\n  builder.setSubText(mediaDescriptionAdapter.getCurrentSubText(player));\n  if (largeIcon == null) {\n    largeIcon =\n        mediaDescriptionAdapter.getCurrentLargeIcon(\n            player, new BitmapCallback(++currentNotificationTag));\n  }\n  setLargeIcon(builder, largeIcon);\n  builder.setContentIntent(mediaDescriptionAdapter.createCurrentContentIntent(player));\n\n  if (groupKey != null) {\n    builder.setGroup(groupKey);\n  }\n\n  builder.setOnlyAlertOnce(true);\n  return builder;\n}",
        "summary_tokens": [
            "creates",
            "the",
            "notification",
            "given",
            "the",
            "current",
            "player",
            "state"
        ]
    },
    {
        "id": 2511,
        "code": "protected List<String> getActions(Player player) {\n  boolean enablePrevious = player.isCommandAvailable(COMMAND_SEEK_TO_PREVIOUS);\n  boolean enableRewind = player.isCommandAvailable(COMMAND_SEEK_BACK);\n  boolean enableFastForward = player.isCommandAvailable(COMMAND_SEEK_FORWARD);\n  boolean enableNext = player.isCommandAvailable(COMMAND_SEEK_TO_NEXT);\n\n  List<String> stringActions = new ArrayList<>();\n  if (usePreviousAction && enablePrevious) {\n    stringActions.add(ACTION_PREVIOUS);\n  }\n  if (useRewindAction && enableRewind) {\n    stringActions.add(ACTION_REWIND);\n  }\n  if (usePlayPauseActions) {\n    if (shouldShowPauseButton(player)) {\n      stringActions.add(ACTION_PAUSE);\n    } else {\n      stringActions.add(ACTION_PLAY);\n    }\n  }\n  if (useFastForwardAction && enableFastForward) {\n    stringActions.add(ACTION_FAST_FORWARD);\n  }\n  if (useNextAction && enableNext) {\n    stringActions.add(ACTION_NEXT);\n  }\n  if (customActionReceiver != null) {\n    stringActions.addAll(customActionReceiver.getCustomActions(player));\n  }\n  if (useStopAction) {\n    stringActions.add(ACTION_STOP);\n  }\n  return stringActions;\n}",
        "summary_tokens": [
            "gets",
            "the",
            "names",
            "and",
            "order",
            "of",
            "the",
            "actions",
            "to",
            "be",
            "included",
            "in",
            "the",
            "notification",
            "at",
            "the",
            "current",
            "player",
            "state"
        ]
    },
    {
        "id": 2512,
        "code": "protected int[] getActionIndicesForCompactView(List<String> actionNames, Player player) {\n  int pauseActionIndex = actionNames.indexOf(ACTION_PAUSE);\n  int playActionIndex = actionNames.indexOf(ACTION_PLAY);\n  int leftSideActionIndex =\n      usePreviousActionInCompactView\n          ? actionNames.indexOf(ACTION_PREVIOUS)\n          : (useRewindActionInCompactView ? actionNames.indexOf(ACTION_REWIND) : -1);\n  int rightSideActionIndex =\n      useNextActionInCompactView\n          ? actionNames.indexOf(ACTION_NEXT)\n          : (useFastForwardActionInCompactView ? actionNames.indexOf(ACTION_FAST_FORWARD) : -1);\n\n  int[] actionIndices = new int[3];\n  int actionCounter = 0;\n  if (leftSideActionIndex != -1) {\n    actionIndices[actionCounter++] = leftSideActionIndex;\n  }\n  boolean shouldShowPauseButton = shouldShowPauseButton(player);\n  if (pauseActionIndex != -1 && shouldShowPauseButton) {\n    actionIndices[actionCounter++] = pauseActionIndex;\n  } else if (playActionIndex != -1 && !shouldShowPauseButton) {\n    actionIndices[actionCounter++] = playActionIndex;\n  }\n  if (rightSideActionIndex != -1) {\n    actionIndices[actionCounter++] = rightSideActionIndex;\n  }\n  return Arrays.copyOf(actionIndices, actionCounter);\n}",
        "summary_tokens": [
            "gets",
            "an",
            "array",
            "with",
            "the",
            "indices",
            "of",
            "the",
            "buttons",
            "to",
            "be",
            "shown",
            "in",
            "compact",
            "mode"
        ]
    },
    {
        "id": 2513,
        "code": "protected boolean getOngoing(Player player) {\n  int playbackState = player.getPlaybackState();\n  return (playbackState == Player.STATE_BUFFERING || playbackState == Player.STATE_READY)\n      && player.getPlayWhenReady();\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "generated",
            "notification",
            "should",
            "be",
            "ongoing"
        ]
    },
    {
        "id": 2514,
        "code": "public static void switchTargetView(\n    Player player, @Nullable PlayerView oldPlayerView, @Nullable PlayerView newPlayerView) {\n  if (oldPlayerView == newPlayerView) {\n    return;\n  }\n    \n    \n    \n    \n  if (newPlayerView != null) {\n    newPlayerView.setPlayer(player);\n  }\n  if (oldPlayerView != null) {\n    oldPlayerView.setPlayer(null);\n  }\n}",
        "summary_tokens": [
            "switches",
            "the",
            "view",
            "targeted",
            "by",
            "a",
            "given",
            "player"
        ]
    },
    {
        "id": 2515,
        "code": "public Player getPlayer() {\n  return player;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "player",
            "currently",
            "set",
            "on",
            "this",
            "view",
            "or",
            "null",
            "if",
            "no",
            "player",
            "is",
            "set"
        ]
    },
    {
        "id": 2516,
        "code": "public void setPlayer(@Nullable Player player) {\n  Assertions.checkState(Looper.myLooper() == Looper.getMainLooper());\n  Assertions.checkArgument(\n      player == null || player.getApplicationLooper() == Looper.getMainLooper());\n  if (this.player == player) {\n    return;\n  }\n  @Nullable Player oldPlayer = this.player;\n  if (oldPlayer != null) {\n    oldPlayer.removeListener(componentListener);\n    if (oldPlayer.isCommandAvailable(COMMAND_SET_VIDEO_SURFACE)) {\n      if (surfaceView instanceof TextureView) {\n        oldPlayer.clearVideoTextureView((TextureView) surfaceView);\n      } else if (surfaceView instanceof SurfaceView) {\n        oldPlayer.clearVideoSurfaceView((SurfaceView) surfaceView);\n      }\n    }\n  }\n  if (subtitleView != null) {\n    subtitleView.setCues(null);\n  }\n  this.player = player;\n  if (useController()) {\n    controller.setPlayer(player);\n  }\n  updateBuffering();\n  updateErrorMessage();\n  updateForCurrentTrackSelections( true);\n  if (player != null) {\n    if (player.isCommandAvailable(COMMAND_SET_VIDEO_SURFACE)) {\n      if (surfaceView instanceof TextureView) {\n        player.setVideoTextureView((TextureView) surfaceView);\n      } else if (surfaceView instanceof SurfaceView) {\n        player.setVideoSurfaceView((SurfaceView) surfaceView);\n      }\n      updateAspectRatio();\n    }\n    if (subtitleView != null && player.isCommandAvailable(COMMAND_GET_TEXT)) {\n      subtitleView.setCues(player.getCurrentCues().cues);\n    }\n    player.addListener(componentListener);\n    maybeShowController(false);\n  } else {\n    hideController();\n  }\n}",
        "summary_tokens": [
            "sets",
            "the",
            "player",
            "to",
            "use"
        ]
    },
    {
        "id": 2517,
        "code": "public void setResizeMode(@ResizeMode int resizeMode) {\n  Assertions.checkStateNotNull(contentFrame);\n  contentFrame.setResizeMode(resizeMode);\n}",
        "summary_tokens": [
            "sets",
            "the",
            "resize",
            "mode"
        ]
    },
    {
        "id": 2518,
        "code": "public @ResizeMode int getResizeMode() {\n  Assertions.checkStateNotNull(contentFrame);\n  return contentFrame.getResizeMode();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "resize",
            "mode"
        ]
    },
    {
        "id": 2519,
        "code": "public boolean getUseArtwork() {\n  return useArtwork;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "artwork",
            "is",
            "displayed",
            "if",
            "present",
            "in",
            "the",
            "media"
        ]
    },
    {
        "id": 2520,
        "code": "public void setUseArtwork(boolean useArtwork) {\n  Assertions.checkState(!useArtwork || artworkView != null);\n  if (this.useArtwork != useArtwork) {\n    this.useArtwork = useArtwork;\n    updateForCurrentTrackSelections( false);\n  }\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "artwork",
            "is",
            "displayed",
            "if",
            "present",
            "in",
            "the",
            "media"
        ]
    },
    {
        "id": 2521,
        "code": "public Drawable getDefaultArtwork() {\n  return defaultArtwork;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "default",
            "artwork",
            "to",
            "display"
        ]
    },
    {
        "id": 2522,
        "code": "public void setDefaultArtwork(@Nullable Drawable defaultArtwork) {\n  if (this.defaultArtwork != defaultArtwork) {\n    this.defaultArtwork = defaultArtwork;\n    updateForCurrentTrackSelections( false);\n  }\n}",
        "summary_tokens": [
            "sets",
            "the",
            "default",
            "artwork",
            "to",
            "display",
            "if",
            "use",
            "artwork",
            "is",
            "true",
            "and",
            "no",
            "artwork",
            "is",
            "present",
            "in",
            "the",
            "media"
        ]
    },
    {
        "id": 2523,
        "code": "public boolean getUseController() {\n  return useController;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "playback",
            "controls",
            "can",
            "be",
            "shown"
        ]
    },
    {
        "id": 2524,
        "code": "public void setUseController(boolean useController) {\n  Assertions.checkState(!useController || controller != null);\n  setClickable(useController || hasOnClickListeners());\n  if (this.useController == useController) {\n    return;\n  }\n  this.useController = useController;\n  if (useController()) {\n    controller.setPlayer(player);\n  } else if (controller != null) {\n    controller.hide();\n    controller.setPlayer( null);\n  }\n  updateContentDescription();\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "playback",
            "controls",
            "can",
            "be",
            "shown"
        ]
    },
    {
        "id": 2525,
        "code": "public void setShutterBackgroundColor(int color) {\n  if (shutterView != null) {\n    shutterView.setBackgroundColor(color);\n  }\n}",
        "summary_tokens": [
            "sets",
            "the",
            "background",
            "color",
            "of",
            "the",
            "exo",
            "shutter",
            "view"
        ]
    },
    {
        "id": 2526,
        "code": "public void setKeepContentOnPlayerReset(boolean keepContentOnPlayerReset) {\n  if (this.keepContentOnPlayerReset != keepContentOnPlayerReset) {\n    this.keepContentOnPlayerReset = keepContentOnPlayerReset;\n    updateForCurrentTrackSelections( false);\n  }\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "currently",
            "displayed",
            "video",
            "frame",
            "or",
            "media",
            "artwork",
            "is",
            "kept",
            "visible",
            "when",
            "the",
            "player",
            "is",
            "reset"
        ]
    },
    {
        "id": 2527,
        "code": "public void setShowBuffering(@ShowBuffering int showBuffering) {\n  if (this.showBuffering != showBuffering) {\n    this.showBuffering = showBuffering;\n    updateBuffering();\n  }\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "a",
            "buffering",
            "spinner",
            "is",
            "displayed",
            "when",
            "the",
            "player",
            "is",
            "in",
            "the",
            "buffering",
            "state"
        ]
    },
    {
        "id": 2528,
        "code": "public void setErrorMessageProvider(\n    @Nullable ErrorMessageProvider<? super PlaybackException> errorMessageProvider) {\n  if (this.errorMessageProvider != errorMessageProvider) {\n    this.errorMessageProvider = errorMessageProvider;\n    updateErrorMessage();\n  }\n}",
        "summary_tokens": [
            "sets",
            "the",
            "optional",
            "error",
            "message",
            "provider"
        ]
    },
    {
        "id": 2529,
        "code": "public void setCustomErrorMessage(@Nullable CharSequence message) {\n  Assertions.checkState(errorMessageView != null);\n  customErrorMessage = message;\n  updateErrorMessage();\n}",
        "summary_tokens": [
            "sets",
            "a",
            "custom",
            "error",
            "message",
            "to",
            "be",
            "displayed",
            "by",
            "the",
            "view"
        ]
    },
    {
        "id": 2530,
        "code": "public boolean dispatchMediaKeyEvent(KeyEvent event) {\n  return useController() && controller.dispatchMediaKeyEvent(event);\n}",
        "summary_tokens": [
            "called",
            "to",
            "process",
            "media",
            "key",
            "events"
        ]
    },
    {
        "id": 2531,
        "code": "public boolean isControllerVisible() {\n  return controller != null && controller.isVisible();\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "controller",
            "is",
            "currently",
            "visible"
        ]
    },
    {
        "id": 2532,
        "code": "public void showController() {\n  showController(shouldShowControllerIndefinitely());\n}",
        "summary_tokens": [
            "shows",
            "the",
            "playback",
            "controls"
        ]
    },
    {
        "id": 2533,
        "code": "public void hideController() {\n  if (controller != null) {\n    controller.hide();\n  }\n}",
        "summary_tokens": [
            "hides",
            "the",
            "playback",
            "controls"
        ]
    },
    {
        "id": 2534,
        "code": "public int getControllerShowTimeoutMs() {\n  return controllerShowTimeoutMs;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "playback",
            "controls",
            "timeout"
        ]
    },
    {
        "id": 2535,
        "code": "public void setControllerShowTimeoutMs(int controllerShowTimeoutMs) {\n  Assertions.checkStateNotNull(controller);\n  this.controllerShowTimeoutMs = controllerShowTimeoutMs;\n  if (controller.isVisible()) {\n      \n    showController();\n  }\n}",
        "summary_tokens": [
            "sets",
            "the",
            "playback",
            "controls",
            "timeout"
        ]
    },
    {
        "id": 2536,
        "code": "public boolean getControllerHideOnTouch() {\n  return controllerHideOnTouch;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "playback",
            "controls",
            "are",
            "hidden",
            "by",
            "touch",
            "events"
        ]
    },
    {
        "id": 2537,
        "code": "public void setControllerHideOnTouch(boolean controllerHideOnTouch) {\n  Assertions.checkStateNotNull(controller);\n  this.controllerHideOnTouch = controllerHideOnTouch;\n  updateContentDescription();\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "playback",
            "controls",
            "are",
            "hidden",
            "by",
            "touch",
            "events"
        ]
    },
    {
        "id": 2538,
        "code": "public boolean getControllerAutoShow() {\n  return controllerAutoShow;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "playback",
            "controls",
            "are",
            "automatically",
            "shown",
            "when",
            "playback",
            "starts",
            "pauses",
            "ends",
            "or",
            "fails"
        ]
    },
    {
        "id": 2539,
        "code": "public void setControllerAutoShow(boolean controllerAutoShow) {\n  this.controllerAutoShow = controllerAutoShow;\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "playback",
            "controls",
            "are",
            "automatically",
            "shown",
            "when",
            "playback",
            "starts",
            "pauses",
            "ends",
            "or",
            "fails"
        ]
    },
    {
        "id": 2540,
        "code": "public void setControllerHideDuringAds(boolean controllerHideDuringAds) {\n  this.controllerHideDuringAds = controllerHideDuringAds;\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "playback",
            "controls",
            "are",
            "hidden",
            "when",
            "ads",
            "are",
            "playing"
        ]
    },
    {
        "id": 2541,
        "code": "public void setControllerVisibilityListener(\n    @Nullable PlayerControlView.VisibilityListener listener) {\n  Assertions.checkStateNotNull(controller);\n  if (this.controllerVisibilityListener == listener) {\n    return;\n  }\n  if (this.controllerVisibilityListener != null) {\n    controller.removeVisibilityListener(this.controllerVisibilityListener);\n  }\n  this.controllerVisibilityListener = listener;\n  if (listener != null) {\n    controller.addVisibilityListener(listener);\n  }\n}",
        "summary_tokens": [
            "sets",
            "the",
            "player",
            "control",
            "view"
        ]
    },
    {
        "id": 2542,
        "code": "public void setShowRewindButton(boolean showRewindButton) {\n  Assertions.checkStateNotNull(controller);\n  controller.setShowRewindButton(showRewindButton);\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "rewind",
            "button",
            "is",
            "shown"
        ]
    },
    {
        "id": 2543,
        "code": "public void setShowFastForwardButton(boolean showFastForwardButton) {\n  Assertions.checkStateNotNull(controller);\n  controller.setShowFastForwardButton(showFastForwardButton);\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "fast",
            "forward",
            "button",
            "is",
            "shown"
        ]
    },
    {
        "id": 2544,
        "code": "public void setShowPreviousButton(boolean showPreviousButton) {\n  Assertions.checkStateNotNull(controller);\n  controller.setShowPreviousButton(showPreviousButton);\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "previous",
            "button",
            "is",
            "shown"
        ]
    },
    {
        "id": 2545,
        "code": "public void setShowNextButton(boolean showNextButton) {\n  Assertions.checkStateNotNull(controller);\n  controller.setShowNextButton(showNextButton);\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "next",
            "button",
            "is",
            "shown"
        ]
    },
    {
        "id": 2546,
        "code": "public void setRepeatToggleModes(@RepeatModeUtil.RepeatToggleModes int repeatToggleModes) {\n  Assertions.checkStateNotNull(controller);\n  controller.setRepeatToggleModes(repeatToggleModes);\n}",
        "summary_tokens": [
            "sets",
            "which",
            "repeat",
            "toggle",
            "modes",
            "are",
            "enabled"
        ]
    },
    {
        "id": 2547,
        "code": "public void setShowShuffleButton(boolean showShuffleButton) {\n  Assertions.checkStateNotNull(controller);\n  controller.setShowShuffleButton(showShuffleButton);\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "shuffle",
            "button",
            "is",
            "shown"
        ]
    },
    {
        "id": 2548,
        "code": "public void setShowMultiWindowTimeBar(boolean showMultiWindowTimeBar) {\n  Assertions.checkStateNotNull(controller);\n  controller.setShowMultiWindowTimeBar(showMultiWindowTimeBar);\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "time",
            "bar",
            "should",
            "show",
            "all",
            "windows",
            "as",
            "opposed",
            "to",
            "just",
            "the",
            "current",
            "one"
        ]
    },
    {
        "id": 2549,
        "code": "public void setExtraAdGroupMarkers(\n    @Nullable long[] extraAdGroupTimesMs, @Nullable boolean[] extraPlayedAdGroups) {\n  Assertions.checkStateNotNull(controller);\n  controller.setExtraAdGroupMarkers(extraAdGroupTimesMs, extraPlayedAdGroups);\n}",
        "summary_tokens": [
            "sets",
            "the",
            "millisecond",
            "positions",
            "of",
            "extra",
            "ad",
            "markers",
            "relative",
            "to",
            "the",
            "start",
            "of",
            "the",
            "window",
            "or",
            "timeline",
            "if",
            "in",
            "multi",
            "window",
            "mode",
            "and",
            "whether",
            "each",
            "extra",
            "ad",
            "has",
            "been",
            "played",
            "or",
            "not"
        ]
    },
    {
        "id": 2550,
        "code": "public void setAspectRatioListener(\n    @Nullable AspectRatioFrameLayout.AspectRatioListener listener) {\n  Assertions.checkStateNotNull(contentFrame);\n  contentFrame.setAspectRatioListener(listener);\n}",
        "summary_tokens": [
            "sets",
            "the",
            "aspect",
            "ratio",
            "frame",
            "layout"
        ]
    },
    {
        "id": 2551,
        "code": "public View getVideoSurfaceView() {\n  return surfaceView;\n}",
        "summary_tokens": [
            "gets",
            "the",
            "view",
            "onto",
            "which",
            "video",
            "is",
            "rendered"
        ]
    },
    {
        "id": 2552,
        "code": "public FrameLayout getOverlayFrameLayout() {\n  return overlayFrameLayout;\n}",
        "summary_tokens": [
            "gets",
            "the",
            "overlay",
            "frame",
            "layout",
            "which",
            "can",
            "be",
            "populated",
            "with",
            "ui",
            "elements",
            "to",
            "show",
            "on",
            "top",
            "of",
            "the",
            "player"
        ]
    },
    {
        "id": 2553,
        "code": "public SubtitleView getSubtitleView() {\n  return subtitleView;\n}",
        "summary_tokens": [
            "gets",
            "the",
            "subtitle",
            "view"
        ]
    },
    {
        "id": 2554,
        "code": "public void onResume() {\n  if (surfaceView instanceof GLSurfaceView) {\n    ((GLSurfaceView) surfaceView).onResume();\n  }\n}",
        "summary_tokens": [
            "should",
            "be",
            "called",
            "when",
            "the",
            "player",
            "is",
            "visible",
            "to",
            "the",
            "user",
            "if",
            "the",
            "surface",
            "type",
            "extends",
            "glsurface",
            "view"
        ]
    },
    {
        "id": 2555,
        "code": "public void onPause() {\n  if (surfaceView instanceof GLSurfaceView) {\n    ((GLSurfaceView) surfaceView).onPause();\n  }\n}",
        "summary_tokens": [
            "should",
            "be",
            "called",
            "when",
            "the",
            "player",
            "is",
            "no",
            "longer",
            "visible",
            "to",
            "the",
            "user",
            "if",
            "the",
            "surface",
            "type",
            "extends",
            "glsurface",
            "view"
        ]
    },
    {
        "id": 2556,
        "code": "protected void onContentAspectRatioChanged(\n    @Nullable AspectRatioFrameLayout contentFrame, float aspectRatio) {\n  if (contentFrame != null) {\n    contentFrame.setAspectRatio(aspectRatio);\n  }\n}",
        "summary_tokens": [
            "called",
            "when",
            "there",
            "s",
            "a",
            "change",
            "in",
            "the",
            "desired",
            "aspect",
            "ratio",
            "of",
            "the",
            "content",
            "frame"
        ]
    },
    {
        "id": 2557,
        "code": "private void maybeShowController(boolean isForced) {\n  if (isPlayingAd() && controllerHideDuringAds) {\n    return;\n  }\n  if (useController()) {\n    boolean wasShowingIndefinitely = controller.isVisible() && controller.getShowTimeoutMs() <= 0;\n    boolean shouldShowIndefinitely = shouldShowControllerIndefinitely();\n    if (isForced || wasShowingIndefinitely || shouldShowIndefinitely) {\n      showController(shouldShowIndefinitely);\n    }\n  }\n}",
        "summary_tokens": [
            "shows",
            "the",
            "playback",
            "controls",
            "but",
            "only",
            "if",
            "forced",
            "or",
            "shown",
            "indefinitely"
        ]
    },
    {
        "id": 2558,
        "code": "private static void applyTextureViewRotation(TextureView textureView, int textureViewRotation) {\n  Matrix transformMatrix = new Matrix();\n  float textureViewWidth = textureView.getWidth();\n  float textureViewHeight = textureView.getHeight();\n  if (textureViewWidth != 0 && textureViewHeight != 0 && textureViewRotation != 0) {\n    float pivotX = textureViewWidth / 2;\n    float pivotY = textureViewHeight / 2;\n    transformMatrix.postRotate(textureViewRotation, pivotX, pivotY);\n\n      \n    RectF originalTextureRect = new RectF(0, 0, textureViewWidth, textureViewHeight);\n    RectF rotatedTextureRect = new RectF();\n    transformMatrix.mapRect(rotatedTextureRect, originalTextureRect);\n    transformMatrix.postScale(\n        textureViewWidth / rotatedTextureRect.width(),\n        textureViewHeight / rotatedTextureRect.height(),\n        pivotX,\n        pivotY);\n  }\n  textureView.setTransform(transformMatrix);\n}",
        "summary_tokens": [
            "applies",
            "a",
            "texture",
            "rotation",
            "to",
            "a",
            "texture",
            "view"
        ]
    },
    {
        "id": 2559,
        "code": "public static HtmlAndCss convert(@Nullable CharSequence text, float displayDensity) {\n  if (text == null) {\n    return new HtmlAndCss(\"\",  ImmutableMap.of());\n  }\n  if (!(text instanceof Spanned)) {\n    return new HtmlAndCss(escapeHtml(text),  ImmutableMap.of());\n  }\n  Spanned spanned = (Spanned) text;\n\n    \n  Set<Integer> backgroundColors = new HashSet<>();\n  for (BackgroundColorSpan backgroundColorSpan :\n      spanned.getSpans(0, spanned.length(), BackgroundColorSpan.class)) {\n    backgroundColors.add(backgroundColorSpan.getBackgroundColor());\n  }\n  HashMap<String, String> cssRuleSets = new HashMap<>();\n  for (int backgroundColor : backgroundColors) {\n    cssRuleSets.put(\n        HtmlUtils.cssAllClassDescendantsSelector(\"bg_\" + backgroundColor),\n        Util.formatInvariant(\"background-color:%s;\", HtmlUtils.toCssRgba(backgroundColor)));\n  }\n\n  SparseArray<Transition> spanTransitions = findSpanTransitions(spanned, displayDensity);\n  StringBuilder html = new StringBuilder(spanned.length());\n  int previousTransition = 0;\n  for (int i = 0; i < spanTransitions.size(); i++) {\n    int index = spanTransitions.keyAt(i);\n    html.append(escapeHtml(spanned.subSequence(previousTransition, index)));\n\n    Transition transition = spanTransitions.get(index);\n    Collections.sort(transition.spansRemoved, SpanInfo.FOR_CLOSING_TAGS);\n    for (SpanInfo spanInfo : transition.spansRemoved) {\n      html.append(spanInfo.closingTag);\n    }\n    Collections.sort(transition.spansAdded, SpanInfo.FOR_OPENING_TAGS);\n    for (SpanInfo spanInfo : transition.spansAdded) {\n      html.append(spanInfo.openingTag);\n    }\n    previousTransition = index;\n  }\n\n  html.append(escapeHtml(spanned.subSequence(previousTransition, spanned.length())));\n\n  return new HtmlAndCss(html.toString(), cssRuleSets);\n}",
        "summary_tokens": [
            "convert",
            "text",
            "into",
            "html",
            "adding",
            "tags",
            "and",
            "styling",
            "to",
            "match",
            "any",
            "styling",
            "spans",
            "present"
        ]
    },
    {
        "id": 2560,
        "code": "public Player getPlayer() {\n  return player;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "player",
            "currently",
            "being",
            "controlled",
            "by",
            "this",
            "view",
            "or",
            "null",
            "if",
            "no",
            "player",
            "is",
            "set"
        ]
    },
    {
        "id": 2561,
        "code": "public void setPlayer(@Nullable Player player) {\n  Assertions.checkState(Looper.myLooper() == Looper.getMainLooper());\n  Assertions.checkArgument(\n      player == null || player.getApplicationLooper() == Looper.getMainLooper());\n  if (this.player == player) {\n    return;\n  }\n  if (this.player != null) {\n    this.player.removeListener(componentListener);\n  }\n  this.player = player;\n  if (player != null) {\n    player.addListener(componentListener);\n  }\n  if (player instanceof ForwardingPlayer) {\n    player = ((ForwardingPlayer) player).getWrappedPlayer();\n  }\n  updateAll();\n}",
        "summary_tokens": [
            "sets",
            "the",
            "player",
            "to",
            "control"
        ]
    },
    {
        "id": 2562,
        "code": "public void setShowMultiWindowTimeBar(boolean showMultiWindowTimeBar) {\n  this.showMultiWindowTimeBar = showMultiWindowTimeBar;\n  updateTimeline();\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "time",
            "bar",
            "should",
            "show",
            "all",
            "windows",
            "as",
            "opposed",
            "to",
            "just",
            "the",
            "current",
            "one"
        ]
    },
    {
        "id": 2563,
        "code": "public void setExtraAdGroupMarkers(\n    @Nullable long[] extraAdGroupTimesMs, @Nullable boolean[] extraPlayedAdGroups) {\n  if (extraAdGroupTimesMs == null) {\n    this.extraAdGroupTimesMs = new long[0];\n    this.extraPlayedAdGroups = new boolean[0];\n  } else {\n    extraPlayedAdGroups = checkNotNull(extraPlayedAdGroups);\n    Assertions.checkArgument(extraAdGroupTimesMs.length == extraPlayedAdGroups.length);\n    this.extraAdGroupTimesMs = extraAdGroupTimesMs;\n    this.extraPlayedAdGroups = extraPlayedAdGroups;\n  }\n  updateTimeline();\n}",
        "summary_tokens": [
            "sets",
            "the",
            "millisecond",
            "positions",
            "of",
            "extra",
            "ad",
            "markers",
            "relative",
            "to",
            "the",
            "start",
            "of",
            "the",
            "window",
            "or",
            "timeline",
            "if",
            "in",
            "multi",
            "window",
            "mode",
            "and",
            "whether",
            "each",
            "extra",
            "ad",
            "has",
            "been",
            "played",
            "or",
            "not"
        ]
    },
    {
        "id": 2564,
        "code": "public void addVisibilityListener(VisibilityListener listener) {\n  checkNotNull(listener);\n  visibilityListeners.add(listener);\n}",
        "summary_tokens": [
            "register",
            "a",
            "styled",
            "player",
            "view"
        ]
    },
    {
        "id": 2565,
        "code": "public void removeVisibilityListener(VisibilityListener listener) {\n  visibilityListeners.remove(listener);\n}",
        "summary_tokens": [
            "register",
            "a",
            "styled",
            "player",
            "view"
        ]
    },
    {
        "id": 2566,
        "code": "public void setProgressUpdateListener(@Nullable ProgressUpdateListener listener) {\n  this.progressUpdateListener = listener;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "progress",
            "update",
            "listener"
        ]
    },
    {
        "id": 2567,
        "code": "public void setShowRewindButton(boolean showRewindButton) {\n  controlViewLayoutManager.setShowButton(rewindButton, showRewindButton);\n  updateNavigation();\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "rewind",
            "button",
            "is",
            "shown"
        ]
    },
    {
        "id": 2568,
        "code": "public void setShowFastForwardButton(boolean showFastForwardButton) {\n  controlViewLayoutManager.setShowButton(fastForwardButton, showFastForwardButton);\n  updateNavigation();\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "fast",
            "forward",
            "button",
            "is",
            "shown"
        ]
    },
    {
        "id": 2569,
        "code": "public void setShowPreviousButton(boolean showPreviousButton) {\n  controlViewLayoutManager.setShowButton(previousButton, showPreviousButton);\n  updateNavigation();\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "previous",
            "button",
            "is",
            "shown"
        ]
    },
    {
        "id": 2570,
        "code": "public void setShowNextButton(boolean showNextButton) {\n  controlViewLayoutManager.setShowButton(nextButton, showNextButton);\n  updateNavigation();\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "next",
            "button",
            "is",
            "shown"
        ]
    },
    {
        "id": 2571,
        "code": "public int getShowTimeoutMs() {\n  return showTimeoutMs;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "playback",
            "controls",
            "timeout"
        ]
    },
    {
        "id": 2572,
        "code": "public void setShowTimeoutMs(int showTimeoutMs) {\n  this.showTimeoutMs = showTimeoutMs;\n  if (isFullyVisible()) {\n    controlViewLayoutManager.resetHideCallbacks();\n  }\n}",
        "summary_tokens": [
            "sets",
            "the",
            "playback",
            "controls",
            "timeout"
        ]
    },
    {
        "id": 2573,
        "code": "public @RepeatModeUtil.RepeatToggleModes int getRepeatToggleModes() {\n  return repeatToggleModes;\n}",
        "summary_tokens": [
            "returns",
            "which",
            "repeat",
            "toggle",
            "modes",
            "are",
            "enabled"
        ]
    },
    {
        "id": 2574,
        "code": "public void setRepeatToggleModes(@RepeatModeUtil.RepeatToggleModes int repeatToggleModes) {\n  this.repeatToggleModes = repeatToggleModes;\n  if (player != null) {\n    @Player.RepeatMode int currentMode = player.getRepeatMode();\n    if (repeatToggleModes == RepeatModeUtil.REPEAT_TOGGLE_MODE_NONE\n        && currentMode != Player.REPEAT_MODE_OFF) {\n      player.setRepeatMode(Player.REPEAT_MODE_OFF);\n    } else if (repeatToggleModes == RepeatModeUtil.REPEAT_TOGGLE_MODE_ONE\n        && currentMode == Player.REPEAT_MODE_ALL) {\n      player.setRepeatMode(Player.REPEAT_MODE_ONE);\n    } else if (repeatToggleModes == RepeatModeUtil.REPEAT_TOGGLE_MODE_ALL\n        && currentMode == Player.REPEAT_MODE_ONE) {\n      player.setRepeatMode(Player.REPEAT_MODE_ALL);\n    }\n  }\n  controlViewLayoutManager.setShowButton(\n      repeatToggleButton, repeatToggleModes != RepeatModeUtil.REPEAT_TOGGLE_MODE_NONE);\n  updateRepeatModeButton();\n}",
        "summary_tokens": [
            "sets",
            "which",
            "repeat",
            "toggle",
            "modes",
            "are",
            "enabled"
        ]
    },
    {
        "id": 2575,
        "code": "public boolean getShowShuffleButton() {\n  return controlViewLayoutManager.getShowButton(shuffleButton);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "shuffle",
            "button",
            "is",
            "shown"
        ]
    },
    {
        "id": 2576,
        "code": "public void setShowShuffleButton(boolean showShuffleButton) {\n  controlViewLayoutManager.setShowButton(shuffleButton, showShuffleButton);\n  updateShuffleButton();\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "shuffle",
            "button",
            "is",
            "shown"
        ]
    },
    {
        "id": 2577,
        "code": "public boolean getShowSubtitleButton() {\n  return controlViewLayoutManager.getShowButton(subtitleButton);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "subtitle",
            "button",
            "is",
            "shown"
        ]
    },
    {
        "id": 2578,
        "code": "public void setShowSubtitleButton(boolean showSubtitleButton) {\n  controlViewLayoutManager.setShowButton(subtitleButton, showSubtitleButton);\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "subtitle",
            "button",
            "is",
            "shown"
        ]
    },
    {
        "id": 2579,
        "code": "public boolean getShowVrButton() {\n  return controlViewLayoutManager.getShowButton(vrButton);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "vr",
            "button",
            "is",
            "shown"
        ]
    },
    {
        "id": 2580,
        "code": "public void setShowVrButton(boolean showVrButton) {\n  controlViewLayoutManager.setShowButton(vrButton, showVrButton);\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "vr",
            "button",
            "is",
            "shown"
        ]
    },
    {
        "id": 2581,
        "code": "public void setVrButtonListener(@Nullable OnClickListener onClickListener) {\n  if (vrButton != null) {\n    vrButton.setOnClickListener(onClickListener);\n    updateButton(onClickListener != null, vrButton);\n  }\n}",
        "summary_tokens": [
            "sets",
            "listener",
            "for",
            "the",
            "vr",
            "button"
        ]
    },
    {
        "id": 2582,
        "code": "public void setAnimationEnabled(boolean animationEnabled) {\n  controlViewLayoutManager.setAnimationEnabled(animationEnabled);\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "an",
            "animation",
            "is",
            "used",
            "to",
            "show",
            "and",
            "hide",
            "the",
            "playback",
            "controls"
        ]
    },
    {
        "id": 2583,
        "code": "public boolean isAnimationEnabled() {\n  return controlViewLayoutManager.isAnimationEnabled();\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "an",
            "animation",
            "is",
            "used",
            "to",
            "show",
            "and",
            "hide",
            "the",
            "playback",
            "controls"
        ]
    },
    {
        "id": 2584,
        "code": "public void setTimeBarMinUpdateInterval(int minUpdateIntervalMs) {\n    \n  timeBarMinUpdateIntervalMs =\n      Util.constrainValue(minUpdateIntervalMs, 16, MAX_UPDATE_INTERVAL_MS);\n}",
        "summary_tokens": [
            "sets",
            "the",
            "minimum",
            "interval",
            "between",
            "time",
            "bar",
            "position",
            "updates"
        ]
    },
    {
        "id": 2585,
        "code": "public void setOnFullScreenModeChangedListener(\n    @Nullable OnFullScreenModeChangedListener listener) {\n  onFullScreenModeChangedListener = listener;\n  updateFullScreenButtonVisibility(fullScreenButton, listener != null);\n  updateFullScreenButtonVisibility(minimalFullScreenButton, listener != null);\n}",
        "summary_tokens": [
            "register",
            "a",
            "styled",
            "player",
            "view"
        ]
    },
    {
        "id": 2586,
        "code": "public void show() {\n  controlViewLayoutManager.show();\n}",
        "summary_tokens": [
            "shows",
            "the",
            "playback",
            "controls"
        ]
    },
    {
        "id": 2587,
        "code": "public void hideImmediately() {\n  controlViewLayoutManager.hideImmediately();\n}",
        "summary_tokens": [
            "hides",
            "the",
            "controller",
            "without",
            "any",
            "animation"
        ]
    },
    {
        "id": 2588,
        "code": "public boolean isFullyVisible() {\n  return controlViewLayoutManager.isFullyVisible();\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "controller",
            "is",
            "fully",
            "visible",
            "which",
            "means",
            "all",
            "ui",
            "controls",
            "are",
            "visible"
        ]
    },
    {
        "id": 2589,
        "code": "public boolean isVisible() {\n  return getVisibility() == VISIBLE;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "controller",
            "is",
            "currently",
            "visible"
        ]
    },
    {
        "id": 2590,
        "code": "public boolean dispatchMediaKeyEvent(KeyEvent event) {\n  int keyCode = event.getKeyCode();\n  @Nullable Player player = this.player;\n  if (player == null || !isHandledMediaKey(keyCode)) {\n    return false;\n  }\n  if (event.getAction() == KeyEvent.ACTION_DOWN) {\n    if (keyCode == KeyEvent.KEYCODE_MEDIA_FAST_FORWARD) {\n      if (player.getPlaybackState() != Player.STATE_ENDED) {\n        player.seekForward();\n      }\n    } else if (keyCode == KeyEvent.KEYCODE_MEDIA_REWIND) {\n      player.seekBack();\n    } else if (event.getRepeatCount() == 0) {\n      switch (keyCode) {\n        case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:\n        case KeyEvent.KEYCODE_HEADSETHOOK:\n          dispatchPlayPause(player);\n          break;\n        case KeyEvent.KEYCODE_MEDIA_PLAY:\n          dispatchPlay(player);\n          break;\n        case KeyEvent.KEYCODE_MEDIA_PAUSE:\n          dispatchPause(player);\n          break;\n        case KeyEvent.KEYCODE_MEDIA_NEXT:\n          player.seekToNext();\n          break;\n        case KeyEvent.KEYCODE_MEDIA_PREVIOUS:\n          player.seekToPrevious();\n          break;\n        default:\n          break;\n      }\n    }\n  }\n  return true;\n}",
        "summary_tokens": [
            "called",
            "to",
            "process",
            "media",
            "key",
            "events"
        ]
    },
    {
        "id": 2591,
        "code": "private static boolean canShowMultiWindowTimeBar(Timeline timeline, Timeline.Window window) {\n  if (timeline.getWindowCount() > MAX_WINDOWS_FOR_MULTI_WINDOW_TIME_BAR) {\n    return false;\n  }\n  int windowCount = timeline.getWindowCount();\n  for (int i = 0; i < windowCount; i++) {\n    if (timeline.getWindow(i, window).durationUs == C.TIME_UNSET) {\n      return false;\n    }\n  }\n  return true;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "specified",
            "timeline",
            "can",
            "be",
            "shown",
            "on",
            "a",
            "multi",
            "window",
            "time",
            "bar"
        ]
    },
    {
        "id": 2592,
        "code": "public static void switchTargetView(\n    Player player,\n    @Nullable StyledPlayerView oldPlayerView,\n    @Nullable StyledPlayerView newPlayerView) {\n  if (oldPlayerView == newPlayerView) {\n    return;\n  }\n    \n    \n    \n    \n  if (newPlayerView != null) {\n    newPlayerView.setPlayer(player);\n  }\n  if (oldPlayerView != null) {\n    oldPlayerView.setPlayer(null);\n  }\n}",
        "summary_tokens": [
            "switches",
            "the",
            "view",
            "targeted",
            "by",
            "a",
            "given",
            "player"
        ]
    },
    {
        "id": 2593,
        "code": "public Player getPlayer() {\n  return player;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "player",
            "currently",
            "set",
            "on",
            "this",
            "view",
            "or",
            "null",
            "if",
            "no",
            "player",
            "is",
            "set"
        ]
    },
    {
        "id": 2594,
        "code": "public void setPlayer(@Nullable Player player) {\n  Assertions.checkState(Looper.myLooper() == Looper.getMainLooper());\n  Assertions.checkArgument(\n      player == null || player.getApplicationLooper() == Looper.getMainLooper());\n  if (this.player == player) {\n    return;\n  }\n  @Nullable Player oldPlayer = this.player;\n  if (oldPlayer != null) {\n    oldPlayer.removeListener(componentListener);\n    if (surfaceView instanceof TextureView) {\n      oldPlayer.clearVideoTextureView((TextureView) surfaceView);\n    } else if (surfaceView instanceof SurfaceView) {\n      oldPlayer.clearVideoSurfaceView((SurfaceView) surfaceView);\n    }\n  }\n  if (subtitleView != null) {\n    subtitleView.setCues(null);\n  }\n  this.player = player;\n  if (useController()) {\n    controller.setPlayer(player);\n  }\n  updateBuffering();\n  updateErrorMessage();\n  updateForCurrentTrackSelections( true);\n  if (player != null) {\n    if (player.isCommandAvailable(COMMAND_SET_VIDEO_SURFACE)) {\n      if (surfaceView instanceof TextureView) {\n        player.setVideoTextureView((TextureView) surfaceView);\n      } else if (surfaceView instanceof SurfaceView) {\n        player.setVideoSurfaceView((SurfaceView) surfaceView);\n      }\n      updateAspectRatio();\n    }\n    if (subtitleView != null && player.isCommandAvailable(COMMAND_GET_TEXT)) {\n      subtitleView.setCues(player.getCurrentCues().cues);\n    }\n    player.addListener(componentListener);\n    maybeShowController(false);\n  } else {\n    hideController();\n  }\n}",
        "summary_tokens": [
            "sets",
            "the",
            "player",
            "to",
            "use"
        ]
    },
    {
        "id": 2595,
        "code": "public void setResizeMode(@ResizeMode int resizeMode) {\n  Assertions.checkStateNotNull(contentFrame);\n  contentFrame.setResizeMode(resizeMode);\n}",
        "summary_tokens": [
            "sets",
            "the",
            "resize",
            "mode"
        ]
    },
    {
        "id": 2596,
        "code": "public @ResizeMode int getResizeMode() {\n  Assertions.checkStateNotNull(contentFrame);\n  return contentFrame.getResizeMode();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "resize",
            "mode"
        ]
    },
    {
        "id": 2597,
        "code": "public boolean getUseArtwork() {\n  return useArtwork;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "artwork",
            "is",
            "displayed",
            "if",
            "present",
            "in",
            "the",
            "media"
        ]
    },
    {
        "id": 2598,
        "code": "public void setUseArtwork(boolean useArtwork) {\n  Assertions.checkState(!useArtwork || artworkView != null);\n  if (this.useArtwork != useArtwork) {\n    this.useArtwork = useArtwork;\n    updateForCurrentTrackSelections( false);\n  }\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "artwork",
            "is",
            "displayed",
            "if",
            "present",
            "in",
            "the",
            "media"
        ]
    },
    {
        "id": 2599,
        "code": "public Drawable getDefaultArtwork() {\n  return defaultArtwork;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "default",
            "artwork",
            "to",
            "display"
        ]
    },
    {
        "id": 2600,
        "code": "public void setDefaultArtwork(@Nullable Drawable defaultArtwork) {\n  if (this.defaultArtwork != defaultArtwork) {\n    this.defaultArtwork = defaultArtwork;\n    updateForCurrentTrackSelections( false);\n  }\n}",
        "summary_tokens": [
            "sets",
            "the",
            "default",
            "artwork",
            "to",
            "display",
            "if",
            "use",
            "artwork",
            "is",
            "true",
            "and",
            "no",
            "artwork",
            "is",
            "present",
            "in",
            "the",
            "media"
        ]
    },
    {
        "id": 2601,
        "code": "public boolean getUseController() {\n  return useController;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "playback",
            "controls",
            "can",
            "be",
            "shown"
        ]
    },
    {
        "id": 2602,
        "code": "public void setUseController(boolean useController) {\n  Assertions.checkState(!useController || controller != null);\n  setClickable(useController || hasOnClickListeners());\n  if (this.useController == useController) {\n    return;\n  }\n  this.useController = useController;\n  if (useController()) {\n    controller.setPlayer(player);\n  } else if (controller != null) {\n    controller.hide();\n    controller.setPlayer( null);\n  }\n  updateContentDescription();\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "playback",
            "controls",
            "can",
            "be",
            "shown"
        ]
    },
    {
        "id": 2603,
        "code": "public void setShutterBackgroundColor(@ColorInt int color) {\n  if (shutterView != null) {\n    shutterView.setBackgroundColor(color);\n  }\n}",
        "summary_tokens": [
            "sets",
            "the",
            "background",
            "color",
            "of",
            "the",
            "exo",
            "shutter",
            "view"
        ]
    },
    {
        "id": 2604,
        "code": "public void setKeepContentOnPlayerReset(boolean keepContentOnPlayerReset) {\n  if (this.keepContentOnPlayerReset != keepContentOnPlayerReset) {\n    this.keepContentOnPlayerReset = keepContentOnPlayerReset;\n    updateForCurrentTrackSelections( false);\n  }\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "currently",
            "displayed",
            "video",
            "frame",
            "or",
            "media",
            "artwork",
            "is",
            "kept",
            "visible",
            "when",
            "the",
            "player",
            "is",
            "reset"
        ]
    },
    {
        "id": 2605,
        "code": "public void setShowBuffering(@ShowBuffering int showBuffering) {\n  if (this.showBuffering != showBuffering) {\n    this.showBuffering = showBuffering;\n    updateBuffering();\n  }\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "a",
            "buffering",
            "spinner",
            "is",
            "displayed",
            "when",
            "the",
            "player",
            "is",
            "in",
            "the",
            "buffering",
            "state"
        ]
    },
    {
        "id": 2606,
        "code": "public void setErrorMessageProvider(\n    @Nullable ErrorMessageProvider<? super PlaybackException> errorMessageProvider) {\n  if (this.errorMessageProvider != errorMessageProvider) {\n    this.errorMessageProvider = errorMessageProvider;\n    updateErrorMessage();\n  }\n}",
        "summary_tokens": [
            "sets",
            "the",
            "optional",
            "error",
            "message",
            "provider"
        ]
    },
    {
        "id": 2607,
        "code": "public void setCustomErrorMessage(@Nullable CharSequence message) {\n  Assertions.checkState(errorMessageView != null);\n  customErrorMessage = message;\n  updateErrorMessage();\n}",
        "summary_tokens": [
            "sets",
            "a",
            "custom",
            "error",
            "message",
            "to",
            "be",
            "displayed",
            "by",
            "the",
            "view"
        ]
    },
    {
        "id": 2608,
        "code": "public boolean dispatchMediaKeyEvent(KeyEvent event) {\n  return useController() && controller.dispatchMediaKeyEvent(event);\n}",
        "summary_tokens": [
            "called",
            "to",
            "process",
            "media",
            "key",
            "events"
        ]
    },
    {
        "id": 2609,
        "code": "public boolean isControllerFullyVisible() {\n  return controller != null && controller.isFullyVisible();\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "controller",
            "is",
            "currently",
            "fully",
            "visible"
        ]
    },
    {
        "id": 2610,
        "code": "public void showController() {\n  showController(shouldShowControllerIndefinitely());\n}",
        "summary_tokens": [
            "shows",
            "the",
            "playback",
            "controls"
        ]
    },
    {
        "id": 2611,
        "code": "public void hideController() {\n  if (controller != null) {\n    controller.hide();\n  }\n}",
        "summary_tokens": [
            "hides",
            "the",
            "playback",
            "controls"
        ]
    },
    {
        "id": 2612,
        "code": "public int getControllerShowTimeoutMs() {\n  return controllerShowTimeoutMs;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "playback",
            "controls",
            "timeout"
        ]
    },
    {
        "id": 2613,
        "code": "public void setControllerShowTimeoutMs(int controllerShowTimeoutMs) {\n  Assertions.checkStateNotNull(controller);\n  this.controllerShowTimeoutMs = controllerShowTimeoutMs;\n  if (controller.isFullyVisible()) {\n      \n    showController();\n  }\n}",
        "summary_tokens": [
            "sets",
            "the",
            "playback",
            "controls",
            "timeout"
        ]
    },
    {
        "id": 2614,
        "code": "public boolean getControllerHideOnTouch() {\n  return controllerHideOnTouch;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "playback",
            "controls",
            "are",
            "hidden",
            "by",
            "touch",
            "events"
        ]
    },
    {
        "id": 2615,
        "code": "public void setControllerHideOnTouch(boolean controllerHideOnTouch) {\n  Assertions.checkStateNotNull(controller);\n  this.controllerHideOnTouch = controllerHideOnTouch;\n  updateContentDescription();\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "playback",
            "controls",
            "are",
            "hidden",
            "by",
            "touch",
            "events"
        ]
    },
    {
        "id": 2616,
        "code": "public boolean getControllerAutoShow() {\n  return controllerAutoShow;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "playback",
            "controls",
            "are",
            "automatically",
            "shown",
            "when",
            "playback",
            "starts",
            "pauses",
            "ends",
            "or",
            "fails"
        ]
    },
    {
        "id": 2617,
        "code": "public void setControllerAutoShow(boolean controllerAutoShow) {\n  this.controllerAutoShow = controllerAutoShow;\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "playback",
            "controls",
            "are",
            "automatically",
            "shown",
            "when",
            "playback",
            "starts",
            "pauses",
            "ends",
            "or",
            "fails"
        ]
    },
    {
        "id": 2618,
        "code": "public void setControllerHideDuringAds(boolean controllerHideDuringAds) {\n  this.controllerHideDuringAds = controllerHideDuringAds;\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "playback",
            "controls",
            "are",
            "hidden",
            "when",
            "ads",
            "are",
            "playing"
        ]
    },
    {
        "id": 2619,
        "code": "public void setControllerVisibilityListener(\n    @Nullable StyledPlayerControlView.VisibilityListener listener) {\n  Assertions.checkStateNotNull(controller);\n  if (this.legacyControllerVisibilityListener == listener) {\n    return;\n  }\n\n  if (this.legacyControllerVisibilityListener != null) {\n    controller.removeVisibilityListener(this.legacyControllerVisibilityListener);\n  }\n  this.legacyControllerVisibilityListener = listener;\n  if (listener != null) {\n    controller.addVisibilityListener(listener);\n  }\n  setControllerVisibilityListener((ControllerVisibilityListener) null);\n}",
        "summary_tokens": [
            "sets",
            "the",
            "styled",
            "player",
            "control",
            "view"
        ]
    },
    {
        "id": 2620,
        "code": "public void setFullscreenButtonClickListener(@Nullable FullscreenButtonClickListener listener) {\n  Assertions.checkStateNotNull(controller);\n  this.fullscreenButtonClickListener = listener;\n  controller.setOnFullScreenModeChangedListener(componentListener);\n}",
        "summary_tokens": [
            "sets",
            "the",
            "fullscreen",
            "button",
            "click",
            "listener"
        ]
    },
    {
        "id": 2621,
        "code": "public void setControllerOnFullScreenModeChangedListener(\n    @Nullable StyledPlayerControlView.OnFullScreenModeChangedListener listener) {\n  Assertions.checkStateNotNull(controller);\n  this.fullscreenButtonClickListener = null;\n  controller.setOnFullScreenModeChangedListener(listener);\n}",
        "summary_tokens": [
            "sets",
            "the",
            "styled",
            "player",
            "control",
            "view"
        ]
    },
    {
        "id": 2622,
        "code": "public void setShowRewindButton(boolean showRewindButton) {\n  Assertions.checkStateNotNull(controller);\n  controller.setShowRewindButton(showRewindButton);\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "rewind",
            "button",
            "is",
            "shown"
        ]
    },
    {
        "id": 2623,
        "code": "public void setShowFastForwardButton(boolean showFastForwardButton) {\n  Assertions.checkStateNotNull(controller);\n  controller.setShowFastForwardButton(showFastForwardButton);\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "fast",
            "forward",
            "button",
            "is",
            "shown"
        ]
    },
    {
        "id": 2624,
        "code": "public void setShowPreviousButton(boolean showPreviousButton) {\n  Assertions.checkStateNotNull(controller);\n  controller.setShowPreviousButton(showPreviousButton);\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "previous",
            "button",
            "is",
            "shown"
        ]
    },
    {
        "id": 2625,
        "code": "public void setShowNextButton(boolean showNextButton) {\n  Assertions.checkStateNotNull(controller);\n  controller.setShowNextButton(showNextButton);\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "next",
            "button",
            "is",
            "shown"
        ]
    },
    {
        "id": 2626,
        "code": "public void setRepeatToggleModes(@RepeatModeUtil.RepeatToggleModes int repeatToggleModes) {\n  Assertions.checkStateNotNull(controller);\n  controller.setRepeatToggleModes(repeatToggleModes);\n}",
        "summary_tokens": [
            "sets",
            "which",
            "repeat",
            "toggle",
            "modes",
            "are",
            "enabled"
        ]
    },
    {
        "id": 2627,
        "code": "public void setShowShuffleButton(boolean showShuffleButton) {\n  Assertions.checkStateNotNull(controller);\n  controller.setShowShuffleButton(showShuffleButton);\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "shuffle",
            "button",
            "is",
            "shown"
        ]
    },
    {
        "id": 2628,
        "code": "public void setShowSubtitleButton(boolean showSubtitleButton) {\n  Assertions.checkStateNotNull(controller);\n  controller.setShowSubtitleButton(showSubtitleButton);\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "subtitle",
            "button",
            "is",
            "shown"
        ]
    },
    {
        "id": 2629,
        "code": "public void setShowVrButton(boolean showVrButton) {\n  Assertions.checkStateNotNull(controller);\n  controller.setShowVrButton(showVrButton);\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "vr",
            "button",
            "is",
            "shown"
        ]
    },
    {
        "id": 2630,
        "code": "public void setShowMultiWindowTimeBar(boolean showMultiWindowTimeBar) {\n  Assertions.checkStateNotNull(controller);\n  controller.setShowMultiWindowTimeBar(showMultiWindowTimeBar);\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "time",
            "bar",
            "should",
            "show",
            "all",
            "windows",
            "as",
            "opposed",
            "to",
            "just",
            "the",
            "current",
            "one"
        ]
    },
    {
        "id": 2631,
        "code": "public void setExtraAdGroupMarkers(\n    @Nullable long[] extraAdGroupTimesMs, @Nullable boolean[] extraPlayedAdGroups) {\n  Assertions.checkStateNotNull(controller);\n  controller.setExtraAdGroupMarkers(extraAdGroupTimesMs, extraPlayedAdGroups);\n}",
        "summary_tokens": [
            "sets",
            "the",
            "millisecond",
            "positions",
            "of",
            "extra",
            "ad",
            "markers",
            "relative",
            "to",
            "the",
            "start",
            "of",
            "the",
            "window",
            "or",
            "timeline",
            "if",
            "in",
            "multi",
            "window",
            "mode",
            "and",
            "whether",
            "each",
            "extra",
            "ad",
            "has",
            "been",
            "played",
            "or",
            "not"
        ]
    },
    {
        "id": 2632,
        "code": "public void setAspectRatioListener(\n    @Nullable AspectRatioFrameLayout.AspectRatioListener listener) {\n  Assertions.checkStateNotNull(contentFrame);\n  contentFrame.setAspectRatioListener(listener);\n}",
        "summary_tokens": [
            "sets",
            "the",
            "aspect",
            "ratio",
            "frame",
            "layout"
        ]
    },
    {
        "id": 2633,
        "code": "public View getVideoSurfaceView() {\n  return surfaceView;\n}",
        "summary_tokens": [
            "gets",
            "the",
            "view",
            "onto",
            "which",
            "video",
            "is",
            "rendered"
        ]
    },
    {
        "id": 2634,
        "code": "public FrameLayout getOverlayFrameLayout() {\n  return overlayFrameLayout;\n}",
        "summary_tokens": [
            "gets",
            "the",
            "overlay",
            "frame",
            "layout",
            "which",
            "can",
            "be",
            "populated",
            "with",
            "ui",
            "elements",
            "to",
            "show",
            "on",
            "top",
            "of",
            "the",
            "player"
        ]
    },
    {
        "id": 2635,
        "code": "public SubtitleView getSubtitleView() {\n  return subtitleView;\n}",
        "summary_tokens": [
            "gets",
            "the",
            "subtitle",
            "view"
        ]
    },
    {
        "id": 2636,
        "code": "public void onResume() {\n  if (surfaceView instanceof GLSurfaceView) {\n    ((GLSurfaceView) surfaceView).onResume();\n  }\n}",
        "summary_tokens": [
            "should",
            "be",
            "called",
            "when",
            "the",
            "player",
            "is",
            "visible",
            "to",
            "the",
            "user",
            "if",
            "the",
            "surface",
            "type",
            "extends",
            "glsurface",
            "view"
        ]
    },
    {
        "id": 2637,
        "code": "public void onPause() {\n  if (surfaceView instanceof GLSurfaceView) {\n    ((GLSurfaceView) surfaceView).onPause();\n  }\n}",
        "summary_tokens": [
            "should",
            "be",
            "called",
            "when",
            "the",
            "player",
            "is",
            "no",
            "longer",
            "visible",
            "to",
            "the",
            "user",
            "if",
            "the",
            "surface",
            "type",
            "extends",
            "glsurface",
            "view"
        ]
    },
    {
        "id": 2638,
        "code": "protected void onContentAspectRatioChanged(\n    @Nullable AspectRatioFrameLayout contentFrame, float aspectRatio) {\n  if (contentFrame != null) {\n    contentFrame.setAspectRatio(aspectRatio);\n  }\n}",
        "summary_tokens": [
            "called",
            "when",
            "there",
            "s",
            "a",
            "change",
            "in",
            "the",
            "desired",
            "aspect",
            "ratio",
            "of",
            "the",
            "content",
            "frame"
        ]
    },
    {
        "id": 2639,
        "code": "private void maybeShowController(boolean isForced) {\n  if (isPlayingAd() && controllerHideDuringAds) {\n    return;\n  }\n  if (useController()) {\n    boolean wasShowingIndefinitely =\n        controller.isFullyVisible() && controller.getShowTimeoutMs() <= 0;\n    boolean shouldShowIndefinitely = shouldShowControllerIndefinitely();\n    if (isForced || wasShowingIndefinitely || shouldShowIndefinitely) {\n      showController(shouldShowIndefinitely);\n    }\n  }\n}",
        "summary_tokens": [
            "shows",
            "the",
            "playback",
            "controls",
            "but",
            "only",
            "if",
            "forced",
            "or",
            "shown",
            "indefinitely"
        ]
    },
    {
        "id": 2640,
        "code": "private static void applyTextureViewRotation(TextureView textureView, int textureViewRotation) {\n  Matrix transformMatrix = new Matrix();\n  float textureViewWidth = textureView.getWidth();\n  float textureViewHeight = textureView.getHeight();\n  if (textureViewWidth != 0 && textureViewHeight != 0 && textureViewRotation != 0) {\n    float pivotX = textureViewWidth / 2;\n    float pivotY = textureViewHeight / 2;\n    transformMatrix.postRotate(textureViewRotation, pivotX, pivotY);\n\n      \n    RectF originalTextureRect = new RectF(0, 0, textureViewWidth, textureViewHeight);\n    RectF rotatedTextureRect = new RectF();\n    transformMatrix.mapRect(rotatedTextureRect, originalTextureRect);\n    transformMatrix.postScale(\n        textureViewWidth / rotatedTextureRect.width(),\n        textureViewHeight / rotatedTextureRect.height(),\n        pivotX,\n        pivotY);\n  }\n  textureView.setTransform(transformMatrix);\n}",
        "summary_tokens": [
            "applies",
            "a",
            "texture",
            "rotation",
            "to",
            "a",
            "texture",
            "view"
        ]
    },
    {
        "id": 2641,
        "code": "public void draw(\n    Cue cue,\n    CaptionStyleCompat style,\n    float defaultTextSizePx,\n    float cueTextSizePx,\n    float bottomPaddingFraction,\n    Canvas canvas,\n    int cueBoxLeft,\n    int cueBoxTop,\n    int cueBoxRight,\n    int cueBoxBottom) {\n  boolean isTextCue = cue.bitmap == null;\n  int windowColor = Color.BLACK;\n  if (isTextCue) {\n    if (TextUtils.isEmpty(cue.text)) {\n        \n      return;\n    }\n    windowColor = cue.windowColorSet ? cue.windowColor : style.windowColor;\n  }\n  if (areCharSequencesEqual(this.cueText, cue.text)\n      && Util.areEqual(this.cueTextAlignment, cue.textAlignment)\n      && this.cueBitmap == cue.bitmap\n      && this.cueLine == cue.line\n      && this.cueLineType == cue.lineType\n      && Util.areEqual(this.cueLineAnchor, cue.lineAnchor)\n      && this.cuePosition == cue.position\n      && Util.areEqual(this.cuePositionAnchor, cue.positionAnchor)\n      && this.cueSize == cue.size\n      && this.cueBitmapHeight == cue.bitmapHeight\n      && this.foregroundColor == style.foregroundColor\n      && this.backgroundColor == style.backgroundColor\n      && this.windowColor == windowColor\n      && this.edgeType == style.edgeType\n      && this.edgeColor == style.edgeColor\n      && Util.areEqual(this.textPaint.getTypeface(), style.typeface)\n      && this.defaultTextSizePx == defaultTextSizePx\n      && this.cueTextSizePx == cueTextSizePx\n      && this.bottomPaddingFraction == bottomPaddingFraction\n      && this.parentLeft == cueBoxLeft\n      && this.parentTop == cueBoxTop\n      && this.parentRight == cueBoxRight\n      && this.parentBottom == cueBoxBottom) {\n      \n    drawLayout(canvas, isTextCue);\n    return;\n  }\n\n  this.cueText = cue.text;\n  this.cueTextAlignment = cue.textAlignment;\n  this.cueBitmap = cue.bitmap;\n  this.cueLine = cue.line;\n  this.cueLineType = cue.lineType;\n  this.cueLineAnchor = cue.lineAnchor;\n  this.cuePosition = cue.position;\n  this.cuePositionAnchor = cue.positionAnchor;\n  this.cueSize = cue.size;\n  this.cueBitmapHeight = cue.bitmapHeight;\n  this.foregroundColor = style.foregroundColor;\n  this.backgroundColor = style.backgroundColor;\n  this.windowColor = windowColor;\n  this.edgeType = style.edgeType;\n  this.edgeColor = style.edgeColor;\n  this.textPaint.setTypeface(style.typeface);\n  this.defaultTextSizePx = defaultTextSizePx;\n  this.cueTextSizePx = cueTextSizePx;\n  this.bottomPaddingFraction = bottomPaddingFraction;\n  this.parentLeft = cueBoxLeft;\n  this.parentTop = cueBoxTop;\n  this.parentRight = cueBoxRight;\n  this.parentBottom = cueBoxBottom;\n\n  if (isTextCue) {\n    Assertions.checkNotNull(cueText);\n    setupTextLayout();\n  } else {\n    Assertions.checkNotNull(cueBitmap);\n    setupBitmapLayout();\n  }\n  drawLayout(canvas, isTextCue);\n}",
        "summary_tokens": [
            "draws",
            "the",
            "provided",
            "cue",
            "into",
            "a",
            "canvas",
            "with",
            "the",
            "specified",
            "styling"
        ]
    },
    {
        "id": 2642,
        "code": "private static boolean areCharSequencesEqual(\n    @Nullable CharSequence first, @Nullable CharSequence second) {\n    \n    \n  return first == second || (first != null && first.equals(second));\n}",
        "summary_tokens": [
            "this",
            "method",
            "is",
            "used",
            "instead",
            "of",
            "text",
            "utils",
            "equals",
            "char",
            "sequence",
            "char",
            "sequence",
            "because",
            "the",
            "latter",
            "only",
            "checks",
            "the",
            "text",
            "of",
            "each",
            "sequence",
            "and",
            "does",
            "not",
            "check",
            "for",
            "equality",
            "of",
            "styling",
            "that",
            "may",
            "be",
            "embedded",
            "within",
            "the",
            "char",
            "sequence",
            "s"
        ]
    },
    {
        "id": 2643,
        "code": "public void setCues(@Nullable List<Cue> cues) {\n  this.cues = (cues != null ? cues : Collections.emptyList());\n  updateOutput();\n}",
        "summary_tokens": [
            "sets",
            "the",
            "cues",
            "to",
            "be",
            "displayed",
            "by",
            "the",
            "view"
        ]
    },
    {
        "id": 2644,
        "code": "public void setViewType(@ViewType int viewType) {\n  if (this.viewType == viewType) {\n    return;\n  }\n  switch (viewType) {\n    case VIEW_TYPE_CANVAS:\n      setView(new CanvasSubtitleOutput(getContext()));\n      break;\n    case VIEW_TYPE_WEB:\n      setView(new WebViewSubtitleOutput(getContext()));\n      break;\n    default:\n      throw new IllegalArgumentException();\n  }\n  this.viewType = viewType;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "type",
            "of",
            "view",
            "used",
            "to",
            "display",
            "subtitles"
        ]
    },
    {
        "id": 2645,
        "code": "public void setFixedTextSize(@Dimension int unit, float size) {\n  Context context = getContext();\n  Resources resources;\n  if (context == null) {\n    resources = Resources.getSystem();\n  } else {\n    resources = context.getResources();\n  }\n  setTextSize(\n      Cue.TEXT_SIZE_TYPE_ABSOLUTE,\n      TypedValue.applyDimension(unit, size, resources.getDisplayMetrics()));\n}",
        "summary_tokens": [
            "sets",
            "the",
            "text",
            "size",
            "to",
            "a",
            "given",
            "unit",
            "and",
            "value"
        ]
    },
    {
        "id": 2646,
        "code": "public void setUserDefaultTextSize() {\n  setFractionalTextSize(DEFAULT_TEXT_SIZE_FRACTION * getUserCaptionFontScale());\n}",
        "summary_tokens": [
            "sets",
            "the",
            "text",
            "size",
            "based",
            "on",
            "captioning",
            "manager",
            "get",
            "font",
            "scale",
            "if",
            "captioning",
            "manager",
            "is",
            "available",
            "and",
            "enabled"
        ]
    },
    {
        "id": 2647,
        "code": "public void setFractionalTextSize(float fractionOfHeight, boolean ignorePadding) {\n  setTextSize(\n      ignorePadding\n          ? Cue.TEXT_SIZE_TYPE_FRACTIONAL_IGNORE_PADDING\n          : Cue.TEXT_SIZE_TYPE_FRACTIONAL,\n      fractionOfHeight);\n}",
        "summary_tokens": [
            "sets",
            "the",
            "text",
            "size",
            "to",
            "be",
            "a",
            "fraction",
            "of",
            "the",
            "height",
            "of",
            "this",
            "view"
        ]
    },
    {
        "id": 2648,
        "code": "public void setApplyEmbeddedStyles(boolean applyEmbeddedStyles) {\n  this.applyEmbeddedStyles = applyEmbeddedStyles;\n  updateOutput();\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "styling",
            "embedded",
            "within",
            "the",
            "cues",
            "should",
            "be",
            "applied"
        ]
    },
    {
        "id": 2649,
        "code": "public void setApplyEmbeddedFontSizes(boolean applyEmbeddedFontSizes) {\n  this.applyEmbeddedFontSizes = applyEmbeddedFontSizes;\n  updateOutput();\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "font",
            "sizes",
            "embedded",
            "within",
            "the",
            "cues",
            "should",
            "be",
            "applied"
        ]
    },
    {
        "id": 2650,
        "code": "public void setUserDefaultStyle() {\n  setStyle(getUserCaptionStyle());\n}",
        "summary_tokens": [
            "styles",
            "the",
            "captions",
            "using",
            "captioning",
            "manager",
            "get",
            "user",
            "style",
            "if",
            "captioning",
            "manager",
            "is",
            "available",
            "and",
            "enabled"
        ]
    },
    {
        "id": 2651,
        "code": "public void setStyle(CaptionStyleCompat style) {\n  this.style = style;\n  updateOutput();\n}",
        "summary_tokens": [
            "sets",
            "the",
            "caption",
            "style"
        ]
    },
    {
        "id": 2652,
        "code": "public void setBottomPaddingFraction(float bottomPaddingFraction) {\n  this.bottomPaddingFraction = bottomPaddingFraction;\n  updateOutput();\n}",
        "summary_tokens": [
            "sets",
            "the",
            "bottom",
            "padding",
            "fraction",
            "to",
            "apply",
            "when",
            "cue",
            "line",
            "is",
            "cue",
            "dimen",
            "unset",
            "as",
            "a",
            "fraction",
            "of",
            "the",
            "view",
            "s",
            "remaining",
            "height",
            "after",
            "its",
            "top",
            "and",
            "bottom",
            "padding",
            "have",
            "been",
            "subtracted"
        ]
    },
    {
        "id": 2653,
        "code": "private List<Cue> getCuesWithStylingPreferencesApplied() {\n  if (applyEmbeddedStyles && applyEmbeddedFontSizes) {\n    return cues;\n  }\n  List<Cue> strippedCues = new ArrayList<>(cues.size());\n  for (int i = 0; i < cues.size(); i++) {\n    strippedCues.add(removeEmbeddedStyling(cues.get(i)));\n  }\n  return strippedCues;\n}",
        "summary_tokens": [
            "returns",
            "cues",
            "with",
            "apply",
            "embedded",
            "styles",
            "and",
            "apply",
            "embedded",
            "font",
            "sizes",
            "applied"
        ]
    },
    {
        "id": 2654,
        "code": "public static float resolveTextSize(\n    @Cue.TextSizeType int textSizeType,\n    float textSize,\n    int rawViewHeight,\n    int viewHeightMinusPadding) {\n  if (textSize == Cue.DIMEN_UNSET) {\n    return Cue.DIMEN_UNSET;\n  }\n  switch (textSizeType) {\n    case Cue.TEXT_SIZE_TYPE_ABSOLUTE:\n      return textSize;\n    case Cue.TEXT_SIZE_TYPE_FRACTIONAL:\n      return textSize * viewHeightMinusPadding;\n    case Cue.TEXT_SIZE_TYPE_FRACTIONAL_IGNORE_PADDING:\n      return textSize * rawViewHeight;\n    case Cue.TYPE_UNSET:\n    default:\n      return Cue.DIMEN_UNSET;\n  }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "text",
            "size",
            "in",
            "px",
            "derived",
            "from",
            "text",
            "size",
            "and",
            "text",
            "size",
            "type"
        ]
    },
    {
        "id": 2655,
        "code": "public static void removeAllEmbeddedStyling(Cue.Builder cue) {\n  cue.clearWindowColor();\n  if (cue.getText() instanceof Spanned) {\n    if (!(cue.getText() instanceof Spannable)) {\n      cue.setText(SpannableString.valueOf(cue.getText()));\n    }\n    removeSpansIf(\n        (Spannable) checkNotNull(cue.getText()), span -> !(span instanceof LanguageFeatureSpan));\n  }\n  removeEmbeddedFontSizes(cue);\n}",
        "summary_tokens": [
            "removes",
            "all",
            "styling",
            "information",
            "from",
            "cue"
        ]
    },
    {
        "id": 2656,
        "code": "public static void removeEmbeddedFontSizes(Cue.Builder cue) {\n  cue.setTextSize(Cue.DIMEN_UNSET, Cue.TYPE_UNSET);\n  if (cue.getText() instanceof Spanned) {\n    if (!(cue.getText() instanceof Spannable)) {\n      cue.setText(SpannableString.valueOf(cue.getText()));\n    }\n    removeSpansIf(\n        (Spannable) checkNotNull(cue.getText()),\n        span -> span instanceof AbsoluteSizeSpan || span instanceof RelativeSizeSpan);\n  }\n}",
        "summary_tokens": [
            "removes",
            "all",
            "font",
            "size",
            "information",
            "from",
            "cue"
        ]
    },
    {
        "id": 2657,
        "code": "public TrackSelectionDialogBuilder setTheme(@StyleRes int themeResId) {\n  this.themeResId = themeResId;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "resource",
            "id",
            "of",
            "the",
            "theme",
            "used",
            "to",
            "inflate",
            "this",
            "dialog"
        ]
    },
    {
        "id": 2658,
        "code": "public TrackSelectionDialogBuilder setIsDisabled(boolean isDisabled) {\n  this.isDisabled = isDisabled;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "selection",
            "is",
            "initially",
            "shown",
            "as",
            "disabled"
        ]
    },
    {
        "id": 2659,
        "code": "public TrackSelectionDialogBuilder setOverride(@Nullable TrackSelectionOverride override) {\n  return setOverrides(\n      override == null\n          ? Collections.emptyMap()\n          : ImmutableMap.of(override.mediaTrackGroup, override));\n}",
        "summary_tokens": [
            "sets",
            "the",
            "single",
            "initial",
            "override"
        ]
    },
    {
        "id": 2660,
        "code": "public TrackSelectionDialogBuilder setOverrides(\n    Map<TrackGroup, TrackSelectionOverride> overrides) {\n  this.overrides = overrides;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "initial",
            "track",
            "overrides"
        ]
    },
    {
        "id": 2661,
        "code": "public TrackSelectionDialogBuilder setAllowAdaptiveSelections(boolean allowAdaptiveSelections) {\n  this.allowAdaptiveSelections = allowAdaptiveSelections;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "adaptive",
            "selections",
            "consisting",
            "of",
            "more",
            "than",
            "one",
            "track",
            "can",
            "be",
            "made"
        ]
    },
    {
        "id": 2662,
        "code": "public TrackSelectionDialogBuilder setAllowMultipleOverrides(boolean allowMultipleOverrides) {\n  this.allowMultipleOverrides = allowMultipleOverrides;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "multiple",
            "overrides",
            "can",
            "be",
            "set",
            "and",
            "selected",
            "i"
        ]
    },
    {
        "id": 2663,
        "code": "public TrackSelectionDialogBuilder setShowDisableOption(boolean showDisableOption) {\n  this.showDisableOption = showDisableOption;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "an",
            "option",
            "is",
            "available",
            "for",
            "disabling",
            "the",
            "renderer"
        ]
    },
    {
        "id": 2664,
        "code": "public void setTrackFormatComparator(@Nullable Comparator<Format> trackFormatComparator) {\n  this.trackFormatComparator = trackFormatComparator;\n}",
        "summary_tokens": [
            "sets",
            "a",
            "comparator",
            "used",
            "to",
            "determine",
            "the",
            "display",
            "order",
            "of",
            "the",
            "tracks",
            "within",
            "each",
            "track",
            "group"
        ]
    },
    {
        "id": 2665,
        "code": "public TrackSelectionDialogBuilder setTrackNameProvider(\n    @Nullable TrackNameProvider trackNameProvider) {\n  this.trackNameProvider = trackNameProvider;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "track",
            "name",
            "provider",
            "used",
            "to",
            "generate",
            "the",
            "user",
            "visible",
            "name",
            "of",
            "each",
            "track",
            "and",
            "updates",
            "the",
            "view",
            "with",
            "track",
            "names",
            "queried",
            "from",
            "the",
            "specified",
            "provider"
        ]
    },
    {
        "id": 2666,
        "code": "public static Map<TrackGroup, TrackSelectionOverride> filterOverrides(\n    Map<TrackGroup, TrackSelectionOverride> overrides,\n    List<Tracks.Group> trackGroups,\n    boolean allowMultipleOverrides) {\n  HashMap<TrackGroup, TrackSelectionOverride> filteredOverrides = new HashMap<>();\n  for (int i = 0; i < trackGroups.size(); i++) {\n    Tracks.Group trackGroup = trackGroups.get(i);\n    @Nullable TrackSelectionOverride override = overrides.get(trackGroup.getMediaTrackGroup());\n    if (override != null && (allowMultipleOverrides || filteredOverrides.isEmpty())) {\n      filteredOverrides.put(override.mediaTrackGroup, override);\n    }\n  }\n  return filteredOverrides;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "subset",
            "of",
            "overrides",
            "that",
            "apply",
            "to",
            "the",
            "specified",
            "track",
            "groups"
        ]
    },
    {
        "id": 2667,
        "code": "public void setAllowAdaptiveSelections(boolean allowAdaptiveSelections) {\n  if (this.allowAdaptiveSelections != allowAdaptiveSelections) {\n    this.allowAdaptiveSelections = allowAdaptiveSelections;\n    updateViews();\n  }\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "adaptive",
            "selections",
            "consisting",
            "of",
            "more",
            "than",
            "one",
            "track",
            "can",
            "be",
            "made",
            "using",
            "this",
            "selection",
            "view"
        ]
    },
    {
        "id": 2668,
        "code": "public void setAllowMultipleOverrides(boolean allowMultipleOverrides) {\n  if (this.allowMultipleOverrides != allowMultipleOverrides) {\n    this.allowMultipleOverrides = allowMultipleOverrides;\n    if (!allowMultipleOverrides && overrides.size() > 1) {\n        \n      Map<TrackGroup, TrackSelectionOverride> filteredOverrides =\n          filterOverrides(overrides, trackGroups,  false);\n      overrides.clear();\n      overrides.putAll(filteredOverrides);\n    }\n    updateViews();\n  }\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "tracks",
            "from",
            "multiple",
            "track",
            "groups",
            "can",
            "be",
            "selected"
        ]
    },
    {
        "id": 2669,
        "code": "public void setShowDisableOption(boolean showDisableOption) {\n  disableView.setVisibility(showDisableOption ? View.VISIBLE : View.GONE);\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "disabled",
            "option",
            "can",
            "be",
            "selected"
        ]
    },
    {
        "id": 2670,
        "code": "public void setTrackNameProvider(TrackNameProvider trackNameProvider) {\n  this.trackNameProvider = Assertions.checkNotNull(trackNameProvider);\n  updateViews();\n}",
        "summary_tokens": [
            "sets",
            "the",
            "track",
            "name",
            "provider",
            "used",
            "to",
            "generate",
            "the",
            "user",
            "visible",
            "name",
            "of",
            "each",
            "track",
            "and",
            "updates",
            "the",
            "view",
            "with",
            "track",
            "names",
            "queried",
            "from",
            "the",
            "specified",
            "provider"
        ]
    },
    {
        "id": 2671,
        "code": "public void init(\n    List<Tracks.Group> trackGroups,\n    boolean isDisabled,\n    Map<TrackGroup, TrackSelectionOverride> overrides,\n    @Nullable Comparator<Format> trackFormatComparator,\n    @Nullable TrackSelectionListener listener) {\n  this.isDisabled = isDisabled;\n  this.trackInfoComparator =\n      trackFormatComparator == null\n          ? null\n          : (o1, o2) -> trackFormatComparator.compare(o1.getFormat(), o2.getFormat());\n  this.listener = listener;\n\n  this.trackGroups.clear();\n  this.trackGroups.addAll(trackGroups);\n  this.overrides.clear();\n  this.overrides.putAll(filterOverrides(overrides, trackGroups, allowMultipleOverrides));\n  updateViews();\n}",
        "summary_tokens": [
            "initialize",
            "the",
            "view",
            "to",
            "select",
            "tracks",
            "from",
            "a",
            "specified",
            "list",
            "of",
            "track",
            "groups"
        ]
    },
    {
        "id": 2672,
        "code": "public boolean getIsDisabled() {\n  return isDisabled;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "disabled",
            "option",
            "is",
            "selected"
        ]
    },
    {
        "id": 2673,
        "code": "public Map<TrackGroup, TrackSelectionOverride> getOverrides() {\n  return overrides;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "selected",
            "track",
            "overrides"
        ]
    },
    {
        "id": 2674,
        "code": "public void destroy() {\n  webView.destroy();\n}",
        "summary_tokens": [
            "cleans",
            "up",
            "internal",
            "state",
            "including",
            "calling",
            "web",
            "view",
            "destroy",
            "on",
            "the",
            "delegate",
            "view"
        ]
    },
    {
        "id": 2675,
        "code": "private String convertTextSizeToCss(@Cue.TextSizeType int type, float size) {\n  float sizePx =\n      SubtitleViewUtils.resolveTextSize(\n          type, size, getHeight(), getHeight() - getPaddingTop() - getPaddingBottom());\n  if (sizePx == Cue.DIMEN_UNSET) {\n    return \"unset\";\n  }\n  float sizeDp = sizePx / getContext().getResources().getDisplayMetrics().density;\n  return Util.formatInvariant(\"%.2fpx\", sizeDp);\n}",
        "summary_tokens": [
            "converts",
            "a",
            "text",
            "size",
            "to",
            "a",
            "css",
            "px",
            "value"
        ]
    },
    {
        "id": 2676,
        "code": "private static boolean shouldSkipDroppedOutputBufferPerformanceAssertions() {\n  return false;\n}",
        "summary_tokens": [
            "provides",
            "a",
            "hook",
            "to",
            "skip",
            "dropped",
            "output",
            "buffer",
            "assertions",
            "in",
            "specific",
            "circumstances"
        ]
    },
    {
        "id": 2677,
        "code": "public static boolean shouldSkipWidevineTest(Context context) {\n  if (Util.SDK_INT < 18) {\n      \n    return true;\n  }\n  if (isGmsInstalled(context)) {\n      \n    return false;\n  }\n    \n  return !MediaDrm.isCryptoSchemeSupported(WIDEVINE_UUID);\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "the",
            "device",
            "doesn",
            "t",
            "support",
            "widevine",
            "and",
            "this",
            "is",
            "permitted"
        ]
    },
    {
        "id": 2678,
        "code": "public static PlaybackOutput register(\n    ExoPlayer player, CapturingRenderersFactory capturingRenderersFactory) {\n  return new PlaybackOutput(player, capturingRenderersFactory);\n}",
        "summary_tokens": [
            "create",
            "an",
            "instance",
            "that",
            "captures",
            "the",
            "metadata",
            "and",
            "text",
            "output",
            "from",
            "player",
            "and",
            "the",
            "audio",
            "and",
            "video",
            "output",
            "via",
            "capturing",
            "renderers",
            "factory"
        ]
    },
    {
        "id": 2679,
        "code": "public ImmutableList<byte[]> getAllOutputBytes() {\n  return ImmutableList.copyOf(decoderOutput);\n}",
        "summary_tokens": [
            "returns",
            "all",
            "arrays",
            "of",
            "bytes",
            "output",
            "from",
            "the",
            "decoder"
        ]
    },
    {
        "id": 2680,
        "code": "public static ConditionVariable createRobolectricConditionVariable() {\n  return new ConditionVariable(\n      new SystemClock() {\n        @Override\n        public long elapsedRealtime() {\n            \n            \n            \n            \n          return Clock.DEFAULT.currentTimeMillis();\n        }\n      });\n}",
        "summary_tokens": [
            "creates",
            "a",
            "condition",
            "variable",
            "whose",
            "condition",
            "variable",
            "block",
            "long",
            "method",
            "times",
            "out",
            "according",
            "to",
            "wallclock",
            "time",
            "when",
            "used",
            "in",
            "robolectric",
            "tests"
        ]
    },
    {
        "id": 2681,
        "code": "public static void runMainLooperUntil(Supplier<Boolean> condition, long timeoutMs, Clock clock)\n    throws TimeoutException {\n  runLooperUntil(Looper.getMainLooper(), condition, timeoutMs, clock);\n}",
        "summary_tokens": [
            "runs",
            "tasks",
            "of",
            "the",
            "main",
            "robolectric",
            "looper",
            "until",
            "the",
            "condition",
            "returns",
            "true"
        ]
    },
    {
        "id": 2682,
        "code": "public static void runLooperUntil(\n    Looper looper, Supplier<Boolean> condition, long timeoutMs, Clock clock)\n    throws TimeoutException {\n  if (Looper.myLooper() != looper) {\n    throw new IllegalStateException();\n  }\n  ShadowLooper shadowLooper = shadowOf(looper);\n  long timeoutTimeMs = clock.currentTimeMillis() + timeoutMs;\n  while (!condition.get()) {\n    if (clock.currentTimeMillis() >= timeoutTimeMs) {\n      throw new TimeoutException();\n    }\n    shadowLooper.runOneTask();\n  }\n}",
        "summary_tokens": [
            "runs",
            "tasks",
            "of",
            "the",
            "looper",
            "until",
            "the",
            "condition",
            "returns",
            "true"
        ]
    },
    {
        "id": 2683,
        "code": "public void blockUntilInitialized() throws InterruptedException {\n  assertThat(initializedCondition.block(TIMEOUT_MS)).isTrue();\n}",
        "summary_tokens": [
            "blocks",
            "until",
            "the",
            "manager",
            "is",
            "initialized"
        ]
    },
    {
        "id": 2684,
        "code": "public void blockUntilIdle() throws InterruptedException {\n  idleCondition.close();\n    \n    \n  ConditionVariable checkedOnMainThread = createRobolectricConditionVariable();\n  new Handler(downloadManager.getApplicationLooper())\n      .post(\n          () -> {\n            if (downloadManager.isIdle()) {\n              idleCondition.open();\n            }\n            checkedOnMainThread.open();\n          });\n  assertThat(checkedOnMainThread.block(TIMEOUT_MS)).isTrue();\n  assertThat(idleCondition.block(TIMEOUT_MS)).isTrue();\n}",
        "summary_tokens": [
            "blocks",
            "until",
            "the",
            "manager",
            "is",
            "idle"
        ]
    },
    {
        "id": 2685,
        "code": "public void blockUntilIdleAndThrowAnyFailure() throws Exception {\n  blockUntilIdle();\n  if (failureReason != Download.FAILURE_REASON_NONE) {\n    throw new Exception(\"Failure reason: \" + failureReason);\n  }\n}",
        "summary_tokens": [
            "blocks",
            "until",
            "the",
            "manager",
            "is",
            "idle",
            "and",
            "throws",
            "if",
            "any",
            "of",
            "the",
            "downloads",
            "failed"
        ]
    },
    {
        "id": 2686,
        "code": "public void assertState(String id, @Download.State int state) {\n  assertStateInternal(id, state);\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "the",
            "specified",
            "download",
            "transitions",
            "to",
            "the",
            "specified",
            "state"
        ]
    },
    {
        "id": 2687,
        "code": "public void assertRemoved(String id) {\n  assertStateInternal(id, STATE_REMOVED);\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "the",
            "specified",
            "download",
            "is",
            "removed"
        ]
    },
    {
        "id": 2688,
        "code": "public final void doActionAndScheduleNext(\n    ExoPlayer player,\n    DefaultTrackSelector trackSelector,\n    @Nullable Surface surface,\n    HandlerWrapper handler,\n    @Nullable ActionNode nextAction) {\n  if (description != null) {\n    Log.i(tag, description);\n  }\n  doActionAndScheduleNextImpl(player, trackSelector, surface, handler, nextAction);\n}",
        "summary_tokens": [
            "executes",
            "the",
            "action",
            "and",
            "schedules",
            "the",
            "next"
        ]
    },
    {
        "id": 2689,
        "code": "protected void doActionAndScheduleNextImpl(\n    ExoPlayer player,\n    DefaultTrackSelector trackSelector,\n    @Nullable Surface surface,\n    HandlerWrapper handler,\n    @Nullable ActionNode nextAction) {\n  doActionImpl(player, trackSelector, surface);\n  if (nextAction != null) {\n    nextAction.schedule(player, trackSelector, surface, handler);\n  }\n}",
        "summary_tokens": [
            "called",
            "by",
            "do",
            "action",
            "and",
            "schedule",
            "next",
            "exo",
            "player",
            "default",
            "track",
            "selector",
            "surface",
            "handler",
            "wrapper",
            "action",
            "node",
            "to",
            "perform",
            "the",
            "action",
            "and",
            "to",
            "schedule",
            "the",
            "next",
            "action",
            "node"
        ]
    },
    {
        "id": 2690,
        "code": " void start(\n    ExoPlayer player,\n    DefaultTrackSelector trackSelector,\n    @Nullable Surface surface,\n    HandlerWrapper mainHandler,\n    @Nullable Callback callback) {\n  callbackAction.setCallback(callback);\n  rootNode.schedule(player, trackSelector, surface, mainHandler);\n}",
        "summary_tokens": [
            "starts",
            "execution",
            "of",
            "the",
            "schedule"
        ]
    },
    {
        "id": 2691,
        "code": "public static void assertCachedData(Cache cache, FakeDataSet fakeDataSet) throws IOException {\n  assertCachedData(cache, new RequestSet(fakeDataSet));\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "the",
            "cache",
            "content",
            "is",
            "equal",
            "to",
            "the",
            "data",
            "in",
            "the",
            "fake",
            "data",
            "set"
        ]
    },
    {
        "id": 2692,
        "code": "public static void assertDataCached(Cache cache, DataSpec dataSpec, byte[] expected)\n    throws IOException {\n  DataSource dataSource = new CacheDataSource(cache, PlaceholderDataSource.INSTANCE, 0);\n  byte[] bytes;\n  try {\n    dataSource.open(dataSpec);\n    bytes = DataSourceUtil.readToEnd(dataSource);\n  } catch (IOException e) {\n    throw new IOException(\"Opening/reading cache failed: \" + dataSpec, e);\n  } finally {\n    dataSource.close();\n  }\n  assertWithMessage(\"Cached data doesn't match expected for '\" + dataSpec.uri + \"',\")\n      .that(bytes)\n      .isEqualTo(expected);\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "the",
            "cache",
            "contains",
            "the",
            "given",
            "data",
            "for",
            "data",
            "spec"
        ]
    },
    {
        "id": 2693,
        "code": "public static void assertReadData(DataSource dataSource, DataSpec dataSpec, byte[] expected)\n    throws IOException {\n  try (DataSourceInputStream inputStream = new DataSourceInputStream(dataSource, dataSpec)) {\n    byte[] bytes = Util.toByteArray(inputStream);\n    assertThat(bytes).isEqualTo(expected);\n  }\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "the",
            "read",
            "data",
            "from",
            "data",
            "source",
            "specified",
            "by",
            "data",
            "spec",
            "is",
            "equal",
            "to",
            "expected",
            "or",
            "not"
        ]
    },
    {
        "id": 2694,
        "code": "public static void assertCacheEmpty(Cache cache) {\n  assertThat(cache.getCacheSpace()).isEqualTo(0);\n  assertThat(cache.getKeys()).isEmpty();\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "the",
            "cache",
            "is",
            "empty"
        ]
    },
    {
        "id": 2695,
        "code": "public static int getTotalBufferCount(DecoderCounters counters) {\n  counters.ensureUpdated();\n  return counters.skippedInputBufferCount\n      + counters.skippedOutputBufferCount\n      + counters.droppedBufferCount\n      + counters.renderedOutputBufferCount;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "sum",
            "of",
            "the",
            "skipped",
            "dropped",
            "and",
            "rendered",
            "buffers"
        ]
    },
    {
        "id": 2696,
        "code": "public static void assertTotalBufferCount(String name, DecoderCounters counters) {\n    \n    \n  int totalInputBufferCount =\n      counters.skippedInputBufferCount\n          + counters.droppedInputBufferCount\n          + counters.queuedInputBufferCount;\n  assertTotalBufferCount(\n      name,\n      counters,\n       totalInputBufferCount - 1,\n       totalInputBufferCount);\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "the",
            "input",
            "and",
            "output",
            "values",
            "in",
            "counters",
            "are",
            "self",
            "consistent"
        ]
    },
    {
        "id": 2697,
        "code": "public static void assertExtensionRendererCreated(\n    Class<? extends Renderer> clazz, @C.TrackType int type) {\n    \n  Renderer[] renderers = createRenderers(EXTENSION_RENDERER_MODE_OFF);\n  for (Renderer renderer : renderers) {\n    assertThat(renderer).isNotInstanceOf(clazz);\n  }\n\n    \n  renderers = createRenderers(EXTENSION_RENDERER_MODE_ON);\n  boolean found = false;\n  for (Renderer renderer : renderers) {\n    if (!found) {\n      if (clazz.isInstance(renderer)) {\n        found = true;\n      }\n    } else {\n      assertThat(renderer.getTrackType()).isNotEqualTo(type);\n    }\n  }\n  assertThat(found).isTrue();\n\n    \n  renderers = createRenderers(EXTENSION_RENDERER_MODE_PREFER);\n  found = false;\n  for (Renderer renderer : renderers) {\n    if (!found) {\n      if (clazz.isInstance(renderer)) {\n        found = true;\n      } else {\n        assertThat(renderer.getTrackType()).isNotEqualTo(type);\n      }\n    } else {\n      assertThat(renderer).isNotInstanceOf(clazz);\n    }\n  }\n  assertThat(found).isTrue();\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "an",
            "extension",
            "renderer",
            "of",
            "type",
            "clazz",
            "is",
            "not",
            "instantiated",
            "for",
            "default",
            "renderers",
            "factory",
            "extension",
            "renderer",
            "mode",
            "off",
            "and",
            "that",
            "it",
            "s",
            "instantiated",
            "in",
            "the",
            "correct",
            "position",
            "relative",
            "to",
            "other",
            "renderers",
            "of",
            "the",
            "same",
            "type",
            "for",
            "default",
            "renderers",
            "factory",
            "extension",
            "renderer",
            "mode",
            "on",
            "and",
            "default",
            "renderers",
            "factory",
            "extension",
            "renderer",
            "mode",
            "prefer",
            "assuming",
            "no",
            "other",
            "extension",
            "renderers",
            "can",
            "be",
            "loaded"
        ]
    },
    {
        "id": 2698,
        "code": "public void runOnMainThread(int timeoutMs, final Runnable runnable) {\n  runTestOnMainThread(timeoutMs, runnable::run);\n}",
        "summary_tokens": [
            "runs",
            "the",
            "provided",
            "runnable",
            "on",
            "the",
            "main",
            "thread",
            "blocking",
            "until",
            "execution",
            "completes",
            "or",
            "until",
            "timeout",
            "milliseconds",
            "have",
            "passed"
        ]
    },
    {
        "id": 2699,
        "code": "public void runTestOnMainThread(int timeoutMs, final TestRunnable runnable) {\n  if (Looper.myLooper() == handler.getLooper()) {\n    try {\n      runnable.run();\n    } catch (Exception e) {\n      Util.sneakyThrow(e);\n    }\n  } else {\n    CountDownLatch finishedLatch = new CountDownLatch(1);\n    AtomicReference<Throwable> thrown = new AtomicReference<>();\n    handler.post(\n        () -> {\n          try {\n            runnable.run();\n          } catch (Throwable t) {\n            thrown.set(t);\n          }\n          finishedLatch.countDown();\n        });\n    try {\n      assertThat(finishedLatch.await(timeoutMs, MILLISECONDS)).isTrue();\n    } catch (InterruptedException e) {\n      Util.sneakyThrow(e);\n    }\n    if (thrown.get() != null) {\n      Util.sneakyThrow(thrown.get());\n    }\n  }\n}",
        "summary_tokens": [
            "runs",
            "the",
            "provided",
            "test",
            "runnable",
            "on",
            "the",
            "main",
            "thread",
            "blocking",
            "until",
            "execution",
            "completes",
            "or",
            "until",
            "timeout",
            "milliseconds",
            "have",
            "passed"
        ]
    },
    {
        "id": 2700,
        "code": "public static void assertOutput(\n    Context context, String actual, String assetDirectory, String dumpFile) throws IOException {\n  if (DUMP_FILE_ACTION == COMPARE_WITH_EXISTING) {\n    String expected;\n    try {\n      expected = TestUtil.getString(context, dumpFile);\n    } catch (FileNotFoundException e) {\n      throw new IOException(\"Dump file not found. \" + DUMP_UPDATE_INSTRUCTIONS, e);\n    }\n    assertWithMessage(\n            \"Actual data doesn't match dump file: %s\\n%s\", dumpFile, DUMP_UPDATE_INSTRUCTIONS)\n        .that(actual)\n        .isEqualTo(expected);\n  } else {\n    File file =\n        DUMP_FILE_ACTION == WRITE_TO_LOCAL\n            ? new File(StandardSystemProperty.USER_DIR.value(), assetDirectory)\n            : context.getExternalFilesDir(null);\n    file = new File(file, dumpFile);\n    Assertions.checkStateNotNull(file.getParentFile()).mkdirs();\n    PrintWriter out = new PrintWriter(file);\n    out.print(actual);\n    out.close();\n  }\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "actual",
            "is",
            "equal",
            "to",
            "the",
            "contents",
            "of",
            "dump",
            "file",
            "in",
            "asset",
            "directory"
        ]
    },
    {
        "id": 2701,
        "code": "public final void setSchedule(ActionSchedule schedule) {\n  if (!isStarted()) {\n    pendingSchedule = schedule;\n  } else {\n    schedule.start(player, trackSelector, surface, actionHandler,  null);\n  }\n}",
        "summary_tokens": [
            "sets",
            "a",
            "schedule",
            "to",
            "be",
            "applied",
            "during",
            "the",
            "test"
        ]
    },
    {
        "id": 2702,
        "code": "public ExoPlayerTestRunner start(boolean doPrepare) {\n  handler.post(\n      () -> {\n        try {\n          player = playerBuilder.setLooper(Looper.myLooper()).build();\n          if (surface != null) {\n            player.setVideoSurface(surface);\n          }\n          if (pauseAtEndOfMediaItems) {\n            player.setPauseAtEndOfMediaItems(true);\n          }\n          player.addListener(ExoPlayerTestRunner.this);\n          if (playerListener != null) {\n            player.addListener(playerListener);\n          }\n          if (analyticsListener != null) {\n            player.addAnalyticsListener(analyticsListener);\n          }\n          player.play();\n          if (actionSchedule != null) {\n            actionSchedule.start(\n                player,\n                playerBuilder.getTrackSelector(),\n                surface,\n                handler,\n                 ExoPlayerTestRunner.this);\n          }\n          if (initialMediaItemIndex != C.INDEX_UNSET) {\n            player.seekTo(initialMediaItemIndex, initialPositionMs);\n          }\n          if (!skipSettingMediaSources) {\n            player.setMediaSources(mediaSources,  false);\n          }\n          if (doPrepare) {\n            player.prepare();\n          }\n        } catch (Exception e) {\n          handleException(e);\n        }\n      });\n  return this;\n}",
        "summary_tokens": [
            "starts",
            "the",
            "test",
            "runner",
            "on",
            "its",
            "own",
            "thread"
        ]
    },
    {
        "id": 2703,
        "code": "public ExoPlayerTestRunner blockUntilEnded(long timeoutMs) throws Exception {\n  clock.onThreadBlocked();\n  if (!endedCountDownLatch.await(timeoutMs, MILLISECONDS)) {\n    exception = new TimeoutException(\"Test playback timed out waiting for playback to end.\");\n  }\n  release();\n    \n  if (exception != null) {\n    throw exception;\n  }\n  return this;\n}",
        "summary_tokens": [
            "blocks",
            "the",
            "current",
            "thread",
            "until",
            "the",
            "test",
            "runner",
            "finishes"
        ]
    },
    {
        "id": 2704,
        "code": "public ExoPlayerTestRunner blockUntilActionScheduleFinished(long timeoutMs)\n    throws TimeoutException, InterruptedException {\n  clock.onThreadBlocked();\n  if (!actionScheduleFinishedCountDownLatch.await(timeoutMs, MILLISECONDS)) {\n    throw new TimeoutException(\"Test playback timed out waiting for action schedule to finish.\");\n  }\n  return this;\n}",
        "summary_tokens": [
            "blocks",
            "the",
            "current",
            "thread",
            "until",
            "the",
            "action",
            "schedule",
            "finished"
        ]
    },
    {
        "id": 2705,
        "code": "public void assertTimelinesSame(Timeline... timelines) {\n  TestUtil.assertTimelinesSame(\n      ImmutableList.copyOf(this.timelines), ImmutableList.copyOf(timelines));\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "the",
            "timelines",
            "reported",
            "by",
            "player"
        ]
    },
    {
        "id": 2706,
        "code": "public void assertTimelineChangeReasonsEqual(Integer... reasons) {\n  assertThat(timelineChangeReasons).containsExactlyElementsIn(Arrays.asList(reasons)).inOrder();\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "the",
            "timeline",
            "change",
            "reasons",
            "reported",
            "by",
            "player"
        ]
    },
    {
        "id": 2707,
        "code": "public void assertPlaybackStatesEqual(Integer... states) {\n  assertThat(playbackStates).containsExactlyElementsIn(states).inOrder();\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "the",
            "playback",
            "states",
            "reported",
            "by",
            "player"
        ]
    },
    {
        "id": 2708,
        "code": "public void assertPositionDiscontinuityReasonsEqual(Integer... discontinuityReasons) {\n  assertThat(this.discontinuityReasons)\n      .containsExactlyElementsIn(Arrays.asList(discontinuityReasons))\n      .inOrder();\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "the",
            "discontinuity",
            "reasons",
            "reported",
            "by",
            "player"
        ]
    },
    {
        "id": 2709,
        "code": "public void assertPlayedPeriodIndices(Integer... periodIndices) {\n  assertThat(this.periodIndices)\n      .containsExactlyElementsIn(Arrays.asList(periodIndices))\n      .inOrder();\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "the",
            "indices",
            "of",
            "played",
            "periods",
            "is",
            "equal",
            "to",
            "the",
            "provided",
            "list",
            "of",
            "periods"
        ]
    },
    {
        "id": 2710,
        "code": "public static ImmutableList<SimulationConfig> configs() {\n  return ImmutableList.of(\n      new SimulationConfig(true, false, false, false),\n      new SimulationConfig(true, false, false, true),\n      new SimulationConfig(true, false, true, false),\n      new SimulationConfig(true, false, true, true),\n      new SimulationConfig(true, true, false, false),\n      new SimulationConfig(true, true, false, true),\n      new SimulationConfig(true, true, true, false),\n      new SimulationConfig(true, true, true, true),\n      new SimulationConfig(false, false, false, false));\n}",
        "summary_tokens": [
            "returns",
            "a",
            "list",
            "of",
            "arrays",
            "containing",
            "simulation",
            "config",
            "objects",
            "to",
            "exercise",
            "different",
            "extractor",
            "paths"
        ]
    },
    {
        "id": 2711,
        "code": "public static List<Object[]> configsNoSniffing() {\n  return Arrays.asList(\n      new Object[] {new SimulationConfig(false, false, false, false)},\n      new Object[] {new SimulationConfig(false, false, false, true)},\n      new Object[] {new SimulationConfig(false, false, true, false)},\n      new Object[] {new SimulationConfig(false, false, true, true)},\n      new Object[] {new SimulationConfig(false, true, false, false)},\n      new Object[] {new SimulationConfig(false, true, false, true)},\n      new Object[] {new SimulationConfig(false, true, true, false)},\n      new Object[] {new SimulationConfig(false, true, true, true)});\n}",
        "summary_tokens": [
            "returns",
            "a",
            "list",
            "of",
            "arrays",
            "containing",
            "simulation",
            "config",
            "objects",
            "to",
            "exercise",
            "different",
            "extractor",
            "paths",
            "in",
            "which",
            "the",
            "input",
            "is",
            "not",
            "sniffed"
        ]
    },
    {
        "id": 2712,
        "code": "public static void assertSniff(\n    Extractor extractor, FakeExtractorInput input, boolean expectedResult) throws IOException {\n  long originalPosition = input.getPosition();\n  while (true) {\n    try {\n      assertThat(extractor.sniff(input)).isEqualTo(expectedResult);\n      if (!expectedResult) {\n        assertThat(input.getPosition()).isEqualTo(originalPosition);\n      }\n      return;\n    } catch (SimulatedIOException e) {\n        \n    }\n  }\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "extractor",
            "sniff",
            "extractor",
            "input",
            "returns",
            "the",
            "expected",
            "result",
            "for",
            "a",
            "given",
            "input",
            "retrying",
            "repeatedly",
            "when",
            "simulated",
            "ioexception",
            "is",
            "thrown"
        ]
    },
    {
        "id": 2713,
        "code": "public static void assertAllBehaviors(\n    ExtractorFactory factory, String file, String dumpFilesPrefix) throws IOException {\n    \n  Extractor extractor = factory.create();\n  extractor.seek(0, 0);\n  extractor.release();\n    \n  Context context = ApplicationProvider.getApplicationContext();\n  byte[] fileData = TestUtil.getByteArray(context, file);\n  assertOutput(\n      factory.create(), dumpFilesPrefix, fileData, context, false, true, false, false, false);\n  assertOutput(\n      factory.create(), dumpFilesPrefix, fileData, context, false, true, false, false, true);\n  assertOutput(\n      factory.create(), dumpFilesPrefix, fileData, context, false, true, false, true, false);\n  assertOutput(\n      factory.create(), dumpFilesPrefix, fileData, context, false, true, false, true, true);\n  assertOutput(\n      factory.create(), dumpFilesPrefix, fileData, context, false, true, true, false, false);\n  assertOutput(\n      factory.create(), dumpFilesPrefix, fileData, context, false, true, true, false, true);\n  assertOutput(\n      factory.create(), dumpFilesPrefix, fileData, context, false, true, true, true, false);\n  assertOutput(\n      factory.create(), dumpFilesPrefix, fileData, context, false, true, true, true, true);\n  assertOutput(\n      factory.create(), dumpFilesPrefix, fileData, context, false, false, false, false, false);\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "an",
            "extractor",
            "behaves",
            "correctly",
            "given",
            "valid",
            "input",
            "data"
        ]
    },
    {
        "id": 2714,
        "code": "public static void assertBehavior(\n    ExtractorFactory factory,\n    String file,\n    AssertionConfig assertionConfig,\n    SimulationConfig simulationConfig)\n    throws IOException {\n    \n  Extractor extractor = factory.create();\n  extractor.seek(0, 0);\n  extractor.release();\n    \n  Context context = ApplicationProvider.getApplicationContext();\n  byte[] fileData = TestUtil.getByteArray(context, file);\n  String dumpFilesPrefix;\n  if (assertionConfig.dumpFilesPrefix != null) {\n    dumpFilesPrefix = assertionConfig.dumpFilesPrefix;\n  } else {\n    String[] path = file.split(\"/\");\n    checkState(\n        path.length > 0 && path[0].equals(\"media\"),\n        \"AssertionConfig.dumpFilesPrefix == null but file isn't in a media/ sub-directory.\\n\"\n            + \"Expected : 'media/<path-to-file>'\\n\"\n            + \"Found    : '\"\n            + file\n            + \"'\\n\"\n            + \"You need to set AssertionConfig.dumpFilesPrefix explicitly if your media and dump\"\n            + \" file aren't located in the expected structure (see docs on\"\n            + \" AssertionConfig.dumpFilesPrefix)\");\n    path[0] = \"extractordumps\";\n    dumpFilesPrefix = Joiner.on('/').join(path);\n  }\n  assertOutput(\n      factory.create(),\n      dumpFilesPrefix,\n      fileData,\n      context,\n      assertionConfig.deduplicateConsecutiveFormats,\n      simulationConfig.sniffFirst,\n      simulationConfig.simulateIOErrors,\n      simulationConfig.simulateUnknownLength,\n      simulationConfig.simulatePartialReads);\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "an",
            "extractor",
            "consumes",
            "valid",
            "input",
            "data",
            "successfully",
            "successfully",
            "under",
            "the",
            "conditions",
            "specified",
            "by",
            "simulation",
            "config"
        ]
    },
    {
        "id": 2715,
        "code": "private static void assertOutput(\n    Extractor extractor,\n    String dumpFilesPrefix,\n    byte[] data,\n    Context context,\n    boolean deduplicateConsecutiveFormats,\n    boolean sniffFirst,\n    boolean simulateIOErrors,\n    boolean simulateUnknownLength,\n    boolean simulatePartialReads)\n    throws IOException {\n  FakeExtractorInput input =\n      new FakeExtractorInput.Builder()\n          .setData(data)\n          .setSimulateIOErrors(simulateIOErrors)\n          .setSimulateUnknownLength(simulateUnknownLength)\n          .setSimulatePartialReads(simulatePartialReads)\n          .build();\n\n  if (sniffFirst) {\n    assertSniff(extractor, input,  true);\n    input.resetPeekPosition();\n  }\n\n  FakeExtractorOutput extractorOutput =\n      consumeTestData(extractor, input, 0, true, deduplicateConsecutiveFormats);\n  if (simulateUnknownLength) {\n    DumpFileAsserts.assertOutput(\n        context, extractorOutput, dumpFilesPrefix + UNKNOWN_LENGTH_EXTENSION);\n  } else {\n    DumpFileAsserts.assertOutput(\n        context, extractorOutput, dumpFilesPrefix + \".0\" + DUMP_EXTENSION);\n  }\n\n    \n  extractorOutput.clearTrackOutputs();\n  input.reset();\n  consumeTestData(extractor, input,  0, extractorOutput, false);\n  if (simulateUnknownLength) {\n    DumpFileAsserts.assertOutput(\n        context, extractorOutput, dumpFilesPrefix + UNKNOWN_LENGTH_EXTENSION);\n  } else {\n    DumpFileAsserts.assertOutput(\n        context, extractorOutput, dumpFilesPrefix + \".0\" + DUMP_EXTENSION);\n  }\n\n  SeekMap seekMap = Assertions.checkNotNull(extractorOutput.seekMap);\n  long durationUs = seekMap.getDurationUs();\n    \n  int numberSeekTests = seekMap.isSeekable() && durationUs != C.TIME_UNSET ? 4 : 1;\n  for (int j = 0; j < numberSeekTests; j++) {\n    long timeUs = durationUs * j / 3;\n    long position = seekMap.getSeekPoints(timeUs).first.position;\n    if (timeUs == 0 && position == 0) {\n        \n      continue;\n    }\n    input.reset();\n    input.setPosition((int) position);\n    extractorOutput.clearTrackOutputs();\n    consumeTestData(extractor, input, timeUs, extractorOutput, false);\n    if (simulateUnknownLength && timeUs == 0) {\n      DumpFileAsserts.assertOutput(\n          context, extractorOutput, dumpFilesPrefix + UNKNOWN_LENGTH_EXTENSION);\n    } else {\n      DumpFileAsserts.assertOutput(\n          context, extractorOutput, dumpFilesPrefix + '.' + j + DUMP_EXTENSION);\n    }\n  }\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "an",
            "extractor",
            "consumes",
            "valid",
            "input",
            "data",
            "successfully",
            "under",
            "the",
            "specified",
            "conditions"
        ]
    },
    {
        "id": 2716,
        "code": "public void release() {\n  prepared = false;\n  for (ChunkSampleStream<FakeChunkSource> sampleStream : sampleStreams) {\n    sampleStream.release();\n  }\n  sampleStreams.clear();\n  sequenceableLoader = new CompositeSequenceableLoader(new SequenceableLoader[0]);\n}",
        "summary_tokens": [
            "releases",
            "the",
            "media",
            "period"
        ]
    },
    {
        "id": 2717,
        "code": "public synchronized void advanceTime(long timeDiffMs) {\n  advanceTimeInternal(timeDiffMs);\n  maybeTriggerMessage();\n}",
        "summary_tokens": [
            "advance",
            "timestamp",
            "of",
            "fake",
            "clock",
            "by",
            "the",
            "specified",
            "duration"
        ]
    },
    {
        "id": 2718,
        "code": "protected synchronized void addPendingHandlerMessage(HandlerMessage message) {\n  handlerMessages.add(message);\n  if (!waitingForMessage) {\n      \n    @Nullable Looper currentLooper = Looper.myLooper();\n    if (currentLooper == null) {\n        \n      maybeTriggerMessage();\n    } else {\n        \n      waitingForMessage = true;\n      new Handler(checkNotNull(Looper.myLooper())).post(this::onMessageHandled);\n    }\n  }\n}",
        "summary_tokens": [
            "adds",
            "a",
            "message",
            "to",
            "the",
            "list",
            "of",
            "pending",
            "messages"
        ]
    },
    {
        "id": 2719,
        "code": "public FakeData newDefaultData() {\n  defaultData = new FakeData(this, null);\n  return defaultData;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "default",
            "data",
            "overwrites",
            "if",
            "there",
            "is",
            "one",
            "already"
        ]
    },
    {
        "id": 2720,
        "code": "public FakeDataSet setRandomData(Uri uri, int length) {\n  return setData(uri, TestUtil.buildTestData(length));\n}",
        "summary_tokens": [
            "sets",
            "random",
            "data",
            "with",
            "the",
            "given",
            "length",
            "for",
            "the",
            "given",
            "uri"
        ]
    },
    {
        "id": 2721,
        "code": "public FakeDataSet setData(Uri uri, byte[] data) {\n  return newData(uri).appendReadData(data).endData();\n}",
        "summary_tokens": [
            "sets",
            "the",
            "given",
            "data",
            "for",
            "the",
            "given",
            "uri"
        ]
    },
    {
        "id": 2722,
        "code": "public FakeData newData(Uri uri) {\n  FakeData data = new FakeData(this, uri);\n  dataMap.put(uri, data);\n  return data;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "new",
            "fake",
            "data",
            "with",
            "the",
            "given",
            "uri"
        ]
    },
    {
        "id": 2723,
        "code": "public FakeData getData(Uri uri) {\n  @Nullable FakeData data = dataMap.get(uri);\n  return data != null ? data : defaultData;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "data",
            "for",
            "the",
            "given",
            "uri",
            "or",
            "default",
            "data",
            "if",
            "no",
            "data",
            "is",
            "set"
        ]
    },
    {
        "id": 2724,
        "code": "public ArrayList<FakeData> getAllData() {\n  ArrayList<FakeData> fakeDatas = new ArrayList<>(dataMap.values());\n  if (defaultData != null) {\n    fakeDatas.add(defaultData);\n  }\n  return fakeDatas;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "list",
            "of",
            "all",
            "data",
            "including",
            "default",
            "data"
        ]
    },
    {
        "id": 2725,
        "code": "public final DataSpec[] getAndClearOpenedDataSpecs() {\n  DataSpec[] dataSpecs = openedDataSpecs.toArray(new DataSpec[0]);\n  openedDataSpecs.clear();\n  return dataSpecs;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "data",
            "spec",
            "instances",
            "passed",
            "to",
            "open",
            "data",
            "spec",
            "since",
            "the",
            "last",
            "call",
            "to",
            "this",
            "method"
        ]
    },
    {
        "id": 2726,
        "code": "public final boolean isOpened() {\n  return sourceOpened;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "data",
            "source",
            "is",
            "currently",
            "opened"
        ]
    },
    {
        "id": 2727,
        "code": "protected void onDataRead(int bytesRead) throws IOException {\n    \n}",
        "summary_tokens": [
            "called",
            "when",
            "data",
            "is",
            "being",
            "read"
        ]
    },
    {
        "id": 2728,
        "code": "protected void onClosed() {\n    \n}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "source",
            "is",
            "closed"
        ]
    },
    {
        "id": 2729,
        "code": "public void triggerEvent(\n    Predicate<byte[]> sessionIdPredicate, int event, int extra, @Nullable byte[] data) {\n  @Nullable OnEventListener onEventListener = this.onEventListener;\n  if (onEventListener == null) {\n    return;\n  }\n  for (List<Byte> sessionId : openSessionIds) {\n    byte[] sessionIdArray = Bytes.toArray(sessionId);\n    if (sessionIdPredicate.apply(sessionIdArray)) {\n      onEventListener.onEvent(this, sessionIdArray, event, extra, data);\n    }\n  }\n}",
        "summary_tokens": [
            "calls",
            "on",
            "event",
            "listener",
            "on",
            "event",
            "exo",
            "media",
            "drm",
            "byte",
            "int",
            "int",
            "byte",
            "on",
            "the",
            "attached",
            "listener",
            "if",
            "present",
            "once",
            "for",
            "each",
            "open",
            "session",
            "id",
            "which",
            "passes",
            "session",
            "id",
            "predicate",
            "passing",
            "the",
            "provided",
            "values",
            "for",
            "event",
            "extra",
            "and",
            "data"
        ]
    },
    {
        "id": 2730,
        "code": "public void resetProvisioning() {\n  provisionsReceived = 0;\n}",
        "summary_tokens": [
            "resets",
            "the",
            "provisioning",
            "state",
            "of",
            "this",
            "instance",
            "so",
            "it",
            "requires",
            "builder",
            "set",
            "provisions",
            "required",
            "int",
            "provisions",
            "required",
            "possibly",
            "zero",
            "provision",
            "operations",
            "before",
            "it",
            "s",
            "operational",
            "again"
        ]
    },
    {
        "id": 2731,
        "code": "public void reset() {\n  readPosition = 0;\n  peekPosition = 0;\n  partiallySatisfiedTargetReadPositions.clear();\n  partiallySatisfiedTargetPeekPositions.clear();\n  failedReadPositions.clear();\n  failedPeekPositions.clear();\n}",
        "summary_tokens": [
            "resets",
            "the",
            "input",
            "to",
            "its",
            "initial",
            "state"
        ]
    },
    {
        "id": 2732,
        "code": "public void setPosition(int position) {\n  assertThat(position).isAtLeast(0);\n  assertThat(position).isAtMost(data.length);\n  readPosition = position;\n  peekPosition = position;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "read",
            "and",
            "peek",
            "positions"
        ]
    },
    {
        "id": 2733,
        "code": "public void setDiscontinuityPositionUs(long discontinuityPositionUs) {\n  this.discontinuityPositionUs = discontinuityPositionUs;\n}",
        "summary_tokens": [
            "sets",
            "a",
            "discontinuity",
            "position",
            "to",
            "be",
            "returned",
            "from",
            "the",
            "next",
            "call",
            "to",
            "read",
            "discontinuity"
        ]
    },
    {
        "id": 2734,
        "code": "public synchronized void setPreparationComplete() {\n  deferOnPrepared = false;\n  if (playerHandler != null && prepareCallback != null) {\n    playerHandler.post(this::finishPreparation);\n  }\n}",
        "summary_tokens": [
            "allows",
            "the",
            "fake",
            "media",
            "period",
            "to",
            "complete",
            "preparation"
        ]
    },
    {
        "id": 2735,
        "code": "public void setSeekToUsOffset(long seekOffsetUs) {\n  this.seekOffsetUs = seekOffsetUs;\n}",
        "summary_tokens": [
            "sets",
            "an",
            "offset",
            "to",
            "be",
            "applied",
            "to",
            "positions",
            "returned",
            "by",
            "seek",
            "to",
            "us",
            "long"
        ]
    },
    {
        "id": 2736,
        "code": "public void release() {\n  prepared = false;\n  for (FakeSampleStream sampleStream : sampleStreams) {\n    sampleStream.release();\n  }\n  sampleStreams.clear();\n}",
        "summary_tokens": [
            "releases",
            "the",
            "media",
            "period"
        ]
    },
    {
        "id": 2737,
        "code": "protected FakeSampleStream createSampleStream(\n    Allocator allocator,\n    @Nullable MediaSourceEventListener.EventDispatcher mediaSourceEventDispatcher,\n    DrmSessionManager drmSessionManager,\n    DrmSessionEventListener.EventDispatcher drmEventDispatcher,\n    Format initialFormat,\n    List<FakeSampleStream.FakeSampleStreamItem> fakeSampleStreamItems) {\n  return new FakeSampleStream(\n      allocator,\n      mediaSourceEventDispatcher,\n      drmSessionManager,\n      drmEventDispatcher,\n      initialFormat,\n      fakeSampleStreamItems);\n}",
        "summary_tokens": [
            "creates",
            "a",
            "new",
            "fake",
            "sample",
            "stream"
        ]
    },
    {
        "id": 2738,
        "code": "public static FakeMediaSource createWithWindowId(Object windowId) {\n  return new FakeMediaSource(\n      new FakeTimeline(\n          new FakeTimeline.TimelineWindowDefinition( 1, windowId)));\n}",
        "summary_tokens": [
            "convenience",
            "method",
            "to",
            "create",
            "a",
            "fake",
            "media",
            "source",
            "with",
            "the",
            "given",
            "window",
            "id"
        ]
    },
    {
        "id": 2739,
        "code": "public synchronized void setAllowPreparation(boolean allowPreparation) {\n  preparationAllowed = allowPreparation;\n  if (allowPreparation && sourceInfoRefreshHandler != null) {\n    sourceInfoRefreshHandler.post(\n        () -> finishSourcePreparation( true));\n  }\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "the",
            "next",
            "call",
            "to",
            "prepare",
            "source",
            "is",
            "allowed",
            "to",
            "finish"
        ]
    },
    {
        "id": 2740,
        "code": "public synchronized void setNewSourceInfo(Timeline newTimeline, boolean sendManifestLoadEvents) {\n  checkState(preparationAllowed);\n  if (sourceInfoRefreshHandler != null) {\n    sourceInfoRefreshHandler.post(\n        () -> {\n          assertThat(releasedSource).isFalse();\n          assertThat(preparedSource).isTrue();\n          timeline = newTimeline;\n          finishSourcePreparation(sendManifestLoadEvents);\n        });\n  } else {\n    timeline = newTimeline;\n  }\n}",
        "summary_tokens": [
            "sets",
            "a",
            "new",
            "timeline"
        ]
    },
    {
        "id": 2741,
        "code": "public boolean isPrepared() {\n  return preparedSource;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "source",
            "is",
            "currently",
            "prepared"
        ]
    },
    {
        "id": 2742,
        "code": "public void assertReleased() {\n  assertThat(releasedSource || !preparedSource).isTrue();\n}",
        "summary_tokens": [
            "assert",
            "that",
            "the",
            "source",
            "and",
            "all",
            "periods",
            "have",
            "been",
            "released"
        ]
    },
    {
        "id": 2743,
        "code": "public void assertMediaPeriodCreated(MediaPeriodId mediaPeriodId) {\n  assertThat(createdMediaPeriods).contains(mediaPeriodId);\n}",
        "summary_tokens": [
            "assert",
            "that",
            "a",
            "media",
            "period",
            "for",
            "the",
            "given",
            "id",
            "has",
            "been",
            "created"
        ]
    },
    {
        "id": 2744,
        "code": "public List<MediaPeriodId> getCreatedMediaPeriods() {\n  return createdMediaPeriods;\n}",
        "summary_tokens": [
            "returns",
            "a",
            "list",
            "of",
            "media",
            "period",
            "id",
            "s",
            "with",
            "one",
            "element",
            "for",
            "each",
            "created",
            "media",
            "period"
        ]
    },
    {
        "id": 2745,
        "code": "protected MediaPeriod createMediaPeriod(\n    MediaPeriodId id,\n    TrackGroupArray trackGroupArray,\n    Allocator allocator,\n    MediaSourceEventListener.EventDispatcher mediaSourceEventDispatcher,\n    DrmSessionManager drmSessionManager,\n    DrmSessionEventListener.EventDispatcher drmEventDispatcher,\n    @Nullable TransferListener transferListener) {\n  long positionInWindowUs =\n      timeline.getPeriodByUid(id.periodUid, new Period()).getPositionInWindowUs();\n  long defaultFirstSampleTimeUs = positionInWindowUs >= 0 || id.isAd() ? 0 : -positionInWindowUs;\n  return new FakeMediaPeriod(\n      trackGroupArray,\n      allocator,\n      trackDataFactory != null\n          ? trackDataFactory\n          : TrackDataFactory.singleSampleWithTimeUs(defaultFirstSampleTimeUs),\n      mediaSourceEventDispatcher,\n      drmSessionManager,\n      drmEventDispatcher,\n       false);\n}",
        "summary_tokens": [
            "creates",
            "a",
            "media",
            "period",
            "for",
            "this",
            "media",
            "source"
        ]
    },
    {
        "id": 2746,
        "code": "protected void releaseMediaPeriod(MediaPeriod mediaPeriod) {\n  ((FakeMediaPeriod) mediaPeriod).release();\n}",
        "summary_tokens": [
            "releases",
            "a",
            "media",
            "period",
            "created",
            "by",
            "create",
            "media",
            "period",
            "media",
            "period",
            "id",
            "track",
            "group",
            "array",
            "allocator",
            "media",
            "source",
            "event",
            "listener"
        ]
    },
    {
        "id": 2747,
        "code": "protected void onFormatChanged(Format format) {}",
        "summary_tokens": [
            "called",
            "when",
            "the",
            "renderer",
            "reads",
            "a",
            "new",
            "format"
        ]
    },
    {
        "id": 2748,
        "code": "public List<Format> getFormatsRead() {\n  return Collections.unmodifiableList(formatsRead);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "list",
            "of",
            "formats",
            "read",
            "by",
            "the",
            "renderer"
        ]
    },
    {
        "id": 2749,
        "code": "protected boolean shouldProcessBuffer(long bufferTimeUs, long playbackPositionUs) {\n  return bufferTimeUs < playbackPositionUs + SOURCE_READAHEAD_US;\n}",
        "summary_tokens": [
            "called",
            "before",
            "the",
            "renderer",
            "processes",
            "a",
            "buffer"
        ]
    },
    {
        "id": 2750,
        "code": "public void append(List<FakeSampleStreamItem> items) {\n  sampleStreamItems.addAll(items);\n}",
        "summary_tokens": [
            "appends",
            "fake",
            "sample",
            "stream",
            "item",
            "fake",
            "sample",
            "stream",
            "items",
            "to",
            "the",
            "list",
            "of",
            "items",
            "that",
            "should",
            "be",
            "written",
            "to",
            "the",
            "queue"
        ]
    },
    {
        "id": 2751,
        "code": "public void writeData(long startPositionUs) {\n  if (sampleStreamItemsWritePosition == 0) {\n    sampleQueue.setStartTimeUs(startPositionUs);\n  }\n  boolean writtenFirstFormat = false;\n  @Nullable Format pendingFirstFormat = null;\n  for (int i = 0; i < sampleStreamItems.size(); i++) {\n    FakeSampleStreamItem fakeSampleStreamItem = sampleStreamItems.get(i);\n    @Nullable FakeSampleStream.SampleInfo sampleInfo = fakeSampleStreamItem.sampleInfo;\n    if (sampleInfo == null) {\n      if (writtenFirstFormat) {\n        sampleQueue.format(checkNotNull(fakeSampleStreamItem.format));\n      } else {\n        pendingFirstFormat = checkNotNull(fakeSampleStreamItem.format);\n      }\n      continue;\n    }\n    if ((sampleInfo.flags & C.BUFFER_FLAG_END_OF_STREAM) != 0) {\n      loadingFinished = true;\n      break;\n    }\n    if (sampleInfo.timeUs >= startPositionUs && i >= sampleStreamItemsWritePosition) {\n      if (!writtenFirstFormat) {\n        sampleQueue.format(checkNotNull(pendingFirstFormat));\n        writtenFirstFormat = true;\n      }\n      sampleQueue.sampleData(new ParsableByteArray(sampleInfo.data), sampleInfo.data.length);\n      sampleQueue.sampleMetadata(\n          sampleInfo.timeUs,\n          sampleInfo.flags,\n          sampleInfo.data.length,\n           0,\n           null);\n    }\n  }\n  sampleStreamItemsWritePosition = sampleStreamItems.size();\n}",
        "summary_tokens": [
            "writes",
            "all",
            "not",
            "yet",
            "written",
            "fake",
            "sample",
            "stream",
            "item",
            "sample",
            "stream",
            "items",
            "to",
            "the",
            "sample",
            "queue",
            "starting",
            "at",
            "the",
            "given",
            "position"
        ]
    },
    {
        "id": 2752,
        "code": "public boolean seekToUs(long positionUs) {\n  return sampleQueue.seekTo(positionUs,  false);\n}",
        "summary_tokens": [
            "seeks",
            "the",
            "stream",
            "to",
            "a",
            "new",
            "position",
            "using",
            "already",
            "available",
            "data",
            "in",
            "the",
            "queue"
        ]
    },
    {
        "id": 2753,
        "code": "public void reset() {\n  sampleQueue.reset();\n  sampleStreamItemsWritePosition = 0;\n  loadingFinished = false;\n}",
        "summary_tokens": [
            "resets",
            "the",
            "sample",
            "queue"
        ]
    },
    {
        "id": 2754,
        "code": "public boolean isLoadingFinished() {\n  return loadingFinished;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "data",
            "has",
            "been",
            "written",
            "to",
            "the",
            "sample",
            "queue",
            "until",
            "the",
            "end",
            "of",
            "stream",
            "signal"
        ]
    },
    {
        "id": 2755,
        "code": "public long getLargestQueuedTimestampUs() {\n  return sampleQueue.getLargestQueuedTimestampUs();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "timestamp",
            "of",
            "the",
            "largest",
            "queued",
            "sample",
            "in",
            "the",
            "queue",
            "or",
            "long",
            "min",
            "value",
            "if",
            "no",
            "samples",
            "are",
            "queued"
        ]
    },
    {
        "id": 2756,
        "code": "public void discardTo(long positionUs, boolean toKeyframe) {\n  sampleQueue.discardTo(positionUs, toKeyframe,  true);\n}",
        "summary_tokens": [
            "discards",
            "data",
            "from",
            "the",
            "queue"
        ]
    },
    {
        "id": 2757,
        "code": "public void release() {\n  sampleQueue.release();\n}",
        "summary_tokens": [
            "release",
            "the",
            "stream",
            "and",
            "its",
            "underlying",
            "sample",
            "queue"
        ]
    },
    {
        "id": 2758,
        "code": "public static AdPlaybackState createAdPlaybackState(int adsPerAdGroup, long... adGroupTimesUs) {\n  int adGroupCount = adGroupTimesUs.length;\n  AdPlaybackState adPlaybackState =\n      new AdPlaybackState( new Object(), adGroupTimesUs);\n  long[][] adDurationsUs = new long[adGroupCount][];\n  for (int i = 0; i < adGroupCount; i++) {\n    adPlaybackState = adPlaybackState.withAdCount( i, adsPerAdGroup);\n    for (int j = 0; j < adsPerAdGroup; j++) {\n      adPlaybackState =\n          adPlaybackState.withAdUri(\n               i,\n               j,\n              Uri.parse(\"https://example.com/ad/\" + i + \"/\" + j));\n    }\n    adDurationsUs[i] = new long[adsPerAdGroup];\n    Arrays.fill(adDurationsUs[i], AD_DURATION_US);\n  }\n  adPlaybackState = adPlaybackState.withAdDurationsUs(adDurationsUs);\n\n  return adPlaybackState;\n}",
        "summary_tokens": [
            "returns",
            "an",
            "ad",
            "playback",
            "state",
            "with",
            "the",
            "specified",
            "number",
            "of",
            "ads",
            "in",
            "each",
            "of",
            "the",
            "specified",
            "ad",
            "groups",
            "each",
            "ten",
            "seconds",
            "long"
        ]
    },
    {
        "id": 2759,
        "code": "public static FakeTimeline createMultiPeriodAdTimeline(\n    Object windowId, int numberOfPlayedAds, boolean... isAdPeriodFlags) {\n  long periodDurationUs = DEFAULT_WINDOW_DURATION_US / isAdPeriodFlags.length;\n  AdPlaybackState contentPeriodState = new AdPlaybackState( \"adsId\");\n  AdPlaybackState firstAdPeriodState =\n      contentPeriodState\n          .withNewAdGroup( 0,  0)\n          .withAdCount( 0, 1)\n          .withAdDurationsUs(\n               0, DEFAULT_WINDOW_OFFSET_IN_FIRST_PERIOD_US + periodDurationUs)\n          .withIsServerSideInserted( 0, true);\n  AdPlaybackState commonAdPeriodState = firstAdPeriodState.withAdDurationsUs(0, periodDurationUs);\n\n  List<AdPlaybackState> adPlaybackStates = new ArrayList<>();\n  int playedAdsCounter = 0;\n  for (boolean isAd : isAdPeriodFlags) {\n    AdPlaybackState periodAdPlaybackState =\n        isAd\n            ? (adPlaybackStates.isEmpty() ? firstAdPeriodState : commonAdPeriodState)\n            : contentPeriodState;\n    if (isAd && playedAdsCounter < numberOfPlayedAds) {\n      periodAdPlaybackState =\n          periodAdPlaybackState.withPlayedAd( 0,  0);\n      playedAdsCounter++;\n    }\n    adPlaybackStates.add(periodAdPlaybackState);\n  }\n  return new FakeTimeline(\n      new FakeTimeline.TimelineWindowDefinition(\n          isAdPeriodFlags.length,\n          windowId,\n           true,\n           false,\n           false,\n           false,\n           DEFAULT_WINDOW_DURATION_US,\n           0,\n           DEFAULT_WINDOW_OFFSET_IN_FIRST_PERIOD_US,\n           adPlaybackStates,\n          MediaItem.EMPTY));\n}",
        "summary_tokens": [
            "creates",
            "a",
            "multi",
            "period",
            "timeline",
            "with",
            "ad",
            "and",
            "content",
            "periods",
            "specified",
            "by",
            "the",
            "flags",
            "passed",
            "as",
            "var",
            "arg",
            "arguments"
        ]
    },
    {
        "id": 2760,
        "code": "public ImmutableMap<Object, AdPlaybackState> getAdPlaybackStates(int windowIndex) {\n  Map<Object, AdPlaybackState> adPlaybackStateMap = new HashMap<>();\n  TimelineWindowDefinition windowDefinition = windowDefinitions[windowIndex];\n  for (int i = 0; i < windowDefinition.adPlaybackStates.size(); i++) {\n    adPlaybackStateMap.put(\n        new Pair<>(windowDefinition.id, i), windowDefinition.adPlaybackStates.get(i));\n  }\n  return ImmutableMap.copyOf(adPlaybackStateMap);\n}",
        "summary_tokens": [
            "returns",
            "a",
            "map",
            "of",
            "ad",
            "playback",
            "states",
            "keyed",
            "by",
            "the",
            "period",
            "uid"
        ]
    },
    {
        "id": 2761,
        "code": "public void runTest(\n    final HostedTest hostedTest, long timeoutMs, boolean failOnTimeoutOrForceStop) {\n  Assertions.checkArgument(timeoutMs > 0);\n  Assertions.checkState(Thread.currentThread() != getMainLooper().getThread());\n  Assertions.checkState(this.hostedTest == null);\n  Assertions.checkNotNull(hostedTest);\n  hostedTestStartedCondition = new ConditionVariable();\n  forcedStopped = false;\n  hostedTestStarted = false;\n\n  runOnUiThread(\n      () -> {\n        HostActivity.this.hostedTest = hostedTest;\n        maybeStartHostedTest();\n      });\n\n  if (!hostedTestStartedCondition.block(START_TIMEOUT_MS)) {\n    String message =\n        \"Test failed to start. Display may be turned off or keyguard may be present.\";\n    Log.e(TAG, message);\n    if (failOnTimeoutOrForceStop) {\n      fail(message);\n    }\n  }\n\n  if (hostedTest.blockUntilStopped(timeoutMs)) {\n    if (!forcedStopped) {\n      Log.d(TAG, \"Checking test pass conditions.\");\n      hostedTest.onFinished();\n      Log.d(TAG, \"Pass conditions checked.\");\n    } else {\n      String message =\n          \"Test force stopped. Activity may have been paused whilst \" + \"test was in progress.\";\n      Log.e(TAG, message);\n      if (failOnTimeoutOrForceStop) {\n        fail(message);\n      }\n    }\n  } else {\n    runOnUiThread(hostedTest::forceStop);\n    String message = \"Test timed out after \" + timeoutMs + \" ms.\";\n    Log.e(TAG, message);\n    if (failOnTimeoutOrForceStop) {\n      fail(message);\n    }\n  }\n  this.hostedTest = null;\n}",
        "summary_tokens": [
            "executes",
            "a",
            "hosted",
            "test",
            "inside",
            "the",
            "host"
        ]
    },
    {
        "id": 2762,
        "code": "public static void assertTrackGroups(MediaPeriod mediaPeriod, TrackGroupArray expectedGroups) {\n  TrackGroupArray actualGroups = prepareAndGetTrackGroups(mediaPeriod);\n  assertThat(actualGroups).isEqualTo(expectedGroups);\n}",
        "summary_tokens": [
            "prepares",
            "the",
            "media",
            "period",
            "and",
            "asserts",
            "that",
            "it",
            "provides",
            "the",
            "specified",
            "track",
            "groups"
        ]
    },
    {
        "id": 2763,
        "code": "public static <T extends FilterableManifest<T>>\n    void assertGetStreamKeysAndManifestFilterIntegration(\n        FilterableManifestMediaPeriodFactory<T> mediaPeriodFactory,\n        T manifest,\n        int periodIndex,\n        @Nullable String ignoredMimeType) {\n  MediaPeriod mediaPeriod = mediaPeriodFactory.createMediaPeriod(manifest, periodIndex);\n  TrackGroupArray trackGroupArray = prepareAndGetTrackGroups(mediaPeriod);\n\n    \n    \n    \n    \n  List<List<ExoTrackSelection>> testSelections = new ArrayList<>();\n  for (int i = 0; i < trackGroupArray.length; i++) {\n    TrackGroup trackGroup = trackGroupArray.get(i);\n    for (int j = 0; j < trackGroup.length; j++) {\n      testSelections.add(Collections.singletonList(new TestTrackSelection(trackGroup, j)));\n    }\n    if (trackGroup.length > 1) {\n      testSelections.add(Collections.singletonList(new TestTrackSelection(trackGroup, 0, 1)));\n      testSelections.add(\n          Arrays.asList(\n              new ExoTrackSelection[] {\n                new TestTrackSelection(trackGroup, 0), new TestTrackSelection(trackGroup, 1)\n              }));\n    }\n    if (trackGroup.length > 2) {\n      int[] allTracks = new int[trackGroup.length];\n      for (int j = 0; j < trackGroup.length; j++) {\n        allTracks[j] = j;\n      }\n      testSelections.add(\n          Collections.singletonList(new TestTrackSelection(trackGroup, allTracks)));\n    }\n  }\n  if (trackGroupArray.length > 1) {\n    for (int i = 0; i < trackGroupArray.length - 1; i++) {\n      for (int j = i + 1; j < trackGroupArray.length; j++) {\n        testSelections.add(\n            Arrays.asList(\n                new ExoTrackSelection[] {\n                  new TestTrackSelection(trackGroupArray.get(i), 0),\n                  new TestTrackSelection(trackGroupArray.get(j), 0)\n                }));\n      }\n    }\n  }\n  if (trackGroupArray.length > 2) {\n    List<ExoTrackSelection> selectionsFromAllGroups = new ArrayList<>();\n    for (int i = 0; i < trackGroupArray.length; i++) {\n      selectionsFromAllGroups.add(new TestTrackSelection(trackGroupArray.get(i), 0));\n    }\n    testSelections.add(selectionsFromAllGroups);\n  }\n\n    \n    \n  for (List<ExoTrackSelection> testSelection : testSelections) {\n    List<StreamKey> streamKeys = mediaPeriod.getStreamKeys(testSelection);\n    if (streamKeys.isEmpty()) {\n        \n      continue;\n    }\n    T filteredManifest = manifest.copy(streamKeys);\n      \n    MediaPeriod filteredMediaPeriod =\n        mediaPeriodFactory.createMediaPeriod(filteredManifest,  0);\n    TrackGroupArray filteredTrackGroupArray = prepareAndGetTrackGroups(filteredMediaPeriod);\n    for (ExoTrackSelection trackSelection : testSelection) {\n      if (ignoredMimeType != null\n          && ignoredMimeType.equals(trackSelection.getFormat(0).sampleMimeType)) {\n        continue;\n      }\n      Format[] expectedFormats = new Format[trackSelection.length()];\n      for (int k = 0; k < trackSelection.length(); k++) {\n        expectedFormats[k] = trackSelection.getFormat(k);\n      }\n      assertOneTrackGroupContainsFormats(filteredTrackGroupArray, expectedFormats);\n    }\n  }\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "the",
            "values",
            "returns",
            "by",
            "media",
            "period",
            "get",
            "stream",
            "keys",
            "list",
            "are",
            "compatible",
            "with",
            "a",
            "filterable",
            "manifest",
            "using",
            "these",
            "stream",
            "keys"
        ]
    },
    {
        "id": 2764,
        "code": "public void runOnPlaybackThread(final Runnable runnable) {\n  Throwable[] throwable = new Throwable[1];\n  CountDownLatch finishedLatch = new CountDownLatch(1);\n  playbackHandler.post(\n      () -> {\n        try {\n          runnable.run();\n        } catch (Throwable e) {\n          throwable[0] = e;\n        } finally {\n          finishedLatch.countDown();\n        }\n      });\n  try {\n    assertThat(finishedLatch.await(TIMEOUT_MS, MILLISECONDS)).isTrue();\n  } catch (InterruptedException e) {\n    Util.sneakyThrow(e);\n  }\n  if (throwable[0] != null) {\n    Util.sneakyThrow(throwable[0]);\n  }\n}",
        "summary_tokens": [
            "runs",
            "the",
            "provided",
            "runnable",
            "on",
            "the",
            "playback",
            "thread",
            "blocking",
            "until",
            "execution",
            "completes"
        ]
    },
    {
        "id": 2765,
        "code": "public Timeline prepareSource() throws IOException {\n  final IOException[] prepareError = new IOException[1];\n  runOnPlaybackThread(\n      () -> {\n        mediaSource.prepareSource(\n            mediaSourceListener,  null, PlayerId.UNSET);\n        try {\n            \n            \n            \n          mediaSource.maybeThrowSourceInfoRefreshError();\n        } catch (IOException e) {\n          prepareError[0] = e;\n        }\n      });\n  if (prepareError[0] != null) {\n    throw prepareError[0];\n  }\n  return assertTimelineChangeBlocking();\n}",
        "summary_tokens": [
            "prepares",
            "the",
            "source",
            "on",
            "the",
            "playback",
            "thread",
            "asserting",
            "that",
            "it",
            "provides",
            "an",
            "initial",
            "timeline"
        ]
    },
    {
        "id": 2766,
        "code": "public MediaPeriod createPeriod(final MediaPeriodId periodId, long startPositionUs) {\n  final MediaPeriod[] holder = new MediaPeriod[1];\n  runOnPlaybackThread(\n      () -> holder[0] = mediaSource.createPeriod(periodId, allocator, startPositionUs));\n  assertThat(holder[0]).isNotNull();\n  return holder[0];\n}",
        "summary_tokens": [
            "calls",
            "media",
            "source",
            "create",
            "period",
            "media",
            "source"
        ]
    },
    {
        "id": 2767,
        "code": "public CountDownLatch preparePeriod(final MediaPeriod mediaPeriod, final long positionUs) {\n  final ConditionVariable prepareCalled = new ConditionVariable();\n  final CountDownLatch preparedLatch = new CountDownLatch(1);\n  runOnPlaybackThread(\n      () -> {\n        mediaPeriod.prepare(\n            new MediaPeriod.Callback() {\n              @Override\n              public void onPrepared(MediaPeriod mediaPeriod1) {\n                preparedLatch.countDown();\n              }\n\n              @Override\n              public void onContinueLoadingRequested(MediaPeriod source) {\n                  \n              }\n            },\n            positionUs);\n        prepareCalled.open();\n      });\n  prepareCalled.block();\n  return preparedLatch;\n}",
        "summary_tokens": [
            "calls",
            "media",
            "period",
            "prepare",
            "media",
            "period"
        ]
    },
    {
        "id": 2768,
        "code": "public void releasePeriod(final MediaPeriod mediaPeriod) {\n  runOnPlaybackThread(() -> mediaSource.releasePeriod(mediaPeriod));\n}",
        "summary_tokens": [
            "calls",
            "media",
            "source",
            "release",
            "period",
            "media",
            "period",
            "on",
            "the",
            "playback",
            "thread"
        ]
    },
    {
        "id": 2769,
        "code": "public void releaseSource() {\n  runOnPlaybackThread(() -> mediaSource.releaseSource(mediaSourceListener));\n}",
        "summary_tokens": [
            "calls",
            "media",
            "source",
            "release",
            "source",
            "media",
            "source",
            "caller",
            "on",
            "the",
            "playback",
            "thread"
        ]
    },
    {
        "id": 2770,
        "code": "public void assertNoTimelineChange() {\n  assertThat(timelines).isEmpty();\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "the",
            "source",
            "has",
            "not",
            "notified",
            "its",
            "listener",
            "of",
            "a",
            "timeline",
            "change",
            "since",
            "the",
            "last",
            "call",
            "to",
            "assert",
            "timeline",
            "change",
            "blocking",
            "or",
            "assert",
            "timeline",
            "change",
            "or",
            "since",
            "the",
            "runner",
            "was",
            "created",
            "if",
            "neither",
            "method",
            "has",
            "been",
            "called"
        ]
    },
    {
        "id": 2771,
        "code": "public Timeline assertTimelineChange() {\n  timeline = timelines.removeFirst();\n  assertNoTimelineChange();\n  return timeline;\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "the",
            "source",
            "has",
            "notified",
            "its",
            "listener",
            "of",
            "a",
            "single",
            "timeline",
            "change"
        ]
    },
    {
        "id": 2772,
        "code": "public Timeline assertTimelineChangeBlocking() {\n  try {\n    timeline = timelines.poll(TIMEOUT_MS, MILLISECONDS);\n    assertThat(timeline).isNotNull(); \n    assertNoTimelineChange();\n    return timeline;\n  } catch (InterruptedException e) {\n      \n    throw new RuntimeException(e);\n  }\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "the",
            "source",
            "notifies",
            "its",
            "listener",
            "of",
            "a",
            "single",
            "timeline",
            "change"
        ]
    },
    {
        "id": 2773,
        "code": "public void assertPrepareAndReleaseAllPeriods() throws InterruptedException {\n  Timeline.Period period = new Timeline.Period();\n  for (int i = 0; i < timeline.getPeriodCount(); i++) {\n    timeline.getPeriod(i, period,  true);\n    assertPrepareAndReleasePeriod(new MediaPeriodId(period.uid, period.windowIndex));\n    for (int adGroupIndex = 0; adGroupIndex < period.getAdGroupCount(); adGroupIndex++) {\n      for (int adIndex = 0; adIndex < period.getAdCountInAdGroup(adGroupIndex); adIndex++) {\n        assertPrepareAndReleasePeriod(\n            new MediaPeriodId(period.uid, adGroupIndex, adIndex, period.windowIndex));\n      }\n    }\n  }\n}",
        "summary_tokens": [
            "creates",
            "and",
            "releases",
            "all",
            "periods",
            "including",
            "ad",
            "periods",
            "defined",
            "in",
            "the",
            "last",
            "timeline",
            "to",
            "be",
            "returned",
            "from",
            "prepare",
            "source",
            "assert",
            "timeline",
            "change",
            "or",
            "assert",
            "timeline",
            "change",
            "blocking"
        ]
    },
    {
        "id": 2774,
        "code": "public void assertCompletedManifestLoads(Integer... windowIndices) {\n  List<Integer> expectedWindowIndices = new ArrayList<>(Arrays.asList(windowIndices));\n  for (Pair<Integer, MediaPeriodId> windowIndexAndMediaPeriodId : completedLoads) {\n    if (windowIndexAndMediaPeriodId.second == null) {\n      assertWithMessage(\"Missing expected load\")\n          .that(expectedWindowIndices)\n          .contains(windowIndexAndMediaPeriodId.first);\n      expectedWindowIndices.remove(windowIndexAndMediaPeriodId.first);\n    }\n  }\n  assertWithMessage(\"Not all expected media source loads have been completed.\")\n      .that(expectedWindowIndices)\n      .isEmpty();\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "the",
            "media",
            "source",
            "reported",
            "completed",
            "loads",
            "via",
            "media",
            "source",
            "event",
            "listener",
            "on",
            "load",
            "completed",
            "int",
            "media",
            "period",
            "id",
            "load",
            "event",
            "info",
            "media",
            "load",
            "data",
            "for",
            "each",
            "specified",
            "window",
            "index",
            "and",
            "a",
            "null",
            "period",
            "id"
        ]
    },
    {
        "id": 2775,
        "code": "public void assertCompletedMediaPeriodLoads(MediaPeriodId... mediaPeriodIds) {\n  Timeline.Period period = new Timeline.Period();\n  HashSet<MediaPeriodId> expectedLoads = new HashSet<>(Arrays.asList(mediaPeriodIds));\n  for (Pair<Integer, MediaPeriodId> windowIndexAndMediaPeriodId : completedLoads) {\n    int windowIndex = windowIndexAndMediaPeriodId.first;\n    MediaPeriodId mediaPeriodId = windowIndexAndMediaPeriodId.second;\n    if (expectedLoads.remove(mediaPeriodId)) {\n      int periodIndex = timeline.getIndexOfPeriod(mediaPeriodId.periodUid);\n      assertThat(windowIndex).isEqualTo(timeline.getPeriod(periodIndex, period).windowIndex);\n    }\n  }\n  assertWithMessage(\"Not all expected media source loads have been completed.\")\n      .that(expectedLoads)\n      .isEmpty();\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "the",
            "media",
            "source",
            "reported",
            "completed",
            "loads",
            "via",
            "media",
            "source",
            "event",
            "listener",
            "on",
            "load",
            "completed",
            "int",
            "media",
            "period",
            "id",
            "load",
            "event",
            "info",
            "media",
            "load",
            "data",
            "for",
            "each",
            "specified",
            "media",
            "period",
            "id",
            "and",
            "asserts",
            "that",
            "the",
            "associated",
            "window",
            "index",
            "matches",
            "the",
            "one",
            "in",
            "the",
            "last",
            "known",
            "timeline",
            "returned",
            "from",
            "prepare",
            "source",
            "assert",
            "timeline",
            "change",
            "or",
            "assert",
            "timeline",
            "change",
            "blocking"
        ]
    },
    {
        "id": 2776,
        "code": "public AudioComponent getAudioComponent() {\n  throw new UnsupportedOperationException();\n}",
        "summary_tokens": [
            "use",
            "exo",
            "player",
            "as",
            "the",
            "audio",
            "component",
            "methods",
            "are",
            "defined",
            "by",
            "that",
            "interface"
        ]
    },
    {
        "id": 2777,
        "code": "public VideoComponent getVideoComponent() {\n  throw new UnsupportedOperationException();\n}",
        "summary_tokens": [
            "use",
            "exo",
            "player",
            "as",
            "the",
            "video",
            "component",
            "methods",
            "are",
            "defined",
            "by",
            "that",
            "interface"
        ]
    },
    {
        "id": 2778,
        "code": "public TextComponent getTextComponent() {\n  throw new UnsupportedOperationException();\n}",
        "summary_tokens": [
            "use",
            "player",
            "as",
            "the",
            "text",
            "component",
            "methods",
            "are",
            "defined",
            "by",
            "that",
            "interface"
        ]
    },
    {
        "id": 2779,
        "code": "public DeviceComponent getDeviceComponent() {\n  throw new UnsupportedOperationException();\n}",
        "summary_tokens": [
            "use",
            "player",
            "as",
            "the",
            "device",
            "component",
            "methods",
            "are",
            "defined",
            "by",
            "that",
            "interface"
        ]
    },
    {
        "id": 2780,
        "code": "public void prepare(MediaSource mediaSource, boolean resetPosition, boolean resetState) {\n  throw new UnsupportedOperationException();\n}",
        "summary_tokens": [
            "use",
            "set",
            "media",
            "source",
            "media",
            "source",
            "boolean",
            "and",
            "prepare",
            "instead"
        ]
    },
    {
        "id": 2781,
        "code": "public TrackGroupArray getCurrentTrackGroups() {\n  throw new UnsupportedOperationException();\n}",
        "summary_tokens": [
            "use",
            "get",
            "current",
            "tracks"
        ]
    },
    {
        "id": 2782,
        "code": "public TrackSelectionArray getCurrentTrackSelections() {\n  throw new UnsupportedOperationException();\n}",
        "summary_tokens": [
            "use",
            "get",
            "current",
            "tracks"
        ]
    },
    {
        "id": 2783,
        "code": "public void setHandleWakeLock(boolean handleWakeLock) {\n  throw new UnsupportedOperationException();\n}",
        "summary_tokens": [
            "use",
            "set",
            "wake",
            "mode",
            "int",
            "instead"
        ]
    },
    {
        "id": 2784,
        "code": "public void stop(boolean reset) {\n  throw new UnsupportedOperationException();\n}",
        "summary_tokens": [
            "use",
            "stop",
            "and",
            "clear",
            "media",
            "items",
            "if",
            "reset",
            "is",
            "true",
            "or",
            "just",
            "stop",
            "if",
            "reset",
            "is",
            "false"
        ]
    },
    {
        "id": 2785,
        "code": "public TestExoPlayerBuilder setUseLazyPreparation(boolean useLazyPreparation) {\n  this.useLazyPreparation = useLazyPreparation;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "whether",
            "to",
            "use",
            "lazy",
            "preparation"
        ]
    },
    {
        "id": 2786,
        "code": "public boolean getUseLazyPreparation() {\n  return useLazyPreparation;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "player",
            "will",
            "use",
            "lazy",
            "preparation"
        ]
    },
    {
        "id": 2787,
        "code": "public TestExoPlayerBuilder setTrackSelector(DefaultTrackSelector trackSelector) {\n  Assertions.checkNotNull(trackSelector);\n  this.trackSelector = trackSelector;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "a",
            "default",
            "track",
            "selector"
        ]
    },
    {
        "id": 2788,
        "code": "public DefaultTrackSelector getTrackSelector() {\n  return trackSelector;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "track",
            "selector",
            "used",
            "by",
            "the",
            "player"
        ]
    },
    {
        "id": 2789,
        "code": "public TestExoPlayerBuilder setLoadControl(LoadControl loadControl) {\n  this.loadControl = loadControl;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "a",
            "load",
            "control",
            "to",
            "be",
            "used",
            "by",
            "the",
            "player"
        ]
    },
    {
        "id": 2790,
        "code": "public LoadControl getLoadControl() {\n  return loadControl;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "load",
            "control",
            "that",
            "will",
            "be",
            "used",
            "by",
            "the",
            "player"
        ]
    },
    {
        "id": 2791,
        "code": "public TestExoPlayerBuilder setBandwidthMeter(BandwidthMeter bandwidthMeter) {\n  Assertions.checkNotNull(bandwidthMeter);\n  this.bandwidthMeter = bandwidthMeter;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "bandwidth",
            "meter"
        ]
    },
    {
        "id": 2792,
        "code": "public BandwidthMeter getBandwidthMeter() {\n  return bandwidthMeter;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "bandwidth",
            "meter",
            "used",
            "by",
            "the",
            "player"
        ]
    },
    {
        "id": 2793,
        "code": "public TestExoPlayerBuilder setRenderers(Renderer... renderers) {\n  assertThat(renderersFactory).isNull();\n  this.renderers = renderers;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "renderer",
            "s"
        ]
    },
    {
        "id": 2794,
        "code": "public Renderer[] getRenderers() {\n  return renderers;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "renderer",
            "renderers",
            "that",
            "have",
            "been",
            "set",
            "with",
            "set",
            "renderers",
            "or",
            "null",
            "if",
            "no",
            "renderer",
            "renderers",
            "have",
            "been",
            "explicitly",
            "set"
        ]
    },
    {
        "id": 2795,
        "code": "public TestExoPlayerBuilder setRenderersFactory(RenderersFactory renderersFactory) {\n  assertThat(renderers).isNull();\n  this.renderersFactory = renderersFactory;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "renderers",
            "factory"
        ]
    },
    {
        "id": 2796,
        "code": "public RenderersFactory getRenderersFactory() {\n  return renderersFactory;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "renderers",
            "factory",
            "that",
            "has",
            "been",
            "set",
            "with",
            "set",
            "renderers",
            "factory",
            "or",
            "null",
            "if",
            "no",
            "factory",
            "has",
            "been",
            "explicitly",
            "set"
        ]
    },
    {
        "id": 2797,
        "code": "public TestExoPlayerBuilder setClock(Clock clock) {\n  assertThat(clock).isNotNull();\n  this.clock = clock;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "clock",
            "to",
            "be",
            "used",
            "by",
            "the",
            "player"
        ]
    },
    {
        "id": 2798,
        "code": "public Clock getClock() {\n  return clock;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "clock",
            "used",
            "by",
            "the",
            "player"
        ]
    },
    {
        "id": 2799,
        "code": "public TestExoPlayerBuilder setLooper(Looper looper) {\n  this.looper = looper;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "looper",
            "to",
            "be",
            "used",
            "by",
            "the",
            "player"
        ]
    },
    {
        "id": 2800,
        "code": "public Looper getLooper() {\n  return looper;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "looper",
            "that",
            "will",
            "be",
            "used",
            "by",
            "the",
            "player",
            "or",
            "null",
            "if",
            "no",
            "looper",
            "has",
            "been",
            "set",
            "yet",
            "and",
            "no",
            "default",
            "is",
            "available"
        ]
    },
    {
        "id": 2801,
        "code": "public MediaSource.Factory getMediaSourceFactory() {\n  return mediaSourceFactory;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "media",
            "source"
        ]
    },
    {
        "id": 2802,
        "code": "public TestExoPlayerBuilder setMediaSourceFactory(MediaSource.Factory mediaSourceFactory) {\n  this.mediaSourceFactory = mediaSourceFactory;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "media",
            "source"
        ]
    },
    {
        "id": 2803,
        "code": "public TestExoPlayerBuilder setSeekBackIncrementMs(long seekBackIncrementMs) {\n  this.seekBackIncrementMs = seekBackIncrementMs;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "seek",
            "back",
            "increment",
            "to",
            "be",
            "used",
            "by",
            "the",
            "player"
        ]
    },
    {
        "id": 2804,
        "code": "public long getSeekBackIncrementMs() {\n  return seekBackIncrementMs;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "seek",
            "back",
            "increment",
            "used",
            "by",
            "the",
            "player"
        ]
    },
    {
        "id": 2805,
        "code": "public TestExoPlayerBuilder setSeekForwardIncrementMs(long seekForwardIncrementMs) {\n  this.seekForwardIncrementMs = seekForwardIncrementMs;\n  return this;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "seek",
            "forward",
            "increment",
            "to",
            "be",
            "used",
            "by",
            "the",
            "player"
        ]
    },
    {
        "id": 2806,
        "code": "public long getSeekForwardIncrementMs() {\n  return seekForwardIncrementMs;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "seek",
            "forward",
            "increment",
            "used",
            "by",
            "the",
            "player"
        ]
    },
    {
        "id": 2807,
        "code": "public ExoPlayer build() {\n  Assertions.checkNotNull(\n      looper, \"TestExoPlayer builder run on a thread without Looper and no Looper specified.\");\n    \n    \n  RenderersFactory playerRenderersFactory = renderersFactory;\n  if (playerRenderersFactory == null) {\n    playerRenderersFactory =\n        (eventHandler,\n            videoRendererEventListener,\n            audioRendererEventListener,\n            textRendererOutput,\n            metadataRendererOutput) ->\n            renderers != null\n                ? renderers\n                : new Renderer[] {\n                  new FakeVideoRenderer(eventHandler, videoRendererEventListener),\n                  new FakeAudioRenderer(eventHandler, audioRendererEventListener)\n                };\n  }\n\n  ExoPlayer.Builder builder =\n      new ExoPlayer.Builder(context, playerRenderersFactory)\n          .setTrackSelector(trackSelector)\n          .setLoadControl(loadControl)\n          .setBandwidthMeter(bandwidthMeter)\n          .setAnalyticsCollector(new DefaultAnalyticsCollector(clock))\n          .setClock(clock)\n          .setUseLazyPreparation(useLazyPreparation)\n          .setLooper(looper)\n          .setSeekBackIncrementMs(seekBackIncrementMs)\n          .setSeekForwardIncrementMs(seekForwardIncrementMs);\n  if (mediaSourceFactory != null) {\n    builder.setMediaSourceFactory(mediaSourceFactory);\n  }\n  return builder.build();\n}",
        "summary_tokens": [
            "builds",
            "an",
            "exo",
            "player",
            "using",
            "the",
            "provided",
            "values",
            "or",
            "their",
            "defaults"
        ]
    },
    {
        "id": 2808,
        "code": "public static byte[] buildTestData(int length, Random random) {\n  byte[] source = new byte[length];\n  random.nextBytes(source);\n  return source;\n}",
        "summary_tokens": [
            "generates",
            "an",
            "array",
            "of",
            "random",
            "bytes",
            "with",
            "the",
            "specified",
            "length"
        ]
    },
    {
        "id": 2809,
        "code": "public static String buildTestString(int length, Random random) {\n  char[] chars = new char[length];\n  for (int i = 0; i < length; i++) {\n    chars[i] = (char) random.nextInt();\n  }\n  return new String(chars);\n}",
        "summary_tokens": [
            "generates",
            "a",
            "random",
            "string",
            "with",
            "the",
            "specified",
            "length"
        ]
    },
    {
        "id": 2810,
        "code": "public static byte[] createByteArray(int... bytes) {\n  byte[] byteArray = new byte[bytes.length];\n  for (int i = 0; i < byteArray.length; i++) {\n    Assertions.checkState(0x00 <= bytes[i] && bytes[i] <= 0xFF);\n    byteArray[i] = (byte) bytes[i];\n  }\n  return byteArray;\n}",
        "summary_tokens": [
            "converts",
            "an",
            "array",
            "of",
            "integers",
            "in",
            "the",
            "range",
            "0",
            "0",
            "into",
            "an",
            "equivalent",
            "byte",
            "array"
        ]
    },
    {
        "id": 2811,
        "code": "public static ImmutableList<Byte> createByteList(int... bytes) {\n  return ImmutableList.copyOf(Bytes.asList(createByteArray(bytes)));\n}",
        "summary_tokens": [
            "converts",
            "an",
            "array",
            "of",
            "integers",
            "in",
            "the",
            "range",
            "0",
            "0",
            "into",
            "an",
            "equivalent",
            "byte",
            "list"
        ]
    },
    {
        "id": 2812,
        "code": "public static File createTestFile(File file, long length) throws IOException {\n  FileOutputStream output = new FileOutputStream(file);\n  for (long i = 0; i < length; i++) {\n    output.write((int) i);\n  }\n  output.close();\n  return file;\n}",
        "summary_tokens": [
            "writes",
            "test",
            "data",
            "with",
            "the",
            "specified",
            "length",
            "to",
            "the",
            "file",
            "and",
            "returns",
            "it"
        ]
    },
    {
        "id": 2813,
        "code": "public static byte[] getByteArray(Context context, String fileName) throws IOException {\n  return Util.toByteArray(getInputStream(context, fileName));\n}",
        "summary_tokens": [
            "returns",
            "the",
            "bytes",
            "of",
            "an",
            "asset",
            "file"
        ]
    },
    {
        "id": 2814,
        "code": "public static InputStream getInputStream(Context context, String fileName) throws IOException {\n  return context.getResources().getAssets().open(fileName);\n}",
        "summary_tokens": [
            "returns",
            "an",
            "input",
            "stream",
            "for",
            "reading",
            "from",
            "an",
            "asset",
            "file"
        ]
    },
    {
        "id": 2815,
        "code": "public static String getString(Context context, String fileName) throws IOException {\n  return Util.fromUtf8Bytes(getByteArray(context, fileName));\n}",
        "summary_tokens": [
            "returns",
            "a",
            "string",
            "read",
            "from",
            "an",
            "asset",
            "file"
        ]
    },
    {
        "id": 2816,
        "code": "public static Bitmap getBitmap(Context context, String fileName) throws IOException {\n  return BitmapFactory.decodeStream(getInputStream(context, fileName));\n}",
        "summary_tokens": [
            "returns",
            "a",
            "bitmap",
            "read",
            "from",
            "an",
            "asset",
            "file"
        ]
    },
    {
        "id": 2817,
        "code": "public static DatabaseProvider getInMemoryDatabaseProvider() {\n  return new DefaultDatabaseProvider(\n      new SQLiteOpenHelper(\n           null,  null,  null,  1) {\n        @Override\n        public void onCreate(SQLiteDatabase db) {\n            \n        }\n\n        @Override\n        public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n            \n        }\n      });\n}",
        "summary_tokens": [
            "returns",
            "a",
            "database",
            "provider",
            "that",
            "provides",
            "an",
            "in",
            "memory",
            "database"
        ]
    },
    {
        "id": 2818,
        "code": "public static void assertTimelinesSame(\n    List<Timeline> actualTimelines, List<Timeline> expectedTimelines) {\n  assertThat(actualTimelines)\n      .comparingElementsUsing(\n          Correspondence.from(\n              TestUtil::timelinesAreSame, \"is equal to (ignoring Window.uid and Period.uid)\"))\n      .containsExactlyElementsIn(expectedTimelines)\n      .inOrder();\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "the",
            "actual",
            "timelines",
            "are",
            "the",
            "same",
            "to",
            "the",
            "expected",
            "timelines"
        ]
    },
    {
        "id": 2819,
        "code": "public static boolean timelinesAreSame(Timeline thisTimeline, Timeline thatTimeline) {\n  return new NoUidOrShufflingTimeline(thisTimeline)\n      .equals(new NoUidOrShufflingTimeline(thatTimeline));\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "this",
            "timeline",
            "is",
            "equal",
            "to",
            "that",
            "timeline",
            "ignoring",
            "timeline"
        ]
    },
    {
        "id": 2820,
        "code": "public static void assertDataSourceContent(\n    DataSource dataSource, DataSpec dataSpec, byte[] expectedData, boolean expectKnownLength)\n    throws IOException {\n  try {\n    long length = dataSource.open(dataSpec);\n    assertThat(length).isEqualTo(expectKnownLength ? expectedData.length : C.LENGTH_UNSET);\n    byte[] readData = DataSourceUtil.readToEnd(dataSource);\n    assertThat(readData).isEqualTo(expectedData);\n  } finally {\n    dataSource.close();\n  }\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "data",
            "read",
            "from",
            "a",
            "data",
            "source",
            "matches",
            "expected"
        ]
    },
    {
        "id": 2821,
        "code": "public static void assertBufferInfosEqual(\n    MediaCodec.BufferInfo expected, MediaCodec.BufferInfo actual) {\n  assertThat(actual.flags).isEqualTo(expected.flags);\n  assertThat(actual.offset).isEqualTo(expected.offset);\n  assertThat(actual.presentationTimeUs).isEqualTo(expected.presentationTimeUs);\n  assertThat(actual.size).isEqualTo(expected.size);\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "two",
            "android"
        ]
    },
    {
        "id": 2822,
        "code": "public static void assertBitmapsAreSimilar(\n    Bitmap expectedBitmap, Bitmap actualBitmap, double psnrThresholdDb) {\n  assertThat(getPsnr(expectedBitmap, actualBitmap)).isAtLeast(psnrThresholdDb);\n}",
        "summary_tokens": [
            "asserts",
            "whether",
            "actual",
            "bitmap",
            "is",
            "very",
            "similar",
            "to",
            "the",
            "expected",
            "bitmap",
            "at",
            "some",
            "quality",
            "level"
        ]
    },
    {
        "id": 2823,
        "code": "private static double getPsnr(Bitmap firstBitmap, Bitmap secondBitmap) {\n  assertThat(firstBitmap.getWidth()).isEqualTo(secondBitmap.getWidth());\n  assertThat(firstBitmap.getHeight()).isEqualTo(secondBitmap.getHeight());\n  long mse = 0;\n  for (int i = 0; i < firstBitmap.getWidth(); i++) {\n    for (int j = 0; j < firstBitmap.getHeight(); j++) {\n      int firstColorInt = firstBitmap.getPixel(i, j);\n      int firstRed = Color.red(firstColorInt);\n      int firstGreen = Color.green(firstColorInt);\n      int firstBlue = Color.blue(firstColorInt);\n      int secondColorInt = secondBitmap.getPixel(i, j);\n      int secondRed = Color.red(secondColorInt);\n      int secondGreen = Color.green(secondColorInt);\n      int secondBlue = Color.blue(secondColorInt);\n      mse +=\n          ((firstRed - secondRed) * (firstRed - secondRed)\n              + (firstGreen - secondGreen) * (firstGreen - secondGreen)\n              + (firstBlue - secondBlue) * (firstBlue - secondBlue));\n    }\n  }\n  double normalizedMse =\n      mse / (255.0 * 255.0 * 3.0 * firstBitmap.getWidth() * firstBitmap.getHeight());\n  return 10 * Math.log10(1.0 / normalizedMse);\n}",
        "summary_tokens": [
            "calculates",
            "the",
            "peak",
            "signal",
            "to",
            "noise",
            "ratio",
            "value",
            "for",
            "0",
            "bitmaps"
        ]
    },
    {
        "id": 2824,
        "code": "public static Uri buildAssetUri(String assetPath) {\n  return Uri.parse(\"asset:///\" + assetPath);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "uri",
            "for",
            "the",
            "given",
            "asset",
            "path"
        ]
    },
    {
        "id": 2825,
        "code": "public static SeekMap extractSeekMap(\n    Extractor extractor, FakeExtractorOutput output, DataSource dataSource, Uri uri)\n    throws IOException {\n  ExtractorInput input = getExtractorInputFromPosition(dataSource,  0, uri);\n  extractor.init(output);\n  PositionHolder positionHolder = new PositionHolder();\n  int readResult = Extractor.RESULT_CONTINUE;\n  while (true) {\n    try {\n        \n      while (readResult == Extractor.RESULT_CONTINUE\n          && (output.seekMap == null || !output.tracksEnded)) {\n        readResult = extractor.read(input, positionHolder);\n      }\n      for (int i = 0; i < output.trackOutputs.size(); i++) {\n        int trackId = output.trackOutputs.keyAt(i);\n        while (readResult == Extractor.RESULT_CONTINUE\n            && output.trackOutputs.get(trackId).lastFormat == null) {\n          readResult = extractor.read(input, positionHolder);\n        }\n      }\n    } finally {\n      DataSourceUtil.closeQuietly(dataSource);\n    }\n\n    if (readResult == Extractor.RESULT_SEEK) {\n      input = getExtractorInputFromPosition(dataSource, positionHolder.position, uri);\n      readResult = Extractor.RESULT_CONTINUE;\n    } else if (readResult == Extractor.RESULT_END_OF_INPUT) {\n      throw new IOException(\"EOF encountered without seekmap\");\n    }\n    if (output.seekMap != null) {\n      return output.seekMap;\n    }\n  }\n}",
        "summary_tokens": [
            "reads",
            "from",
            "the",
            "given",
            "input",
            "using",
            "the",
            "given",
            "extractor",
            "until",
            "it",
            "can",
            "produce",
            "the",
            "seek",
            "map",
            "and",
            "all",
            "of",
            "the",
            "track",
            "formats",
            "have",
            "been",
            "identified",
            "or",
            "until",
            "the",
            "extractor",
            "encounters",
            "eof"
        ]
    },
    {
        "id": 2826,
        "code": "public static FakeExtractorOutput extractAllSamplesFromFile(\n    Extractor extractor, Context context, String fileName) throws IOException {\n  byte[] data = TestUtil.getByteArray(context, fileName);\n  FakeExtractorOutput expectedOutput = new FakeExtractorOutput();\n  extractor.init(expectedOutput);\n  FakeExtractorInput input = new FakeExtractorInput.Builder().setData(data).build();\n\n  PositionHolder positionHolder = new PositionHolder();\n  int readResult = Extractor.RESULT_CONTINUE;\n  while (readResult != Extractor.RESULT_END_OF_INPUT) {\n    while (readResult == Extractor.RESULT_CONTINUE) {\n      readResult = extractor.read(input, positionHolder);\n    }\n    if (readResult == Extractor.RESULT_SEEK) {\n      input.setPosition((int) positionHolder.position);\n      readResult = Extractor.RESULT_CONTINUE;\n    }\n  }\n  return expectedOutput;\n}",
        "summary_tokens": [
            "extracts",
            "all",
            "samples",
            "from",
            "the",
            "given",
            "file",
            "into",
            "a",
            "fake",
            "track",
            "output"
        ]
    },
    {
        "id": 2827,
        "code": "public static int seekToTimeUs(\n    Extractor extractor,\n    SeekMap seekMap,\n    long seekTimeUs,\n    DataSource dataSource,\n    FakeTrackOutput trackOutput,\n    Uri uri)\n    throws IOException {\n  int numSampleBeforeSeek = trackOutput.getSampleCount();\n  SeekMap.SeekPoints seekPoints = seekMap.getSeekPoints(seekTimeUs);\n\n  long initialSeekLoadPosition = seekPoints.first.position;\n  extractor.seek(initialSeekLoadPosition, seekTimeUs);\n\n  PositionHolder positionHolder = new PositionHolder();\n  positionHolder.position = C.POSITION_UNSET;\n  ExtractorInput extractorInput =\n      TestUtil.getExtractorInputFromPosition(dataSource, initialSeekLoadPosition, uri);\n  int extractorReadResult = Extractor.RESULT_CONTINUE;\n  while (true) {\n    try {\n        \n      while (extractorReadResult == Extractor.RESULT_CONTINUE\n          && trackOutput.getSampleCount() == numSampleBeforeSeek) {\n        extractorReadResult = extractor.read(extractorInput, positionHolder);\n      }\n    } finally {\n      DataSourceUtil.closeQuietly(dataSource);\n    }\n\n    if (extractorReadResult == Extractor.RESULT_SEEK) {\n      extractorInput =\n          TestUtil.getExtractorInputFromPosition(dataSource, positionHolder.position, uri);\n      extractorReadResult = Extractor.RESULT_CONTINUE;\n    } else if (extractorReadResult == Extractor.RESULT_END_OF_INPUT\n        && trackOutput.getSampleCount() == numSampleBeforeSeek) {\n      return C.INDEX_UNSET;\n    } else if (trackOutput.getSampleCount() > numSampleBeforeSeek) {\n        \n      return numSampleBeforeSeek;\n    }\n  }\n}",
        "summary_tokens": [
            "seeks",
            "to",
            "the",
            "given",
            "seek",
            "time",
            "of",
            "the",
            "stream",
            "from",
            "the",
            "given",
            "input",
            "and",
            "keeps",
            "reading",
            "from",
            "the",
            "input",
            "until",
            "we",
            "can",
            "extract",
            "at",
            "least",
            "one",
            "sample",
            "following",
            "the",
            "seek",
            "position",
            "or",
            "until",
            "end",
            "of",
            "input",
            "is",
            "reached"
        ]
    },
    {
        "id": 2828,
        "code": "public static ExtractorInput getExtractorInputFromPosition(\n    DataSource dataSource, long position, Uri uri) throws IOException {\n  DataSpec dataSpec = new DataSpec(uri, position, C.LENGTH_UNSET);\n  long length = dataSource.open(dataSpec);\n  if (length != C.LENGTH_UNSET) {\n    length += position;\n  }\n  return new DefaultExtractorInput(dataSource, position, length);\n}",
        "summary_tokens": [
            "returns",
            "an",
            "extractor",
            "input",
            "to",
            "read",
            "from",
            "the",
            "given",
            "input",
            "at",
            "given",
            "position"
        ]
    },
    {
        "id": 2829,
        "code": "public static MetadataInputBuffer createMetadataInputBuffer(byte[] data) {\n  MetadataInputBuffer buffer = new MetadataInputBuffer();\n  buffer.data = ByteBuffer.allocate(data.length).put(data);\n  buffer.data.flip();\n  return buffer;\n}",
        "summary_tokens": [
            "create",
            "a",
            "new",
            "metadata",
            "input",
            "buffer",
            "and",
            "copy",
            "data",
            "into",
            "the",
            "backing",
            "byte",
            "buffer"
        ]
    },
    {
        "id": 2830,
        "code": "public static List<Method> getPublicMethods(Class<?> clazz) {\n    \n  Queue<Class<?>> supertypeQueue = new ArrayDeque<>();\n  supertypeQueue.add(clazz);\n  Set<Class<?>> supertypes = new HashSet<>();\n  Object object = new Object();\n  while (!supertypeQueue.isEmpty()) {\n    Class<?> currentSupertype = supertypeQueue.remove();\n    if (supertypes.add(currentSupertype)) {\n      @Nullable Class<?> superclass = currentSupertype.getSuperclass();\n      if (superclass != null && !superclass.isInstance(object)) {\n        supertypeQueue.add(superclass);\n      }\n\n      Collections.addAll(supertypeQueue, currentSupertype.getInterfaces());\n    }\n  }\n\n  List<Method> list = new ArrayList<>();\n  for (Class<?> supertype : supertypes) {\n    for (Method method : supertype.getDeclaredMethods()) {\n      if (Modifier.isPublic(method.getModifiers())) {\n        list.add(method);\n      }\n    }\n  }\n\n  return list;\n}",
        "summary_tokens": [
            "returns",
            "all",
            "the",
            "public",
            "methods",
            "of",
            "a",
            "java",
            "class",
            "except",
            "those",
            "defined",
            "by",
            "object"
        ]
    },
    {
        "id": 2831,
        "code": "public static void assertEmpty(Timeline timeline) {\n  assertWindowTags(timeline);\n  assertPeriodCounts(timeline);\n  for (boolean shuffled : new boolean[] {false, true}) {\n    assertThat(timeline.getFirstWindowIndex(shuffled)).isEqualTo(C.INDEX_UNSET);\n    assertThat(timeline.getLastWindowIndex(shuffled)).isEqualTo(C.INDEX_UNSET);\n  }\n}",
        "summary_tokens": [
            "assert",
            "that",
            "timeline",
            "is",
            "empty",
            "i"
        ]
    },
    {
        "id": 2832,
        "code": "public static void assertWindowTags(\n    Timeline timeline, @NullableType Object... expectedWindowTags) {\n  Window window = new Window();\n  assertThat(timeline.getWindowCount()).isEqualTo(expectedWindowTags.length);\n  for (int i = 0; i < timeline.getWindowCount(); i++) {\n    timeline.getWindow(i, window);\n    if (expectedWindowTags[i] != null) {\n      MediaItem.LocalConfiguration localConfiguration = window.mediaItem.localConfiguration;\n      assertThat(localConfiguration).isNotNull();\n      assertThat(Util.castNonNull(localConfiguration).tag).isEqualTo(expectedWindowTags[i]);\n    }\n  }\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "window",
            "tags",
            "are",
            "set",
            "correctly"
        ]
    },
    {
        "id": 2833,
        "code": "public static void assertWindowIsDynamic(Timeline timeline, boolean... windowIsDynamic) {\n  Window window = new Window();\n  for (int i = 0; i < timeline.getWindowCount(); i++) {\n    timeline.getWindow(i, window);\n    assertThat(window.isDynamic).isEqualTo(windowIsDynamic[i]);\n  }\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "window",
            "properties",
            "window"
        ]
    },
    {
        "id": 2834,
        "code": "public static void assertPreviousWindowIndices(\n    Timeline timeline,\n    @Player.RepeatMode int repeatMode,\n    boolean shuffleModeEnabled,\n    int... expectedPreviousWindowIndices) {\n  for (int i = 0; i < timeline.getWindowCount(); i++) {\n    assertThat(timeline.getPreviousWindowIndex(i, repeatMode, shuffleModeEnabled))\n        .isEqualTo(expectedPreviousWindowIndices[i]);\n  }\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "previous",
            "window",
            "indices",
            "for",
            "each",
            "window",
            "depending",
            "on",
            "the",
            "repeat",
            "mode",
            "and",
            "the",
            "shuffle",
            "mode",
            "are",
            "equal",
            "to",
            "the",
            "given",
            "sequence"
        ]
    },
    {
        "id": 2835,
        "code": "public static void assertNextWindowIndices(\n    Timeline timeline,\n    @Player.RepeatMode int repeatMode,\n    boolean shuffleModeEnabled,\n    int... expectedNextWindowIndices) {\n  for (int i = 0; i < timeline.getWindowCount(); i++) {\n    assertThat(timeline.getNextWindowIndex(i, repeatMode, shuffleModeEnabled))\n        .isEqualTo(expectedNextWindowIndices[i]);\n  }\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "next",
            "window",
            "indices",
            "for",
            "each",
            "window",
            "depending",
            "on",
            "the",
            "repeat",
            "mode",
            "and",
            "the",
            "shuffle",
            "mode",
            "are",
            "equal",
            "to",
            "the",
            "given",
            "sequence"
        ]
    },
    {
        "id": 2836,
        "code": "public static void assertEqualPreviousWindowIndices(\n    Timeline expectedTimeline,\n    Timeline actualTimeline,\n    @Player.RepeatMode int repeatMode,\n    boolean shuffleModeEnabled) {\n  for (int windowIndex = 0; windowIndex < actualTimeline.getWindowCount(); windowIndex++) {\n    assertThat(actualTimeline.getPreviousWindowIndex(windowIndex, repeatMode, shuffleModeEnabled))\n        .isEqualTo(\n            expectedTimeline.getPreviousWindowIndex(windowIndex, repeatMode, shuffleModeEnabled));\n  }\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "previous",
            "window",
            "indices",
            "for",
            "each",
            "window",
            "of",
            "the",
            "actual",
            "timeline",
            "are",
            "equal",
            "to",
            "the",
            "indices",
            "of",
            "the",
            "expected",
            "timeline",
            "depending",
            "on",
            "the",
            "repeat",
            "mode",
            "and",
            "the",
            "shuffle",
            "mode"
        ]
    },
    {
        "id": 2837,
        "code": "public static void assertEqualNextWindowIndices(\n    Timeline expectedTimeline,\n    Timeline actualTimeline,\n    @Player.RepeatMode int repeatMode,\n    boolean shuffleModeEnabled) {\n  for (int windowIndex = 0; windowIndex < actualTimeline.getWindowCount(); windowIndex++) {\n    assertThat(actualTimeline.getNextWindowIndex(windowIndex, repeatMode, shuffleModeEnabled))\n        .isEqualTo(\n            expectedTimeline.getNextWindowIndex(windowIndex, repeatMode, shuffleModeEnabled));\n  }\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "next",
            "window",
            "indices",
            "for",
            "each",
            "window",
            "of",
            "the",
            "actual",
            "timeline",
            "are",
            "equal",
            "to",
            "the",
            "indices",
            "of",
            "the",
            "expected",
            "timeline",
            "depending",
            "on",
            "the",
            "repeat",
            "mode",
            "and",
            "the",
            "shuffle",
            "mode"
        ]
    },
    {
        "id": 2838,
        "code": "public static void assertPeriodDurations(Timeline timeline, long... durationsUs) {\n  int periodCount = timeline.getPeriodCount();\n  assertThat(periodCount).isEqualTo(durationsUs.length);\n  Period period = new Period();\n  for (int i = 0; i < periodCount; i++) {\n    assertThat(timeline.getPeriod(i, period).durationUs).isEqualTo(durationsUs[i]);\n  }\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "the",
            "durations",
            "of",
            "the",
            "periods",
            "in",
            "the",
            "timeline",
            "and",
            "the",
            "durations",
            "in",
            "the",
            "given",
            "sequence",
            "are",
            "equal"
        ]
    },
    {
        "id": 2839,
        "code": "public static void assertPeriodCounts(Timeline timeline, int... expectedPeriodCounts) {\n  int windowCount = timeline.getWindowCount();\n  assertThat(windowCount).isEqualTo(expectedPeriodCounts.length);\n  int[] accumulatedPeriodCounts = new int[windowCount + 1];\n  accumulatedPeriodCounts[0] = 0;\n  for (int i = 0; i < windowCount; i++) {\n    accumulatedPeriodCounts[i + 1] = accumulatedPeriodCounts[i] + expectedPeriodCounts[i];\n  }\n  assertThat(timeline.getPeriodCount())\n      .isEqualTo(accumulatedPeriodCounts[accumulatedPeriodCounts.length - 1]);\n  Window window = new Window();\n  Period period = new Period();\n  for (int i = 0; i < windowCount; i++) {\n    timeline.getWindow(i, window);\n    assertThat(window.firstPeriodIndex).isEqualTo(accumulatedPeriodCounts[i]);\n    assertThat(window.lastPeriodIndex).isEqualTo(accumulatedPeriodCounts[i + 1] - 1);\n  }\n  int expectedWindowIndex = 0;\n  for (int i = 0; i < timeline.getPeriodCount(); i++) {\n    timeline.getPeriod(i, period, true);\n    while (i >= accumulatedPeriodCounts[expectedWindowIndex + 1]) {\n      expectedWindowIndex++;\n    }\n    assertThat(period.windowIndex).isEqualTo(expectedWindowIndex);\n    Object periodUid = Assertions.checkNotNull(period.uid);\n    assertThat(timeline.getIndexOfPeriod(periodUid)).isEqualTo(i);\n    assertThat(timeline.getUidOfPeriod(i)).isEqualTo(periodUid);\n    for (int repeatMode : REPEAT_MODES) {\n      if (i < accumulatedPeriodCounts[expectedWindowIndex + 1] - 1) {\n        assertThat(timeline.getNextPeriodIndex(i, period, window, repeatMode, false))\n            .isEqualTo(i + 1);\n      } else {\n        int nextWindow = timeline.getNextWindowIndex(expectedWindowIndex, repeatMode, false);\n        int nextPeriod =\n            nextWindow == C.INDEX_UNSET ? C.INDEX_UNSET : accumulatedPeriodCounts[nextWindow];\n        assertThat(timeline.getNextPeriodIndex(i, period, window, repeatMode, false))\n            .isEqualTo(nextPeriod);\n      }\n    }\n  }\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "period",
            "counts",
            "for",
            "each",
            "window",
            "are",
            "set",
            "correctly"
        ]
    },
    {
        "id": 2840,
        "code": "public static void assertAdGroupCounts(Timeline timeline, int... expectedAdGroupCounts) {\n  Period period = new Period();\n  for (int i = 0; i < timeline.getPeriodCount(); i++) {\n    timeline.getPeriod(i, period);\n    assertThat(period.getAdGroupCount()).isEqualTo(expectedAdGroupCounts[i]);\n  }\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "periods",
            "period",
            "get",
            "ad",
            "group",
            "count",
            "are",
            "set",
            "correctly"
        ]
    },
    {
        "id": 2841,
        "code": "public static void assertEqualsExceptIdsAndManifest(\n    Timeline expectedTimeline, Timeline actualTimeline) {\n  assertThat(actualTimeline.getWindowCount()).isEqualTo(expectedTimeline.getWindowCount());\n  for (int i = 0; i < actualTimeline.getWindowCount(); i++) {\n    Window expectedWindow = new Window();\n    Window actualWindow = new Window();\n    assertWindowEqualsExceptUidAndManifest(\n        expectedTimeline.getWindow(i, expectedWindow,  0),\n        actualTimeline.getWindow(i, actualWindow,  0));\n  }\n  assertThat(actualTimeline.getPeriodCount()).isEqualTo(expectedTimeline.getPeriodCount());\n  for (int i = 0; i < actualTimeline.getPeriodCount(); i++) {\n    Period expectedPeriod = new Period();\n    Period actualPeriod = new Period();\n    assertPeriodEqualsExceptIds(\n        expectedTimeline.getPeriod(i, expectedPeriod,  false),\n        actualTimeline.getPeriod(i, actualPeriod,  false));\n  }\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "timeline",
            "timelines",
            "are",
            "equal",
            "except",
            "window",
            "uid",
            "window",
            "manifest",
            "period",
            "id",
            "and",
            "period",
            "uid"
        ]
    },
    {
        "id": 2842,
        "code": "public static void assertWindowEqualsExceptUidAndManifest(\n    Window expectedWindow, Window actualWindow) {\n  Object uid = expectedWindow.uid;\n  @Nullable Object manifest = expectedWindow.manifest;\n  try {\n    expectedWindow.uid = actualWindow.uid;\n    expectedWindow.manifest = actualWindow.manifest;\n    assertThat(actualWindow).isEqualTo(expectedWindow);\n  } finally {\n    expectedWindow.uid = uid;\n    expectedWindow.manifest = manifest;\n  }\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "window",
            "windows",
            "are",
            "equal",
            "except",
            "window",
            "uid",
            "and",
            "window",
            "manifest"
        ]
    },
    {
        "id": 2843,
        "code": "public static void assertPeriodEqualsExceptIds(Period expectedPeriod, Period actualPeriod) {\n  @Nullable Object id = expectedPeriod.id;\n  @Nullable Object uid = expectedPeriod.uid;\n  try {\n    expectedPeriod.id = actualPeriod.id;\n    expectedPeriod.uid = actualPeriod.uid;\n    assertThat(actualPeriod).isEqualTo(expectedPeriod);\n  } finally {\n    expectedPeriod.id = id;\n    expectedPeriod.uid = uid;\n  }\n}",
        "summary_tokens": [
            "asserts",
            "that",
            "period",
            "periods",
            "are",
            "equal",
            "except",
            "period",
            "id",
            "and",
            "period",
            "uid"
        ]
    }
]