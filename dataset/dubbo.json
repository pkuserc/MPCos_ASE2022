[
    {
        "id": 1,
        "code": "static Optional<List<Configurator>> toConfigurators(List<URL> urls) {\n    if (CollectionUtils.isEmpty(urls)) {\n        return Optional.empty();\n    }\n\n    ConfiguratorFactory configuratorFactory = urls.get(0).getOrDefaultApplicationModel().getExtensionLoader(ConfiguratorFactory.class)\n            .getAdaptiveExtension();\n\n    List<Configurator> configurators = new ArrayList<>(urls.size());\n    for (URL url : urls) {\n        if (EMPTY_PROTOCOL.equals(url.getProtocol())) {\n            configurators.clear();\n            break;\n        }\n        Map<String, String> override = new HashMap<>(url.getParameters());\n            \n        override.remove(ANYHOST_KEY);\n        if (CollectionUtils.isEmptyMap(override)) {\n            continue;\n        }\n        configurators.add(configuratorFactory.getConfigurator(url));\n    }\n    Collections.sort(configurators);\n    return Optional.of(configurators);\n}",
        "summary_tokens": [
            "convert",
            "override",
            "urls",
            "to",
            "map",
            "for",
            "use",
            "when",
            "re",
            "refer"
        ]
    },
    {
        "id": 2,
        "code": "default int compareTo(Configurator o) {\n    if (o == null) {\n        return -1;\n    }\n\n    int ipCompare = getUrl().getHost().compareTo(o.getUrl().getHost());\n        \n    if (ipCompare == 0) {\n        int i = getUrl().getParameter(PRIORITY_KEY, 0);\n        int j = o.getUrl().getParameter(PRIORITY_KEY, 0);\n        return Integer.compare(i, j);\n    } else {\n        return ipCompare;\n    }\n}",
        "summary_tokens": [
            "sort",
            "by",
            "host",
            "then",
            "by",
            "priority",
            "0"
        ]
    },
    {
        "id": 3,
        "code": "default <T> RouterResult<Invoker<T>> route(List<Invoker<T>> invokers, URL url, Invocation invocation,\n                                                 boolean needToPrintMessage) throws RpcException {\n    return new RouterResult<>(route(invokers, url, invocation));\n}",
        "summary_tokens": [
            "this",
            "method",
            "can",
            "return",
            "the",
            "state",
            "of",
            "whether",
            "router",
            "chain",
            "needed",
            "to",
            "continue",
            "route"
        ]
    },
    {
        "id": 4,
        "code": "default <T> void notify(List<Invoker<T>> invokers) {\n\n}",
        "summary_tokens": [
            "notify",
            "the",
            "router",
            "the",
            "invoker",
            "list"
        ]
    },
    {
        "id": 5,
        "code": "public void initWithRouters(List<Router> builtinRouters) {\n    this.builtinRouters = builtinRouters;\n    this.routers = new LinkedList<>(builtinRouters);\n}",
        "summary_tokens": [
            "the",
            "resident",
            "routers",
            "must",
            "being",
            "initialized",
            "before",
            "address",
            "notification"
        ]
    },
    {
        "id": 6,
        "code": "public void addRouters(List<Router> routers) {\n    List<Router> newRouters = new LinkedList<>();\n    newRouters.addAll(builtinRouters);\n    newRouters.addAll(routers);\n    CollectionUtils.sort(newRouters);\n    this.routers = newRouters;\n}",
        "summary_tokens": [
            "if",
            "we",
            "use",
            "route",
            "protocol",
            "in",
            "version",
            "before",
            "0"
        ]
    },
    {
        "id": 7,
        "code": "private void printRouterSnapshot(URL url, BitList<Invoker<T>> availableInvokers, Invocation invocation) {\n    if (logger.isWarnEnabled()) {\n        logRouterSnapshot(url, invocation, buildRouterSnapshot(url, availableInvokers, invocation));\n    }\n}",
        "summary_tokens": [
            "store",
            "each",
            "router",
            "s",
            "input",
            "and",
            "output",
            "log",
            "out",
            "if",
            "empty"
        ]
    },
    {
        "id": 8,
        "code": "public RouterSnapshotNode<T> buildRouterSnapshot(URL url, BitList<Invoker<T>> availableInvokers, Invocation invocation) {\n    BitList<Invoker<T>> resultInvokers = availableInvokers.clone();\n    RouterSnapshotNode<T> parentNode = new RouterSnapshotNode<T>(\"Parent\", resultInvokers.clone());\n    parentNode.setNodeOutputInvokers(resultInvokers.clone());\n\n        \n    Holder<RouterSnapshotNode<T>> nodeHolder = new Holder<>();\n    nodeHolder.set(parentNode);\n\n    resultInvokers = headStateRouter.route(resultInvokers, url, invocation, true, nodeHolder);\n\n        \n    if (routers.isEmpty() || (resultInvokers.isEmpty() && shouldFailFast)) {\n        parentNode.setChainOutputInvokers(resultInvokers.clone());\n        return parentNode;\n    }\n\n    RouterSnapshotNode<T> commonRouterNode = new RouterSnapshotNode<T>(\"CommonRouter\", resultInvokers.clone());\n    parentNode.appendNode(commonRouterNode);\n    List<Invoker<T>> commonRouterResult = resultInvokers;\n\n        \n    for (Router router : routers) {\n            \n        List<Invoker<T>> inputInvokers = new ArrayList<>(commonRouterResult);\n\n        RouterSnapshotNode<T> currentNode = new RouterSnapshotNode<T>(router.getClass().getSimpleName(), inputInvokers);\n\n            \n        commonRouterNode.appendNode(currentNode);\n        commonRouterNode = currentNode;\n\n        RouterResult<Invoker<T>> routeStateResult = router.route(inputInvokers, url, invocation, true);\n        List<Invoker<T>> routeResult = routeStateResult.getResult();\n        String routerMessage = routeStateResult.getMessage();\n\n        currentNode.setNodeOutputInvokers(routeResult);\n        currentNode.setRouterMessage(routerMessage);\n\n        commonRouterResult = routeResult;\n\n            \n        if (CollectionUtils.isEmpty(routeResult) && shouldFailFast) {\n            break;\n        }\n\n        if (!routeStateResult.isNeedContinueRoute()) {\n            break;\n        }\n    }\n    commonRouterNode.setChainOutputInvokers(commonRouterNode.getNodeOutputInvokers());\n\n        \n    RouterSnapshotNode<T> currentNode = commonRouterNode;\n    while (currentNode != null){\n        RouterSnapshotNode<T> parent = currentNode.getParentNode();\n        if (parent != null) {\n                \n            parent.setChainOutputInvokers(currentNode.getChainOutputInvokers());\n        }\n        currentNode = parent;\n    }\n    return parentNode;\n}",
        "summary_tokens": [
            "build",
            "each",
            "router",
            "s",
            "result"
        ]
    },
    {
        "id": 9,
        "code": "public void setInvokers(BitList<Invoker<T>> invokers) {\n    this.invokers = (invokers == null ? BitList.emptyList() : invokers);\n    routers.forEach(router -> router.notify(this.invokers));\n    stateRouters.forEach(router -> router.notify(this.invokers));\n}",
        "summary_tokens": [
            "notify",
            "router",
            "chain",
            "of",
            "the",
            "initial",
            "addresses",
            "from",
            "registry",
            "at",
            "the",
            "first",
            "time"
        ]
    },
    {
        "id": 10,
        "code": "public void refreshInvoker() {\n    if (invokersInitialized) {\n        refreshInvokerInternal();\n    }\n}",
        "summary_tokens": [
            "refresh",
            "invokers",
            "from",
            "total",
            "invokers",
            "0"
        ]
    },
    {
        "id": 11,
        "code": "public <T> Invoker<T> buildInvokerChain(final Invoker<T> originalInvoker, String key, String group) {\n    Invoker<T> last = originalInvoker;\n    URL url = originalInvoker.getUrl();\n    List<ModuleModel> moduleModels = getModuleModelsFromUrl(url);\n    List<Filter> filters;\n    if (moduleModels != null && moduleModels.size() == 1) {\n        filters = ScopeModelUtil.getExtensionLoader(Filter.class, moduleModels.get(0)).getActivateExtension(url, key, group);\n    } else if (moduleModels != null && moduleModels.size() > 1) {\n        filters = new ArrayList<>();\n        List<ExtensionDirector> directors = new ArrayList<>();\n        for (ModuleModel moduleModel : moduleModels) {\n            List<Filter> tempFilters = ScopeModelUtil.getExtensionLoader(Filter.class, moduleModel).getActivateExtension(url, key, group);\n            filters.addAll(tempFilters);\n            directors.add(moduleModel.getExtensionDirector());\n        }\n        filters = sortingAndDeduplication(filters, directors);\n\n    } else {\n        filters = ScopeModelUtil.getExtensionLoader(Filter.class, null).getActivateExtension(url, key, group);\n    }\n\n\n    if (!CollectionUtils.isEmpty(filters)) {\n        for (int i = filters.size() - 1; i >= 0; i--) {\n            final Filter filter = filters.get(i);\n            final Invoker<T> next = last;\n            last = new CopyOfFilterChainNode<>(originalInvoker, next, filter);\n        }\n        return new CallbackRegistrationInvoker<>(last, filters);\n    }\n\n    return last;\n}",
        "summary_tokens": [
            "build",
            "consumer",
            "provider",
            "filter",
            "chain"
        ]
    },
    {
        "id": 12,
        "code": "public <T> ClusterInvoker<T> buildClusterInvokerChain(final ClusterInvoker<T> originalInvoker, String key, String group) {\n    ClusterInvoker<T> last = originalInvoker;\n    URL url = originalInvoker.getUrl();\n    List<ModuleModel> moduleModels = getModuleModelsFromUrl(url);\n    List<ClusterFilter> filters;\n    if (moduleModels != null && moduleModels.size() == 1) {\n        filters = ScopeModelUtil.getExtensionLoader(ClusterFilter.class, moduleModels.get(0)).getActivateExtension(url, key, group);\n    } else if (moduleModels != null && moduleModels.size() > 1) {\n        filters = new ArrayList<>();\n        List<ExtensionDirector> directors = new ArrayList<>();\n        for (ModuleModel moduleModel : moduleModels) {\n            List<ClusterFilter> tempFilters = ScopeModelUtil.getExtensionLoader(ClusterFilter.class, moduleModel).getActivateExtension(url, key, group);\n            filters.addAll(tempFilters);\n            directors.add(moduleModel.getExtensionDirector());\n        }\n        filters = sortingAndDeduplication(filters, directors);\n\n    } else {\n        filters = ScopeModelUtil.getExtensionLoader(ClusterFilter.class, null).getActivateExtension(url, key, group);\n    }\n\n    if (!CollectionUtils.isEmpty(filters)) {\n        for (int i = filters.size() - 1; i >= 0; i--) {\n            final ClusterFilter filter = filters.get(i);\n            final Invoker<T> next = last;\n            last = new CopyOfClusterFilterChainNode<>(originalInvoker, next, filter);\n        }\n        return new ClusterCallbackRegistrationInvoker<>(originalInvoker, last, filters);\n    }\n\n    return last;\n}",
        "summary_tokens": [
            "build",
            "consumer",
            "cluster",
            "filter",
            "chain"
        ]
    },
    {
        "id": 13,
        "code": "private List<ModuleModel> getModuleModelsFromUrl(URL url) {\n    List<ModuleModel> moduleModels = null;\n    ScopeModel scopeModel = url.getScopeModel();\n    if (scopeModel instanceof ApplicationModel) {\n        moduleModels = ((ApplicationModel) scopeModel).getPubModuleModels();\n    } else if (scopeModel instanceof ModuleModel) {\n        moduleModels = new ArrayList<>();\n        moduleModels.add((ModuleModel) scopeModel);\n    }\n    return moduleModels;\n}",
        "summary_tokens": [
            "when",
            "the",
            "application",
            "level",
            "service",
            "registration",
            "and",
            "discovery",
            "strategy",
            "is",
            "adopted",
            "the",
            "url",
            "will",
            "be",
            "of",
            "type",
            "instance",
            "address",
            "url",
            "and",
            "instance",
            "address",
            "url",
            "belongs",
            "to",
            "the",
            "application",
            "layer",
            "and",
            "holds",
            "the",
            "application",
            "model",
            "but",
            "the",
            "filter",
            "is",
            "at",
            "the",
            "module",
            "layer",
            "and",
            "holds",
            "the",
            "module",
            "model",
            "so",
            "it",
            "needs",
            "to",
            "be",
            "based",
            "on",
            "the",
            "url",
            "in",
            "the",
            "scope",
            "model",
            "type",
            "to",
            "parse",
            "out",
            "all",
            "the",
            "module",
            "models",
            "held",
            "by",
            "the",
            "url",
            "to",
            "obtain",
            "the",
            "filter",
            "configuration"
        ]
    },
    {
        "id": 14,
        "code": "default void addListener(String key, ConfigurationListener listener) {\n    addListener(key, DEFAULT_GROUP, listener);\n}",
        "summary_tokens": [
            "add",
            "listener",
            "string",
            "string",
            "configuration",
            "listener"
        ]
    },
    {
        "id": 15,
        "code": "default void removeListener(String key, ConfigurationListener listener) {\n    removeListener(key, DEFAULT_GROUP, listener);\n}",
        "summary_tokens": [
            "remove",
            "listener",
            "string",
            "string",
            "configuration",
            "listener"
        ]
    },
    {
        "id": 16,
        "code": "default String getRule(String key, String group) {\n    return getRule(key, group, -1L);\n}",
        "summary_tokens": [
            "get",
            "the",
            "governance",
            "rule",
            "mapped",
            "to",
            "the",
            "given",
            "key",
            "and",
            "the",
            "given",
            "group"
        ]
    },
    {
        "id": 17,
        "code": "default Result intercept(AbstractClusterInvoker<?> clusterInvoker, Invocation invocation) throws RpcException {\n    return clusterInvoker.invoke(invocation);\n}",
        "summary_tokens": [
            "override",
            "this",
            "method",
            "or",
            "before",
            "abstract",
            "cluster",
            "invoker",
            "invocation",
            "and",
            "after",
            "abstract",
            "cluster",
            "invoker",
            "invocation",
            "methods",
            "to",
            "add",
            "your",
            "own",
            "logic",
            "expected",
            "to",
            "be",
            "executed",
            "before",
            "and",
            "after",
            "invoke"
        ]
    },
    {
        "id": 18,
        "code": "static int calculateWarmupWeight(int uptime, int warmup, int weight) {\n    int ww = (int) ( uptime / ((float) warmup / weight));\n    return ww < 1 ? 1 : (Math.min(ww, weight));\n}",
        "summary_tokens": [
            "calculate",
            "the",
            "weight",
            "according",
            "to",
            "the",
            "uptime",
            "proportion",
            "of",
            "warmup",
            "time",
            "the",
            "new",
            "weight",
            "will",
            "be",
            "within",
            "0",
            "inclusive",
            "to",
            "weight",
            "inclusive"
        ]
    },
    {
        "id": 19,
        "code": "protected int getWeight(Invoker<?> invoker, Invocation invocation) {\n    int weight;\n    URL url = invoker.getUrl();\n    if (invoker instanceof ClusterInvoker) {\n        url = ((ClusterInvoker<?>) invoker).getRegistryUrl();\n    }\n\n        \n    if (REGISTRY_SERVICE_REFERENCE_PATH.equals(url.getServiceInterface())) {\n        weight = url.getParameter(WEIGHT_KEY, DEFAULT_WEIGHT);\n    } else {\n        weight = url.getMethodParameter(invocation.getMethodName(), WEIGHT_KEY, DEFAULT_WEIGHT);\n        if (weight > 0) {\n            long timestamp = invoker.getUrl().getParameter(TIMESTAMP_KEY, 0L);\n            if (timestamp > 0L) {\n                long uptime = System.currentTimeMillis() - timestamp;\n                if (uptime < 0) {\n                    return 1;\n                }\n                int warmup = invoker.getUrl().getParameter(WARMUP_KEY, DEFAULT_WARMUP);\n                if (uptime > 0 && uptime < warmup) {\n                    weight = calculateWarmupWeight((int)uptime, warmup, weight);\n                }\n            }\n        }\n    }\n    return Math.max(weight, 0);\n}",
        "summary_tokens": [
            "get",
            "the",
            "weight",
            "of",
            "the",
            "invoker",
            "s",
            "invocation",
            "which",
            "takes",
            "warmup",
            "time",
            "into",
            "account",
            "if",
            "the",
            "uptime",
            "is",
            "within",
            "the",
            "warmup",
            "time",
            "the",
            "weight",
            "will",
            "be",
            "reduce",
            "proportionally"
        ]
    },
    {
        "id": 20,
        "code": "protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {\n        \n    int length = invokers.size();\n\n    if (!needWeightLoadBalance(invokers, invocation)) {\n        return invokers.get(ThreadLocalRandom.current().nextInt(length));\n    }\n\n        \n    boolean sameWeight = true;\n        \n    int[] weights = new int[length];\n        \n    int totalWeight = 0;\n    for (int i = 0; i < length; i++) {\n        int weight = getWeight(invokers.get(i), invocation);\n            \n        totalWeight += weight;\n            \n        weights[i] = totalWeight;\n        if (sameWeight && totalWeight != weight * (i + 1)) {\n            sameWeight = false;\n        }\n    }\n    if (totalWeight > 0 && !sameWeight) {\n            \n        int offset = ThreadLocalRandom.current().nextInt(totalWeight);\n            \n        for (int i = 0; i < length; i++) {\n            if (offset < weights[i]) {\n                return invokers.get(i);\n            }\n        }\n    }\n        \n    return invokers.get(ThreadLocalRandom.current().nextInt(length));\n}",
        "summary_tokens": [
            "select",
            "one",
            "invoker",
            "between",
            "a",
            "list",
            "using",
            "a",
            "random",
            "criteria"
        ]
    },
    {
        "id": 21,
        "code": "protected <T> Collection<String> getInvokerAddrList(List<Invoker<T>> invokers, Invocation invocation) {\n    String key = invokers.get(0).getUrl().getServiceKey() + \".\" + invocation.getMethodName();\n    Map<String, WeightedRoundRobin> map = methodWeightMap.get(key);\n    if (map != null) {\n        return map.keySet();\n    }\n    return null;\n}",
        "summary_tokens": [
            "get",
            "invoker",
            "addr",
            "list",
            "cached",
            "for",
            "specified",
            "invocation",
            "p",
            "b",
            "for",
            "unit",
            "test",
            "only",
            "b"
        ]
    },
    {
        "id": 22,
        "code": "public <T> Merger<T> getMerger(Class<T> returnType) {\n    if (returnType == null) {\n        throw new IllegalArgumentException(\"returnType is null\");\n    }\n\n    if (CollectionUtils.isEmptyMap(MERGER_CACHE)) {\n        loadMergers();\n    }\n    Merger merger = MERGER_CACHE.get(returnType);\n    if (merger == null && returnType.isArray()) {\n        merger = ArrayMerger.INSTANCE;\n    }\n    return merger;\n}",
        "summary_tokens": [
            "find",
            "the",
            "merger",
            "according",
            "to",
            "the",
            "return",
            "type",
            "class",
            "the",
            "merger",
            "will",
            "merge",
            "an",
            "array",
            "of",
            "return",
            "type",
            "into",
            "one"
        ]
    },
    {
        "id": 23,
        "code": "private Class<?> getActualTypeArgument(Class<? extends Merger> mergerCls) {\n    Class<?> superClass = mergerCls;\n    while (superClass != Object.class) {\n        Type[] interfaceTypes = superClass.getGenericInterfaces();\n        ParameterizedType mergerType;\n        for (Type it : interfaceTypes) {\n            if (it instanceof ParameterizedType\n                && (mergerType = ((ParameterizedType) it)).getRawType() == Merger.class) {\n                Type typeArg = mergerType.getActualTypeArguments()[0];\n                return TypeUtils.getRawClass(typeArg);\n            }\n        }\n\n        superClass = superClass.getSuperclass();\n    }\n\n    return null;\n}",
        "summary_tokens": [
            "get",
            "merger",
            "s",
            "actual",
            "type",
            "argument",
            "same",
            "as",
            "return",
            "type",
            "merger",
            "cls"
        ]
    },
    {
        "id": 24,
        "code": "public boolean matchArguments(Map.Entry<String, MatchPair> matchPair, Invocation invocation) {\n    try {\n            \n        String key = matchPair.getKey();\n        String[] expressArray = key.split(\"\\\\.\");\n        String argumentExpress = expressArray[0];\n        final Matcher matcher = ARGUMENTS_PATTERN.matcher(argumentExpress);\n        if (!matcher.find()) {\n            return false;\n        }\n\n            \n        int index = Integer.parseInt(matcher.group(1));\n        if (index < 0 || index > invocation.getArguments().length) {\n            return false;\n        }\n\n            \n        Object object = invocation.getArguments()[index];\n\n        if (matchPair.getValue().isMatch(String.valueOf(object), null)) {\n            return true;\n        }\n    } catch (Exception e) {\n        logger.warn(\"2-7\",\"condition state router arguments match failed\",\"\",\"Arguments match failed, matchPair[]\" + matchPair + \"] invocation[\" + invocation + \"]\",e);\n    }\n\n    return false;\n}",
        "summary_tokens": [
            "analysis",
            "the",
            "arguments",
            "in",
            "the",
            "rule"
        ]
    },
    {
        "id": 25,
        "code": "default boolean isEnable() {\n    return false;\n}",
        "summary_tokens": [
            "whether",
            "current",
            "environment",
            "support",
            "listen"
        ]
    },
    {
        "id": 26,
        "code": "protected List<DubboRouteDestination> getDubboRouteDestination(DubboRoute dubboRoute, Invocation invocation) {\n    List<DubboRouteDetail> dubboRouteDetailList = dubboRoute.getRoutedetail();\n    if (CollectionUtils.isNotEmpty(dubboRouteDetailList)) {\n        for (DubboRouteDetail dubboRouteDetail : dubboRouteDetailList) {\n            List<DubboMatchRequest> matchRequestList = dubboRouteDetail.getMatch();\n            if (CollectionUtils.isEmpty(matchRequestList)) {\n                return dubboRouteDetail.getRoute();\n            }\n\n            if (matchRequestList.stream().allMatch(\n                request -> request.isMatch(invocation, sourcesLabels, tracingContextProviders))) {\n                return dubboRouteDetail.getRoute();\n            }\n        }\n    }\n\n    return null;\n}",
        "summary_tokens": [
            "match",
            "route",
            "detail",
            "by",
            "params"
        ]
    },
    {
        "id": 27,
        "code": "protected DubboRoute getDubboRoute(VirtualServiceRule virtualServiceRule, Invocation invocation) {\n    String serviceName = invocation.getServiceName();\n\n    VirtualServiceSpec spec = virtualServiceRule.getSpec();\n    List<DubboRoute> dubboRouteList = spec.getDubbo();\n    if (CollectionUtils.isNotEmpty(dubboRouteList)) {\n        for (DubboRoute dubboRoute : dubboRouteList) {\n            List<StringMatch> stringMatchList = dubboRoute.getServices();\n            if (CollectionUtils.isEmpty(stringMatchList)) {\n                return dubboRoute;\n            }\n            for (StringMatch stringMatch : stringMatchList) {\n                if (stringMatch.isMatch(serviceName)) {\n                    return dubboRoute;\n                }\n            }\n        }\n    }\n    return null;\n}",
        "summary_tokens": [
            "match",
            "virtual",
            "service",
            "by",
            "service",
            "name"
        ]
    },
    {
        "id": 28,
        "code": "protected String randomSelectDestination(MeshRuleCache<T> meshRuleCache, String appName, List<DubboRouteDestination> routeDestination, BitList<Invoker<T>> availableInvokers) throws RpcException {\n        \n    int totalWeight = 0;\n    for (DubboRouteDestination dubboRouteDestination : routeDestination) {\n        totalWeight += Math.max(dubboRouteDestination.getWeight(), 1);\n    }\n    int target = ThreadLocalRandom.current().nextInt(totalWeight);\n    for (DubboRouteDestination destination : routeDestination) {\n        target -= Math.max(destination.getWeight(), 1);\n        if (target <= 0) {\n                \n            String result = computeDestination(meshRuleCache, appName, destination.getDestination(), availableInvokers);\n            if (result != null) {\n                return result;\n            }\n        }\n    }\n\n        \n    for (DubboRouteDestination destination : routeDestination) {\n        String result = computeDestination(meshRuleCache, appName, destination.getDestination(), availableInvokers);\n        if (result != null) {\n            return result;\n        }\n    }\n    return null;\n}",
        "summary_tokens": [
            "find",
            "out",
            "target",
            "invokers",
            "from",
            "route",
            "destination"
        ]
    },
    {
        "id": 29,
        "code": "private String getRule(URL url) {\n    String vRule = url.getParameterAndDecoded(RULE_KEY);\n    if (StringUtils.isEmpty(vRule)) {\n        throw new IllegalStateException(\"route rule can not be empty.\");\n    }\n    return vRule;\n}",
        "summary_tokens": [
            "get",
            "rule",
            "from",
            "url",
            "parameters"
        ]
    },
    {
        "id": 30,
        "code": "private ScriptEngine getEngine(URL url) {\n    String type = url.getParameter(TYPE_KEY, DEFAULT_SCRIPT_TYPE_KEY);\n\n    return ENGINES.computeIfAbsent(type, t -> {\n        ScriptEngine scriptEngine = new ScriptEngineManager().getEngineByName(type);\n        if (scriptEngine == null) {\n            throw new IllegalStateException(\"unsupported route engine type: \" + type);\n        }\n        return scriptEngine;\n    });\n}",
        "summary_tokens": [
            "create",
            "script",
            "engine",
            "instance",
            "by",
            "type",
            "from",
            "url",
            "parameters",
            "then",
            "cache",
            "it"
        ]
    },
    {
        "id": 31,
        "code": "protected BitList<Invoker<T>> getRoutedInvokers(BitList<Invoker<T>> invokers, Object obj) {\n    BitList<Invoker<T>> result = invokers.clone();\n    if (obj instanceof Invoker[]) {\n        result.retainAll(Arrays.asList((Invoker<T>[]) obj));\n    } else if (obj instanceof Object[]) {\n        result.retainAll(Arrays.stream((Object[]) obj).map(item -> (Invoker<T>) item).collect(Collectors.toList()));\n    } else {\n        result.retainAll((List<Invoker<T>>) obj);\n    }\n    return result;\n}",
        "summary_tokens": [
            "get",
            "routed",
            "invokers",
            "from",
            "result",
            "of",
            "script",
            "rule",
            "evaluation"
        ]
    },
    {
        "id": 32,
        "code": "private Bindings createBindings(List<Invoker<T>> invokers, Invocation invocation) {\n    Bindings bindings = engine.createBindings();\n        \n    bindings.put(\"invokers\", new ArrayList<>(invokers));\n    bindings.put(\"invocation\", invocation);\n    bindings.put(\"context\", RpcContext.getClientAttachment());\n    return bindings;\n}",
        "summary_tokens": [
            "create",
            "bindings",
            "for",
            "script",
            "engine"
        ]
    },
    {
        "id": 33,
        "code": "protected final BitList<Invoker<T>> continueRoute(BitList<Invoker<T>> invokers, URL url, Invocation invocation,\n                                                  boolean needToPrintMessage, Holder<RouterSnapshotNode<T>> nodeHolder) {\n    if (nextRouter != null) {\n        return nextRouter.route(invokers, url, invocation, needToPrintMessage, nodeHolder);\n    } else {\n        return invokers;\n    }\n}",
        "summary_tokens": [
            "call",
            "next",
            "router",
            "to",
            "get",
            "result"
        ]
    },
    {
        "id": 34,
        "code": "protected boolean supportContinueRoute() {\n    return false;\n}",
        "summary_tokens": [
            "whether",
            "current",
            "router",
            "s",
            "implementation",
            "support",
            "call",
            "abstract",
            "state",
            "router",
            "continue",
            "route",
            "bit",
            "list",
            "url",
            "invocation",
            "boolean",
            "holder",
            "by",
            "router",
            "itself"
        ]
    },
    {
        "id": 35,
        "code": "public final void setNextRouter(StateRouter<T> nextRouter) {\n    this.nextRouter = nextRouter;\n}",
        "summary_tokens": [
            "next",
            "router",
            "node",
            "state",
            "is",
            "maintained",
            "by",
            "abstract",
            "state",
            "router",
            "and",
            "this",
            "method",
            "is",
            "not",
            "allow",
            "to",
            "override"
        ]
    },
    {
        "id": 36,
        "code": "public BitList<E> and(BitList<E> target) {\n    rootSet.and(target.rootSet);\n    return this;\n}",
        "summary_tokens": [
            "and",
            "operation",
            "between",
            "two",
            "bit",
            "list"
        ]
    },
    {
        "id": 37,
        "code": "public boolean add(E e) {\n    int index = originList.indexOf(e);\n    if (index > -1) {\n        rootSet.set(index);\n        return true;\n    } else {\n        if (tailList == null) {\n            tailList = new LinkedList<>();\n        }\n        return tailList.add(e);\n    }\n}",
        "summary_tokens": [
            "if",
            "the",
            "element",
            "to",
            "added",
            "is",
            "appeared",
            "in",
            "origin",
            "list",
            "even",
            "if",
            "it",
            "is",
            "not",
            "in",
            "root",
            "set",
            "directly",
            "set",
            "its",
            "index",
            "in",
            "root",
            "set",
            "to",
            "true"
        ]
    },
    {
        "id": 38,
        "code": "public boolean remove(Object o) {\n    int idx = originList.indexOf(o);\n    if (idx > -1 && rootSet.get(idx)) {\n        rootSet.set(idx, false);\n        return true;\n    }\n    if (CollectionUtils.isNotEmpty(tailList)) {\n        return tailList.remove(o);\n    }\n    return false;\n}",
        "summary_tokens": [
            "if",
            "the",
            "element",
            "to",
            "added",
            "is",
            "appeared",
            "in",
            "origin",
            "list",
            "directly",
            "set",
            "its",
            "index",
            "in",
            "root",
            "set",
            "to",
            "false"
        ]
    },
    {
        "id": 39,
        "code": "public void clear() {\n    rootSet.clear();\n        \n    originList = Collections.emptyList();\n    if (CollectionUtils.isNotEmpty(tailList)) {\n        tailList = null;\n    }\n}",
        "summary_tokens": [
            "caution",
            "this",
            "operation",
            "will",
            "clear",
            "origin",
            "list",
            "for",
            "removing",
            "references",
            "purpose"
        ]
    },
    {
        "id": 40,
        "code": "private <T> BitList<Invoker<T>> filterUsingStaticTag(BitList<Invoker<T>> invokers, URL url, Invocation invocation) {\n    BitList<Invoker<T>> result;\n        \n    String tag = StringUtils.isEmpty(invocation.getAttachment(TAG_KEY)) ? url.getParameter(TAG_KEY) :\n        invocation.getAttachment(TAG_KEY);\n        \n    if (!StringUtils.isEmpty(tag)) {\n        result = filterInvoker(invokers, invoker -> tag.equals(invoker.getUrl().getParameter(TAG_KEY)));\n        if (CollectionUtils.isEmpty(result) && !isForceUseTag(invocation)) {\n            result = filterInvoker(invokers, invoker -> StringUtils.isEmpty(invoker.getUrl().getParameter(TAG_KEY)));\n        }\n    } else {\n        result = filterInvoker(invokers, invoker -> StringUtils.isEmpty(invoker.getUrl().getParameter(TAG_KEY)));\n    }\n    return result;\n}",
        "summary_tokens": [
            "if",
            "there",
            "s",
            "no",
            "dynamic",
            "tag",
            "rule",
            "being",
            "set",
            "use",
            "static",
            "tag",
            "in",
            "url"
        ]
    },
    {
        "id": 41,
        "code": "protected Invoker<T> select(LoadBalance loadbalance, Invocation invocation,\n                            List<Invoker<T>> invokers, List<Invoker<T>> selected) throws RpcException {\n\n    if (CollectionUtils.isEmpty(invokers)) {\n        return null;\n    }\n    String methodName = invocation == null ? StringUtils.EMPTY_STRING : invocation.getMethodName();\n\n    boolean sticky = invokers.get(0).getUrl()\n        .getMethodParameter(methodName, CLUSTER_STICKY_KEY, DEFAULT_CLUSTER_STICKY);\n\n        \n    if (stickyInvoker != null && !invokers.contains(stickyInvoker)) {\n        stickyInvoker = null;\n    }\n        \n    if (sticky && stickyInvoker != null && (selected == null || !selected.contains(stickyInvoker))) {\n        if (availableCheck && stickyInvoker.isAvailable()) {\n            return stickyInvoker;\n        }\n    }\n\n    Invoker<T> invoker = doSelect(loadbalance, invocation, invokers, selected);\n\n    if (sticky) {\n        stickyInvoker = invoker;\n    }\n\n    return invoker;\n}",
        "summary_tokens": [
            "select",
            "a",
            "invoker",
            "using",
            "loadbalance",
            "policy"
        ]
    },
    {
        "id": 42,
        "code": "private Invoker<T> reselect(LoadBalance loadbalance, Invocation invocation,\n                            List<Invoker<T>> invokers, List<Invoker<T>> selected, boolean availableCheck) throws RpcException {\n\n        \n    List<Invoker<T>> reselectInvokers = new ArrayList<>(Math.min(invokers.size(), reselectCount));\n\n        \n        \n        \n        \n        \n        \n    if (reselectCount >= invokers.size()) {\n        for (Invoker<T> invoker : invokers) {\n                \n            if (availableCheck && !invoker.isAvailable()) {\n                    \n                invalidateInvoker(invoker);\n                continue;\n            }\n\n            if (selected == null || !selected.contains(invoker)) {\n                reselectInvokers.add(invoker);\n            }\n        }\n    } else {\n        for (int i = 0; i < reselectCount; i++) {\n                \n            Invoker<T> invoker = invokers.get(ThreadLocalRandom.current().nextInt(invokers.size()));\n                \n            if (availableCheck && !invoker.isAvailable()) {\n                    \n                invalidateInvoker(invoker);\n                continue;\n            }\n                \n            if (selected == null || !selected.contains(invoker) || !reselectInvokers.contains(invoker)) {\n                reselectInvokers.add(invoker);\n            }\n        }\n    }\n\n        \n    if (!reselectInvokers.isEmpty()) {\n        return loadbalance.select(reselectInvokers, getUrl(), invocation);\n    }\n\n        \n        \n    if (selected != null) {\n        for (Invoker<T> invoker : selected) {\n            if ((invoker.isAvailable()) \n                && !reselectInvokers.contains(invoker)) {\n                reselectInvokers.add(invoker);\n            }\n        }\n    }\n\n        \n        \n    if (!reselectInvokers.isEmpty()) {\n        return loadbalance.select(reselectInvokers, getUrl(), invocation);\n    }\n\n        \n    return null;\n}",
        "summary_tokens": [
            "reselect",
            "use",
            "invokers",
            "not",
            "in",
            "selected",
            "first",
            "if",
            "all",
            "invokers",
            "are",
            "in",
            "selected",
            "just",
            "pick",
            "an",
            "available",
            "one",
            "using",
            "loadbalance",
            "policy"
        ]
    },
    {
        "id": 43,
        "code": "protected Result invokeWithContextAsync(Invoker<T> invoker, Invocation invocation, URL consumerUrl) {\n    setContext(invoker, consumerUrl);\n    Result result;\n    try {\n        result = invoker.invoke(invocation);\n    } finally {\n        clearContext(invoker);\n    }\n    return result;\n}",
        "summary_tokens": [
            "when",
            "using",
            "a",
            "thread",
            "pool",
            "to",
            "fork",
            "a",
            "child",
            "thread",
            "thread",
            "local",
            "cannot",
            "be",
            "passed"
        ]
    },
    {
        "id": 44,
        "code": "private List<Invoker<T>> selectMockInvoker(Invocation invocation) {\n    List<Invoker<T>> invokers = null;\n        \n    if (invocation instanceof RpcInvocation) {\n            \n        invocation.setAttachment(INVOCATION_NEED_MOCK, Boolean.TRUE.toString());\n            \n        try {\n            RpcContext.getServiceContext().setConsumerUrl(getUrl());\n            invokers = directory.list(invocation);\n        } catch (RpcException e) {\n            if (logger.isInfoEnabled()) {\n                logger.info(\"Exception when try to invoke mock. Get mock invokers error for service:\"\n                        + getUrl().getServiceInterface() + \", method:\" + invocation.getMethodName()\n                        + \", will construct a new mock with 'new MockInvoker()'.\", e);\n            }\n        }\n    }\n    return invokers;\n}",
        "summary_tokens": [
            "return",
            "mock",
            "invoker",
            "contract",
            "directory"
        ]
    },
    {
        "id": 45,
        "code": "public void testBuildRouterChain() {\n    RouterChain<DemoService> routerChain = createRouterChanin();\n    Assertions.assertEquals(0, routerChain.getRouters().size());\n    Assertions.assertEquals(5, routerChain.getStateRouters().size());\n}",
        "summary_tokens": [
            "verify",
            "the",
            "router",
            "and",
            "state",
            "router",
            "loaded",
            "by",
            "default"
        ]
    },
    {
        "id": 46,
        "code": "public void tagRouterRuleParseTest() {\n    String tagRouterRuleConfig = \"---\\n\" +\n        \"force: false\\n\" +\n        \"runtime: true\\n\" +\n        \"enabled: false\\n\" +\n        \"priority: 1\\n\" +\n        \"key: demo-provider\\n\" +\n        \"tags:\\n\" +\n        \"  - name: tag1\\n\" +\n        \"    addresses: null\\n\" +\n        \"  - name: tag2\\n\" +\n        \"    addresses: [\\\"30.5.120.37:20880\\\"]\\n\" +\n        \"  - name: tag3\\n\" +\n        \"    addresses: []\\n\" +\n        \"  - name: tag4\\n\" +\n        \"    addresses: ~\\n\" +\n        \"...\";\n\n    TagRouterRule tagRouterRule = TagRuleParser.parse(tagRouterRuleConfig);\n\n        \n    assert tagRouterRule.getKey().equals(\"demo-provider\");\n    assert tagRouterRule.getPriority() == 1;\n    assert tagRouterRule.getTagNames().contains(\"tag1\");\n    assert tagRouterRule.getTagNames().contains(\"tag2\");\n    assert tagRouterRule.getTagNames().contains(\"tag3\");\n    assert tagRouterRule.getTagNames().contains(\"tag4\");\n        \n    assert tagRouterRule.getAddresses().contains(\"30.5.120.37:20880\");\n    assert tagRouterRule.getTagnameToAddresses().get(\"tag1\") == null;\n    assert tagRouterRule.getTagnameToAddresses().get(\"tag2\").size() == 1;\n    assert tagRouterRule.getTagnameToAddresses().get(\"tag3\") == null;\n    assert tagRouterRule.getTagnameToAddresses().get(\"tag4\") == null;\n    assert tagRouterRule.getAddresses().size() == 1;\n}",
        "summary_tokens": [
            "tag",
            "router",
            "rule",
            "parse",
            "test",
            "when",
            "the",
            "tags",
            "addresses",
            "is",
            "null"
        ]
    },
    {
        "id": 47,
        "code": "public void testMockedInvokerSelect() {\n    initlistsize5();\n    invokers.add(mockedInvoker1);\n\n    initDic();\n\n    RpcInvocation mockedInvocation = new RpcInvocation();\n    mockedInvocation.setMethodName(\"sayHello\");\n    mockedInvocation.setAttachment(INVOCATION_NEED_MOCK, \"true\");\n    List<Invoker<IHelloService>> mockedInvokers = dic.list(mockedInvocation);\n    Assertions.assertEquals(1, mockedInvokers.size());\n\n    List<Invoker<IHelloService>> invokers = dic.list(invocation);\n    Assertions.assertEquals(5, invokers.size());\n}",
        "summary_tokens": [
            "test",
            "mock",
            "invoker",
            "selector",
            "works",
            "as",
            "expected"
        ]
    },
    {
        "id": 48,
        "code": "public void testInvokerDestroyAndReList() {\n    final URL url = URL.valueOf(\"test://localhost/\" + Demo.class.getName() + \"?loadbalance=roundrobin&retries=\" + retries);\n    RpcException exception = new RpcException(RpcException.TIMEOUT_EXCEPTION);\n    MockInvoker<Demo> invoker1 = new MockInvoker<>(Demo.class, url);\n    invoker1.setException(exception);\n\n    MockInvoker<Demo> invoker2 = new MockInvoker<>(Demo.class, url);\n    invoker2.setException(exception);\n\n    final List<Invoker<Demo>> invokers = new ArrayList<>();\n    invokers.add(invoker1);\n    invokers.add(invoker2);\n\n    MockDirectory<Demo> dic = new MockDirectory<>(url, invokers);\n\n    Callable<Object> callable = () -> {\n            \n        for (Invoker<Demo> invoker : invokers) {\n            invoker.destroy();\n        }\n        invokers.clear();\n        MockInvoker<Demo> invoker3 = new MockInvoker<>(Demo.class, url);\n        invoker3.setResult(AsyncRpcResult.newDefaultAsyncResult(mock(RpcInvocation.class)));\n        invokers.add(invoker3);\n        dic.notify(invokers);\n        return null;\n    };\n    invoker1.setCallable(callable);\n    invoker2.setCallable(callable);\n\n    RpcInvocation inv = new RpcInvocation();\n    inv.setMethodName(\"test\");\n\n    FailoverClusterInvoker<Demo> clusterInvoker = new FailoverClusterInvoker<>(dic);\n    clusterInvoker.invoke(inv);\n}",
        "summary_tokens": [
            "when",
            "invokers",
            "in",
            "directory",
            "changes",
            "after",
            "a",
            "failed",
            "request",
            "but",
            "just",
            "before",
            "a",
            "retry",
            "effort",
            "then",
            "we",
            "should",
            "reselect",
            "from",
            "the",
            "latest",
            "invokers",
            "before",
            "retry"
        ]
    },
    {
        "id": 49,
        "code": "public void testInvokerToException() {\n    String menu = \"first\";\n    List<String> menuItems = new ArrayList<String>() {\n        {\n            add(\"1\");\n            add(\"2\");\n        }\n    };\n\n    given(invocation.getMethodName()).willReturn(\"addMenu\");\n    given(invocation.getParameterTypes()).willReturn(new Class<?>[]{String.class, List.class});\n    given(invocation.getArguments()).willReturn(new Object[]{menu, menuItems});\n    given(invocation.getObjectAttachments()).willReturn(new HashMap<>());\n    given(invocation.getInvoker()).willReturn(firstInvoker);\n\n    given(firstInvoker.getUrl()).willReturn(url.addParameter(GROUP_KEY, \"first\"));\n    given(firstInvoker.getInterface()).willReturn(MenuService.class);\n    given(firstInvoker.invoke(invocation)).willReturn(new AppResponse());\n    given(firstInvoker.isAvailable()).willReturn(true);\n    given(firstInvoker.invoke(invocation)).willThrow(new RpcException(RpcException.NETWORK_EXCEPTION));\n\n    given(secondInvoker.getUrl()).willReturn(url.addParameter(GROUP_KEY, \"second\"));\n    given(secondInvoker.getInterface()).willReturn(MenuService.class);\n    given(secondInvoker.invoke(invocation)).willReturn(new AppResponse());\n    given(secondInvoker.isAvailable()).willReturn(true);\n    given(secondInvoker.invoke(invocation)).willThrow(new RpcException(RpcException.NETWORK_EXCEPTION));\n\n    given(directory.list(invocation)).willReturn(new ArrayList() {\n\n        {\n            add(firstInvoker);\n            add(secondInvoker);\n        }\n    });\n    given(directory.getUrl()).willReturn(url);\n    given(directory.getConsumerUrl()).willReturn(url);\n    given(directory.getConsumerUrl()).willReturn(url);\n    given(directory.getInterface()).willReturn(MenuService.class);\n\n    mergeableClusterInvoker = new MergeableClusterInvoker<MenuService>(directory);\n\n        \n    try {\n        Result result = mergeableClusterInvoker.invoke(invocation);\n        fail();\n        Assertions.assertNull(result.getValue());\n    } catch (RpcException expected) {\n        assertEquals(expected.getCode(), RpcException.NETWORK_EXCEPTION);\n    }\n}",
        "summary_tokens": [
            "test",
            "when",
            "network",
            "exception"
        ]
    },
    {
        "id": 50,
        "code": "public void testMockInvokerInvoke_normal() {\n    URL url = URL.valueOf(\"remote://1.2.3.4/\" + IHelloService.class.getName());\n    url = url.addParameter(REFER_KEY,\n            URL.encode(PATH_KEY + \"=\" + IHelloService.class.getName()\n                    + \"&\" + \"mock=fail\"));\n    Invoker<IHelloService> cluster = getClusterInvoker(url);\n    URL mockUrl = URL.valueOf(\"mock://localhost/\" + IHelloService.class.getName()\n            + \"?getSomething.mock=return aa\");\n\n    Protocol protocol = new MockProtocol();\n    Invoker<IHelloService> mInvoker1 = protocol.refer(IHelloService.class, mockUrl);\n    invokers.add(mInvoker1);\n\n        \n    RpcInvocation invocation = new RpcInvocation();\n    invocation.setMethodName(\"getSomething\");\n    Result ret = cluster.invoke(invocation);\n    Assertions.assertEquals(\"something\", ret.getValue());\n\n        \n    invocation = new RpcInvocation();\n    invocation.setMethodName(\"sayHello\");\n    ret = cluster.invoke(invocation);\n    Assertions.assertNull(ret.getValue());\n}",
        "summary_tokens": [
            "test",
            "if",
            "mock",
            "policy",
            "works",
            "fine",
            "fail",
            "mock"
        ]
    },
    {
        "id": 51,
        "code": "public void testMockInvokerInvoke_failmock() {\n    URL url = URL.valueOf(\"remote://1.2.3.4/\" + IHelloService.class.getName())\n            .addParameter(REFER_KEY,\n                    URL.encode(PATH_KEY + \"=\" + IHelloService.class.getName()\n                            + \"&\" + \"mock=fail:return null\"))\n            .addParameter(\"invoke_return_error\", \"true\");\n    URL mockUrl = URL.valueOf(\"mock://localhost/\" + IHelloService.class.getName())\n            .addParameter(\"mock\",\"fail:return null\")\n            .addParameter(\"getSomething.mock\",\"return aa\")\n            .addParameter(REFER_KEY, URL.encode(PATH_KEY + \"=\" + IHelloService.class.getName()))\n            .addParameter(\"invoke_return_error\", \"true\");\n\n    Protocol protocol = new MockProtocol();\n    Invoker<IHelloService> mInvoker1 = protocol.refer(IHelloService.class, mockUrl);\n    Invoker<IHelloService> cluster = getClusterInvokerMock(url, mInvoker1);\n\n        \n    RpcInvocation invocation = new RpcInvocation();\n    invocation.setMethodName(\"getSomething\");\n    Result ret = cluster.invoke(invocation);\n    Assertions.assertEquals(\"aa\", ret.getValue());\n\n        \n    invocation = new RpcInvocation();\n    invocation.setMethodName(\"getSomething2\");\n    ret = cluster.invoke(invocation);\n    Assertions.assertNull(ret.getValue());\n\n        \n    invocation = new RpcInvocation();\n    invocation.setMethodName(\"sayHello\");\n    ret = cluster.invoke(invocation);\n    Assertions.assertNull(ret.getValue());\n}",
        "summary_tokens": [
            "test",
            "if",
            "mock",
            "policy",
            "works",
            "fine",
            "fail",
            "mock"
        ]
    },
    {
        "id": 52,
        "code": "public void testMockInvokerInvoke_forcemock() {\n    URL url = URL.valueOf(\"remote://1.2.3.4/\" + IHelloService.class.getName())\n            .addParameter(REFER_KEY,\n                    URL.encode(PATH_KEY + \"=\" + IHelloService.class.getName()\n                            + \"&\" + \"mock=force:return null\"));\n\n    URL mockUrl = URL.valueOf(\"mock://localhost/\" + IHelloService.class.getName())\n            .addParameter(\"mock\",\"force:return null\")\n            .addParameter(\"getSomething.mock\",\"return aa\")\n            .addParameter(\"getSomething3xx.mock\",\"return xx\")\n            .addParameter(REFER_KEY, URL.encode(PATH_KEY + \"=\" + IHelloService.class.getName()));\n\n    Protocol protocol = new MockProtocol();\n    Invoker<IHelloService> mInvoker1 = protocol.refer(IHelloService.class, mockUrl);\n    Invoker<IHelloService> cluster = getClusterInvokerMock(url, mInvoker1);\n\n        \n    RpcInvocation invocation = new RpcInvocation();\n    invocation.setMethodName(\"getSomething\");\n    Result ret = cluster.invoke(invocation);\n    Assertions.assertEquals(\"aa\", ret.getValue());\n\n        \n    invocation = new RpcInvocation();\n    invocation.setMethodName(\"getSomething2\");\n    ret = cluster.invoke(invocation);\n    Assertions.assertNull(ret.getValue());\n\n        \n    invocation = new RpcInvocation();\n    invocation.setMethodName(\"sayHello\");\n    ret = cluster.invoke(invocation);\n    Assertions.assertNull(ret.getValue());\n\n\n\n}",
        "summary_tokens": [
            "test",
            "if",
            "mock",
            "policy",
            "works",
            "fine",
            "force",
            "mock"
        ]
    },
    {
        "id": 53,
        "code": "public void testMockInvokerFromOverride_Invoke_Fock_someMethods() {\n    URL url = URL.valueOf(\"remote://1.2.3.4/\" + IHelloService.class.getName())\n            .addParameter(REFER_KEY,\n                    URL.encode(PATH_KEY + \"=\" + IHelloService.class.getName()\n                            + \"&\" + \"getSomething.mock=fail:return x\"\n                            + \"&\" + \"getSomething2.mock=force:return y\"));\n    Invoker<IHelloService> cluster = getClusterInvoker(url);\n        \n    RpcInvocation invocation = new RpcInvocation();\n    invocation.setMethodName(\"getSomething\");\n    Result ret = cluster.invoke(invocation);\n    Assertions.assertEquals(\"something\", ret.getValue());\n\n        \n    invocation = new RpcInvocation();\n    invocation.setMethodName(\"getSomething2\");\n    ret = cluster.invoke(invocation);\n    Assertions.assertEquals(\"y\", ret.getValue());\n\n        \n    invocation = new RpcInvocation();\n    invocation.setMethodName(\"getSomething3\");\n    ret = cluster.invoke(invocation);\n    Assertions.assertEquals(\"something3\", ret.getValue());\n\n        \n    invocation = new RpcInvocation();\n    invocation.setMethodName(\"sayHello\");\n    ret = cluster.invoke(invocation);\n    Assertions.assertNull(ret.getValue());\n}",
        "summary_tokens": [
            "test",
            "if",
            "mock",
            "policy",
            "works",
            "fine",
            "fail",
            "mock"
        ]
    },
    {
        "id": 54,
        "code": "public void testMockInvokerFromOverride_Invoke_Fock_WithOutDefault() {\n    URL url = URL.valueOf(\"remote://1.2.3.4/\" + IHelloService.class.getName())\n            .addParameter(REFER_KEY,\n                    URL.encode(PATH_KEY + \"=\" + IHelloService.class.getName()\n                            + \"&\" + \"getSomething.mock=fail:return x\"\n                            + \"&\" + \"getSomething2.mock=fail:return y\"))\n            .addParameter(\"invoke_return_error\", \"true\");\n    Invoker<IHelloService> cluster = getClusterInvoker(url);\n        \n    RpcInvocation invocation = new RpcInvocation();\n    invocation.setMethodName(\"getSomething\");\n    Result ret = cluster.invoke(invocation);\n    Assertions.assertEquals(\"x\", ret.getValue());\n\n        \n    invocation = new RpcInvocation();\n    invocation.setMethodName(\"getSomething2\");\n    ret = cluster.invoke(invocation);\n    Assertions.assertEquals(\"y\", ret.getValue());\n\n        \n    invocation = new RpcInvocation();\n    invocation.setMethodName(\"getSomething3\");\n    try {\n        ret = cluster.invoke(invocation);\n        Assertions.fail();\n    } catch (RpcException e) {\n\n    }\n}",
        "summary_tokens": [
            "test",
            "if",
            "mock",
            "policy",
            "works",
            "fine",
            "fail",
            "mock"
        ]
    },
    {
        "id": 55,
        "code": "public void testMockInvokerFromOverride_Invoke_Fock_WithDefault() {\n    URL url = URL.valueOf(\"remote://1.2.3.4/\" + IHelloService.class.getName())\n            .addParameter(REFER_KEY,\n                    URL.encode(PATH_KEY + \"=\" + IHelloService.class.getName()\n                            + \"&\" + \"mock\" + \"=\" + \"fail:return null\"\n                            + \"&\" + \"getSomething.mock\" + \"=\" + \"fail:return x\"\n                            + \"&\" + \"getSomething2.mock\" + \"=\" + \"fail:return y\"))\n            .addParameter(\"invoke_return_error\", \"true\");\n    Invoker<IHelloService> cluster = getClusterInvoker(url);\n        \n    RpcInvocation invocation = new RpcInvocation();\n    invocation.setMethodName(\"getSomething\");\n    Result ret = cluster.invoke(invocation);\n    Assertions.assertEquals(\"x\", ret.getValue());\n\n        \n    invocation = new RpcInvocation();\n    invocation.setMethodName(\"getSomething2\");\n    ret = cluster.invoke(invocation);\n    Assertions.assertEquals(\"y\", ret.getValue());\n\n        \n    invocation = new RpcInvocation();\n    invocation.setMethodName(\"getSomething3\");\n    ret = cluster.invoke(invocation);\n    Assertions.assertNull(ret.getValue());\n\n        \n    invocation = new RpcInvocation();\n    invocation.setMethodName(\"sayHello\");\n    ret = cluster.invoke(invocation);\n    Assertions.assertNull(ret.getValue());\n}",
        "summary_tokens": [
            "test",
            "if",
            "mock",
            "policy",
            "works",
            "fine",
            "fail",
            "mock"
        ]
    },
    {
        "id": 56,
        "code": "public void testMockInvokerFromOverride_Invoke_Fock_WithFailDefault() {\n    URL url = URL.valueOf(\"remote://1.2.3.4/\" + IHelloService.class.getName())\n            .addParameter(REFER_KEY,\n                    URL.encode(PATH_KEY + \"=\" + IHelloService.class.getName()\n                            + \"&\" + \"mock=fail:return z\"\n                            + \"&\" + \"getSomething.mock=fail:return x\"\n                            + \"&\" + \"getSomething2.mock=force:return y\"))\n            .addParameter(\"invoke_return_error\", \"true\");\n    Invoker<IHelloService> cluster = getClusterInvoker(url);\n        \n    RpcInvocation invocation = new RpcInvocation();\n    invocation.setMethodName(\"getSomething\");\n    Result ret = cluster.invoke(invocation);\n    Assertions.assertEquals(\"x\", ret.getValue());\n\n        \n    invocation = new RpcInvocation();\n    invocation.setMethodName(\"getSomething2\");\n    ret = cluster.invoke(invocation);\n    Assertions.assertEquals(\"y\", ret.getValue());\n\n        \n    invocation = new RpcInvocation();\n    invocation.setMethodName(\"getSomething3\");\n    ret = cluster.invoke(invocation);\n    Assertions.assertEquals(\"z\", ret.getValue());\n\n        \n    invocation = new RpcInvocation();\n    invocation.setMethodName(\"sayHello\");\n    ret = cluster.invoke(invocation);\n    Assertions.assertEquals(\"z\", ret.getValue());\n}",
        "summary_tokens": [
            "test",
            "if",
            "mock",
            "policy",
            "works",
            "fine",
            "fail",
            "mock"
        ]
    },
    {
        "id": 57,
        "code": "public void testMockInvokerFromOverride_Invoke_Fock_WithForceDefault() {\n    URL url = URL.valueOf(\"remote://1.2.3.4/\" + IHelloService.class.getName())\n            .addParameter(REFER_KEY,\n                    URL.encode(PATH_KEY + \"=\" + IHelloService.class.getName()\n                            + \"&\" + \"mock=force:return z\"\n                            + \"&\" + \"getSomething.mock=fail:return x\"\n                            + \"&\" + \"getSomething2.mock=force:return y\"))\n            .addParameter(\"invoke_return_error\", \"true\");\n    Invoker<IHelloService> cluster = getClusterInvoker(url);\n        \n    RpcInvocation invocation = new RpcInvocation();\n    invocation.setMethodName(\"getSomething\");\n    Result ret = cluster.invoke(invocation);\n    Assertions.assertEquals(\"x\", ret.getValue());\n\n        \n    invocation = new RpcInvocation();\n    invocation.setMethodName(\"getSomething2\");\n    ret = cluster.invoke(invocation);\n    Assertions.assertEquals(\"y\", ret.getValue());\n\n        \n    invocation = new RpcInvocation();\n    invocation.setMethodName(\"getSomething3\");\n    ret = cluster.invoke(invocation);\n    Assertions.assertEquals(\"z\", ret.getValue());\n\n        \n    invocation = new RpcInvocation();\n    invocation.setMethodName(\"sayHello\");\n    ret = cluster.invoke(invocation);\n    Assertions.assertEquals(\"z\", ret.getValue());\n}",
        "summary_tokens": [
            "test",
            "if",
            "mock",
            "policy",
            "works",
            "fine",
            "fail",
            "mock"
        ]
    },
    {
        "id": 58,
        "code": "public void testMockInvokerFromOverride_Invoke_Fock_Default() {\n    URL url = URL.valueOf(\"remote://1.2.3.4/\" + IHelloService.class.getName())\n            .addParameter(REFER_KEY,\n                    URL.encode(PATH_KEY + \"=\" + IHelloService.class.getName()\n                            + \"&\" + \"mock=fail:return x\"))\n            .addParameter(\"invoke_return_error\", \"true\");\n    Invoker<IHelloService> cluster = getClusterInvoker(url);\n        \n    RpcInvocation invocation = new RpcInvocation();\n    invocation.setMethodName(\"getSomething\");\n    Result ret = cluster.invoke(invocation);\n    Assertions.assertEquals(\"x\", ret.getValue());\n\n        \n    invocation = new RpcInvocation();\n    invocation.setMethodName(\"getSomething2\");\n    ret = cluster.invoke(invocation);\n    Assertions.assertEquals(\"x\", ret.getValue());\n\n        \n    invocation = new RpcInvocation();\n    invocation.setMethodName(\"sayHello\");\n    ret = cluster.invoke(invocation);\n    Assertions.assertEquals(\"x\", ret.getValue());\n}",
        "summary_tokens": [
            "test",
            "if",
            "mock",
            "policy",
            "works",
            "fine",
            "fail",
            "mock"
        ]
    },
    {
        "id": 59,
        "code": "public void testMockInvokerFromOverride_Invoke_checkCompatible_return() {\n    URL url = URL.valueOf(\"remote://1.2.3.4/\" + IHelloService.class.getName())\n            .addParameter(REFER_KEY,\n                    URL.encode(PATH_KEY + \"=\" + IHelloService.class.getName()\n                            + \"&\" + \"getSomething.mock=return x\"))\n            .addParameter(\"invoke_return_error\", \"true\");\n    Invoker<IHelloService> cluster = getClusterInvoker(url);\n        \n    RpcInvocation invocation = new RpcInvocation();\n    invocation.setMethodName(\"getSomething\");\n    Result ret = cluster.invoke(invocation);\n    Assertions.assertEquals(\"x\", ret.getValue());\n\n        \n    invocation = new RpcInvocation();\n    invocation.setMethodName(\"getSomething3\");\n    try {\n        ret = cluster.invoke(invocation);\n        Assertions.fail(\"fail invoke\");\n    } catch (RpcException e) {\n\n    }\n}",
        "summary_tokens": [
            "test",
            "if",
            "mock",
            "policy",
            "works",
            "fine",
            "fail",
            "mock"
        ]
    },
    {
        "id": 60,
        "code": "public void testMockInvokerFromOverride_Invoke_checkCompatible_ImplMock() {\n    URL url = URL.valueOf(\"remote://1.2.3.4/\" + IHelloService.class.getName())\n            .addParameter(REFER_KEY,\n                    URL.encode(PATH_KEY + \"=\" + IHelloService.class.getName()\n                            + \"&\" + \"mock=true\"\n                            + \"&\" + \"proxy=jdk\"))\n            .addParameter(\"invoke_return_error\", \"true\");\n    Invoker<IHelloService> cluster = getClusterInvoker(url);\n        \n    RpcInvocation invocation = new RpcInvocation();\n    invocation.setMethodName(\"getSomething\");\n    Result ret = cluster.invoke(invocation);\n    Assertions.assertEquals(\"somethingmock\", ret.getValue());\n}",
        "summary_tokens": [
            "test",
            "if",
            "mock",
            "policy",
            "works",
            "fine",
            "fail",
            "mock"
        ]
    },
    {
        "id": 61,
        "code": "public void testMockInvokerFromOverride_Invoke_checkCompatible_ImplMock2() {\n    URL url = URL.valueOf(\"remote://1.2.3.4/\" + IHelloService.class.getName())\n            .addParameter(REFER_KEY,\n                    URL.encode(PATH_KEY + \"=\" + IHelloService.class.getName() + \"&\" + \"mock=fail\"))\n            .addParameter(\"invoke_return_error\", \"true\");\n    Invoker<IHelloService> cluster = getClusterInvoker(url);\n        \n    RpcInvocation invocation = new RpcInvocation();\n    invocation.setMethodName(\"getSomething\");\n    Result ret = cluster.invoke(invocation);\n    Assertions.assertEquals(\"somethingmock\", ret.getValue());\n}",
        "summary_tokens": [
            "test",
            "if",
            "mock",
            "policy",
            "works",
            "fine",
            "fail",
            "mock"
        ]
    },
    {
        "id": 62,
        "code": "public void testMockInvokerFromOverride_Invoke_checkCompatible_ImplMock3() {\n    URL url = URL.valueOf(\"remote://1.2.3.4/\" + IHelloService.class.getName())\n            .addParameter(REFER_KEY,\n                    URL.encode(PATH_KEY + \"=\" + IHelloService.class.getName() + \"&\" + \"mock=force\"));\n    Invoker<IHelloService> cluster = getClusterInvoker(url);\n        \n    RpcInvocation invocation = new RpcInvocation();\n    invocation.setMethodName(\"getSomething\");\n    Result ret = cluster.invoke(invocation);\n    Assertions.assertEquals(\"somethingmock\", ret.getValue());\n}",
        "summary_tokens": [
            "test",
            "if",
            "mock",
            "policy",
            "works",
            "fine",
            "fail",
            "mock"
        ]
    },
    {
        "id": 63,
        "code": "public void testMockInvokerProviderRpcException() {\n    URL url = URL.valueOf(\"remote://1.2.3.4/\" + IHelloRpcService.class.getName());\n    url = url.addParameter(MOCK_KEY, \"true\").addParameter(\"invoke_return_error\", \"true\")\n            .addParameter(REFER_KEY,\n                    URL.encode(PATH_KEY + \"=\" + MockProviderRpcExceptionTest.IHelloRpcService.class.getName()\n                            + \"&\" + \"mock=true\"\n                            + \"&\" + \"proxy=jdk\"));\n    Invoker<IHelloRpcService> cluster = getClusterInvoker(url);\n    RpcInvocation invocation = new RpcInvocation();\n    invocation.setMethodName(\"getSomething4\");\n    Result ret = cluster.invoke(invocation);\n    Assertions.assertEquals(\"something4mock\", ret.getValue());\n\n}",
        "summary_tokens": [
            "test",
            "if",
            "mock",
            "policy",
            "works",
            "fine",
            "provider",
            "rpc",
            "exception"
        ]
    },
    {
        "id": 64,
        "code": "public static URL valueOf(String url, boolean encoded) {\n    if (encoded) {\n        return URLStrParser.parseEncodedStr(url);\n    }\n    return URLStrParser.parseDecodedStr(url);\n}",
        "summary_tokens": [
            "parse",
            "normal",
            "or",
            "encoded",
            "url",
            "string",
            "into",
            "strutted",
            "url",
            "dubbo",
            "host",
            "port",
            "path",
            "param",
            "value",
            "url"
        ]
    },
    {
        "id": 65,
        "code": "public String getAuthority() {\n    StringBuilder ret = new StringBuilder();\n\n    ret.append(getUserInformation());\n\n    if (StringUtils.isNotEmpty(getHost())) {\n        if (StringUtils.isNotEmpty(getUsername()) || StringUtils.isNotEmpty(getPassword())) {\n            ret.append('@');\n        }\n        ret.append(getHost());\n        if (getPort() != 0) {\n            ret.append(':');\n            ret.append(getPort());\n        }\n    }\n\n    return ret.length() == 0 ? null : ret.toString();\n}",
        "summary_tokens": [
            "refer",
            "to",
            "https",
            "datatracker"
        ]
    },
    {
        "id": 66,
        "code": "public String getUserInformation() {\n    StringBuilder ret = new StringBuilder();\n\n    if (StringUtils.isEmpty(getUsername()) && StringUtils.isEmpty(getPassword())) {\n        return ret.toString();\n    }\n\n    if (StringUtils.isNotEmpty(getUsername())) {\n        ret.append(getUsername());\n    }\n\n    ret.append(':');\n\n    if (StringUtils.isNotEmpty(getPassword())) {\n        ret.append(getPassword());\n    }\n\n    return ret.length() == 0 ? null : ret.toString();\n}",
        "summary_tokens": [
            "refer",
            "to",
            "https",
            "datatracker"
        ]
    },
    {
        "id": 67,
        "code": "public Map<String, String> getParameters(Predicate<String> nameToSelect) {\n    Map<String, String> selectedParameters = new LinkedHashMap<>();\n    for (Map.Entry<String, String> entry : getParameters().entrySet()) {\n        String name = entry.getKey();\n        if (nameToSelect.test(name)) {\n            selectedParameters.put(name, entry.getValue());\n        }\n    }\n    return Collections.unmodifiableMap(selectedParameters);\n}",
        "summary_tokens": [
            "get",
            "the",
            "parameters",
            "to",
            "be",
            "selected",
            "filtered"
        ]
    },
    {
        "id": 68,
        "code": "public URL addParameters(Map<String, String> parameters) {\n    URLParam newParam = urlParam.addParameters(parameters);\n    return returnURL(newParam);\n}",
        "summary_tokens": [
            "add",
            "parameters",
            "to",
            "a",
            "new",
            "url"
        ]
    },
    {
        "id": 69,
        "code": "public String getColonSeparatedKey() {\n    StringBuilder serviceNameBuilder = new StringBuilder();\n    serviceNameBuilder.append(this.getServiceInterface());\n    append(serviceNameBuilder, VERSION_KEY, false);\n    append(serviceNameBuilder, GROUP_KEY, false);\n    return serviceNameBuilder.toString();\n}",
        "summary_tokens": [
            "the",
            "format",
            "is",
            "interface",
            "version",
            "group"
        ]
    },
    {
        "id": 70,
        "code": "public String getServiceKey() {\n    if (serviceKey != null) {\n        return serviceKey;\n    }\n    String inf = getServiceInterface();\n    if (inf == null) {\n        return null;\n    }\n    serviceKey = buildKey(inf, getGroup(), getVersion());\n    return serviceKey;\n}",
        "summary_tokens": [
            "the",
            "format",
            "of",
            "return",
            "value",
            "is",
            "group",
            "interface",
            "name",
            "version"
        ]
    },
    {
        "id": 71,
        "code": "public String getPathKey() {\n    String inf = StringUtils.isNotEmpty(getPath()) ? getPath() : getServiceInterface();\n    if (inf == null) {\n        return null;\n    }\n    return buildKey(inf, getGroup(), getVersion());\n}",
        "summary_tokens": [
            "the",
            "format",
            "of",
            "return",
            "value",
            "is",
            "group",
            "path",
            "interface",
            "name",
            "version"
        ]
    },
    {
        "id": 72,
        "code": "public static URL parseDecodedStr(String decodedURLStr) {\n    Map<String, String> parameters = null;\n    int pathEndIdx = decodedURLStr.indexOf('?');\n    if (pathEndIdx >= 0) {\n        parameters = parseDecodedParams(decodedURLStr, pathEndIdx + 1);\n    } else {\n        pathEndIdx = decodedURLStr.length();\n    }\n\n    String decodedBody = decodedURLStr.substring(0, pathEndIdx);\n    return parseURLBody(decodedURLStr, decodedBody, parameters);\n}",
        "summary_tokens": [
            "decoded",
            "urlstr",
            "after",
            "url",
            "decode",
            "string",
            "decoded",
            "urlstr",
            "format",
            "protocol",
            "username",
            "password",
            "port",
            "path",
            "k",
            "0",
            "v",
            "0",
            "k",
            "0",
            "v",
            "0",
            "protocol",
            "username",
            "password",
            "host",
            "port",
            "path",
            "k",
            "0",
            "v",
            "0",
            "k",
            "0",
            "v",
            "0"
        ]
    },
    {
        "id": 73,
        "code": "private static URL parseURLBody(String fullURLStr, String decodedBody, Map<String, String> parameters) {\n    int starIdx = 0, endIdx = decodedBody.length();\n        \n    int poundIndex = decodedBody.indexOf('#');\n    if (poundIndex != -1) {\n        endIdx = poundIndex;\n    }\n\n    String protocol = null;\n    int protoEndIdx = decodedBody.indexOf(\"://\");\n    if (protoEndIdx >= 0) {\n        if (protoEndIdx == 0) {\n            throw new IllegalStateException(\"url missing protocol: \\\"\" + fullURLStr + \"\\\"\");\n        }\n        protocol = decodedBody.substring(0, protoEndIdx);\n        starIdx = protoEndIdx + 3;\n    } else {\n            \n        protoEndIdx = decodedBody.indexOf(\":/\");\n        if (protoEndIdx >= 0) {\n            if (protoEndIdx == 0) {\n                throw new IllegalStateException(\"url missing protocol: \\\"\" + fullURLStr + \"\\\"\");\n            }\n            protocol = decodedBody.substring(0, protoEndIdx);\n            starIdx = protoEndIdx + 1;\n        }\n    }\n\n    String path = null;\n    int pathStartIdx = indexOf(decodedBody, '/', starIdx, endIdx);\n    if (pathStartIdx >= 0) {\n        path = decodedBody.substring(pathStartIdx + 1, endIdx);\n        endIdx = pathStartIdx;\n    }\n\n    String username = null;\n    String password = null;\n    int pwdEndIdx = lastIndexOf(decodedBody, '@', starIdx, endIdx);\n    if (pwdEndIdx > 0) {\n        int passwordStartIdx = indexOf(decodedBody, ':', starIdx, pwdEndIdx);\n        if (passwordStartIdx != -1) {\n            username = decodedBody.substring(starIdx, passwordStartIdx);\n            password = decodedBody.substring(passwordStartIdx + 1, pwdEndIdx);\n        } else {\n            username = decodedBody.substring(starIdx, pwdEndIdx);\n        }\n        starIdx = pwdEndIdx + 1;\n    }\n\n    String host = null;\n    int port = 0;\n    int hostEndIdx = lastIndexOf(decodedBody, ':', starIdx, endIdx);\n    if (hostEndIdx > 0 && hostEndIdx < decodedBody.length() - 1) {\n        if (lastIndexOf(decodedBody, '%', starIdx, endIdx) > hostEndIdx) {\n                \n                \n                \n                \n        } else {\n            port = Integer.parseInt(decodedBody.substring(hostEndIdx + 1, endIdx));\n            endIdx = hostEndIdx;\n        }\n    }\n\n    if (endIdx > starIdx) {\n        host = decodedBody.substring(starIdx, endIdx);\n    }\n\n        \n    protocol = URLItemCache.intern(protocol);\n    path = URLItemCache.checkPath(path);\n\n    return new ServiceConfigURL(protocol, username, password, host, port, path, parameters);\n}",
        "summary_tokens": [
            "full",
            "urlstr",
            "full",
            "urlstring",
            "decoded",
            "body",
            "format",
            "protocol",
            "username",
            "password",
            "host",
            "port",
            "path",
            "parameters",
            "url"
        ]
    },
    {
        "id": 74,
        "code": "public static URL parseEncodedStr(String encodedURLStr) {\n    Map<String, String> parameters = null;\n    int pathEndIdx = encodedURLStr.toUpperCase().indexOf(\"%3F\");\n    if (pathEndIdx >= 0) {\n        parameters = parseEncodedParams(encodedURLStr, pathEndIdx + 3);\n    } else {\n        pathEndIdx = encodedURLStr.length();\n    }\n\n        \n    String decodedBody = decodeComponent(encodedURLStr, 0, pathEndIdx, false, DECODE_TEMP_BUF.get());\n    return parseURLBody(encodedURLStr, decodedBody, parameters);\n}",
        "summary_tokens": [
            "encoded",
            "urlstr",
            "after",
            "url",
            "encode",
            "string",
            "string",
            "encoded",
            "urlstr",
            "after",
            "decode",
            "format",
            "protocol",
            "username",
            "password",
            "port",
            "path",
            "k",
            "0",
            "v",
            "0",
            "k",
            "0",
            "v",
            "0",
            "protocol",
            "username",
            "password",
            "host",
            "port",
            "path",
            "k",
            "0",
            "v",
            "0",
            "k",
            "0",
            "v",
            "0"
        ]
    },
    {
        "id": 75,
        "code": "public static int compare(String version1, String version2) {\n    return Integer.compare(getIntVersion(version1), getIntVersion(version2));\n}",
        "summary_tokens": [
            "compare",
            "versions",
            "the",
            "value",
            "0",
            "if",
            "version",
            "0",
            "version",
            "0",
            "a",
            "value",
            "less",
            "than",
            "0",
            "if",
            "version",
            "0",
            "version",
            "0",
            "and",
            "a",
            "value",
            "greater",
            "than",
            "0",
            "if",
            "version",
            "0",
            "version",
            "0"
        ]
    },
    {
        "id": 76,
        "code": "public static boolean isRelease270OrHigher(String version) {\n    if (StringUtils.isEmpty(version)) {\n        return false;\n    }\n\n    return getIntVersion(version) >= 2070000;\n}",
        "summary_tokens": [
            "check",
            "the",
            "framework",
            "release",
            "version",
            "number",
            "to",
            "decide",
            "if",
            "it",
            "s",
            "0"
        ]
    },
    {
        "id": 77,
        "code": "public static boolean isRelease263OrHigher(String version) {\n    return getIntVersion(version) >= 2060300;\n}",
        "summary_tokens": [
            "check",
            "the",
            "framework",
            "release",
            "version",
            "number",
            "to",
            "decide",
            "if",
            "it",
            "s",
            "0"
        ]
    },
    {
        "id": 78,
        "code": "private static String getPrefixDigits(String v) {\n    Matcher matcher = PREFIX_DIGITS_PATTERN.matcher(v);\n    if (matcher.find()) {\n        return matcher.group(1);\n    }\n    return \"\";\n}",
        "summary_tokens": [
            "get",
            "prefix",
            "digits",
            "from",
            "given",
            "version",
            "string"
        ]
    },
    {
        "id": 79,
        "code": "private static String getFromFile(String file) {\n        \n    file = file.substring(0, file.length() - 4);\n\n        \n    int i = file.lastIndexOf('/');\n    if (i >= 0) {\n        file = file.substring(i + 1);\n    }\n\n        \n    i = file.indexOf(\"-\");\n    if (i >= 0) {\n        file = file.substring(i + 1);\n    }\n\n        \n    while (file.length() > 0 && !Character.isDigit(file.charAt(0))) {\n        i = file.indexOf(\"-\");\n        if (i >= 0) {\n            file = file.substring(i + 1);\n        } else {\n            break;\n        }\n    }\n    return file;\n}",
        "summary_tokens": [
            "get",
            "version",
            "from",
            "file",
            "path",
            "to",
            "group",
            "module",
            "x"
        ]
    },
    {
        "id": 80,
        "code": "private static Set<String> getResources(String path) throws IOException {\n    Enumeration<URL> urls = ClassUtils.getCallerClassLoader(Version.class).getResources(path);\n    Set<String> files = new HashSet<String>();\n    while (urls.hasMoreElements()) {\n        URL url = urls.nextElement();\n        if (url != null) {\n            String file = url.getFile();\n            if (StringUtils.isNotEmpty(file)) {\n                files.add(file);\n            }\n        }\n    }\n    return files;\n}",
        "summary_tokens": [
            "search",
            "resources",
            "in",
            "caller",
            "s",
            "classloader"
        ]
    },
    {
        "id": 81,
        "code": "public Class<?> toClass(Class<?> neighbor) {\n    return toClass(neighbor,\n        mClassLoader,\n        getClass().getProtectionDomain());\n}",
        "summary_tokens": [
            "neighbor",
            "a",
            "class",
            "belonging",
            "to",
            "the",
            "same",
            "package",
            "that",
            "this",
            "class",
            "belongs",
            "to"
        ]
    },
    {
        "id": 82,
        "code": "public static Mixin mixin(Class<?>[] ics, Class<?>[] dcs, ClassLoader cl) {\n    assertInterfaceArray(ics);\n\n    long id = MIXIN_CLASS_COUNTER.getAndIncrement();\n    String pkg = null;\n    ClassGenerator ccp = null, ccm = null;\n    try {\n        ccp = ClassGenerator.newInstance(cl);\n\n            \n        StringBuilder code = new StringBuilder();\n        for (int i = 0; i < dcs.length; i++) {\n            if (!Modifier.isPublic(dcs[i].getModifiers())) {\n                String npkg = dcs[i].getPackage().getName();\n                if (pkg == null) {\n                    pkg = npkg;\n                } else {\n                    if (!pkg.equals(npkg)) {\n                        throw new IllegalArgumentException(\"non-public interfaces class from different packages\");\n                    }\n                }\n            }\n\n            ccp.addField(\"private \" + dcs[i].getName() + \" d\" + i + \";\");\n\n            code.append('d').append(i).append(\" = (\").append(dcs[i].getName()).append(\")$1[\").append(i).append(\"];\\n\");\n            if (MixinAware.class.isAssignableFrom(dcs[i])) {\n                code.append('d').append(i).append(\".setMixinInstance(this);\\n\");\n            }\n        }\n        ccp.addConstructor(Modifier.PUBLIC, new Class<?>[]{Object[].class}, code.toString());\n\n        Class<?> neighbor = null;\n            \n        Set<String> worked = new HashSet<String>();\n        for (int i = 0; i < ics.length; i++) {\n            if (!Modifier.isPublic(ics[i].getModifiers())) {\n                String npkg = ics[i].getPackage().getName();\n                if (pkg == null) {\n                    pkg = npkg;\n                    neighbor = ics[i];\n                } else {\n                    if (!pkg.equals(npkg)) {\n                        throw new IllegalArgumentException(\"non-public delegate class from different packages\");\n                    }\n                }\n            }\n\n            ccp.addInterface(ics[i]);\n\n            for (Method method : ics[i].getMethods()) {\n                if (\"java.lang.Object\".equals(method.getDeclaringClass().getName())) {\n                    continue;\n                }\n\n                String desc = ReflectUtils.getDesc(method);\n                if (worked.contains(desc)) {\n                    continue;\n                }\n                worked.add(desc);\n\n                int ix = findMethod(dcs, desc);\n                if (ix < 0) {\n                    throw new RuntimeException(\"Missing method [\" + desc + \"] implement.\");\n                }\n\n                Class<?> rt = method.getReturnType();\n                String mn = method.getName();\n                if (Void.TYPE.equals(rt)) {\n                    ccp.addMethod(mn, method.getModifiers(), rt, method.getParameterTypes(), method.getExceptionTypes(),\n                            \"d\" + ix + \".\" + mn + \"($$);\");\n                } else {\n                    ccp.addMethod(mn, method.getModifiers(), rt, method.getParameterTypes(), method.getExceptionTypes(),\n                            \"return ($r)d\" + ix + \".\" + mn + \"($$);\");\n                }\n            }\n        }\n\n        if (pkg == null) {\n            pkg = PACKAGE_NAME;\n            neighbor = Mixin.class;\n        }\n\n            \n        String micn = pkg + \".mixin\" + id;\n        ccp.setClassName(micn);\n        ccp.toClass(neighbor);\n\n            \n        String fcn = Mixin.class.getName() + id;\n        ccm = ClassGenerator.newInstance(cl);\n        ccm.setClassName(fcn);\n        ccm.addDefaultConstructor();\n        ccm.setSuperClass(Mixin.class.getName());\n        ccm.addMethod(\"public Object newInstance(Object[] delegates){ return new \" + micn + \"($1); }\");\n        Class<?> mixin = ccm.toClass(Mixin.class);\n        return (Mixin) mixin.getDeclaredConstructor().newInstance();\n    } catch (RuntimeException e) {\n        throw e;\n    } catch (Exception e) {\n        throw new RuntimeException(e.getMessage(), e);\n    } finally {\n            \n        if (ccp != null) {\n            ccp.release();\n        }\n        if (ccm != null) {\n            ccm.release();\n        }\n    }\n}",
        "summary_tokens": [
            "mixin",
            "interface",
            "and",
            "delegates"
        ]
    },
    {
        "id": 83,
        "code": "public Object newInstance(InvocationHandler handler) {\n    Constructor<?> constructor;\n    try {\n        constructor = classToCreate.getDeclaredConstructor(InvocationHandler.class);\n        return constructor.newInstance(handler);\n    } catch (ReflectiveOperationException e) {\n        throw new RuntimeException(e);\n    }\n}",
        "summary_tokens": [
            "get",
            "instance",
            "with",
            "special",
            "handler"
        ]
    },
    {
        "id": 84,
        "code": "protected String getCacheFilePath() {\n    return cacheFilePath;\n}",
        "summary_tokens": [
            "for",
            "unit",
            "test",
            "only"
        ]
    },
    {
        "id": 85,
        "code": "private static String safeName(String name) {\n    int len = name.length();\n    StringBuilder sb = new StringBuilder(len);\n    for (int i = 0; i < len; i++) {\n        char c = name.charAt(i);\n        if (LEGAL_CHARACTERS.contains(c)) {\n            sb.append(c);\n        } else {\n            sb.append(ESCAPE_MARK);\n            sb.append(String.format(\"%04x\", (int) c));\n        }\n    }\n    return sb.toString();\n}",
        "summary_tokens": [
            "sanitize",
            "a",
            "name",
            "for",
            "valid",
            "file",
            "or",
            "directory",
            "name"
        ]
    },
    {
        "id": 86,
        "code": "private static FileCacheStore getFile(String name, boolean enableFileCache) {\n    if (!enableFileCache) {\n        return FileCacheStore.Empty.getInstance(name);\n    }\n\n    try {\n        FileCacheStore.Builder builder = FileCacheStore.newBuilder();\n        tryFileLock(builder, name);\n        File file = new File(name);\n\n        if (!file.exists()) {\n            Path pathObjectOfFile = file.toPath();\n            Files.createFile(pathObjectOfFile);\n        }\n\n        builder.cacheFilePath(name)\n            .cacheFile(file);\n\n        return builder.build();\n    } catch (Throwable t) {\n\n        logger.warn(\"0-3\", \"inaccessible of cache path\", \"\",\n            \"Failed to create file store cache. Local file cache will be disabled. Cache file name: \" + name, t);\n\n        return FileCacheStore.Empty.getInstance(name);\n    }\n}",
        "summary_tokens": [
            "get",
            "a",
            "file",
            "object",
            "for",
            "the",
            "given",
            "name"
        ]
    },
    {
        "id": 87,
        "code": "static Map<String, FileCacheStore> getCacheMap() {\n    return cacheMap;\n}",
        "summary_tokens": [
            "for",
            "unit",
            "test",
            "only"
        ]
    },
    {
        "id": 88,
        "code": "default Class<?> compile(Class<?> neighbor, String code, ClassLoader classLoader) {\n    return compile(code, classLoader);\n}",
        "summary_tokens": [
            "compile",
            "java",
            "source",
            "code"
        ]
    },
    {
        "id": 89,
        "code": "public static String getSimpleClassName(String qualifiedName) {\n    if (null == qualifiedName) {\n        return null;\n    }\n    int i = qualifiedName.lastIndexOf('.');\n    return i < 0 ? qualifiedName : qualifiedName.substring(i + 1);\n}",
        "summary_tokens": [
            "get",
            "simple",
            "class",
            "name",
            "from",
            "qualified",
            "class",
            "name"
        ]
    },
    {
        "id": 90,
        "code": "protected String getQualifiedClassName(String className) {\n    if (className.contains(\".\")) {\n        return className;\n    }\n\n    if (fullNames.containsKey(className)) {\n        return fullNames.get(className);\n    }\n\n    return ClassUtils.forName(imports.toArray(new String[0]), className).getName();\n}",
        "summary_tokens": [
            "get",
            "full",
            "qualified",
            "class",
            "name"
        ]
    },
    {
        "id": 91,
        "code": "public CtClass build(ClassLoader classLoader) throws NotFoundException, CannotCompileException {\n    ClassPool pool = new ClassPool(true);\n    pool.insertClassPath(new LoaderClassPath(classLoader));\n    pool.insertClassPath(new DubboLoaderClassPath());\n        \n        \n    CtClass ctClass = pool.makeClass(className, pool.get(superClassName));\n\n        \n    imports.forEach(pool::importPackage);\n\n        \n    for (String iface : ifaces) {\n        ctClass.addInterface(pool.get(iface));\n    }\n\n        \n    for (String constructor : constructors) {\n        ctClass.addConstructor(CtNewConstructor.make(constructor, ctClass));\n    }\n\n        \n    for (String field : fields) {\n        ctClass.addField(CtField.make(field, ctClass));\n    }\n\n        \n    for (String method : methods) {\n        ctClass.addMethod(CtNewMethod.make(method, ctClass));\n    }\n\n    return ctClass;\n}",
        "summary_tokens": [
            "build",
            "ct",
            "class",
            "object"
        ]
    },
    {
        "id": 92,
        "code": "public final T get() {\n    T result;\n\n    while ((result = reference.get()) == null) {\n        if (factory.compareAndSet(null, this)) {\n            reference.set(initialize());\n        }\n    }\n\n    return result;\n}",
        "summary_tokens": [
            "get",
            "and",
            "initialize",
            "if",
            "not",
            "initialized",
            "yet",
            "the",
            "required",
            "object"
        ]
    },
    {
        "id": 93,
        "code": "protected T initialize() {\n    try {\n        return callable.call();\n    } catch (Exception e) {\n        throw new RuntimeException(e.getMessage(), e);\n    }\n}",
        "summary_tokens": [
            "creates",
            "and",
            "initializes",
            "the",
            "object",
            "managed",
            "by",
            "this",
            "atomic",
            "initializer"
        ]
    },
    {
        "id": 94,
        "code": "default String getString(String key, String defaultValue) {\n    return convert(String.class, key, defaultValue);\n}",
        "summary_tokens": [
            "get",
            "a",
            "string",
            "associated",
            "with",
            "the",
            "given",
            "configuration",
            "key"
        ]
    },
    {
        "id": 95,
        "code": "default Object getProperty(String key, Object defaultValue) {\n    Object value = getInternalProperty(key);\n    return value != null ? value : defaultValue;\n}",
        "summary_tokens": [
            "gets",
            "a",
            "property",
            "from",
            "the",
            "configuration"
        ]
    },
    {
        "id": 96,
        "code": "default boolean containsKey(String key) {\n    return !isEmptyValue(getProperty(key));\n}",
        "summary_tokens": [
            "check",
            "if",
            "the",
            "configuration",
            "contains",
            "the",
            "specified",
            "key"
        ]
    },
    {
        "id": 97,
        "code": "public static Configuration getSystemConfiguration() {\n    return ApplicationModel.defaultModel().getModelEnvironment().getSystemConfiguration();\n}",
        "summary_tokens": [
            "for",
            "compact",
            "single",
            "instance",
            "replaced",
            "to",
            "configuration",
            "utils",
            "get",
            "system",
            "configuration",
            "scope",
            "model"
        ]
    },
    {
        "id": 98,
        "code": "public static Configuration getEnvConfiguration() {\n    return ApplicationModel.defaultModel().getModelEnvironment().getEnvironmentConfiguration();\n}",
        "summary_tokens": [
            "for",
            "compact",
            "single",
            "instance",
            "replaced",
            "to",
            "configuration",
            "utils",
            "get",
            "env",
            "configuration",
            "scope",
            "model"
        ]
    },
    {
        "id": 99,
        "code": "public static Configuration getGlobalConfiguration() {\n    return ApplicationModel.defaultModel().getModelEnvironment().getConfiguration();\n}",
        "summary_tokens": [
            "for",
            "compact",
            "single",
            "instance",
            "replaced",
            "to",
            "configuration",
            "utils",
            "get",
            "global",
            "configuration",
            "scope",
            "model"
        ]
    },
    {
        "id": 100,
        "code": "public static int getServerShutdownTimeout(ScopeModel scopeModel) {\n    int timeout = DEFAULT_SERVER_SHUTDOWN_TIMEOUT;\n    Configuration configuration = getGlobalConfiguration(scopeModel);\n    String value = StringUtils.trim(configuration.getString(SHUTDOWN_WAIT_KEY));\n\n    if (StringUtils.isNotEmpty(value)) {\n        try {\n            timeout = Integer.parseInt(value);\n        } catch (Exception e) {\n                \n        }\n    } else {\n        value = StringUtils.trim(configuration.getString(SHUTDOWN_WAIT_SECONDS_KEY));\n        if (StringUtils.isNotEmpty(value)) {\n            try {\n                timeout = Integer.parseInt(value) * 1000;\n            } catch (Exception e) {\n                    \n            }\n        }\n    }\n    return timeout;\n}",
        "summary_tokens": [
            "server",
            "shutdown",
            "wait",
            "timeout",
            "mills"
        ]
    },
    {
        "id": 101,
        "code": "public static <V extends Object> Map<String, V> getSubProperties(Collection<Map<String, V>> configMaps, String prefix) {\n    Map<String, V> map = new LinkedHashMap<>();\n    for (Map<String, V> configMap : configMaps) {\n        getSubProperties(configMap, prefix, map);\n    }\n    return map;\n}",
        "summary_tokens": [
            "search",
            "props",
            "and",
            "extract",
            "sub",
            "properties"
        ]
    },
    {
        "id": 102,
        "code": "public static <V extends Object> Set<String> getSubIds(Collection<Map<String, V>> configMaps, String prefix) {\n    if (!prefix.endsWith(\".\")) {\n        prefix += \".\";\n    }\n    Set<String> ids = new LinkedHashSet<>();\n    for (Map<String, V> configMap : configMaps) {\n        for (Map.Entry<String, V> entry : configMap.entrySet()) {\n            String key = entry.getKey();\n            V val = entry.getValue();\n            if (StringUtils.startsWithIgnoreCase(key, prefix)\n                && key.length() > prefix.length()\n                && !ConfigurationUtils.isEmptyValue(val)) {\n\n                String k = key.substring(prefix.length());\n                int endIndex = k.indexOf(\".\");\n                if (endIndex > 0) {\n                    String id = k.substring(0, endIndex);\n                    ids.add(id);\n                }\n            }\n        }\n    }\n    return ids;\n}",
        "summary_tokens": [
            "search",
            "props",
            "and",
            "extract",
            "config",
            "ids",
            "pre",
            "properties",
            "dubbo"
        ]
    },
    {
        "id": 103,
        "code": "public static DynamicConfigurationFactory getDynamicConfigurationFactory(ExtensionAccessor extensionAccessor, String name) {\n    ExtensionLoader<DynamicConfigurationFactory> loader = extensionAccessor.getExtensionLoader(DynamicConfigurationFactory.class);\n    return loader.getOrDefaultExtension(name);\n}",
        "summary_tokens": [
            "get",
            "an",
            "instance",
            "of",
            "dynamic",
            "configuration",
            "factory",
            "by",
            "the",
            "specified",
            "name"
        ]
    },
    {
        "id": 104,
        "code": "public static Configuration getDynamicGlobalConfiguration() {\n    return ApplicationModel.defaultModel().getDefaultModule().getModelEnvironment().getDynamicGlobalConfiguration();\n}",
        "summary_tokens": [
            "for",
            "compact",
            "single",
            "instance",
            "replaced",
            "to",
            "configuration",
            "utils",
            "get",
            "dynamic",
            "global",
            "configuration",
            "scope",
            "model"
        ]
    },
    {
        "id": 105,
        "code": "public static String getCachedDynamicProperty(String key, String defaultValue) {\n    return getCachedDynamicProperty(ApplicationModel.defaultModel(), key, defaultValue);\n}",
        "summary_tokens": [
            "for",
            "compact",
            "single",
            "instance",
            "replaced",
            "to",
            "configuration",
            "utils",
            "get",
            "cached",
            "dynamic",
            "property",
            "scope",
            "model",
            "string",
            "string"
        ]
    },
    {
        "id": 106,
        "code": "public static String getDynamicProperty(String property, String defaultValue) {\n    return getDynamicProperty(ApplicationModel.defaultModel(), property, defaultValue);\n}",
        "summary_tokens": [
            "for",
            "compact",
            "single",
            "instance",
            "replaced",
            "to",
            "configuration",
            "utils",
            "get",
            "dynamic",
            "property",
            "scope",
            "model",
            "string",
            "string"
        ]
    },
    {
        "id": 107,
        "code": "public static String getProperty(String property, String defaultValue) {\n    return getProperty(ApplicationModel.defaultModel(), property, defaultValue);\n}",
        "summary_tokens": [
            "for",
            "compact",
            "single",
            "instance",
            "replaced",
            "to",
            "configuration",
            "utils",
            "get",
            "property",
            "scope",
            "model",
            "string",
            "string"
        ]
    },
    {
        "id": 108,
        "code": "public static int get(String property, int defaultValue) {\n    return get(ApplicationModel.defaultModel(), property, defaultValue);\n}",
        "summary_tokens": [
            "for",
            "compact",
            "single",
            "instance",
            "replaced",
            "to",
            "configuration",
            "utils",
            "get",
            "scope",
            "model",
            "string",
            "int"
        ]
    },
    {
        "id": 109,
        "code": "private void loadMigrationRule() {\n    if (Boolean.parseBoolean(System.getProperty(CommonConstants.DUBBO_MIGRATION_FILE_ENABLE, \"false\"))) {\n        String path = System.getProperty(CommonConstants.DUBBO_MIGRATION_KEY);\n        if (StringUtils.isEmpty(path)) {\n            path = System.getenv(CommonConstants.DUBBO_MIGRATION_KEY);\n            if (StringUtils.isEmpty(path)) {\n                path = CommonConstants.DEFAULT_DUBBO_MIGRATION_FILE;\n            }\n        }\n        this.localMigrationRule = ConfigUtils.loadMigrationRule(scopeModel.getClassLoaders(), path);\n    } else {\n        this.localMigrationRule = null;\n    }\n}",
        "summary_tokens": [
            "migration",
            "rule",
            "will",
            "be",
            "removed",
            "in",
            "0"
        ]
    },
    {
        "id": 110,
        "code": "public void updateAppConfigMap(Map<String, String> map) {\n    this.appConfiguration.addProperties(map);\n}",
        "summary_tokens": [
            "merge",
            "target",
            "map",
            "properties",
            "into",
            "app",
            "configuration",
            "map"
        ]
    },
    {
        "id": 111,
        "code": "public Configuration getPrefixedConfiguration(AbstractConfig config, String prefix) {\n\n        \n    Configuration instanceConfiguration = new ConfigConfigurationAdapter(config, prefix);\n    CompositeConfiguration compositeConfiguration = new CompositeConfiguration();\n    compositeConfiguration.addConfiguration(systemConfiguration);\n    compositeConfiguration.addConfiguration(environmentConfiguration);\n    compositeConfiguration.addConfiguration(appExternalConfiguration);\n    compositeConfiguration.addConfiguration(externalConfiguration);\n    compositeConfiguration.addConfiguration(appConfiguration);\n    compositeConfiguration.addConfiguration(instanceConfiguration);\n    compositeConfiguration.addConfiguration(propertiesConfiguration);\n\n    return new PrefixedConfiguration(compositeConfiguration, prefix);\n}",
        "summary_tokens": [
            "at",
            "start",
            "up",
            "dubbo",
            "is",
            "driven",
            "by",
            "various",
            "configuration",
            "such",
            "as",
            "application",
            "registry",
            "protocol",
            "etc"
        ]
    },
    {
        "id": 112,
        "code": "public CompositeConfiguration getConfiguration() {\n    if (globalConfiguration == null) {\n        CompositeConfiguration configuration = new CompositeConfiguration();\n        configuration.addConfiguration(systemConfiguration);\n        configuration.addConfiguration(environmentConfiguration);\n        configuration.addConfiguration(appExternalConfiguration);\n        configuration.addConfiguration(externalConfiguration);\n        configuration.addConfiguration(appConfiguration);\n        configuration.addConfiguration(propertiesConfiguration);\n        globalConfiguration = configuration;\n    }\n    return globalConfiguration;\n}",
        "summary_tokens": [
            "there",
            "are",
            "two",
            "ways",
            "to",
            "get",
            "configuration",
            "during",
            "exposure",
            "reference",
            "or",
            "at",
            "runtime",
            "0"
        ]
    },
    {
        "id": 113,
        "code": "public List<Map<String, String>> getConfigurationMaps() {\n    if (globalConfigurationMaps == null) {\n        globalConfigurationMaps = getConfigurationMaps(null, null);\n    }\n    return globalConfigurationMaps;\n}",
        "summary_tokens": [
            "get",
            "global",
            "configuration",
            "as",
            "map",
            "list"
        ]
    },
    {
        "id": 114,
        "code": "public void addProperty(String key, String value) {\n    store.put(key, value);\n}",
        "summary_tokens": [
            "add",
            "one",
            "property",
            "into",
            "the",
            "store",
            "the",
            "previous",
            "value",
            "will",
            "be",
            "replaced",
            "if",
            "the",
            "key",
            "exists"
        ]
    },
    {
        "id": 115,
        "code": "public void addProperties(Map<String, String> properties) {\n    if (properties != null) {\n        this.store.putAll(properties);\n    }\n}",
        "summary_tokens": [
            "add",
            "a",
            "set",
            "of",
            "properties",
            "into",
            "the",
            "store"
        ]
    },
    {
        "id": 116,
        "code": "public String getDefaultGroup() {\n    return getGroup();\n}",
        "summary_tokens": [
            "the",
            "default",
            "group",
            "0"
        ]
    },
    {
        "id": 117,
        "code": "public long getDefaultTimeout() {\n    return getTimeout();\n}",
        "summary_tokens": [
            "the",
            "default",
            "timeout",
            "0"
        ]
    },
    {
        "id": 118,
        "code": "protected final <V> V execute(Callable<V> task, long timeout) {\n    V value = null;\n    try {\n\n        if (timeout < 1) { \n            value = task.call();\n        } else {\n            Future<V> future = workersThreadPool.submit(task);\n            value = future.get(timeout, TimeUnit.MILLISECONDS);\n        }\n    } catch (Exception e) {\n        if (logger.isErrorEnabled()) {\n            logger.error(e.getMessage(), e);\n        }\n    }\n    return value;\n}",
        "summary_tokens": [
            "executes",
            "the",
            "callable",
            "with",
            "the",
            "specified",
            "timeout"
        ]
    },
    {
        "id": 119,
        "code": "protected static String getGroup(URL url) {\n    String group = getParameter(url, GROUP_PARAM_NAME, null);\n    return StringUtils.isBlank(group) ? getParameter(url, GROUP_KEY, DEFAULT_GROUP) : group;\n}",
        "summary_tokens": [
            "get",
            "the",
            "group",
            "from",
            "url",
            "the",
            "specified",
            "connection",
            "url"
        ]
    },
    {
        "id": 120,
        "code": "protected static long getTimeout(URL url) {\n    return getParameter(url, TIMEOUT_PARAM_NAME, -1L);\n}",
        "summary_tokens": [
            "get",
            "the",
            "timeout",
            "from",
            "url",
            "the",
            "specified",
            "connection",
            "url"
        ]
    },
    {
        "id": 121,
        "code": "default void addListener(String key, ConfigurationListener listener) {\n    addListener(key, getDefaultGroup(), listener);\n}",
        "summary_tokens": [
            "add",
            "listener",
            "string",
            "string",
            "configuration",
            "listener"
        ]
    },
    {
        "id": 122,
        "code": "default void removeListener(String key, ConfigurationListener listener) {\n    removeListener(key, getDefaultGroup(), listener);\n}",
        "summary_tokens": [
            "remove",
            "listener",
            "string",
            "string",
            "configuration",
            "listener"
        ]
    },
    {
        "id": 123,
        "code": "default String getConfig(String key, String group) {\n    return getConfig(key, group, getDefaultTimeout());\n}",
        "summary_tokens": [
            "get",
            "the",
            "configuration",
            "mapped",
            "to",
            "the",
            "given",
            "key",
            "and",
            "the",
            "given",
            "group",
            "with",
            "get",
            "default",
            "timeout",
            "the",
            "default",
            "timeout"
        ]
    },
    {
        "id": 124,
        "code": "default ConfigItem getConfigItem(String key, String group) {\n    String content = getConfig(key, group);\n    return new ConfigItem(content, null);\n}",
        "summary_tokens": [
            "get",
            "config",
            "item",
            "which",
            "contains",
            "content",
            "and",
            "stat",
            "info"
        ]
    },
    {
        "id": 125,
        "code": "default String getProperties(String key, String group, long timeout) throws IllegalStateException {\n    return getConfig(key, group, timeout);\n}",
        "summary_tokens": [
            "this",
            "method",
            "are",
            "mostly",
            "used",
            "to",
            "get",
            "a",
            "compound",
            "config",
            "file",
            "such",
            "as",
            "a",
            "complete",
            "dubbo"
        ]
    },
    {
        "id": 126,
        "code": "default boolean publishConfig(String key, String group, String content) throws UnsupportedOperationException {\n    return false;\n}",
        "summary_tokens": [
            "publish",
            "config",
            "mapped",
            "to",
            "the",
            "given",
            "key",
            "and",
            "the",
            "given",
            "group"
        ]
    },
    {
        "id": 127,
        "code": "default boolean publishConfigCas(String key, String group, String content, Object ticket) throws UnsupportedOperationException {\n    return false;\n}",
        "summary_tokens": [
            "publish",
            "config",
            "mapped",
            "to",
            "this",
            "given",
            "key",
            "and",
            "given",
            "group",
            "with",
            "stat"
        ]
    },
    {
        "id": 128,
        "code": "default String getDefaultGroup() {\n    return DEFAULT_GROUP;\n}",
        "summary_tokens": [
            "get",
            "the",
            "default",
            "group",
            "for",
            "the",
            "operations"
        ]
    },
    {
        "id": 129,
        "code": "default long getDefaultTimeout() {\n    return -1L;\n}",
        "summary_tokens": [
            "get",
            "the",
            "default",
            "timeout",
            "for",
            "the",
            "operations",
            "in",
            "milliseconds"
        ]
    },
    {
        "id": 130,
        "code": "static String getRuleKey(URL url) {\n    return url.getColonSeparatedKey();\n}",
        "summary_tokens": [
            "the",
            "format",
            "is",
            "interface",
            "name",
            "version",
            "group"
        ]
    },
    {
        "id": 131,
        "code": "default boolean removeConfig(String key, String group) {\n    return true;\n}",
        "summary_tokens": [
            "key",
            "the",
            "key",
            "to",
            "represent",
            "a",
            "configuration",
            "group",
            "the",
            "group",
            "where",
            "the",
            "key",
            "belongs",
            "to",
            "code",
            "true",
            "code",
            "if",
            "success",
            "or",
            "code",
            "false",
            "code",
            "0"
        ]
    },
    {
        "id": 132,
        "code": "protected String getRootPath(URL url) {\n\n    String rootPath = url.getParameter(CONFIG_ROOT_PATH_PARAM_NAME, buildRootPath(url));\n\n    rootPath = normalize(rootPath);\n\n    int rootPathLength = rootPath.length();\n\n    if (rootPathLength > 1 && rootPath.endsWith(PATH_SEPARATOR)) {\n        rootPath = rootPath.substring(0, rootPathLength - 1);\n    }\n\n    return rootPath;\n}",
        "summary_tokens": [
            "get",
            "the",
            "root",
            "path",
            "from",
            "the",
            "specified",
            "url",
            "connection",
            "url"
        ]
    },
    {
        "id": 133,
        "code": "protected String getConfigNamespace(URL url) {\n    return url.getParameter(CONFIG_NAMESPACE_KEY, DEFAULT_GROUP);\n}",
        "summary_tokens": [
            "get",
            "the",
            "namespace",
            "from",
            "the",
            "specified",
            "url",
            "connection",
            "url"
        ]
    },
    {
        "id": 134,
        "code": "protected String getConfigBasePath(URL url) {\n    String configBasePath = url.getParameter(CONFIG_BASE_PATH_PARAM_NAME, DEFAULT_CONFIG_BASE_PATH);\n    if (StringUtils.isNotEmpty(configBasePath) && !configBasePath.startsWith(PATH_SEPARATOR)) {\n        configBasePath = PATH_SEPARATOR + configBasePath;\n    }\n    return configBasePath;\n}",
        "summary_tokens": [
            "get",
            "the",
            "config",
            "base",
            "path",
            "from",
            "the",
            "specified",
            "url",
            "connection",
            "url"
        ]
    },
    {
        "id": 135,
        "code": "private void registerDubboShutdownHook() {\n    if (!hasRegisteredShutdownHook.compareAndSet(false, true)) {\n        return;\n    }\n    ShutdownHookCallbacks shutdownHookCallbacks = ScopeModelUtil.getApplicationModel(scopeModel).getBeanFactory().getBean(ShutdownHookCallbacks.class);\n    shutdownHookCallbacks.addCallback(() -> {\n        watchService.ifPresent(w -> {\n            try {\n                w.close();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        });\n        getWatchEventsLoopThreadPool().shutdown();\n    });\n}",
        "summary_tokens": [
            "register",
            "the",
            "dubbo",
            "shutdown",
            "hook"
        ]
    },
    {
        "id": 136,
        "code": "private void processWatchEvents(WatchService watchService) {\n    getWatchEventsLoopThreadPool().execute(() -> { \n        while (true) {\n            WatchKey watchKey = null;\n            try {\n                watchKey = watchService.take();\n                if (watchKey.isValid()) {\n                    for (WatchEvent event : watchKey.pollEvents()) {\n                        WatchEvent.Kind kind = event.kind();\n                            \n                        ConfigChangeType configChangeType = CONFIG_CHANGE_TYPES_MAP.get(kind.name());\n                        if (configChangeType != null) {\n                            Path configDirectoryPath = (Path) watchKey.watchable();\n                            Path currentPath = (Path) event.context();\n                            Path configFilePath = configDirectoryPath.resolve(currentPath);\n                            File configDirectory = configDirectoryPath.toFile();\n                            executeMutually(configDirectory, () -> {\n                                fireConfigChangeEvent(configDirectory, configFilePath.toFile(), configChangeType);\n                                signalConfigDirectory(configDirectory);\n                                return null;\n                            });\n                        }\n                    }\n                }\n            } catch (Exception e) {\n                return;\n            } finally {\n                if (watchKey != null) {\n                        \n                    watchKey.reset();\n                }\n            }\n        }\n    });\n}",
        "summary_tokens": [
            "process",
            "the",
            "watch",
            "event",
            "watch",
            "events",
            "loop",
            "in",
            "async",
            "execution"
        ]
    },
    {
        "id": 137,
        "code": "protected <V> V delay(String configFilePath, ThrowableFunction<File, V> function) {\n    File configFile = new File(configFilePath);\n        \n    if (isBasedPoolingWatchService()) {\n        File configDirectory = configFile.getParentFile();\n        executeMutually(configDirectory, () -> {\n            if (hasListeners(configFile) && isProcessing(configDirectory)) {\n                Integer delay = getDelay();\n                if (delay != null) {\n                        \n                    long timeout = SECONDS.toMillis(delay);\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(format(\"The config[path : %s] is about to delay in %d ms.\",\n                                configFilePath, timeout));\n                    }\n                    configDirectory.wait(timeout);\n                }\n            }\n            addProcessing(configDirectory);\n            return null;\n        });\n    }\n\n    V value = null;\n\n    try {\n        value = function.apply(configFile);\n    } catch (Throwable e) {\n        if (logger.isErrorEnabled()) {\n            logger.error(e.getMessage(), e);\n        }\n    }\n\n    return value;\n}",
        "summary_tokens": [
            "delay",
            "action",
            "for",
            "config",
            "file",
            "string",
            "string",
            "config",
            "file"
        ]
    },
    {
        "id": 138,
        "code": "private boolean isProcessing(File configDirectory) {\n    return processingDirectories.contains(configDirectory);\n}",
        "summary_tokens": [
            "is",
            "processing",
            "on",
            "build",
            "group",
            "path",
            "string",
            "config",
            "root",
            "directory"
        ]
    },
    {
        "id": 139,
        "code": "protected static boolean isBasedPoolingWatchService() {\n    return BASED_POOLING_WATCH_SERVICE;\n}",
        "summary_tokens": [
            "it",
            "s",
            "whether",
            "the",
            "implementation",
            "of",
            "watch",
            "service",
            "is",
            "based",
            "on",
            "sun"
        ]
    },
    {
        "id": 140,
        "code": "private static boolean detectPoolingBasedWatchService(Optional<WatchService> watchService) {\n    String className = watchService.map(Object::getClass).map(Class::getName).orElse(null);\n    return POLLING_WATCH_SERVICE_CLASS_NAME.equals(className);\n}",
        "summary_tokens": [
            "detect",
            "the",
            "argument",
            "of",
            "watch",
            "service",
            "is",
            "based",
            "on",
            "sun"
        ]
    },
    {
        "id": 141,
        "code": "default boolean accept(Class<?> sourceType, Class<?> targetType) {\n    return isAssignableFrom(sourceType, getSourceType()) && isAssignableFrom(targetType, getTargetType());\n}",
        "summary_tokens": [
            "accept",
            "the",
            "source",
            "type",
            "and",
            "target",
            "type",
            "or",
            "not"
        ]
    },
    {
        "id": 142,
        "code": "default Class<S> getSourceType() {\n    return findActualTypeArgument(getClass(), Converter.class, 0);\n}",
        "summary_tokens": [
            "get",
            "the",
            "source",
            "type"
        ]
    },
    {
        "id": 143,
        "code": "default Class<T> getTargetType() {\n    return findActualTypeArgument(getClass(), Converter.class, 1);\n}",
        "summary_tokens": [
            "get",
            "the",
            "target",
            "type"
        ]
    },
    {
        "id": 144,
        "code": "public Converter<?, ?> getConverter(Class<?> sourceType, Class<?> targetType) {\n    Map<Class<?>, List<Converter>> toTargetMap = converterCache.computeIfAbsent(sourceType, (k) -> new ConcurrentHashMap<>());\n    List<Converter> converters = toTargetMap.computeIfAbsent(targetType, (k) -> frameworkModel.getExtensionLoader(Converter.class)\n        .getSupportedExtensionInstances()\n        .stream()\n        .filter(converter -> converter.accept(sourceType, targetType))\n        .collect(Collectors.toList()));\n\n    return converters.size() > 0 ? converters.get(0) : null;\n}",
        "summary_tokens": [
            "get",
            "the",
            "converter",
            "instance",
            "from",
            "extension",
            "loader",
            "with",
            "the",
            "specified",
            "source",
            "and",
            "target",
            "type"
        ]
    },
    {
        "id": 145,
        "code": "public <T> T convertIfPossible(Object source, Class<T> targetType) {\n    Converter converter = getConverter(source.getClass(), targetType);\n    if (converter != null) {\n        return (T) converter.convert(source);\n    }\n    return null;\n}",
        "summary_tokens": [
            "convert",
            "the",
            "value",
            "of",
            "source",
            "to",
            "target",
            "type",
            "value",
            "if",
            "possible"
        ]
    },
    {
        "id": 146,
        "code": "default Class<S> getSourceType() {\n    return findActualTypeArgument(getClass(), MultiValueConverter.class, 0);\n}",
        "summary_tokens": [
            "get",
            "the",
            "source",
            "type"
        ]
    },
    {
        "id": 147,
        "code": "static MultiValueConverter<?> find(Class<?> sourceType, Class<?> targetType) {\n    return getExtensionLoader(MultiValueConverter.class)\n            .getSupportedExtensionInstances()\n            .stream()\n            .filter(converter -> converter.accept(sourceType, targetType))\n            .findFirst()\n            .orElse(null);\n}",
        "summary_tokens": [
            "find",
            "the",
            "multi",
            "value",
            "converter",
            "instance",
            "from",
            "extension",
            "loader",
            "with",
            "the",
            "specified",
            "source",
            "and",
            "target",
            "type"
        ]
    },
    {
        "id": 148,
        "code": "private boolean hasAdaptiveMethod() {\n    return Arrays.stream(type.getMethods()).anyMatch(m -> m.isAnnotationPresent(Adaptive.class));\n}",
        "summary_tokens": [
            "test",
            "if",
            "given",
            "type",
            "has",
            "at",
            "least",
            "one",
            "method",
            "annotated",
            "with",
            "code",
            "adaptive",
            "code"
        ]
    },
    {
        "id": 149,
        "code": "public String generate(boolean sort) {\n        \n    if (!hasAdaptiveMethod()) {\n        throw new IllegalStateException(\"No adaptive method exist on extension \" + type.getName() + \", refuse to create the adaptive class!\");\n    }\n\n    StringBuilder code = new StringBuilder();\n    code.append(generatePackageInfo());\n    code.append(generateImports());\n    code.append(generateClassDeclaration());\n\n    Method[] methods = type.getMethods();\n    if (sort) {\n        Arrays.sort(methods, Comparator.comparing(Method::toString));\n    }\n    for (Method method : methods) {\n        code.append(generateMethod(method));\n    }\n    code.append('}');\n\n    if (logger.isDebugEnabled()) {\n        logger.debug(code.toString());\n    }\n    return code.toString();",
        "summary_tokens": [
            "generate",
            "and",
            "return",
            "class",
            "code",
            "sort",
            "whether",
            "sort",
            "methods"
        ]
    },
    {
        "id": 150,
        "code": "private String generateUnsupported(Method method) {\n    return String.format(CODE_UNSUPPORTED, method, type.getName());\n}",
        "summary_tokens": [
            "generate",
            "method",
            "not",
            "annotated",
            "with",
            "adaptive",
            "with",
            "throwing",
            "unsupported",
            "exception"
        ]
    },
    {
        "id": 151,
        "code": "private int getUrlTypeIndex(Method method) {\n    int urlTypeIndex = -1;\n    Class<?>[] pts = method.getParameterTypes();\n    for (int i = 0; i < pts.length; ++i) {\n        if (pts[i].equals(URL.class)) {\n            urlTypeIndex = i;\n            break;\n        }\n    }\n    return urlTypeIndex;\n}",
        "summary_tokens": [
            "get",
            "index",
            "of",
            "parameter",
            "with",
            "type",
            "url"
        ]
    },
    {
        "id": 152,
        "code": "private String generateUrlNullCheck(int index) {\n    return String.format(CODE_URL_NULL_CHECK, index, URL.class.getName(), index);\n}",
        "summary_tokens": [
            "generate",
            "method",
            "url",
            "argument",
            "null",
            "check"
        ]
    },
    {
        "id": 153,
        "code": "private String generateExtNameNullCheck(String[] value) {\n    return String.format(CODE_EXT_NAME_NULL_CHECK, type.getName(), Arrays.toString(value));\n}",
        "summary_tokens": [
            "generate",
            "code",
            "for",
            "variable",
            "ext",
            "name",
            "null",
            "check"
        ]
    },
    {
        "id": 154,
        "code": "private String generateExtNameAssignment(String[] value, boolean hasInvocation) {\n        \n    String getNameCode = null;\n    for (int i = value.length - 1; i >= 0; --i) {\n        if (i == value.length - 1) {\n            if (null != defaultExtName) {\n                if (!\"protocol\".equals(value[i])) {\n                    if (hasInvocation) {\n                        getNameCode = String.format(\"url.getMethodParameter(methodName, \\\"%s\\\", \\\"%s\\\")\", value[i], defaultExtName);\n                    } else {\n                        getNameCode = String.format(\"url.getParameter(\\\"%s\\\", \\\"%s\\\")\", value[i], defaultExtName);\n                    }\n                } else {\n                    getNameCode = String.format(\"( url.getProtocol() == null ? \\\"%s\\\" : url.getProtocol() )\", defaultExtName);\n                }\n            } else {\n                if (!\"protocol\".equals(value[i])) {\n                    if (hasInvocation) {\n                        getNameCode = String.format(\"url.getMethodParameter(methodName, \\\"%s\\\", \\\"%s\\\")\", value[i], defaultExtName);\n                    } else {\n                        getNameCode = String.format(\"url.getParameter(\\\"%s\\\")\", value[i]);\n                    }\n                } else {\n                    getNameCode = \"url.getProtocol()\";\n                }\n            }\n        } else {\n            if (!\"protocol\".equals(value[i])) {\n                if (hasInvocation) {\n                    getNameCode = String.format(\"url.getMethodParameter(methodName, \\\"%s\\\", \\\"%s\\\")\", value[i], defaultExtName);\n                } else {\n                    getNameCode = String.format(\"url.getParameter(\\\"%s\\\", %s)\", value[i], getNameCode);\n                }\n            } else {\n                getNameCode = String.format(\"url.getProtocol() == null ? (%s) : url.getProtocol()\", getNameCode);\n            }\n        }\n    }\n\n    return String.format(CODE_EXT_NAME_ASSIGNMENT, getNameCode);\n}",
        "summary_tokens": [
            "generate",
            "ext",
            "name",
            "assignment",
            "code"
        ]
    },
    {
        "id": 155,
        "code": "private String generateReturnAndInvocation(Method method) {\n    String returnStatement = method.getReturnType().equals(void.class) ? \"\" : \"return \";\n\n    String args = IntStream.range(0, method.getParameters().length)\n            .mapToObj(i -> String.format(CODE_EXTENSION_METHOD_INVOKE_ARGUMENT, i))\n            .collect(Collectors.joining(\", \"));\n\n    return returnStatement + String.format(\"extension.%s(%s);\\n\", method.getName(), args);\n}",
        "summary_tokens": [
            "generate",
            "method",
            "invocation",
            "statement",
            "and",
            "return",
            "it",
            "if",
            "necessary"
        ]
    },
    {
        "id": 156,
        "code": "private boolean hasInvocationArgument(Method method) {\n    Class<?>[] pts = method.getParameterTypes();\n    return Arrays.stream(pts).anyMatch(p -> CLASS_NAME_INVOCATION.equals(p.getName()));\n}",
        "summary_tokens": [
            "test",
            "if",
            "method",
            "has",
            "argument",
            "of",
            "type",
            "code",
            "invocation",
            "code"
        ]
    },
    {
        "id": 157,
        "code": "private String generateInvocationArgumentNullCheck(Method method) {\n    Class<?>[] pts = method.getParameterTypes();\n    return IntStream.range(0, pts.length).filter(i -> CLASS_NAME_INVOCATION.equals(pts[i].getName()))\n                    .mapToObj(i -> String.format(CODE_INVOCATION_ARGUMENT_NULL_CHECK, i, i))\n                    .findFirst().orElse(\"\");\n}",
        "summary_tokens": [
            "generate",
            "code",
            "to",
            "test",
            "argument",
            "of",
            "type",
            "code",
            "invocation",
            "code",
            "is",
            "null"
        ]
    },
    {
        "id": 158,
        "code": "private String[] getMethodAdaptiveValue(Adaptive adaptiveAnnotation) {\n    String[] value = adaptiveAnnotation.value();\n        \n    if (value.length == 0) {\n        String splitName = StringUtils.camelToSplitName(type.getSimpleName(), \".\");\n        value = new String[]{splitName};\n    }\n    return value;\n}",
        "summary_tokens": [
            "get",
            "value",
            "of",
            "adaptive",
            "annotation",
            "or",
            "if",
            "empty",
            "return",
            "splitted",
            "simple",
            "name"
        ]
    },
    {
        "id": 159,
        "code": "private String generateUrlAssignmentIndirectly(Method method) {\n    Class<?>[] pts = method.getParameterTypes();\n\n    Map<String, Integer> getterReturnUrl = new HashMap<>();\n        \n    for (int i = 0; i < pts.length; ++i) {\n        for (Method m : pts[i].getMethods()) {\n            String name = m.getName();\n            if ((name.startsWith(\"get\") || name.length() > 3)\n                    && Modifier.isPublic(m.getModifiers())\n                    && !Modifier.isStatic(m.getModifiers())\n                    && m.getParameterTypes().length == 0\n                    && m.getReturnType() == URL.class) {\n                getterReturnUrl.put(name, i);\n            }\n        }\n    }\n\n    if (getterReturnUrl.size() <= 0) {\n            \n        throw new IllegalStateException(\"Failed to create adaptive class for interface \" + type.getName()\n                + \": not found url parameter or url attribute in parameters of method \" + method.getName());\n    }\n\n    Integer index = getterReturnUrl.get(\"getUrl\");\n    if (index != null) {\n        return generateGetUrlNullCheck(index, pts[index], \"getUrl\");\n    } else {\n        Map.Entry<String, Integer> entry = getterReturnUrl.entrySet().iterator().next();\n        return generateGetUrlNullCheck(entry.getValue(), pts[entry.getValue()], entry.getKey());\n    }\n}",
        "summary_tokens": [
            "get",
            "parameter",
            "with",
            "type",
            "code",
            "url",
            "code",
            "from",
            "method",
            "parameter",
            "p",
            "test",
            "if",
            "parameter",
            "has",
            "method",
            "which",
            "returns",
            "type",
            "code",
            "url",
            "code",
            "p",
            "if",
            "not",
            "found",
            "throws",
            "illegal",
            "state",
            "exception"
        ]
    },
    {
        "id": 160,
        "code": "private String generateGetUrlNullCheck(int index, Class<?> type, String method) {\n        \n    StringBuilder code = new StringBuilder();\n    code.append(String.format(\"if (arg%d == null) throw new IllegalArgumentException(\\\"%s argument == null\\\");\\n\",\n            index, type.getName()));\n    code.append(String.format(\"if (arg%d.%s() == null) throw new IllegalArgumentException(\\\"%s argument %s() == null\\\");\\n\",\n            index, method, type.getName(), method));\n\n    code.append(String.format(\"%s url = arg%d.%s();\\n\", URL.class.getName(), index, method));\n    return code.toString();\n}",
        "summary_tokens": [
            "0",
            "test",
            "if",
            "argi",
            "is",
            "null",
            "0",
            "test",
            "if",
            "argi"
        ]
    },
    {
        "id": 161,
        "code": "default String[] includedPackages() {\n        \n    return null;\n}",
        "summary_tokens": [
            "to",
            "restrict",
            "some",
            "class",
            "that",
            "should",
            "not",
            "be",
            "loaded",
            "from",
            "org"
        ]
    },
    {
        "id": 162,
        "code": "default String[] includedPackagesInCompatibleType() {\n        \n    return null;\n}",
        "summary_tokens": [
            "to",
            "restrict",
            "some",
            "class",
            "that",
            "should",
            "not",
            "be",
            "loaded",
            "from",
            "org"
        ]
    },
    {
        "id": 163,
        "code": "default String[] onlyExtensionClassLoaderPackages() {\n    return new String[]{};\n}",
        "summary_tokens": [
            "to",
            "restrict",
            "some",
            "class",
            "that",
            "should",
            "load",
            "from",
            "dubbo",
            "s",
            "class",
            "loader"
        ]
    },
    {
        "id": 164,
        "code": "default boolean overridden() {\n    return false;\n}",
        "summary_tokens": [
            "indicates",
            "current",
            "loading",
            "strategy",
            "supports",
            "overriding",
            "other",
            "lower",
            "prioritized",
            "instances",
            "or",
            "not"
        ]
    },
    {
        "id": 165,
        "code": "static <T> Predicate<T> alwaysTrue() {\n    return e -> true;\n}",
        "summary_tokens": [
            "predicate",
            "always",
            "return",
            "code",
            "true",
            "code"
        ]
    },
    {
        "id": 166,
        "code": "static <T> Predicate<T> alwaysFalse() {\n    return e -> false;\n}",
        "summary_tokens": [
            "predicate",
            "always",
            "return",
            "code",
            "false",
            "code"
        ]
    },
    {
        "id": 167,
        "code": "static <T> Predicate<T> and(Predicate<T>... predicates) {\n    return of(predicates).reduce((a, b) -> a.and(b)).orElseGet(Predicates::alwaysTrue);\n}",
        "summary_tokens": [
            "a",
            "composed",
            "predicate",
            "that",
            "represents",
            "a",
            "short",
            "circuiting",
            "logical",
            "and",
            "of",
            "predicate",
            "predicates"
        ]
    },
    {
        "id": 168,
        "code": "static <T> Predicate<T> or(Predicate<T>... predicates) {\n    return of(predicates).reduce((a, b) -> a.or(b)).orElse(e -> true);\n}",
        "summary_tokens": [
            "a",
            "composed",
            "predicate",
            "that",
            "represents",
            "a",
            "short",
            "circuiting",
            "logical",
            "or",
            "of",
            "predicate",
            "predicates"
        ]
    },
    {
        "id": 169,
        "code": "public static String bytes2base64(final byte[] bs, final int off, final int len, final char[] code) {\n    if (off < 0) {\n        throw new IndexOutOfBoundsException(\"bytes2base64: offset < 0, offset is \" + off);\n    }\n    if (len < 0) {\n        throw new IndexOutOfBoundsException(\"bytes2base64: length < 0, length is \" + len);\n    }\n    if (off + len > bs.length) {\n        throw new IndexOutOfBoundsException(\"bytes2base64: offset + length > array length.\");\n    }\n\n    if (code.length < 64) {\n        throw new IllegalArgumentException(\"Base64 code length < 64.\");\n    }\n\n    boolean pad = code.length > 64; \n    int num = len / 3, rem = len % 3, r = off, w = 0;\n    char[] cs = new char[num * 4 + (rem == 0 ? 0 : pad ? 4 : rem + 1)];\n\n    for (int i = 0; i < num; i++) {\n        int b1 = bs[r++] & MASK8, b2 = bs[r++] & MASK8, b3 = bs[r++] & MASK8;\n\n        cs[w++] = code[b1 >> 2];\n        cs[w++] = code[(b1 << 4) & MASK6 | (b2 >> 4)];\n        cs[w++] = code[(b2 << 2) & MASK6 | (b3 >> 6)];\n        cs[w++] = code[b3 & MASK6];\n    }\n\n    if (rem == 1) {\n        int b1 = bs[r++] & MASK8;\n        cs[w++] = code[b1 >> 2];\n        cs[w++] = code[(b1 << 4) & MASK6];\n        if (pad) {\n            cs[w++] = code[64];\n            cs[w++] = code[64];\n        }\n    } else if (rem == 2) {\n        int b1 = bs[r++] & MASK8, b2 = bs[r++] & MASK8;\n        cs[w++] = code[b1 >> 2];\n        cs[w++] = code[(b1 << 4) & MASK6 | (b2 >> 4)];\n        cs[w++] = code[(b2 << 2) & MASK6];\n        if (pad) {\n            cs[w++] = code[64];\n        }\n    }\n    return new String(cs);\n}",
        "summary_tokens": [
            "to",
            "base",
            "0",
            "string"
        ]
    },
    {
        "id": 170,
        "code": "public static byte[] base642bytes(final String str, final int off, final int len, final char[] code) {\n    if (off < 0) {\n        throw new IndexOutOfBoundsException(\"base642bytes: offset < 0, offset is \" + off);\n    }\n    if (len < 0) {\n        throw new IndexOutOfBoundsException(\"base642bytes: length < 0, length is \" + len);\n    }\n    if (len == 0) {\n        return new byte[0];\n    }\n    if (off + len > str.length()) {\n        throw new IndexOutOfBoundsException(\"base642bytes: offset + length > string length.\");\n    }\n\n    if (code.length < 64) {\n        throw new IllegalArgumentException(\"Base64 code length < 64.\");\n    }\n\n    int rem = len % 4;\n    if (rem == 1) {\n        throw new IllegalArgumentException(\"base642bytes: base64 string length % 4 == 1.\");\n    }\n\n    int num = len / 4, size = num * 3;\n    if (code.length > 64) {\n        if (rem != 0) {\n            throw new IllegalArgumentException(\"base642bytes: base64 string length error.\");\n        }\n\n        char pc = code[64];\n        if (str.charAt(off + len - 2) == pc) {\n            size -= 2;\n            --num;\n            rem = 2;\n        } else if (str.charAt(off + len - 1) == pc) {\n            size--;\n            --num;\n            rem = 3;\n        }\n    } else {\n        if (rem == 2) {\n            size++;\n        } else if (rem == 3) {\n            size += 2;\n        }\n    }\n\n    int r = off, w = 0;\n    byte[] b = new byte[size];\n    for (int i = 0; i < num; i++) {\n        int c1 = indexOf(code, str.charAt(r++)), c2 = indexOf(code, str.charAt(r++));\n        int c3 = indexOf(code, str.charAt(r++)), c4 = indexOf(code, str.charAt(r++));\n\n        b[w++] = (byte) ((c1 << 2) | (c2 >> 4));\n        b[w++] = (byte) ((c2 << 4) | (c3 >> 2));\n        b[w++] = (byte) ((c3 << 6) | c4);\n    }\n\n    if (rem == 2) {\n        int c1 = indexOf(code, str.charAt(r++)), c2 = indexOf(code, str.charAt(r++));\n\n        b[w++] = (byte) ((c1 << 2) | (c2 >> 4));\n    } else if (rem == 3) {\n        int c1 = indexOf(code, str.charAt(r++)), c2 = indexOf(code, str.charAt(r++)), c3 = indexOf(code, str.charAt(r++));\n\n        b[w++] = (byte) ((c1 << 2) | (c2 >> 4));\n        b[w++] = (byte) ((c2 << 4) | (c3 >> 2));\n    }\n    return b;\n}",
        "summary_tokens": [
            "from",
            "base",
            "0",
            "string"
        ]
    },
    {
        "id": 171,
        "code": "public List<Map<String, ?>> getListOfObjects(Map<String, ?> obj, String key) {\n    assert obj != null;\n    List<?> list = getList(obj, key);\n    if (list == null) {\n        return null;\n    }\n    return checkObjectList(list);\n}",
        "summary_tokens": [
            "gets",
            "a",
            "list",
            "from",
            "an",
            "object",
            "for",
            "the",
            "given",
            "key",
            "and",
            "verifies",
            "all",
            "entries",
            "are",
            "objects"
        ]
    },
    {
        "id": 172,
        "code": "public List<String> getListOfStrings(Map<String, ?> obj, String key) {\n    assert obj != null;\n    List<?> list = getList(obj, key);\n    if (list == null) {\n        return null;\n    }\n    return checkStringList(list);\n}",
        "summary_tokens": [
            "gets",
            "a",
            "list",
            "from",
            "an",
            "object",
            "for",
            "the",
            "given",
            "key",
            "and",
            "verifies",
            "all",
            "entries",
            "are",
            "strings"
        ]
    },
    {
        "id": 173,
        "code": "public Map<String, ?> getObject(Map<String, ?> obj, String key) {\n    assert obj != null;\n    assert key != null;\n    if (!obj.containsKey(key)) {\n        return null;\n    }\n    Object value = obj.get(key);\n    if (!(value instanceof Map)) {\n        throw new ClassCastException(\n            String.format(\"value '%s' for key '%s' in '%s' is not object\", value, key, obj));\n    }\n    return (Map<String, ?>) value;\n}",
        "summary_tokens": [
            "gets",
            "an",
            "object",
            "from",
            "an",
            "object",
            "for",
            "the",
            "given",
            "key"
        ]
    },
    {
        "id": 174,
        "code": "public Double getNumberAsDouble(Map<String, ?> obj, String key) {\n    assert obj != null;\n    assert key != null;\n    if (!obj.containsKey(key)) {\n        return null;\n    }\n    Object value = obj.get(key);\n    if (value instanceof Double) {\n        return (Double) value;\n    }\n    if (value instanceof String) {\n        try {\n            return Double.parseDouble((String) value);\n        } catch (NumberFormatException e) {\n            throw new IllegalArgumentException(\n                String.format(\"value '%s' for key '%s' is not a double\", value, key));\n        }\n    }\n    throw new IllegalArgumentException(\n        String.format(\"value '%s' for key '%s' in '%s' is not a number\", value, key, obj));\n}",
        "summary_tokens": [
            "gets",
            "a",
            "number",
            "from",
            "an",
            "object",
            "for",
            "the",
            "given",
            "key"
        ]
    },
    {
        "id": 175,
        "code": "public Integer getNumberAsInteger(Map<String, ?> obj, String key) {\n    assert obj != null;\n    assert key != null;\n    if (!obj.containsKey(key)) {\n        return null;\n    }\n    Object value = obj.get(key);\n    if (value instanceof Double) {\n        Double d = (Double) value;\n        int i = d.intValue();\n        if (i != d) {\n            throw new ClassCastException(\"Number expected to be integer: \" + d);\n        }\n        return i;\n    }\n    if (value instanceof String) {\n        try {\n            return Integer.parseInt((String) value);\n        } catch (NumberFormatException e) {\n            throw new IllegalArgumentException(\n                String.format(\"value '%s' for key '%s' is not an integer\", value, key));\n        }\n    }\n    throw new IllegalArgumentException(\n        String.format(\"value '%s' for key '%s' is not an integer\", value, key));\n}",
        "summary_tokens": [
            "gets",
            "a",
            "number",
            "from",
            "an",
            "object",
            "for",
            "the",
            "given",
            "key",
            "casted",
            "to",
            "an",
            "integer"
        ]
    },
    {
        "id": 176,
        "code": "public Long getNumberAsLong(Map<String, ?> obj, String key) {\n    assert obj != null;\n    assert key != null;\n    if (!obj.containsKey(key)) {\n        return null;\n    }\n    Object value = obj.get(key);\n    if (value instanceof Double) {\n        Double d = (Double) value;\n        long l = d.longValue();\n        if (l != d) {\n            throw new ClassCastException(\"Number expected to be long: \" + d);\n        }\n        return l;\n    }\n    if (value instanceof String) {\n        try {\n            return Long.parseLong((String) value);\n        } catch (NumberFormatException e) {\n            throw new IllegalArgumentException(\n                String.format(\"value '%s' for key '%s' is not a long integer\", value, key));\n        }\n    }\n    throw new IllegalArgumentException(\n        String.format(\"value '%s' for key '%s' is not a long integer\", value, key));\n}",
        "summary_tokens": [
            "gets",
            "a",
            "number",
            "from",
            "an",
            "object",
            "for",
            "the",
            "given",
            "key",
            "casted",
            "to",
            "an",
            "long"
        ]
    },
    {
        "id": 177,
        "code": "public String getString(Map<String, ?> obj, String key) {\n    assert obj != null;\n    assert key != null;\n    if (!obj.containsKey(key)) {\n        return null;\n    }\n    Object value = obj.get(key);\n    if (!(value instanceof String)) {\n        throw new ClassCastException(\n            String.format(\"value '%s' for key '%s' in '%s' is not String\", value, key, obj));\n    }\n    return (String) value;\n}",
        "summary_tokens": [
            "gets",
            "a",
            "string",
            "from",
            "an",
            "object",
            "for",
            "the",
            "given",
            "key"
        ]
    },
    {
        "id": 178,
        "code": "public List<Map<String, ?>> checkObjectList(List<?> rawList) {\n    assert rawList != null;\n    for (int i = 0; i < rawList.size(); i++) {\n        if (!(rawList.get(i) instanceof Map)) {\n            throw new ClassCastException(\n                String.format(\"value %s for idx %d in %s is not object\", rawList.get(i), i, rawList));\n        }\n    }\n    return (List<Map<String, ?>>) rawList;\n}",
        "summary_tokens": [
            "casts",
            "a",
            "list",
            "of",
            "unchecked",
            "json",
            "values",
            "to",
            "a",
            "list",
            "of",
            "checked",
            "objects",
            "in",
            "java",
            "type"
        ]
    },
    {
        "id": 179,
        "code": "public List<String> checkStringList(List<?> rawList) {\n    assert rawList != null;\n    for (int i = 0; i < rawList.size(); i++) {\n        if (!(rawList.get(i) instanceof String)) {\n            throw new ClassCastException(\n                String.format(\n                    \"value '%s' for idx %d in '%s' is not string\", rawList.get(i), i, rawList));\n        }\n    }\n    return (List<String>) rawList;\n}",
        "summary_tokens": [
            "casts",
            "a",
            "list",
            "of",
            "unchecked",
            "json",
            "values",
            "to",
            "a",
            "list",
            "of",
            "string"
        ]
    },
    {
        "id": 180,
        "code": "public static ErrorTypeAwareLogger getErrorTypeAwareLogger(String key) {\n    return ERROR_TYPE_AWARE_LOGGERS.computeIfAbsent(key, k -> new FailsafeErrorTypeAwareLogger(LOGGER_ADAPTER.getLogger(k)));\n}",
        "summary_tokens": [
            "get",
            "error",
            "type",
            "aware",
            "logger",
            "by",
            "a",
            "string",
            "key"
        ]
    },
    {
        "id": 181,
        "code": "public static void setLevel(Level level) {\n    LOGGER_ADAPTER.setLevel(level);\n}",
        "summary_tokens": [
            "set",
            "the",
            "current",
            "logging",
            "level"
        ]
    },
    {
        "id": 182,
        "code": "public static File getFile() {\n    return LOGGER_ADAPTER.getFile();\n}",
        "summary_tokens": [
            "get",
            "the",
            "current",
            "logging",
            "file"
        ]
    },
    {
        "id": 183,
        "code": "public static List<String> getAvailableAdapter() {\n    Map<Class<? extends LoggerAdapter>, String> candidates = new HashMap<>();\n    candidates.put(Log4jLoggerAdapter.class, \"log4j\");\n    candidates.put(Slf4jLoggerAdapter.class, \"slf4j\");\n    candidates.put(Log4j2LoggerAdapter.class, \"log4j2\");\n    candidates.put(JclLoggerAdapter.class, \"jcl\");\n    candidates.put(JdkLoggerAdapter.class, \"jdk\");\n    List<String> result = new LinkedList<>();\n    for (Map.Entry<Class<? extends LoggerAdapter>, String> entry : candidates.entrySet()) {\n        try {\n            LoggerAdapter loggerAdapter = entry.getKey().newInstance();\n            loggerAdapter.getLogger(LoggerFactory.class);\n            result.add(entry.getValue());\n        } catch (Throwable ignored) {\n        }\n    }\n    return result;\n}",
        "summary_tokens": [
            "get",
            "the",
            "available",
            "adapter",
            "names"
        ]
    },
    {
        "id": 184,
        "code": "public static String getCurrentAdapter() {\n    Map<Class<? extends LoggerAdapter>, String> candidates = new HashMap<>();\n    candidates.put(Log4jLoggerAdapter.class, \"log4j\");\n    candidates.put(Slf4jLoggerAdapter.class, \"slf4j\");\n    candidates.put(Log4j2LoggerAdapter.class, \"log4j2\");\n    candidates.put(JclLoggerAdapter.class, \"jcl\");\n    candidates.put(JdkLoggerAdapter.class, \"jdk\");\n\n    String name = candidates.get(LOGGER_ADAPTER.getClass());\n    if (name == null) {\n        name = LOGGER_ADAPTER.getClass().getSimpleName();\n    }\n    return name;\n}",
        "summary_tokens": [
            "get",
            "the",
            "current",
            "adapter",
            "name"
        ]
    },
    {
        "id": 185,
        "code": "public final ReferenceCountedResource retain() {\n    long oldCount = COUNTER_UPDATER.getAndIncrement(this);\n    if (oldCount <= 0) {\n        COUNTER_UPDATER.getAndDecrement(this);\n        throw new AssertionError(\"This instance has been destroyed\");\n    }\n    return this;\n}",
        "summary_tokens": [
            "increments",
            "the",
            "reference",
            "count",
            "by",
            "0"
        ]
    },
    {
        "id": 186,
        "code": "public final boolean release() {\n    long remainingCount = COUNTER_UPDATER.decrementAndGet(this);\n\n    if (remainingCount == 0) {\n        destroy();\n        return true;\n    } else if (remainingCount <= -1) {\n        logger.warn(\"This instance has been destroyed\");\n        return false;\n    } else {\n        return false;\n    }\n}",
        "summary_tokens": [
            "decreases",
            "the",
            "reference",
            "count",
            "by",
            "0",
            "and",
            "calls",
            "this",
            "destroy",
            "if",
            "the",
            "reference",
            "count",
            "reaches",
            "0"
        ]
    },
    {
        "id": 187,
        "code": "public final void close() {\n    release();\n}",
        "summary_tokens": [
            "useful",
            "when",
            "used",
            "together",
            "with",
            "try",
            "with",
            "resources",
            "pattern"
        ]
    },
    {
        "id": 188,
        "code": "public static void registerGlobalDisposable(Disposable disposable) {\n    if (!globalReusedDisposables.contains(disposable)) {\n        synchronized (GlobalResourcesRepository.class) {\n            if (!globalReusedDisposables.contains(disposable)) {\n                globalReusedDisposables.add(disposable);\n            }\n        }\n    }\n}",
        "summary_tokens": [
            "register",
            "a",
            "global",
            "reused",
            "disposable"
        ]
    },
    {
        "id": 189,
        "code": "public void registerDisposable(Disposable disposable) {\n    if (!oneoffDisposables.contains(disposable)) {\n        synchronized (this) {\n            if (!oneoffDisposables.contains(disposable)) {\n                oneoffDisposables.add(disposable);\n            }\n        }\n    }\n}",
        "summary_tokens": [
            "register",
            "a",
            "one",
            "off",
            "disposable",
            "the",
            "disposable",
            "is",
            "removed",
            "automatically",
            "on",
            "first",
            "shutdown"
        ]
    },
    {
        "id": 190,
        "code": "public void run() {\n    try{\n        runnable.run();\n    }finally {\n        InternalThreadLocal.removeAll();\n    }\n}",
        "summary_tokens": [
            "after",
            "the",
            "task",
            "execution",
            "is",
            "completed",
            "it",
            "will",
            "call",
            "internal",
            "thread",
            "local",
            "remove",
            "all",
            "to",
            "clear",
            "unnecessary",
            "variables",
            "in",
            "the",
            "thread"
        ]
    },
    {
        "id": 191,
        "code": " public static Runnable Wrap(Runnable runnable){\n    return runnable instanceof InternalRunnable?runnable:new InternalRunnable(runnable);\n}",
        "summary_tokens": [
            "wrap",
            "ordinary",
            "runnable",
            "into",
            "internal",
            "thread",
            "local"
        ]
    },
    {
        "id": 192,
        "code": "public final InternalThreadLocalMap threadLocalMap() {\n    return threadLocalMap;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "internal",
            "data",
            "structure",
            "that",
            "keeps",
            "the",
            "thread",
            "local",
            "variables",
            "bound",
            "to",
            "this",
            "thread"
        ]
    },
    {
        "id": 193,
        "code": "public final void setThreadLocalMap(InternalThreadLocalMap threadLocalMap) {\n    this.threadLocalMap = threadLocalMap;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "internal",
            "data",
            "structure",
            "that",
            "keeps",
            "the",
            "thread",
            "local",
            "variables",
            "bound",
            "to",
            "this",
            "thread"
        ]
    },
    {
        "id": 194,
        "code": "public static void removeAll() {\n    InternalThreadLocalMap threadLocalMap = InternalThreadLocalMap.getIfSet();\n    if (threadLocalMap == null) {\n        return;\n    }\n\n    try {\n        Object v = threadLocalMap.indexedVariable(VARIABLES_TO_REMOVE_INDEX);\n        if (v != null && v != InternalThreadLocalMap.UNSET) {\n            Set<InternalThreadLocal<?>> variablesToRemove = (Set<InternalThreadLocal<?>>) v;\n            InternalThreadLocal<?>[] variablesToRemoveArray =\n                    variablesToRemove.toArray(new InternalThreadLocal[0]);\n            for (InternalThreadLocal<?> tlv : variablesToRemoveArray) {\n                tlv.remove(threadLocalMap);\n            }\n        }\n    } finally {\n        InternalThreadLocalMap.remove();\n    }\n}",
        "summary_tokens": [
            "removes",
            "all",
            "internal",
            "thread",
            "local",
            "variables",
            "bound",
            "to",
            "the",
            "current",
            "thread"
        ]
    },
    {
        "id": 195,
        "code": "public static int size() {\n    InternalThreadLocalMap threadLocalMap = InternalThreadLocalMap.getIfSet();\n    if (threadLocalMap == null) {\n        return 0;\n    } else {\n        return threadLocalMap.size();\n    }\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "thread",
            "local",
            "variables",
            "bound",
            "to",
            "the",
            "current",
            "thread"
        ]
    },
    {
        "id": 196,
        "code": "public final V get() {\n    InternalThreadLocalMap threadLocalMap = InternalThreadLocalMap.get();\n    Object v = threadLocalMap.indexedVariable(index);\n    if (v != InternalThreadLocalMap.UNSET) {\n        return (V) v;\n    }\n\n    return initialize(threadLocalMap);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "current",
            "value",
            "for",
            "the",
            "current",
            "thread"
        ]
    },
    {
        "id": 197,
        "code": "public final void set(V value) {\n    if (value == null || value == InternalThreadLocalMap.UNSET) {\n        remove();\n    } else {\n        InternalThreadLocalMap threadLocalMap = InternalThreadLocalMap.get();\n        if (threadLocalMap.setIndexedVariable(index, value)) {\n            addToVariablesToRemove(threadLocalMap, this);\n        }\n    }\n}",
        "summary_tokens": [
            "sets",
            "the",
            "value",
            "for",
            "the",
            "current",
            "thread"
        ]
    },
    {
        "id": 198,
        "code": "public final void remove(InternalThreadLocalMap threadLocalMap) {\n    if (threadLocalMap == null) {\n        return;\n    }\n\n    Object v = threadLocalMap.removeIndexedVariable(index);\n    removeFromVariablesToRemove(threadLocalMap, this);\n\n    if (v != InternalThreadLocalMap.UNSET) {\n        try {\n            onRemoval((V) v);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}",
        "summary_tokens": [
            "sets",
            "the",
            "value",
            "to",
            "uninitialized",
            "for",
            "the",
            "specified",
            "thread",
            "local",
            "map",
            "a",
            "proceeding",
            "call",
            "to",
            "get",
            "will",
            "trigger",
            "a",
            "call",
            "to",
            "initial",
            "value"
        ]
    },
    {
        "id": 199,
        "code": "protected V initialValue() {\n    return null;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "initial",
            "value",
            "for",
            "this",
            "thread",
            "local",
            "variable"
        ]
    },
    {
        "id": 200,
        "code": "protected void onRemoval(@SuppressWarnings(\"unused\") V value) throws Exception {\n}",
        "summary_tokens": [
            "invoked",
            "when",
            "this",
            "thread",
            "local",
            "variable",
            "is",
            "removed",
            "by",
            "remove"
        ]
    },
    {
        "id": 201,
        "code": "public boolean setIndexedVariable(int index, Object value) {\n    Object[] lookup = indexedVariables;\n    if (index < lookup.length) {\n        Object oldValue = lookup[index];\n        lookup[index] = value;\n        return oldValue == UNSET;\n    } else {\n        expandIndexedVariableTableAndSet(index, value);\n        return true;\n    }\n}",
        "summary_tokens": [
            "true",
            "if",
            "and",
            "only",
            "if",
            "a",
            "new",
            "thread",
            "local",
            "variable",
            "has",
            "been",
            "created"
        ]
    },
    {
        "id": 202,
        "code": "public static long maxAvailable() {\n    checkAndScheduleRefresh();\n    return maxAvailable;\n}",
        "summary_tokens": [
            "get",
            "the",
            "maximum",
            "available",
            "memory",
            "of",
            "the",
            "current",
            "jvm"
        ]
    },
    {
        "id": 203,
        "code": "public static long calculate(final float percentage) {\n    if (percentage <= 0 || percentage > 1) {\n        throw new IllegalArgumentException();\n    }\n    checkAndScheduleRefresh();\n    return (long) (maxAvailable() * percentage);\n}",
        "summary_tokens": [
            "take",
            "the",
            "current",
            "jvm",
            "s",
            "maximum",
            "available",
            "memory",
            "as",
            "a",
            "percentage",
            "of",
            "the",
            "result",
            "as",
            "the",
            "limit"
        ]
    },
    {
        "id": 204,
        "code": "public static long defaultLimit() {\n    checkAndScheduleRefresh();\n    return (long) (maxAvailable() * 0.8);\n}",
        "summary_tokens": [
            "by",
            "default",
            "it",
            "takes",
            "0",
            "of",
            "the",
            "maximum",
            "available",
            "memory",
            "of",
            "the",
            "current",
            "jvm"
        ]
    },
    {
        "id": 205,
        "code": "private void fullyLock() {\n    acquireLock.lock();\n    releaseLock.lock();\n}",
        "summary_tokens": [
            "locks",
            "to",
            "prevent",
            "both",
            "acquires",
            "and",
            "releases"
        ]
    },
    {
        "id": 206,
        "code": "private void fullyUnlock() {\n    releaseLock.unlock();\n    acquireLock.unlock();\n}",
        "summary_tokens": [
            "unlocks",
            "to",
            "allow",
            "both",
            "acquires",
            "and",
            "releases"
        ]
    },
    {
        "id": 207,
        "code": "public void setMaxFreeMemory(final int maxFreeMemory) {\n    this.maxFreeMemory = maxFreeMemory;\n}",
        "summary_tokens": [
            "set",
            "the",
            "max",
            "free",
            "memory"
        ]
    },
    {
        "id": 208,
        "code": "public int getMaxFreeMemory() {\n    return maxFreeMemory;\n}",
        "summary_tokens": [
            "get",
            "the",
            "max",
            "free",
            "memory"
        ]
    },
    {
        "id": 209,
        "code": "public boolean hasRemainedMemory() {\n    return MemoryLimitCalculator.maxAvailable() > maxFreeMemory;\n}",
        "summary_tokens": [
            "determine",
            "if",
            "there",
            "is",
            "any",
            "remaining",
            "free",
            "memory"
        ]
    },
    {
        "id": 210,
        "code": "public void waitAndDrain() throws InterruptedException {\n        \n    if (isFinished()) {\n        return;\n    }\n\n    Runnable runnable;\n    try {\n        runnable = queue.take();\n    } catch (InterruptedException e) {\n        setWaiting(false);\n        throw e;\n    }\n\n    synchronized (lock) {\n        setWaiting(false);\n        runnable.run();\n    }\n\n    runnable = queue.poll();\n    while (runnable != null) {\n        runnable.run();\n        runnable = queue.poll();\n    }\n        \n    setFinished(true);\n}",
        "summary_tokens": [
            "waits",
            "until",
            "there",
            "is",
            "a",
            "task",
            "executes",
            "the",
            "task",
            "and",
            "all",
            "queued",
            "tasks",
            "if",
            "there",
            "re",
            "any"
        ]
    },
    {
        "id": 211,
        "code": "public void execute(Runnable runnable) {\n    runnable = new RunnableWrapper(runnable);\n    synchronized (lock) {\n        if (!isWaiting()) {\n            runnable.run();\n            return;\n        }\n        queue.add(runnable);\n    }\n}",
        "summary_tokens": [
            "if",
            "the",
            "calling",
            "thread",
            "is",
            "still",
            "waiting",
            "for",
            "a",
            "callback",
            "task",
            "add",
            "the",
            "task",
            "into",
            "the",
            "blocking",
            "queue",
            "to",
            "wait",
            "for",
            "schedule"
        ]
    },
    {
        "id": 212,
        "code": "public void notifyReturn(Throwable t) {\n        \n    execute(() -> {\n        waitingFuture.completeExceptionally(t);\n    });\n}",
        "summary_tokens": [
            "tells",
            "the",
            "thread",
            "blocking",
            "on",
            "wait",
            "and",
            "drain",
            "to",
            "return",
            "despite",
            "of",
            "the",
            "current",
            "status",
            "to",
            "avoid",
            "endless",
            "waiting"
        ]
    },
    {
        "id": 213,
        "code": "public void shutdown() {\n    shutdownNow();\n}",
        "summary_tokens": [
            "the",
            "following",
            "methods",
            "are",
            "still",
            "not",
            "supported"
        ]
    },
    {
        "id": 214,
        "code": "public synchronized ExecutorService createExecutorIfAbsent(URL url) {\n    Map<Integer, ExecutorService> executors = data.computeIfAbsent(getExecutorKey(url), k -> new ConcurrentHashMap<>());\n        \n    Integer portKey = CONSUMER_SIDE.equalsIgnoreCase(url.getParameter(SIDE_KEY)) ? Integer.MAX_VALUE : url.getPort();\n\n    String protocol = url.getProtocol();\n    if (StringUtils.isEmpty(protocol)) {\n        protocol = DEFAULT_PROTOCOL;\n    }\n\n    if (url.getParameter(THREAD_NAME_KEY) == null) {\n        url = url.putAttribute(THREAD_NAME_KEY, protocol + \"-protocol-\" + portKey);\n    }\n    URL finalUrl = url;\n    ExecutorService executor = executors.computeIfAbsent(portKey, k -> createExecutor(finalUrl));\n        \n    if (executor.isShutdown() || executor.isTerminated()) {\n        executors.remove(portKey);\n        executor = createExecutor(url);\n        executors.put(portKey, executor);\n    }\n    return executor;\n}",
        "summary_tokens": [
            "get",
            "called",
            "when",
            "the",
            "server",
            "or",
            "client",
            "instance",
            "initiating"
        ]
    },
    {
        "id": 215,
        "code": "private String getExecutorKey(URL url) {\n    String executorKey = INTERNAL_EXECUTOR_SERVICE_COMPONENT_KEY;\n    ServiceDescriptor serviceDescriptor = applicationModel.getInternalModule().getServiceRepository().lookupService(url.getServiceInterface());\n        \n    if (serviceDescriptor == null) {\n        executorKey = EXECUTOR_SERVICE_COMPONENT_KEY;\n\n    }\n    return executorKey;\n}",
        "summary_tokens": [
            "return",
            "the",
            "executor",
            "key",
            "based",
            "on",
            "the",
            "type",
            "internal",
            "or",
            "biz",
            "of",
            "the",
            "current",
            "service"
        ]
    },
    {
        "id": 216,
        "code": "public ScheduledExecutorService nextScheduledExecutor() {\n    return scheduledExecutors.pollItem();\n}",
        "summary_tokens": [
            "returns",
            "a",
            "scheduler",
            "from",
            "the",
            "scheduler",
            "list",
            "call",
            "this",
            "method",
            "whenever",
            "you",
            "need",
            "a",
            "scheduler",
            "for",
            "a",
            "cron",
            "job"
        ]
    },
    {
        "id": 217,
        "code": "public ScheduledExecutorService getRegistryNotificationExecutor() {\n    return registryNotificationExecutorRing.pollItem();\n}",
        "summary_tokens": [
            "scheduled",
            "executor",
            "handle",
            "registry",
            "notification"
        ]
    },
    {
        "id": 218,
        "code": "public ExecutorService getSharedExecutor() {\n    return sharedExecutor;\n}",
        "summary_tokens": [
            "get",
            "the",
            "default",
            "shared",
            "thread",
            "pool"
        ]
    },
    {
        "id": 219,
        "code": "public ScheduledExecutorService getSharedScheduledExecutor() {\n    return sharedScheduledExecutor;\n}",
        "summary_tokens": [
            "get",
            "the",
            "shared",
            "schedule",
            "executor"
        ]
    },
    {
        "id": 220,
        "code": "public ScheduledExecutorService getConnectivityScheduledExecutor() {\n    return connectivityScheduledExecutor;\n}",
        "summary_tokens": [
            "scheduled",
            "executor",
            "handle",
            "connectivity",
            "check",
            "task"
        ]
    },
    {
        "id": 221,
        "code": "public ScheduledExecutorService getCacheRefreshingScheduledExecutor() {\n    return cacheRefreshingScheduledExecutor;\n}",
        "summary_tokens": [
            "scheduler",
            "used",
            "to",
            "refresh",
            "file",
            "based",
            "caches",
            "from",
            "memory",
            "to",
            "disk"
        ]
    },
    {
        "id": 222,
        "code": "public ExecutorService getMappingRefreshingExecutor() {\n    return mappingRefreshingExecutor;\n}",
        "summary_tokens": [
            "executor",
            "used",
            "to",
            "run",
            "async",
            "mapping",
            "tasks"
        ]
    },
    {
        "id": 223,
        "code": "public void execute(Runnable r) {\n    runQueue.add(r);\n    schedule(r);\n}",
        "summary_tokens": [
            "runs",
            "the",
            "given",
            "runnable",
            "strictly",
            "after",
            "all",
            "runnables",
            "that",
            "were",
            "submitted",
            "before",
            "it",
            "and",
            "using",
            "the",
            "executor",
            "passed",
            "to",
            "the",
            "constructor"
        ]
    },
    {
        "id": 224,
        "code": "public void dispatchThreadPoolExhaustedEvent(String msg) {\n    listeners.forEach(listener -> listener.onEvent(new ThreadPoolExhaustedEvent(msg)));\n}",
        "summary_tokens": [
            "dispatch",
            "thread",
            "pool",
            "exhausted",
            "event",
            "msg"
        ]
    },
    {
        "id": 225,
        "code": "public void start() {\n    switch (WORKER_STATE_UPDATER.get(this)) {\n        case WORKER_STATE_INIT:\n            if (WORKER_STATE_UPDATER.compareAndSet(this, WORKER_STATE_INIT, WORKER_STATE_STARTED)) {\n                workerThread.start();\n            }\n            break;\n        case WORKER_STATE_STARTED:\n            break;\n        case WORKER_STATE_SHUTDOWN:\n            throw new IllegalStateException(\"cannot be started once stopped\");\n        default:\n            throw new Error(\"Invalid WorkerState\");\n    }\n\n        \n    while (startTime == 0) {\n        try {\n            startTimeInitialized.await();\n        } catch (InterruptedException ignore) {\n                \n        }\n    }\n}",
        "summary_tokens": [
            "starts",
            "the",
            "background",
            "thread",
            "explicitly"
        ]
    },
    {
        "id": 226,
        "code": "public long pendingTimeouts() {\n    return pendingTimeouts.get();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "pending",
            "timeouts",
            "of",
            "this",
            "timer"
        ]
    },
    {
        "id": 227,
        "code": "public Map<String, String> getAllParameters() {\n    Map<String, String> allParameters = new HashMap<>((int)(super.getParameters().size()/.75 + 1));\n    allParameters.putAll(super.getParameters());\n    if (consumerURL != null) {\n        allParameters.putAll(consumerURL.getParameters());\n    }\n    if (overrideURL != null) {\n        allParameters.putAll(overrideURL.getParameters());\n    }\n    return Collections.unmodifiableMap(allParameters);\n}",
        "summary_tokens": [
            "the",
            "returned",
            "parameters",
            "is",
            "imprecise",
            "regarding",
            "override",
            "priorities",
            "of",
            "consumer",
            "url",
            "and",
            "provider",
            "url"
        ]
    },
    {
        "id": 228,
        "code": "public boolean equals(Object obj) {\n    if (this == obj) {\n        return true;\n    }\n    if (obj == null) {\n        return false;\n    }\n    if (!(obj instanceof DubboServiceAddressURL)) {\n        return false;\n    }\n    if (overrideURL == null) {\n        return super.equals(obj);\n    } else {\n        DubboServiceAddressURL other = (DubboServiceAddressURL) obj;\n        boolean overrideEquals = Objects.equals(overrideURL.getParameters(), other.getOverrideURL().getParameters());\n        if (!overrideEquals) {\n            return false;\n        }\n\n        Map<String, String> params = this.getParameters();\n        for (Map.Entry<String, String> entry : params.entrySet()) {\n            String key = entry.getKey();\n            if (overrideURL.getParameters().containsKey(key)) {\n                continue;\n            }\n            if (!entry.getValue().equals(other.getUrlParam().getParameter(key))) {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
        "summary_tokens": [
            "ignore",
            "consumer",
            "url",
            "compare"
        ]
    },
    {
        "id": 229,
        "code": "public String getIp() {\n    if (ip == null) {\n        ip = NetUtils.getIpByHost(getHost());\n    }\n    return ip;\n}",
        "summary_tokens": [
            "fetch",
            "ip",
            "address",
            "for",
            "this",
            "url"
        ]
    },
    {
        "id": 230,
        "code": "public boolean equals(Object obj) {\n    if (this == obj) {\n        return true;\n    }\n    if (obj == null) {\n        return false;\n    }\n    if (!(obj instanceof ServiceAddressURL)) {\n        return false;\n    }\n    return super.equals(obj);\n}",
        "summary_tokens": [
            "ignore",
            "consumer",
            "url",
            "compare"
        ]
    },
    {
        "id": 231,
        "code": "public boolean hasMethodParameter(String method) {\n    if (method == null) {\n        return false;\n    }\n\n    String methodsString = getParameter(METHODS_KEY);\n    if (StringUtils.isNotEmpty(methodsString)) {\n        if (!methodsString.contains(method)) {\n            return false;\n        }\n    }\n\n    for (Map.Entry<String, Map<String, String>> methods : METHOD_PARAMETERS.entrySet()) {\n        if (methods.getValue().containsKey(method)) {\n            return true;\n        }\n    }\n    return false;\n}",
        "summary_tokens": [
            "weather",
            "there",
            "contains",
            "some",
            "parameter",
            "match",
            "method"
        ]
    },
    {
        "id": 232,
        "code": "public String getMethodParameter(String method, String key) {\n    String strictResult = getMethodParameterStrict(method, key);\n    return StringUtils.isNotEmpty(strictResult) ? strictResult : getParameter(key);\n}",
        "summary_tokens": [
            "get",
            "method",
            "related",
            "parameter"
        ]
    },
    {
        "id": 233,
        "code": "public String getMethodParameterStrict(String method, String key) {\n    String methodsString = getParameter(METHODS_KEY);\n    if (StringUtils.isNotEmpty(methodsString)) {\n        if (!methodsString.contains(method)) {\n            return null;\n        }\n    }\n\n    Map<String, String> methodMap = METHOD_PARAMETERS.get(key);\n    if (CollectionUtils.isNotEmptyMap(methodMap)) {\n        return methodMap.get(method);\n    } else {\n        return null;\n    }\n}",
        "summary_tokens": [
            "get",
            "method",
            "related",
            "parameter"
        ]
    },
    {
        "id": 234,
        "code": "public Map<String, String> getParameters() {\n    return new URLParamMap(this);\n}",
        "summary_tokens": [
            "get",
            "a",
            "map",
            "like",
            "urlparam"
        ]
    },
    {
        "id": 235,
        "code": "public String getAnyMethodParameter(String key) {\n    Map<String, String> methodMap = METHOD_PARAMETERS.get(key);\n    if (CollectionUtils.isNotEmptyMap(methodMap)) {\n        String methods = getParameter(METHODS_KEY);\n        if (StringUtils.isNotEmpty(methods)) {\n            for (String method : methods.split(\",\")) {\n                String value = methodMap.get(method);\n                if (StringUtils.isNotEmpty(value)) {\n                    return value;\n                }\n            }\n        } else {\n            return methodMap.values().iterator().next();\n        }\n    }\n    return null;\n}",
        "summary_tokens": [
            "get",
            "any",
            "method",
            "related",
            "parameter",
            "which",
            "match",
            "key"
        ]
    },
    {
        "id": 236,
        "code": "public URLParam addParameter(String key, String value) {\n    if (StringUtils.isEmpty(key) || StringUtils.isEmpty(value)) {\n        return this;\n    }\n    return addParameters(Collections.singletonMap(key, value));\n}",
        "summary_tokens": [
            "add",
            "parameters",
            "to",
            "a",
            "new",
            "urlparam"
        ]
    },
    {
        "id": 237,
        "code": "public URLParam addParameterIfAbsent(String key, String value) {\n    if (StringUtils.isEmpty(key) || StringUtils.isEmpty(value)) {\n        return this;\n    }\n    if (hasParameter(key)) {\n        return this;\n    }\n    return addParametersIfAbsent(Collections.singletonMap(key, value));\n}",
        "summary_tokens": [
            "add",
            "absent",
            "parameters",
            "to",
            "a",
            "new",
            "urlparam"
        ]
    },
    {
        "id": 238,
        "code": "public URLParam addParameters(Map<String, String> parameters) {\n    if (CollectionUtils.isEmptyMap(parameters)) {\n        return this;\n    }\n\n    boolean hasAndEqual = true;\n    Map<String, String> urlParamMap = getParameters();\n    for (Map.Entry<String, String> entry : parameters.entrySet()) {\n        String value = urlParamMap.get(entry.getKey());\n        if (value == null) {\n            if (entry.getValue() != null) {\n                hasAndEqual = false;\n                break;\n            }\n        } else {\n            if (!value.equals(entry.getValue())) {\n                hasAndEqual = false;\n                break;\n            }\n        }\n    }\n        \n    if (hasAndEqual) {\n        return this;\n    }\n\n    return doAddParameters(parameters, false);\n}",
        "summary_tokens": [
            "add",
            "parameters",
            "to",
            "a",
            "new",
            "urlparam"
        ]
    },
    {
        "id": 239,
        "code": "public URLParam addParametersIfAbsent(Map<String, String> parameters) {\n    if (CollectionUtils.isEmptyMap(parameters)) {\n        return this;\n    }\n\n    return doAddParameters(parameters, true);\n}",
        "summary_tokens": [
            "add",
            "absent",
            "parameters",
            "to",
            "a",
            "new",
            "urlparam"
        ]
    },
    {
        "id": 240,
        "code": "public URLParam removeParameters(String... keys) {\n    if (keys == null || keys.length == 0) {\n        return this;\n    }\n        \n    BitSet newKey = null;\n    int[] newValueArray = null;\n    Map<String, String> newExtraParams = null;\n    Map<String, Map<String, String>> newMethodParams = null;\n    for (String key : keys) {\n        int keyIndex = DynamicParamTable.getKeyIndex(enableCompressed, key);\n        if (keyIndex >= 0 && KEY.get(keyIndex)) {\n            if (newKey == null) {\n                newKey = (BitSet) KEY.clone();\n            }\n            newKey.clear(keyIndex);\n                \n            if (newValueArray == null) {\n                newValueArray = new int[VALUE.length];\n                System.arraycopy(VALUE, 0, newValueArray, 0, VALUE.length);\n            }\n                \n            newValueArray[keyIndexToIndex(KEY, keyIndex)] = -1;\n        }\n        if (EXTRA_PARAMS.containsKey(key)) {\n            if (newExtraParams == null) {\n                newExtraParams = new HashMap<>(EXTRA_PARAMS);\n            }\n            newExtraParams.remove(key);\n\n            String[] methodSplit = key.split(\"\\\\.\");\n            if (methodSplit.length == 2) {\n                if (newMethodParams == null) {\n                    newMethodParams = new HashMap<>(METHOD_PARAMETERS);\n                }\n                Map<String, String> methodMap = newMethodParams.get(methodSplit[1]);\n                if (CollectionUtils.isNotEmptyMap(methodMap)) {\n                    methodMap.remove(methodSplit[0]);\n                }\n            }\n        }\n            \n    }\n    if (newKey == null) {\n        newKey = KEY;\n    }\n    if (newValueArray == null) {\n        newValueArray = VALUE;\n    } else {\n            \n        newValueArray = compressArray(newValueArray);\n    }\n    if (newExtraParams == null) {\n        newExtraParams = EXTRA_PARAMS;\n    }\n    if (newMethodParams == null) {\n        newMethodParams = METHOD_PARAMETERS;\n    }\n    if (newKey.cardinality() + newExtraParams.size() == 0) {\n            \n        return EMPTY_PARAM;\n    } else {\n        return new URLParam(newKey, newValueArray, newExtraParams, newMethodParams, null);\n    }\n}",
        "summary_tokens": [
            "remove",
            "specified",
            "parameters",
            "in",
            "urlparam"
        ]
    },
    {
        "id": 241,
        "code": "public URLParam clearParameters() {\n    return EMPTY_PARAM;\n}",
        "summary_tokens": [
            "remove",
            "all",
            "of",
            "the",
            "parameters",
            "in",
            "urlparam"
        ]
    },
    {
        "id": 242,
        "code": "public boolean hasParameter(String key) {\n    int keyIndex = DynamicParamTable.getKeyIndex(enableCompressed, key);\n    if (keyIndex < 0) {\n        return EXTRA_PARAMS.containsKey(key);\n    }\n    return KEY.get(keyIndex);\n}",
        "summary_tokens": [
            "check",
            "if",
            "specified",
            "key",
            "is",
            "present",
            "in",
            "urlparam"
        ]
    },
    {
        "id": 243,
        "code": "public String getParameter(String key) {\n    int keyIndex = DynamicParamTable.getKeyIndex(enableCompressed, key);\n    if (keyIndex < 0) {\n        return EXTRA_PARAMS.get(key);\n    }\n    if (KEY.get(keyIndex)) {\n        String value;\n        int offset = keyIndexToOffset(keyIndex);\n        value = DynamicParamTable.getValue(keyIndex, offset);\n\n        return value;\n\n\n\n\n\n\n\n    }\n    return null;\n}",
        "summary_tokens": [
            "get",
            "value",
            "of",
            "specified",
            "key",
            "in",
            "urlparam"
        ]
    },
    {
        "id": 244,
        "code": "public String getRawParam() {\n    if (StringUtils.isNotEmpty(rawParam)) {\n        return rawParam;\n    } else {\n            \n        return toString();\n    }\n}",
        "summary_tokens": [
            "get",
            "raw",
            "string",
            "like",
            "parameters"
        ]
    },
    {
        "id": 245,
        "code": "public static URLParam parse(Map<String, String> params, String rawParam) {\n    if (CollectionUtils.isNotEmptyMap(params)) {\n        int capacity = (int) (params.size() / .75f) + 1;\n        BitSet keyBit = new BitSet(capacity);\n        Map<Integer, Integer> valueMap = new HashMap<>(capacity);\n        Map<String, String> extraParam = new HashMap<>(capacity);\n        Map<String, Map<String, String>> methodParameters = new HashMap<>(capacity);\n\n        for (Map.Entry<String, String> entry : params.entrySet()) {\n            addParameter(keyBit, valueMap, extraParam, methodParameters, entry.getKey(), entry.getValue(), false);\n        }\n        return new URLParam(keyBit, valueMap, extraParam, methodParameters, rawParam);\n    } else {\n        return EMPTY_PARAM;\n    }\n}",
        "summary_tokens": [
            "parse",
            "urlparam",
            "init",
            "urlparam",
            "by",
            "constructor",
            "is",
            "not",
            "allowed"
        ]
    },
    {
        "id": 246,
        "code": "public String getN(int n) {\n    return values[n];\n}",
        "summary_tokens": [
            "default",
            "value",
            "will",
            "be",
            "returned",
            "if",
            "n",
            "0",
            "n"
        ]
    },
    {
        "id": 247,
        "code": "static <A extends Annotation> Class<A> resolveAnnotationType(AnnotatedElement annotatedElement,\n                                                             String annotationClassName) {\n    ClassLoader classLoader = annotatedElement.getClass().getClassLoader();\n    Class<?> annotationType = resolveClass(annotationClassName, classLoader);\n    if (annotationType == null || !Annotation.class.isAssignableFrom(annotationType)) {\n        return null;\n    }\n    return (Class<A>) annotationType;\n}",
        "summary_tokens": [
            "resolve",
            "the",
            "annotation",
            "type",
            "by",
            "the",
            "annotated",
            "element",
            "and",
            "resolved",
            "class",
            "name"
        ]
    },
    {
        "id": 248,
        "code": "static boolean isType(AnnotatedElement annotatedElement) {\n    return annotatedElement instanceof Class;\n}",
        "summary_tokens": [
            "is",
            "the",
            "specified",
            "type",
            "a",
            "generic",
            "class",
            "type"
        ]
    },
    {
        "id": 249,
        "code": "static boolean isSameType(Annotation annotation, Class<? extends Annotation> annotationType) {\n    if (annotation == null || annotationType == null) {\n        return false;\n    }\n    return Objects.equals(annotation.annotationType(), annotationType);\n}",
        "summary_tokens": [
            "is",
            "the",
            "type",
            "of",
            "specified",
            "annotation",
            "same",
            "to",
            "the",
            "expected",
            "type"
        ]
    },
    {
        "id": 250,
        "code": "static Predicate<Annotation> excludedType(Class<? extends Annotation> excludedAnnotationType) {\n    return annotation -> !isSameType(annotation, excludedAnnotationType);\n}",
        "summary_tokens": [
            "build",
            "an",
            "instance",
            "of",
            "predicate",
            "to",
            "excluded",
            "annotation",
            "type"
        ]
    },
    {
        "id": 251,
        "code": "static <T> T getAttribute(Annotation annotation, String attributeName) throws IllegalArgumentException {\n    return annotation == null ? null : invokeMethod(annotation, attributeName);\n}",
        "summary_tokens": [
            "get",
            "the",
            "attribute",
            "from",
            "the",
            "specified",
            "annotation",
            "annotation"
        ]
    },
    {
        "id": 252,
        "code": "static <T> T getValue(Annotation annotation) throws IllegalArgumentException {\n    return getAttribute(annotation, \"value\");\n}",
        "summary_tokens": [
            "get",
            "the",
            "value",
            "attribute",
            "from",
            "the",
            "specified",
            "annotation",
            "annotation"
        ]
    },
    {
        "id": 253,
        "code": "static <A extends Annotation> A getAnnotation(AnnotatedElement annotatedElement, String annotationClassName)\n        throws ClassCastException {\n    Class<? extends Annotation> annotationType = resolveAnnotationType(annotatedElement, annotationClassName);\n    if (annotationType == null) {\n        return null;\n    }\n    return (A) annotatedElement.getAnnotation(annotationType);\n}",
        "summary_tokens": [
            "get",
            "the",
            "annotation",
            "from",
            "the",
            "specified",
            "annotated",
            "element",
            "the",
            "annotated",
            "element",
            "and",
            "annotation",
            "annotation",
            "class",
            "name"
        ]
    },
    {
        "id": 254,
        "code": "static List<Annotation> getDeclaredAnnotations(AnnotatedElement annotatedElement,\n                                               Predicate<Annotation>... annotationsToFilter) {\n    if (annotatedElement == null) {\n        return emptyList();\n    }\n\n    return unmodifiableList(filterAll(asList(annotatedElement.getDeclaredAnnotations()), annotationsToFilter));\n}",
        "summary_tokens": [
            "get",
            "annotations",
            "that",
            "are",
            "em",
            "directly",
            "present",
            "em",
            "on",
            "this",
            "element"
        ]
    },
    {
        "id": 255,
        "code": "static List<Annotation> getAllDeclaredAnnotations(Class<?> type, Predicate<Annotation>... annotationsToFilter) {\n\n    if (type == null) {\n        return emptyList();\n    }\n\n    List<Annotation> allAnnotations = new LinkedList<>();\n\n        \n    Set<Class<?>> allTypes = new LinkedHashSet<>();\n        \n    allTypes.add(type);\n        \n    allTypes.addAll(getAllInheritedTypes(type, t -> !Object.class.equals(t)));\n\n    for (Class<?> t : allTypes) {\n        allAnnotations.addAll(getDeclaredAnnotations(t, annotationsToFilter));\n    }\n\n    return unmodifiableList(allAnnotations);\n}",
        "summary_tokens": [
            "get",
            "all",
            "directly",
            "declared",
            "annotations",
            "of",
            "the",
            "specified",
            "type",
            "and",
            "its",
            "all",
            "hierarchical",
            "types",
            "not",
            "including",
            "meta",
            "annotations"
        ]
    },
    {
        "id": 256,
        "code": "static List<Annotation> getMetaAnnotations(Class<? extends Annotation> annotationType,\n                                           Predicate<Annotation>... metaAnnotationsToFilter) {\n    return getDeclaredAnnotations(annotationType,\n                \n                \n            excludedType(Target.class),\n            excludedType(Retention.class),\n            excludedType(Documented.class),\n                \n            and(metaAnnotationsToFilter)\n    );\n}",
        "summary_tokens": [
            "get",
            "the",
            "meta",
            "annotated",
            "annotation",
            "annotations",
            "directly",
            "excluding",
            "target",
            "retention",
            "and",
            "documented"
        ]
    },
    {
        "id": 257,
        "code": "static List<Annotation> getAllMetaAnnotations(Class<? extends Annotation> annotationType,\n                                              Predicate<Annotation>... annotationsToFilter) {\n\n    List<Annotation> allMetaAnnotations = new LinkedList<>();\n\n    List<Annotation> metaAnnotations = getMetaAnnotations(annotationType);\n\n    allMetaAnnotations.addAll(metaAnnotations);\n\n    for (Annotation metaAnnotation : metaAnnotations) {\n            \n        allMetaAnnotations.addAll(getAllMetaAnnotations(metaAnnotation.annotationType()));\n    }\n\n    return unmodifiableList(filterAll(allMetaAnnotations, annotationsToFilter));\n}",
        "summary_tokens": [
            "get",
            "all",
            "meta",
            "annotations",
            "from",
            "the",
            "specified",
            "annotation",
            "annotation",
            "type"
        ]
    },
    {
        "id": 258,
        "code": "static <A extends Annotation> A findAnnotation(AnnotatedElement annotatedElement, Class<A> annotationType) {\n    return (A) filterFirst(getAllDeclaredAnnotations(annotatedElement), a -> isSameType(a, annotationType));\n}",
        "summary_tokens": [
            "find",
            "the",
            "annotation",
            "that",
            "is",
            "annotated",
            "on",
            "the",
            "specified",
            "element",
            "may",
            "be",
            "a",
            "meta",
            "annotation"
        ]
    },
    {
        "id": 259,
        "code": "static <A extends Annotation> List<A> findMetaAnnotations(AnnotatedElement annotatedElement,\n                                                          Class<A> metaAnnotationType) {\n    List<A> metaAnnotations = new LinkedList<>();\n\n    for (Annotation annotation : getAllDeclaredAnnotations(annotatedElement)) {\n        metaAnnotations.addAll(findMetaAnnotations(annotation.annotationType(), metaAnnotationType));\n    }\n\n    return unmodifiableList(metaAnnotations);\n}",
        "summary_tokens": [
            "find",
            "the",
            "meta",
            "annotations",
            "from",
            "the",
            "the",
            "the",
            "annotated",
            "element",
            "by",
            "meta",
            "annotation",
            "type"
        ]
    },
    {
        "id": 260,
        "code": "static <A extends Annotation> A findMetaAnnotation(AnnotatedElement annotatedElement, Class<A> metaAnnotationType) {\n    return first(findMetaAnnotations(annotatedElement, metaAnnotationType));\n}",
        "summary_tokens": [
            "find",
            "the",
            "meta",
            "annotation",
            "from",
            "the",
            "annotated",
            "element",
            "by",
            "meta",
            "annotation",
            "type"
        ]
    },
    {
        "id": 261,
        "code": "static boolean isAnnotationPresent(AnnotatedElement annotatedElement, Class<? extends Annotation> annotationType) {\n    if (isType(annotatedElement)) {\n        return isAnnotationPresent((Class) annotatedElement, annotationType);\n    } else {\n        return annotatedElement.isAnnotationPresent(annotationType) ||\n                findMetaAnnotation(annotatedElement, annotationType) != null; \n    }\n}",
        "summary_tokens": [
            "tests",
            "the",
            "annotated",
            "element",
            "is",
            "present",
            "any",
            "specified",
            "annotation",
            "types"
        ]
    },
    {
        "id": 262,
        "code": "static boolean isAllAnnotationPresent(Class<?> type, Class<? extends Annotation>... annotationTypes) {\n    return isAnnotationPresent(type, true, annotationTypes);\n}",
        "summary_tokens": [
            "tests",
            "the",
            "annotated",
            "element",
            "is",
            "annotated",
            "all",
            "specified",
            "annotations",
            "or",
            "not"
        ]
    },
    {
        "id": 263,
        "code": "static boolean isAnyAnnotationPresent(Class<?> type,\n                                      Class<? extends Annotation>... annotationTypes) {\n    return isAnnotationPresent(type, false, annotationTypes);\n}",
        "summary_tokens": [
            "tests",
            "the",
            "annotated",
            "element",
            "is",
            "present",
            "any",
            "specified",
            "annotation",
            "types"
        ]
    },
    {
        "id": 264,
        "code": "static <T> T getDefaultValue(Class<? extends Annotation> annotationType, String attributeName) {\n    Method method = findMethod(annotationType, attributeName);\n    return (T) (method == null ? null : method.getDefaultValue());\n}",
        "summary_tokens": [
            "get",
            "the",
            "default",
            "value",
            "of",
            "attribute",
            "on",
            "the",
            "specified",
            "annotation"
        ]
    },
    {
        "id": 265,
        "code": "static Map<String, Object> filterDefaultValues(Annotation annotation, Map<String, Object> attributes) {\n    return filterDefaultValues(annotation.annotationType(), attributes);\n}",
        "summary_tokens": [
            "filter",
            "default",
            "value",
            "of",
            "annotation",
            "type",
            "annotation",
            "attributes"
        ]
    },
    {
        "id": 266,
        "code": "static Map<String, Object> getAttributes(Annotation annotation, boolean filterDefaultValue) {\n    Class<?> annotationType = annotation.annotationType();\n    Method[] methods = annotationType.getMethods();\n    Map<String, Object> attributes = new LinkedHashMap<>(methods.length);\n    for (Method method : methods) {\n        try {\n            if (method.getDeclaringClass() == Annotation.class) {\n                continue;\n            }\n            String name = method.getName();\n            Object value = method.invoke(annotation);\n            if (!filterDefaultValue || !Objects.deepEquals(value, method.getDefaultValue())) {\n                attributes.put(name, value);\n            }\n        } catch (Exception e) {\n            throw new IllegalStateException(\"get attribute value of annotation failed: \" + method, e);\n        }\n    }\n    return attributes;\n}",
        "summary_tokens": [
            "get",
            "attributes",
            "of",
            "annotation",
            "annotation"
        ]
    },
    {
        "id": 267,
        "code": "public static boolean isEmpty(final Object[] array) {\n    return array == null || array.length == 0;\n}",
        "summary_tokens": [
            "p",
            "checks",
            "if",
            "the",
            "array",
            "is",
            "null",
            "or",
            "empty"
        ]
    },
    {
        "id": 268,
        "code": "public static boolean isNotEmpty(final Object[] array) {\n    return !isEmpty(array);\n}",
        "summary_tokens": [
            "p",
            "checks",
            "if",
            "the",
            "array",
            "is",
            "not",
            "null",
            "or",
            "empty"
        ]
    },
    {
        "id": 269,
        "code": "public static <T> T[] of(T... values) {\n    return values;\n}",
        "summary_tokens": [
            "convert",
            "from",
            "variable",
            "arguments",
            "to",
            "array"
        ]
    },
    {
        "id": 270,
        "code": "public static ClassLoader getClassLoader() {\n    return getClassLoader(ClassHelper.class);\n}",
        "summary_tokens": [
            "return",
            "the",
            "default",
            "class",
            "loader",
            "to",
            "use",
            "typically",
            "the",
            "thread",
            "context",
            "class",
            "loader",
            "if",
            "available",
            "the",
            "class",
            "loader",
            "that",
            "loaded",
            "the",
            "class",
            "utils",
            "class",
            "will",
            "be",
            "used",
            "as",
            "fallback"
        ]
    },
    {
        "id": 271,
        "code": "public static Class<?> forName(String name, ClassLoader classLoader)\n        throws ClassNotFoundException, LinkageError {\n    return ClassUtils.forName(name, classLoader);\n}",
        "summary_tokens": [
            "replacement",
            "for",
            "code",
            "class"
        ]
    },
    {
        "id": 272,
        "code": "public static Class<?> resolvePrimitiveClassName(String name) {\n    return ClassUtils.resolvePrimitiveClassName(name);\n}",
        "summary_tokens": [
            "resolve",
            "the",
            "given",
            "class",
            "name",
            "as",
            "primitive",
            "class",
            "if",
            "appropriate",
            "according",
            "to",
            "the",
            "jvm",
            "s",
            "naming",
            "rules",
            "for",
            "primitive",
            "classes"
        ]
    },
    {
        "id": 273,
        "code": "public static boolean isTypeMatch(Class<?> type, String value) {\nreturn ClassUtils.isTypeMatch(type,value);\n}",
        "summary_tokens": [
            "we",
            "only",
            "check",
            "boolean",
            "value",
            "at",
            "this",
            "moment"
        ]
    },
    {
        "id": 274,
        "code": "public static ClassLoader getClassLoader() {\n    return getClassLoader(ClassUtils.class);\n}",
        "summary_tokens": [
            "return",
            "the",
            "default",
            "class",
            "loader",
            "to",
            "use",
            "typically",
            "the",
            "thread",
            "context",
            "class",
            "loader",
            "if",
            "available",
            "the",
            "class",
            "loader",
            "that",
            "loaded",
            "the",
            "class",
            "utils",
            "class",
            "will",
            "be",
            "used",
            "as",
            "fallback"
        ]
    },
    {
        "id": 275,
        "code": "public static Class<?> forName(String name, ClassLoader classLoader)\n        throws ClassNotFoundException, LinkageError {\n\n    Class<?> clazz = resolvePrimitiveClassName(name);\n    if (clazz != null) {\n        return clazz;\n    }\n\n        \n    if (name.endsWith(ARRAY_SUFFIX)) {\n        String elementClassName = name.substring(0, name.length() - ARRAY_SUFFIX.length());\n        Class<?> elementClass = forName(elementClassName, classLoader);\n        return Array.newInstance(elementClass, 0).getClass();\n    }\n\n        \n    int internalArrayMarker = name.indexOf(INTERNAL_ARRAY_PREFIX);\n    if (internalArrayMarker != -1 && name.endsWith(\";\")) {\n        String elementClassName = null;\n        if (internalArrayMarker == 0) {\n            elementClassName = name\n                    .substring(INTERNAL_ARRAY_PREFIX.length(), name.length() - 1);\n        } else if (name.startsWith(\"[\")) {\n            elementClassName = name.substring(1);\n        }\n        Class<?> elementClass = forName(elementClassName, classLoader);\n        return Array.newInstance(elementClass, 0).getClass();\n    }\n\n    ClassLoader classLoaderToUse = classLoader;\n    if (classLoaderToUse == null) {\n        classLoaderToUse = getClassLoader();\n    }\n    return classLoaderToUse.loadClass(name);\n}",
        "summary_tokens": [
            "replacement",
            "for",
            "code",
            "class"
        ]
    },
    {
        "id": 276,
        "code": "public static Class<?> resolvePrimitiveClassName(String name) {\n    Class<?> result = null;\n        \n        \n    if (name != null && name.length() <= 8) {\n            \n        result = (Class<?>) PRIMITIVE_TYPE_NAME_MAP.get(name);\n    }\n    return result;\n}",
        "summary_tokens": [
            "resolve",
            "the",
            "given",
            "class",
            "name",
            "as",
            "primitive",
            "class",
            "if",
            "appropriate",
            "according",
            "to",
            "the",
            "jvm",
            "s",
            "naming",
            "rules",
            "for",
            "primitive",
            "classes"
        ]
    },
    {
        "id": 277,
        "code": "public static boolean isPrimitive(Class<?> type) {\n    return type != null && (type.isPrimitive() || isSimpleType(type));\n}",
        "summary_tokens": [
            "the",
            "specified",
            "type",
            "is",
            "primitive",
            "type",
            "or",
            "simple",
            "type"
        ]
    },
    {
        "id": 278,
        "code": "public static boolean isSimpleType(Class<?> type) {\n    return SIMPLE_TYPES.contains(type);\n}",
        "summary_tokens": [
            "the",
            "specified",
            "type",
            "is",
            "simple",
            "type",
            "or",
            "not"
        ]
    },
    {
        "id": 279,
        "code": "public static boolean isTypeMatch(Class<?> type, String value) {\n    if ((type == boolean.class || type == Boolean.class)\n            && !(\"true\".equals(value) || \"false\".equals(value))) {\n        return false;\n    }\n    return true;\n}",
        "summary_tokens": [
            "we",
            "only",
            "check",
            "boolean",
            "value",
            "at",
            "this",
            "moment"
        ]
    },
    {
        "id": 280,
        "code": "public static Set<Class<?>> getAllSuperClasses(Class<?> type, Predicate<Class<?>>... classFilters) {\n\n    Set<Class<?>> allSuperClasses = new LinkedHashSet<>();\n\n    Class<?> superClass = type.getSuperclass();\n    while (superClass != null) {\n            \n        allSuperClasses.add(superClass);\n        superClass = superClass.getSuperclass();\n    }\n\n    return unmodifiableSet(filterAll(allSuperClasses, classFilters));\n}",
        "summary_tokens": [
            "get",
            "all",
            "super",
            "classes",
            "from",
            "the",
            "specified",
            "type"
        ]
    },
    {
        "id": 281,
        "code": "public static Set<Class<?>> getAllInterfaces(Class<?> type, Predicate<Class<?>>... interfaceFilters) {\n    if (type == null || type.isPrimitive()) {\n        return emptySet();\n    }\n\n    Set<Class<?>> allInterfaces = new LinkedHashSet<>();\n    Set<Class<?>> resolved = new LinkedHashSet<>();\n    Queue<Class<?>> waitResolve = new LinkedList<>();\n\n    resolved.add(type);\n    Class<?> clazz = type;\n    while (clazz != null) {\n\n        Class<?>[] interfaces = clazz.getInterfaces();\n\n        if (isNotEmpty(interfaces)) {\n                \n            Arrays.stream(interfaces)\n                    .filter(resolved::add)\n                    .forEach(cls -> {\n                        allInterfaces.add(cls);\n                        waitResolve.add(cls);\n                    });\n        }\n\n            \n        getAllSuperClasses(clazz)\n                .stream()\n                .filter(resolved::add)\n                .forEach(waitResolve::add);\n\n        clazz = waitResolve.poll();\n    }\n\n    return filterAll(allInterfaces, interfaceFilters);\n}",
        "summary_tokens": [
            "get",
            "all",
            "interfaces",
            "from",
            "the",
            "specified",
            "type"
        ]
    },
    {
        "id": 282,
        "code": "public static Set<Class<?>> getAllInheritedTypes(Class<?> type, Predicate<Class<?>>... typeFilters) {\n        \n    Set<Class<?>> types = new LinkedHashSet<>(getAllSuperClasses(type, typeFilters));\n        \n    types.addAll(getAllInterfaces(type, typeFilters));\n    return unmodifiableSet(types);\n}",
        "summary_tokens": [
            "get",
            "all",
            "inherited",
            "types",
            "from",
            "the",
            "specified",
            "type"
        ]
    },
    {
        "id": 283,
        "code": "public static boolean isAssignableFrom(Class<?> superType, Class<?> targetType) {\n        \n    if (superType == null || targetType == null) {\n        return false;\n    }\n        \n    if (Objects.equals(superType, targetType)) {\n        return true;\n    }\n        \n    return superType.isAssignableFrom(targetType);\n}",
        "summary_tokens": [
            "the",
            "semantics",
            "is",
            "same",
            "as",
            "class",
            "is",
            "assignable",
            "from",
            "class"
        ]
    },
    {
        "id": 284,
        "code": "public static boolean isPresent(String className, ClassLoader classLoader) {\n    try {\n        forName(className, classLoader);\n    } catch (Throwable ignored) { \n        return false;\n    }\n    return true;\n}",
        "summary_tokens": [
            "test",
            "the",
            "specified",
            "class",
            "name",
            "is",
            "present",
            "in",
            "the",
            "class",
            "loader"
        ]
    },
    {
        "id": 285,
        "code": "public static Class<?> resolveClass(String className, ClassLoader classLoader) {\n    Class<?> targetClass = null;\n    try {\n        targetClass = forName(className, classLoader);\n    } catch (Throwable ignored) { \n    }\n    return targetClass;\n}",
        "summary_tokens": [
            "resolve",
            "the",
            "class",
            "by",
            "the",
            "specified",
            "name",
            "and",
            "class",
            "loader"
        ]
    },
    {
        "id": 286,
        "code": "public static boolean isGenericClass(Class<?> type) {\n    return type != null && !void.class.equals(type) && !Void.class.equals(type);\n}",
        "summary_tokens": [
            "is",
            "generic",
            "class",
            "or",
            "not"
        ]
    },
    {
        "id": 287,
        "code": "public static String[] getMethodNames(Class<?> tClass) {\n    if (tClass == Object.class) {\n        return OBJECT_METHODS;\n    }\n    Method[] methods = Arrays.stream(tClass.getMethods())\n        .collect(Collectors.toList())\n        .toArray(new Method[] {});\n    List<String> mns = new ArrayList<>(); \n    boolean hasMethod = hasMethods(methods);\n    if (hasMethod) {\n        for (Method m : methods) {\n                \n            if (m.getDeclaringClass() == Object.class) {\n                continue;\n            }\n            String mn = m.getName();\n            mns.add(mn);\n        }\n    }\n    return mns.toArray(new String[0]);\n}",
        "summary_tokens": [
            "get",
            "method",
            "name",
            "array"
        ]
    },
    {
        "id": 288,
        "code": "public static String[] getDeclaredMethodNames(Class<?> tClass) {\n    if (tClass == Object.class) {\n        return OBJECT_METHODS;\n    }\n    Method[] methods = Arrays.stream(tClass.getMethods())\n        .collect(Collectors.toList())\n        .toArray(new Method[] {});\n    List<String> dmns = new ArrayList<>(); \n    boolean hasMethod = hasMethods(methods);\n    if (hasMethod) {\n        for (Method m : methods) {\n                \n            if (m.getDeclaringClass() == Object.class) {\n                continue;\n            }\n            String mn = m.getName();\n            if (m.getDeclaringClass() == tClass) {\n                dmns.add(mn);\n            }\n        }\n    }\n    return dmns.toArray(new String[0]);\n}",
        "summary_tokens": [
            "get",
            "method",
            "name",
            "array"
        ]
    },
    {
        "id": 289,
        "code": "public static <K, V> Map<V, K> flip(Map<K, V> map) {\n    if (isEmptyMap(map)) {\n        return (Map<V, K>) map;\n    }\n    Set<V> set = map.values().stream().collect(Collectors.toSet());\n    if (set.size() != map.size()) {\n        throw new IllegalArgumentException(\"The map value must be unique.\");\n    }\n    return map.entrySet()\n            .stream()\n            .collect(Collectors.toMap(Map.Entry::getValue, Map.Entry::getKey));\n}",
        "summary_tokens": [
            "flip",
            "the",
            "specified",
            "map"
        ]
    },
    {
        "id": 290,
        "code": "public static boolean isEmpty(Collection<?> collection) {\n    return collection == null || collection.isEmpty();\n}",
        "summary_tokens": [
            "return",
            "true",
            "if",
            "the",
            "supplied",
            "collection",
            "is",
            "null",
            "or",
            "empty"
        ]
    },
    {
        "id": 291,
        "code": "public static boolean isNotEmpty(Collection<?> collection) {\n    return !isEmpty(collection);\n}",
        "summary_tokens": [
            "return",
            "true",
            "if",
            "the",
            "supplied",
            "collection",
            "is",
            "not",
            "null",
            "or",
            "not",
            "empty"
        ]
    },
    {
        "id": 292,
        "code": "public static boolean isEmptyMap(Map map) {\n    return map == null || map.size() == 0;\n}",
        "summary_tokens": [
            "return",
            "true",
            "if",
            "the",
            "supplied",
            "map",
            "is",
            "null",
            "or",
            "empty"
        ]
    },
    {
        "id": 293,
        "code": "public static boolean isNotEmptyMap(Map map) {\n    return !isEmptyMap(map);\n}",
        "summary_tokens": [
            "return",
            "true",
            "if",
            "the",
            "supplied",
            "map",
            "is",
            "not",
            "null",
            "or",
            "not",
            "empty"
        ]
    },
    {
        "id": 294,
        "code": "public static <T> Set<T> ofSet(T... values) {\n    int size = values == null ? 0 : values.length;\n    if (size < 1) {\n        return emptySet();\n    }\n\n    float loadFactor = 1f / ((size + 1) * 1.0f);\n\n    if (loadFactor > 0.75f) {\n        loadFactor = 0.75f;\n    }\n\n    Set<T> elements = new LinkedHashSet<>(size, loadFactor);\n    for (int i = 0; i < size; i++) {\n        elements.add(values[i]);\n    }\n    return unmodifiableSet(elements);\n}",
        "summary_tokens": [
            "convert",
            "to",
            "multiple",
            "values",
            "to",
            "be",
            "linked",
            "hash",
            "set"
        ]
    },
    {
        "id": 295,
        "code": "public static int size(Collection<?> collection) {\n    return collection == null ? 0 : collection.size();\n}",
        "summary_tokens": [
            "get",
            "the",
            "size",
            "of",
            "the",
            "specified",
            "collection"
        ]
    },
    {
        "id": 296,
        "code": "public static boolean equals(Collection<?> one, Collection<?> another) {\n\n    if (one == another) {\n        return true;\n    }\n\n    if (isEmpty(one) && isEmpty(another)) {\n        return true;\n    }\n\n    if (size(one) != size(another)) {\n        return false;\n    }\n\n    try {\n        return one.containsAll(another);\n    } catch (ClassCastException | NullPointerException unused) {\n        return false;\n    }\n}",
        "summary_tokens": [
            "compares",
            "the",
            "specified",
            "collection",
            "with",
            "another",
            "the",
            "main",
            "implementation",
            "references",
            "abstract",
            "set"
        ]
    },
    {
        "id": 297,
        "code": "public static <T> int addAll(Collection<T> collection, T... values) {\n\n    int size = values == null ? 0 : values.length;\n\n    if (collection == null || size < 1) {\n        return 0;\n    }\n\n    int effectedCount = 0;\n    for (int i = 0; i < size; i++) {\n        if (collection.add(values[i])) {\n            effectedCount++;\n        }\n    }\n\n    return effectedCount;\n}",
        "summary_tokens": [
            "add",
            "the",
            "multiple",
            "values",
            "into",
            "collection",
            "the",
            "specified",
            "collection"
        ]
    },
    {
        "id": 298,
        "code": "public static <T> T first(Collection<T> values) {\n    if (isEmpty(values)) {\n        return null;\n    }\n    if (values instanceof List) {\n        List<T> list = (List<T>) values;\n        return list.get(0);\n    } else {\n        return values.iterator().next();\n    }\n}",
        "summary_tokens": [
            "take",
            "the",
            "first",
            "element",
            "from",
            "the",
            "specified",
            "collection"
        ]
    },
    {
        "id": 299,
        "code": "public Iterator<E> iterator() {\n    return map.keySet().iterator();\n}",
        "summary_tokens": [
            "returns",
            "an",
            "iterator",
            "over",
            "the",
            "elements",
            "in",
            "this",
            "set"
        ]
    },
    {
        "id": 300,
        "code": "public int size() {\n    return map.size();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "number",
            "of",
            "elements",
            "in",
            "this",
            "set",
            "its",
            "cardinality"
        ]
    },
    {
        "id": 301,
        "code": "public boolean isEmpty() {\n    return map.isEmpty();\n}",
        "summary_tokens": [
            "returns",
            "tt",
            "true",
            "tt",
            "if",
            "this",
            "set",
            "contains",
            "no",
            "elements"
        ]
    },
    {
        "id": 302,
        "code": "public boolean contains(Object o) {\n    return map.containsKey(o);\n}",
        "summary_tokens": [
            "returns",
            "tt",
            "true",
            "tt",
            "if",
            "this",
            "set",
            "contains",
            "the",
            "specified",
            "element"
        ]
    },
    {
        "id": 303,
        "code": "public boolean add(E e) {\n    return map.put(e, PRESENT) == null;\n}",
        "summary_tokens": [
            "adds",
            "the",
            "specified",
            "element",
            "to",
            "this",
            "set",
            "if",
            "it",
            "is",
            "not",
            "already",
            "present"
        ]
    },
    {
        "id": 304,
        "code": "public boolean remove(Object o) {\n    return map.remove(o) == PRESENT;\n}",
        "summary_tokens": [
            "removes",
            "the",
            "specified",
            "element",
            "from",
            "this",
            "set",
            "if",
            "it",
            "is",
            "present"
        ]
    },
    {
        "id": 305,
        "code": "public void clear() {\n    map.clear();\n}",
        "summary_tokens": [
            "removes",
            "all",
            "of",
            "the",
            "elements",
            "from",
            "this",
            "set"
        ]
    },
    {
        "id": 306,
        "code": "public static List<String> mergeValues(ExtensionDirector extensionDirector, Class<?> type, String cfg, List<String> def) {\n    List<String> defaults = new ArrayList<String>();\n    if (def != null) {\n        for (String name : def) {\n            if (extensionDirector.getExtensionLoader(type).hasExtension(name)) {\n                defaults.add(name);\n            }\n        }\n    }\n\n    List<String> names = new ArrayList<String>();\n\n        \n    String[] configs = (cfg == null || cfg.trim().length() == 0) ? new String[0] : COMMA_SPLIT_PATTERN.split(cfg);\n    for (String config : configs) {\n        if (config != null && config.trim().length() > 0) {\n            names.add(config);\n        }\n    }\n\n        \n    if (!names.contains(REMOVE_VALUE_PREFIX + DEFAULT_KEY)) {\n            \n        int i = names.indexOf(DEFAULT_KEY);\n        if (i > 0) {\n            names.addAll(i, defaults);\n        } else {\n            names.addAll(0, defaults);\n        }\n        names.remove(DEFAULT_KEY);\n    } else {\n        names.remove(DEFAULT_KEY);\n    }\n\n        \n    for (String name : new ArrayList<String>(names)) {\n        if (name.startsWith(REMOVE_VALUE_PREFIX)) {\n            names.remove(name);\n            names.remove(name.substring(1));\n        }\n    }\n    return names;\n}",
        "summary_tokens": [
            "insert",
            "default",
            "extension",
            "into",
            "extension",
            "list"
        ]
    },
    {
        "id": 307,
        "code": "public static String getSystemProperty(String key) {\n    String value = System.getenv(key);\n    if (StringUtils.isEmpty(value)) {\n        value = System.getProperty(key);\n    }\n    return value;\n}",
        "summary_tokens": [
            "system",
            "environment",
            "system",
            "properties"
        ]
    },
    {
        "id": 308,
        "code": "public static Properties loadProperties(Set<ClassLoader> classLoaders, String fileName, boolean allowMultiFile, boolean optional) {\n    Properties properties = new Properties();\n        \n    if (checkFileNameExist(fileName)) {\n        try {\n            FileInputStream input = new FileInputStream(fileName);\n            try {\n                properties.load(input);\n            } finally {\n                input.close();\n            }\n        } catch (Throwable e) {\n            logger.warn(\"Failed to load \" + fileName + \" file from \" + fileName + \"(ignore this file): \" + e.getMessage(), e);\n        }\n        return properties;\n    }\n\n    Set<java.net.URL> set = null;\n    try {\n        List<ClassLoader> classLoadersToLoad = new LinkedList<>();\n        classLoadersToLoad.add(ClassUtils.getClassLoader());\n        classLoadersToLoad.addAll(classLoaders);\n        set = ClassLoaderResourceLoader.loadResources(fileName, classLoadersToLoad).values().stream().reduce(new LinkedHashSet<>(), (a, i) -> {\n            a.addAll(i);\n            return a;\n        });\n    } catch (Throwable t) {\n        logger.warn(\"Fail to load \" + fileName + \" file: \" + t.getMessage(), t);\n    }\n\n    if (CollectionUtils.isEmpty(set)) {\n        if (!optional) {\n            logger.warn(\"No \" + fileName + \" found on the class path.\");\n        }\n        return properties;\n    }\n\n    if (!allowMultiFile) {\n        if (set.size() > 1) {\n            String errMsg = String.format(\"only 1 %s file is expected, but %d dubbo.properties files found on class path: %s\",\n                fileName, set.size(), set);\n            logger.warn(errMsg);\n        }\n\n            \n        try {\n            properties.load(ClassUtils.getClassLoader().getResourceAsStream(fileName));\n        } catch (Throwable e) {\n            logger.warn(\"Failed to load \" + fileName + \" file from \" + fileName + \"(ignore this file): \" + e.getMessage(), e);\n        }\n        return properties;\n    }\n\n    logger.info(\"load \" + fileName + \" properties file from \" + set);\n\n    for (java.net.URL url : set) {\n        try {\n            Properties p = new Properties();\n            InputStream input = url.openStream();\n            if (input != null) {\n                try {\n                    p.load(input);\n                    properties.putAll(p);\n                } finally {\n                    try {\n                        input.close();\n                    } catch (Throwable t) {\n                    }\n                }\n            }\n        } catch (Throwable e) {\n            logger.warn(\"Fail to load \" + fileName + \" file from \" + url + \"(ignore this file): \" + e.getMessage(), e);\n        }\n    }\n\n    return properties;\n}",
        "summary_tokens": [
            "load",
            "properties",
            "file",
            "to",
            "properties",
            "from",
            "class",
            "path"
        ]
    },
    {
        "id": 309,
        "code": "private static boolean checkFileNameExist(String fileName) {\n    File file = new File(fileName);\n    return file.exists();\n}",
        "summary_tokens": [
            "check",
            "if",
            "the",
            "file",
            "name",
            "can",
            "be",
            "found",
            "in",
            "filesystem"
        ]
    },
    {
        "id": 310,
        "code": "public static void gracefulShutdown(Executor executor, int timeout) {\n    if (!(executor instanceof ExecutorService) || isTerminated(executor)) {\n        return;\n    }\n    final ExecutorService es = (ExecutorService) executor;\n    try {\n            \n        es.shutdown();\n    } catch (SecurityException | NullPointerException ex2) {\n        return;\n    }\n    try {\n            \n        if (!es.awaitTermination(timeout, TimeUnit.MILLISECONDS)) {\n            es.shutdownNow();\n        }\n    } catch (InterruptedException ex) {\n        es.shutdownNow();\n        Thread.currentThread().interrupt();\n    }\n    if (!isTerminated(es)) {\n        newThreadToCloseExecutor(es);\n    }\n}",
        "summary_tokens": [
            "use",
            "the",
            "shutdown",
            "pattern",
            "from",
            "https",
            "docs"
        ]
    },
    {
        "id": 311,
        "code": "public static URL setThreadName(URL url, String defaultName) {\n    String name = url.getParameter(THREAD_NAME_KEY, defaultName);\n    name = name + \"-\" + url.getAddress();\n    url = url.addParameter(THREAD_NAME_KEY, name);\n    return url;\n}",
        "summary_tokens": [
            "append",
            "thread",
            "name",
            "with",
            "url",
            "address"
        ]
    },
    {
        "id": 312,
        "code": "static Field getDeclaredField(Class<?> declaredClass, String fieldName) {\n    try {\n        Field[] fields = declaredClass.getDeclaredFields();\n        for (int i = 0; i < fields.length; i++) {\n            if (fields[i].getName().equals(fieldName)) {\n                return fields[i];\n            }\n        }\n        return null;\n    } catch (Exception exception) {\n        throw new RuntimeException(exception);\n    }\n}",
        "summary_tokens": [
            "like",
            "the",
            "class",
            "get",
            "declared",
            "field",
            "string",
            "method",
            "without",
            "throwing",
            "any",
            "exception"
        ]
    },
    {
        "id": 313,
        "code": "static Field findField(Object object, String fieldName) {\n    return findField(object.getClass(), fieldName);\n}",
        "summary_tokens": [
            "find",
            "the",
            "field",
            "by",
            "the",
            "name",
            "in",
            "the",
            "specified",
            "class",
            "and",
            "its",
            "inherited",
            "types"
        ]
    },
    {
        "id": 314,
        "code": "static <T> T getFieldValue(Object object, Field field) {\n    boolean accessible = field.isAccessible();\n    Object value = null;\n    try {\n        if (!accessible) {\n            field.setAccessible(true);\n        }\n        value = field.get(object);\n    } catch (IllegalAccessException ignored) {\n    } finally {\n        field.setAccessible(accessible);\n    }\n    return (T) value;\n}",
        "summary_tokens": [
            "get",
            "the",
            "value",
            "of",
            "the",
            "specified",
            "field"
        ]
    },
    {
        "id": 315,
        "code": "static <T> T setFieldValue(Object object, Field field, T value) {\n    boolean accessible = field.isAccessible();\n    Object previousValue = null;\n    try {\n        if (!accessible) {\n            field.setAccessible(true);\n        }\n        previousValue = field.get(object);\n        field.set(object, value);\n    } catch (IllegalAccessException ignored) {\n    } finally {\n        field.setAccessible(accessible);\n    }\n    return (T) previousValue;\n}",
        "summary_tokens": [
            "set",
            "the",
            "value",
            "for",
            "the",
            "specified",
            "field"
        ]
    },
    {
        "id": 316,
        "code": "public static URL getURL(String resourceLocation) throws FileNotFoundException {\n    Assert.notNull(resourceLocation, \"Resource location must not be null\");\n    if (resourceLocation.startsWith(CommonConstants.CLASSPATH_URL_PREFIX)) {\n        String path = resourceLocation.substring(CommonConstants.CLASSPATH_URL_PREFIX.length());\n        ClassLoader cl = ClassUtils.getClassLoader();\n        URL url = (cl != null ? cl.getResource(path) : ClassLoader.getSystemResource(path));\n        if (url == null) {\n            String description = \"class path resource [\" + path + \"]\";\n            throw new FileNotFoundException(description +\n                \" cannot be resolved to URL because it does not exist\");\n        }\n        return url;\n    }\n    try {\n            \n        return new URL(resourceLocation);\n    } catch (MalformedURLException ex) {\n            \n        try {\n            return new File(resourceLocation).toURI().toURL();\n        } catch (MalformedURLException ex2) {\n            throw new FileNotFoundException(\"Resource location [\" + resourceLocation +\n                \"] is neither a URL not a well-formed file path\");\n        }\n    }\n}",
        "summary_tokens": [
            "use",
            "like",
            "spring",
            "code"
        ]
    },
    {
        "id": 317,
        "code": "private int proceedEviction() {\n    int targetSize = capacity - evictionCount;\n    int evictedElements = 0;\n\n    FREQ_TABLE_ITER_LOOP:\n    for (int i = 0; i <= capacity; i++) {\n        CacheNode<K, V> node;\n        while (!freqTable[i].isEmpty()) {\n            node = freqTable[i].pollFirst();\n            remove(node.key);\n            if (targetSize >= curSize) {\n                break FREQ_TABLE_ITER_LOOP;\n            }\n            evictedElements++;\n        }\n    }\n    return evictedElements;\n}",
        "summary_tokens": [
            "evicts",
            "less",
            "frequently",
            "used",
            "elements",
            "corresponding",
            "to",
            "eviction",
            "factor",
            "specified",
            "at",
            "instantiation",
            "step"
        ]
    },
    {
        "id": 318,
        "code": "public int getSize() {\n    return curSize;\n}",
        "summary_tokens": [
            "returns",
            "cache",
            "current",
            "size"
        ]
    },
    {
        "id": 319,
        "code": "public String getMd5(String input) {\n    byte[] md5;\n        \n    synchronized (mdInst) {\n        mdInst.update(input.getBytes(UTF_8));\n        md5 = mdInst.digest();\n    }\n\n    int j = md5.length;\n    char str[] = new char[j * 2];\n    int k = 0;\n    for (int i = 0; i < j; i++) {\n        byte byte0 = md5[i];\n        str[k++] = hexDigits[byte0 >>> 4 & 0xf];\n        str[k++] = hexDigits[byte0 & 0xf];\n    }\n    return new String(str);\n}",
        "summary_tokens": [
            "calculation",
            "md",
            "0",
            "value",
            "of",
            "specify",
            "string",
            "input"
        ]
    },
    {
        "id": 320,
        "code": "static boolean isStatic(Member member) {\n    return member != null && Modifier.isStatic(member.getModifiers());\n}",
        "summary_tokens": [
            "check",
            "the",
            "specified",
            "member",
            "member",
            "is",
            "static",
            "or",
            "not"
        ]
    },
    {
        "id": 321,
        "code": "static boolean isPrivate(Member member) {\n    return member != null && Modifier.isPrivate(member.getModifiers());\n}",
        "summary_tokens": [
            "check",
            "the",
            "specified",
            "member",
            "member",
            "is",
            "private",
            "or",
            "not"
        ]
    },
    {
        "id": 322,
        "code": "static boolean isPublic(Member member) {\n    return member != null && Modifier.isPublic(member.getModifiers());\n}",
        "summary_tokens": [
            "check",
            "the",
            "specified",
            "member",
            "member",
            "is",
            "public",
            "or",
            "not"
        ]
    },
    {
        "id": 323,
        "code": "static boolean isSetter(Method method) {\n    return method.getName().startsWith(\"set\")\n            && !\"set\".equals(method.getName())\n            && Modifier.isPublic(method.getModifiers())\n            && method.getParameterCount() == 1\n            && ClassUtils.isPrimitive(method.getParameterTypes()[0]);\n}",
        "summary_tokens": [
            "return",
            "true",
            "if",
            "the",
            "provided",
            "method",
            "is",
            "a",
            "set",
            "method"
        ]
    },
    {
        "id": 324,
        "code": "static boolean isGetter(Method method) {\n    String name = method.getName();\n    return (name.startsWith(\"get\") || name.startsWith(\"is\"))\n            && !\"get\".equals(name) && !\"is\".equals(name)\n            && !\"getClass\".equals(name) && !\"getObject\".equals(name)\n            && Modifier.isPublic(method.getModifiers())\n            && method.getParameterTypes().length == 0\n            && ClassUtils.isPrimitive(method.getReturnType());\n}",
        "summary_tokens": [
            "return",
            "true",
            "if",
            "the",
            "provided",
            "method",
            "is",
            "a",
            "get",
            "method"
        ]
    },
    {
        "id": 325,
        "code": "static boolean isMetaMethod(Method method) {\n    String name = method.getName();\n    if (!(name.startsWith(\"get\") || name.startsWith(\"is\"))) {\n        return false;\n    }\n    if (\"get\".equals(name)) {\n        return false;\n    }\n    if (\"getClass\".equals(name)) {\n        return false;\n    }\n    if (!Modifier.isPublic(method.getModifiers())) {\n        return false;\n    }\n    if (method.getParameterTypes().length != 0) {\n        return false;\n    }\n    if (!ClassUtils.isPrimitive(method.getReturnType())) {\n        return false;\n    }\n    return true;\n}",
        "summary_tokens": [
            "return",
            "true",
            "if",
            "this",
            "method",
            "is",
            "a",
            "meta",
            "method"
        ]
    },
    {
        "id": 326,
        "code": "static boolean isDeprecated(Method method) {\n    return method.getAnnotation(Deprecated.class) != null;\n}",
        "summary_tokens": [
            "check",
            "if",
            "the",
            "method",
            "is",
            "a",
            "deprecated",
            "method"
        ]
    },
    {
        "id": 327,
        "code": "static Predicate<Method> excludedDeclaredClass(Class<?> declaredClass) {\n    return method -> !Objects.equals(declaredClass, method.getDeclaringClass());\n}",
        "summary_tokens": [
            "create",
            "an",
            "instance",
            "of",
            "predicate",
            "for",
            "method",
            "to",
            "exclude",
            "the",
            "specified",
            "declared",
            "class"
        ]
    },
    {
        "id": 328,
        "code": "static List<Method> getMethods(Class<?> declaringClass, Predicate<Method>... methodsToFilter) {\n    return getMethods(declaringClass, false, true, methodsToFilter);\n}",
        "summary_tokens": [
            "get",
            "all",
            "public",
            "method",
            "methods",
            "of",
            "the",
            "declared",
            "class",
            "including",
            "the",
            "inherited",
            "methods"
        ]
    },
    {
        "id": 329,
        "code": "static List<Method> getDeclaredMethods(Class<?> declaringClass, Predicate<Method>... methodsToFilter) {\n    return getMethods(declaringClass, false, false, methodsToFilter);\n}",
        "summary_tokens": [
            "get",
            "all",
            "declared",
            "method",
            "methods",
            "of",
            "the",
            "declared",
            "class",
            "excluding",
            "the",
            "inherited",
            "methods"
        ]
    },
    {
        "id": 330,
        "code": "static List<Method> getAllDeclaredMethods(Class<?> declaringClass, Predicate<Method>... methodsToFilter) {\n    return getMethods(declaringClass, true, false, methodsToFilter);\n}",
        "summary_tokens": [
            "get",
            "all",
            "declared",
            "method",
            "methods",
            "of",
            "the",
            "declared",
            "class",
            "including",
            "the",
            "inherited",
            "methods"
        ]
    },
    {
        "id": 331,
        "code": "static List<Method> getAllMethods(Class<?> declaringClass, Predicate<Method>... methodsToFilter) {\n    return getMethods(declaringClass, true, true, methodsToFilter);\n}",
        "summary_tokens": [
            "get",
            "all",
            "public",
            "method",
            "methods",
            "of",
            "the",
            "declared",
            "class",
            "including",
            "the",
            "inherited",
            "methods"
        ]
    },
    {
        "id": 332,
        "code": "static Method findMethod(Class type, String methodName, Class<?>... parameterTypes) {\n    Method method = null;\n    try {\n        if (type != null && isNotEmpty(methodName)) {\n            method = type.getDeclaredMethod(methodName, parameterTypes);\n        }\n    } catch (NoSuchMethodException e) {\n    }\n    return method;\n}",
        "summary_tokens": [
            "find",
            "the",
            "method",
            "by",
            "the",
            "the",
            "specified",
            "type",
            "method",
            "name",
            "and",
            "parameter",
            "types"
        ]
    },
    {
        "id": 333,
        "code": "static <T> T invokeMethod(Object object, String methodName, Object... methodParameters) {\n    Class type = object.getClass();\n    Class[] parameterTypes = resolveTypes(methodParameters);\n    Method method = findMethod(type, methodName, parameterTypes);\n    T value = null;\n\n    if (method == null) {\n        throw new IllegalStateException(String.format(\"cannot find method %s,class: %s\", methodName, type.getName()));\n    }\n\n    try {\n        final boolean isAccessible = method.isAccessible();\n\n        if (!isAccessible) {\n            method.setAccessible(true);\n        }\n        value = (T) method.invoke(object, methodParameters);\n        method.setAccessible(isAccessible);\n    } catch (Exception e) {\n        throw new IllegalArgumentException(e);\n    }\n\n    return value;\n}",
        "summary_tokens": [
            "invoke",
            "the",
            "target",
            "object",
            "and",
            "method"
        ]
    },
    {
        "id": 334,
        "code": "static boolean overrides(Method overrider, Method overridden) {\n\n    if (overrider == null || overridden == null) {\n        return false;\n    }\n\n        \n    if (Objects.equals(overrider, overridden)) {\n        return false;\n    }\n\n        \n    if (isStatic(overrider) || isStatic(overridden)) { \n        return false;\n    }\n\n        \n    if (isPrivate(overrider) || isPrivate(overridden)) {\n        return false;\n    }\n\n        \n    if (!overridden.getDeclaringClass().isAssignableFrom(overrider.getDeclaringClass())) {\n        return false;\n    }\n\n        \n    if (overrider.isDefault()) {\n        return false;\n    }\n\n        \n    if (!Objects.equals(overrider.getName(), overridden.getName())) {\n        return false;\n    }\n\n        \n    if (!Objects.equals(overrider.getParameterCount(), overridden.getParameterCount())) {\n        return false;\n    }\n\n        \n    for (int i = 0; i < overrider.getParameterCount(); i++) {\n        if (!Objects.equals(overridden.getParameterTypes()[i], overrider.getParameterTypes()[i])) {\n            return false;\n        }\n    }\n\n        \n    if (!overridden.getReturnType().isAssignableFrom(overrider.getReturnType())) {\n        return false;\n    }\n\n        \n\n    return true;\n}",
        "summary_tokens": [
            "tests",
            "whether",
            "one",
            "method",
            "as",
            "a",
            "member",
            "of",
            "a",
            "given",
            "type",
            "overrides",
            "another",
            "method"
        ]
    },
    {
        "id": 335,
        "code": "static Method findNearestOverriddenMethod(Method overrider) {\n    Class<?> declaringClass = overrider.getDeclaringClass();\n    Method overriddenMethod = null;\n    for (Class<?> inheritedType : getAllInheritedTypes(declaringClass)) {\n        overriddenMethod = findOverriddenMethod(overrider, inheritedType);\n        if (overriddenMethod != null) {\n            break;\n        }\n    }\n    return overriddenMethod;\n}",
        "summary_tokens": [
            "find",
            "the",
            "nearest",
            "overridden",
            "method",
            "method",
            "from",
            "the",
            "inherited",
            "class"
        ]
    },
    {
        "id": 336,
        "code": "static Method findOverriddenMethod(Method overrider, Class<?> declaringClass) {\n    List<Method> matchedMethods = getAllMethods(declaringClass, method -> overrides(overrider, method));\n    return matchedMethods.isEmpty() ? null : matchedMethods.get(0);\n}",
        "summary_tokens": [
            "find",
            "the",
            "overridden",
            "method",
            "method",
            "from",
            "the",
            "declaring",
            "class"
        ]
    },
    {
        "id": 337,
        "code": "static String extractFieldName(Method method) {\n    List<String> emptyFieldMethod = Arrays.asList(\"is\", \"get\", \"getObject\", \"getClass\");\n    String methodName = method.getName();\n    String fieldName = \"\";\n\n    if (emptyFieldMethod.contains(methodName)) {\n        return fieldName;\n    } else if (methodName.startsWith(\"get\")) {\n        fieldName = methodName.substring(\"get\".length());\n    } else if (methodName.startsWith(\"set\")) {\n        fieldName = methodName.substring(\"set\".length());\n    } else if (methodName.startsWith(\"is\")) {\n        fieldName = methodName.substring(\"is\".length());\n    } else {\n        return fieldName;\n    }\n\n    if (StringUtils.isNotEmpty(fieldName)) {\n        fieldName = fieldName.substring(0, 1).toLowerCase() + fieldName.substring(1);\n    }\n\n    return fieldName;\n}",
        "summary_tokens": [
            "extract",
            "field",
            "name",
            "from",
            "set",
            "get",
            "is",
            "method"
        ]
    },
    {
        "id": 338,
        "code": "static double invokeAndReturnDouble(Method method, Object targetObj) {\n    try {\n        return method != null ? (double) method.invoke(targetObj) : Double.NaN;\n    } catch (Exception e) {\n        return Double.NaN;\n    }\n}",
        "summary_tokens": [
            "invoke",
            "and",
            "return",
            "double",
            "value"
        ]
    },
    {
        "id": 339,
        "code": "static long invokeAndReturnLong(Method method, Object targetObj) {\n    try {\n        return method != null ? (long) method.invoke(targetObj) : -1;\n    } catch (Exception e) {\n        return -1;\n    }\n}",
        "summary_tokens": [
            "invoke",
            "and",
            "return",
            "long",
            "value"
        ]
    },
    {
        "id": 340,
        "code": "public static boolean isPortInUsed(int port) {\n    try (ServerSocket ignored = new ServerSocket(port)) {\n        return false;\n    } catch (IOException e) {\n            \n    }\n    return true;\n}",
        "summary_tokens": [
            "check",
            "the",
            "port",
            "whether",
            "is",
            "in",
            "use",
            "in",
            "os",
            "port",
            "port",
            "to",
            "check",
            "true",
            "if",
            "it",
            "s",
            "occupied"
        ]
    },
    {
        "id": 341,
        "code": "public static boolean isInvalidPort(int port) {\n    return port < MIN_PORT || port > MAX_PORT;\n}",
        "summary_tokens": [
            "tells",
            "whether",
            "the",
            "port",
            "to",
            "test",
            "is",
            "an",
            "invalid",
            "port"
        ]
    },
    {
        "id": 342,
        "code": "public static boolean isValidAddress(String address) {\n    return ADDRESS_PATTERN.matcher(address).matches();\n}",
        "summary_tokens": [
            "tells",
            "whether",
            "the",
            "address",
            "to",
            "test",
            "is",
            "an",
            "invalid",
            "address"
        ]
    },
    {
        "id": 343,
        "code": "static boolean isPreferIPV6Address() {\n    return Boolean.getBoolean(\"java.net.preferIPv6Addresses\");\n}",
        "summary_tokens": [
            "check",
            "if",
            "an",
            "ipv",
            "0",
            "address"
        ]
    },
    {
        "id": 344,
        "code": "static InetAddress normalizeV6Address(Inet6Address address) {\n    String addr = address.getHostAddress();\n    int i = addr.lastIndexOf('%');\n    if (i > 0) {\n        try {\n            return InetAddress.getByName(addr.substring(0, i) + '%' + address.getScopeId());\n        } catch (UnknownHostException e) {\n                \n            logger.debug(\"Unknown IPV6 address: \", e);\n        }\n    }\n    return address;\n}",
        "summary_tokens": [
            "normalize",
            "the",
            "ipv",
            "0",
            "address",
            "convert",
            "scope",
            "name",
            "to",
            "scope",
            "id"
        ]
    },
    {
        "id": 345,
        "code": "public static InetAddress getLocalAddress() {\n    if (LOCAL_ADDRESS != null) {\n        return LOCAL_ADDRESS;\n    }\n    InetAddress localAddress = getLocalAddress0();\n    LOCAL_ADDRESS = localAddress;\n    return localAddress;\n}",
        "summary_tokens": [
            "find",
            "first",
            "valid",
            "ip",
            "from",
            "local",
            "network",
            "card"
        ]
    },
    {
        "id": 346,
        "code": "private static boolean ignoreNetworkInterface(NetworkInterface networkInterface) throws SocketException {\n    if (networkInterface == null\n        || networkInterface.isLoopback()\n        || networkInterface.isVirtual()\n        || !networkInterface.isUp()) {\n        return true;\n    }\n    String ignoredInterfaces = System.getProperty(DUBBO_NETWORK_IGNORED_INTERFACE);\n    String networkInterfaceDisplayName;\n    if (StringUtils.isNotEmpty(ignoredInterfaces)\n        && StringUtils.isNotEmpty(networkInterfaceDisplayName = networkInterface.getDisplayName())) {\n        for (String ignoredInterface : ignoredInterfaces.split(\",\")) {\n            String trimIgnoredInterface = ignoredInterface.trim();\n            boolean matched = false;\n            try {                     \n                matched = networkInterfaceDisplayName.matches(trimIgnoredInterface);\n            } catch (PatternSyntaxException e) {\n                    \n                logger.warn(\"exception occurred: \" + networkInterfaceDisplayName + \" matches \" + trimIgnoredInterface, e);\n            } finally {\n                if (matched) {\n                    return true;\n                }\n                if (networkInterfaceDisplayName.equals(trimIgnoredInterface)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "the",
            "specified",
            "network",
            "interface",
            "should",
            "be",
            "ignored",
            "with",
            "the",
            "given",
            "conditions"
        ]
    },
    {
        "id": 347,
        "code": "private static List<NetworkInterface> getValidNetworkInterfaces() throws SocketException {\n    List<NetworkInterface> validNetworkInterfaces = new LinkedList<>();\n    Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();\n    while (interfaces.hasMoreElements()) {\n        NetworkInterface networkInterface = interfaces.nextElement();\n        if (ignoreNetworkInterface(networkInterface)) { \n            continue;\n        }\n        validNetworkInterfaces.add(networkInterface);\n    }\n    return validNetworkInterfaces;\n}",
        "summary_tokens": [
            "get",
            "the",
            "valid",
            "network",
            "interface",
            "network",
            "interfaces"
        ]
    },
    {
        "id": 348,
        "code": "public static boolean isPreferredNetworkInterface(NetworkInterface networkInterface) {\n    String preferredNetworkInterface = System.getProperty(DUBBO_PREFERRED_NETWORK_INTERFACE);\n    return Objects.equals(networkInterface.getDisplayName(), preferredNetworkInterface);\n}",
        "summary_tokens": [
            "is",
            "preferred",
            "network",
            "interface",
            "or",
            "not"
        ]
    },
    {
        "id": 349,
        "code": "public static NetworkInterface findNetworkInterface() {\n\n    List<NetworkInterface> validNetworkInterfaces = emptyList();\n    try {\n        validNetworkInterfaces = getValidNetworkInterfaces();\n    } catch (Throwable e) {\n        logger.warn(e);\n    }\n\n    NetworkInterface result = null;\n\n        \n    for (NetworkInterface networkInterface : validNetworkInterfaces) {\n        if (isPreferredNetworkInterface(networkInterface)) {\n            result = networkInterface;\n            break;\n        }\n    }\n\n    if (result == null) { \n        for (NetworkInterface networkInterface : validNetworkInterfaces) {\n            Enumeration<InetAddress> addresses = networkInterface.getInetAddresses();\n            while (addresses.hasMoreElements()) {\n                Optional<InetAddress> addressOp = toValidAddress(addresses.nextElement());\n                if (addressOp.isPresent()) {\n                    try {\n                        if (addressOp.get().isReachable(100)) {\n                            return networkInterface;\n                        }\n                    } catch (IOException e) {\n                            \n                    }\n                }\n            }\n        }\n    }\n\n    if (result == null) {\n        result = first(validNetworkInterfaces);\n    }\n\n    return result;\n}",
        "summary_tokens": [
            "get",
            "the",
            "suitable",
            "network",
            "interface"
        ]
    },
    {
        "id": 350,
        "code": "public static String getIpByHost(String hostName) {\n    try {\n        return InetAddress.getByName(hostName).getHostAddress();\n    } catch (UnknownHostException e) {\n        return hostName;\n    }\n}",
        "summary_tokens": [
            "host",
            "name",
            "ip",
            "address",
            "or",
            "host",
            "name",
            "if",
            "unknown",
            "host",
            "exception"
        ]
    },
    {
        "id": 351,
        "code": "public static boolean matchIpRange(String pattern, String host, int port) throws UnknownHostException {\n    if (pattern == null || host == null) {\n        throw new IllegalArgumentException(\"Illegal Argument pattern or hostName. Pattern:\" + pattern + \", Host:\" + host);\n    }\n    pattern = pattern.trim();\n    if (\"*.*.*.*\".equals(pattern) || \"*\".equals(pattern)) {\n        return true;\n    }\n\n    InetAddress inetAddress = InetAddress.getByName(host);\n    boolean isIpv4 = isValidV4Address(inetAddress);\n    String[] hostAndPort = getPatternHostAndPort(pattern, isIpv4);\n    if (hostAndPort[1] != null && !hostAndPort[1].equals(String.valueOf(port))) {\n        return false;\n    }\n    pattern = hostAndPort[0];\n\n    String splitCharacter = SPLIT_IPV4_CHARACTER;\n    if (!isIpv4) {\n        splitCharacter = SPLIT_IPV6_CHARACTER;\n    }\n    String[] mask = pattern.split(splitCharacter);\n        \n    checkHostPattern(pattern, mask, isIpv4);\n\n    host = inetAddress.getHostAddress();\n    if (pattern.equals(host)) {\n        return true;\n    }\n\n        \n    if (!ipPatternContainExpression(pattern)) {\n        InetAddress patternAddress = InetAddress.getByName(pattern);\n        return patternAddress.getHostAddress().equals(host);\n    }\n\n    String[] ipAddress = host.split(splitCharacter);\n\n    for (int i = 0; i < mask.length; i++) {\n        if (\"*\".equals(mask[i]) || mask[i].equals(ipAddress[i])) {\n            continue;\n        } else if (mask[i].contains(\"-\")) {\n            String[] rangeNumStrs = StringUtils.split(mask[i], '-');\n            if (rangeNumStrs.length != 2) {\n                throw new IllegalArgumentException(\"There is wrong format of ip Address: \" + mask[i]);\n            }\n            Integer min = getNumOfIpSegment(rangeNumStrs[0], isIpv4);\n            Integer max = getNumOfIpSegment(rangeNumStrs[1], isIpv4);\n            Integer ip = getNumOfIpSegment(ipAddress[i], isIpv4);\n            if (ip < min || ip > max) {\n                return false;\n            }\n        } else if (\"0\".equals(ipAddress[i]) && (\"0\".equals(mask[i]) || \"00\".equals(mask[i]) || \"000\".equals(mask[i]) || \"0000\".equals(mask[i]))) {\n            continue;\n        } else if (!mask[i].equals(ipAddress[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
        "summary_tokens": [
            "pattern",
            "host",
            "port",
            "unknown",
            "host",
            "exception"
        ]
    },
    {
        "id": 352,
        "code": "public static boolean isMulticastAddress(String host) {\n    int i = host.indexOf('.');\n    if (i > 0) {\n        String prefix = host.substring(0, i);\n        if (StringUtils.isNumber(prefix)) {\n            int p = Integer.parseInt(prefix);\n            return p >= 224 && p <= 239;\n        }\n    }\n    return false;\n}",
        "summary_tokens": [
            "is",
            "multicast",
            "address",
            "or",
            "not"
        ]
    },
    {
        "id": 353,
        "code": "default int getDataSize() {\n    return getData().size();\n}",
        "summary_tokens": [
            "the",
            "size",
            "of",
            "get",
            "data",
            "data"
        ]
    },
    {
        "id": 354,
        "code": "default boolean hasData() {\n    return getDataSize() > 0;\n}",
        "summary_tokens": [
            "returns",
            "whether",
            "the",
            "page",
            "has",
            "data",
            "at",
            "all"
        ]
    },
    {
        "id": 355,
        "code": "static String normalize(String path) {\n    if (isEmpty(path)) {\n        return SLASH;\n    }\n    String normalizedPath = path;\n    int index = normalizedPath.indexOf(QUESTION_MASK);\n    if (index > -1) {\n        normalizedPath = normalizedPath.substring(0, index);\n    }\n\n    while (normalizedPath.contains(\"//\")) {\n        normalizedPath = replace(normalizedPath, \"//\", \"/\");\n    }\n\n    return normalizedPath;\n}",
        "summary_tokens": [
            "normalize",
            "path",
            "ol",
            "li",
            "to",
            "remove",
            "query",
            "string",
            "if",
            "presents",
            "li",
            "li",
            "to",
            "remove",
            "duplicated",
            "slash",
            "if",
            "exists",
            "li",
            "ol"
        ]
    },
    {
        "id": 356,
        "code": "private static Type getKeyTypeForMap(Class<?> clazz) {\n    Type[] interfaces = clazz.getGenericInterfaces();\n    if (!ArrayUtils.isEmpty(interfaces)) {\n        for (Type type : interfaces) {\n            if (type instanceof ParameterizedType) {\n                ParameterizedType t = (ParameterizedType) type;\n                if (\"java.util.Map\".equals(t.getRawType().getTypeName())) {\n                    return t.getActualTypeArguments()[0];\n                }\n            }\n        }\n    }\n    return null;\n}",
        "summary_tokens": [
            "get",
            "key",
            "type",
            "for",
            "map",
            "directly",
            "implemented",
            "by",
            "clazz"
        ]
    },
    {
        "id": 357,
        "code": "public static <T> void updatePropertyIfAbsent(Supplier<T> getterMethod, Consumer<T> setterMethod, T newValue) {\n    if (newValue != null && getterMethod.get() == null) {\n        setterMethod.accept(newValue);\n    }\n}",
        "summary_tokens": [
            "update",
            "the",
            "property",
            "if",
            "absent"
        ]
    },
    {
        "id": 358,
        "code": "public static <T> T mapToPojo(Map<String, Object> map, Class<T> cls) throws ReflectiveOperationException {\n    T instance = cls.getDeclaredConstructor().newInstance();\n    Map<String, Field> beanPropertyFields = ReflectUtils.getBeanPropertyFields(cls);\n    for (Map.Entry<String, Field> entry : beanPropertyFields.entrySet()) {\n        String name = entry.getKey();\n        Field field = entry.getValue();\n        Object mapObject = map.get(name);\n        if (mapObject == null) {\n            continue;\n        }\n\n        Type type = field.getGenericType();\n        Object fieldObject = getFieldObject(mapObject, type);\n        field.set(instance, fieldObject);\n    }\n\n    return instance;\n}",
        "summary_tokens": [
            "convert",
            "map",
            "to",
            "a",
            "specific",
            "class",
            "instance"
        ]
    },
    {
        "id": 359,
        "code": "public static String getDesc(final Class<?>[] cs) {\n    if (cs.length == 0) {\n        return \"\";\n    }\n\n    StringBuilder sb = new StringBuilder(64);\n    for (Class<?> c : cs) {\n        sb.append(getDesc(c));\n    }\n    return sb.toString();\n}",
        "summary_tokens": [
            "get",
            "class",
            "array",
            "desc"
        ]
    },
    {
        "id": 360,
        "code": "private static Class<?>[] desc2classArray(ClassLoader cl, String desc) throws ClassNotFoundException {\n    if (desc.length() == 0) {\n        return EMPTY_CLASS_ARRAY;\n    }\n\n    List<Class<?>> cs = new ArrayList<Class<?>>();\n    Matcher m = DESC_PATTERN.matcher(desc);\n    while (m.find()) {\n        cs.add(desc2class(cl, m.group()));\n    }\n    return cs.toArray(EMPTY_CLASS_ARRAY);\n}",
        "summary_tokens": [
            "get",
            "class",
            "array",
            "instance"
        ]
    },
    {
        "id": 361,
        "code": "public static Method findMethodByMethodSignature(Class<?> clazz, String methodName, String[] parameterTypes)\n        throws NoSuchMethodException, ClassNotFoundException {\n    String signature = clazz.getName() + \".\" + methodName;\n    if (parameterTypes != null && parameterTypes.length > 0) {\n        signature += StringUtils.join(parameterTypes);\n    }\n    Method method;\n    if (parameterTypes == null) {\n        List<Method> finded = new ArrayList<Method>();\n        for (Method m : clazz.getMethods()) {\n            if (m.getName().equals(methodName)) {\n                finded.add(m);\n            }\n        }\n        if (finded.isEmpty()) {\n            throw new NoSuchMethodException(\"No such method \" + methodName + \" in class \" + clazz);\n        }\n        if (finded.size() > 1) {\n            String msg = String.format(\"Not unique method for method name(%s) in class(%s), find %d methods.\",\n                    methodName, clazz.getName(), finded.size());\n            throw new IllegalStateException(msg);\n        }\n        method = finded.get(0);\n    } else {\n        Class<?>[] types = new Class<?>[parameterTypes.length];\n        for (int i = 0; i < parameterTypes.length; i++) {\n            types[i] = ReflectUtils.name2class(parameterTypes[i]);\n        }\n        method = clazz.getMethod(methodName, types);\n\n    }\n    return method;\n}",
        "summary_tokens": [
            "find",
            "method",
            "from",
            "method",
            "signature"
        ]
    },
    {
        "id": 362,
        "code": "public static Method findMethodByMethodName(Class<?> clazz, String methodName)\n        throws NoSuchMethodException, ClassNotFoundException {\n    return findMethodByMethodSignature(clazz, methodName, null);\n}",
        "summary_tokens": [
            "clazz",
            "target",
            "class",
            "to",
            "find",
            "method",
            "method",
            "name",
            "method",
            "signature",
            "e"
        ]
    },
    {
        "id": 363,
        "code": "public static boolean isInstance(Object obj, String interfaceClazzName) {\n    for (Class<?> clazz = obj.getClass();\n         clazz != null && !clazz.equals(Object.class);\n         clazz = clazz.getSuperclass()) {\n        Class<?>[] interfaces = clazz.getInterfaces();\n        for (Class<?> itf : interfaces) {\n            if (itf.getName().equals(interfaceClazzName)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}",
        "summary_tokens": [
            "check",
            "if",
            "one",
            "object",
            "is",
            "the",
            "implementation",
            "for",
            "a",
            "given",
            "interface"
        ]
    },
    {
        "id": 364,
        "code": "public static Set<ParameterizedType> findParameterizedTypes(Class<?> sourceClass) {\n        \n    List<Type> genericTypes = new LinkedList<>(asList(sourceClass.getGenericInterfaces()));\n        \n    genericTypes.add(sourceClass.getGenericSuperclass());\n\n    Set<ParameterizedType> parameterizedTypes = genericTypes.stream()\n            .filter(type -> type instanceof ParameterizedType)\n            .map(ParameterizedType.class::cast)  \n            .collect(Collectors.toSet());\n\n    if (parameterizedTypes.isEmpty()) { \n        genericTypes.stream()\n                .filter(type -> type instanceof Class)\n                .map(Class.class::cast)\n                .forEach(superClass -> parameterizedTypes.addAll(findParameterizedTypes(superClass)));\n    }\n\n    return unmodifiableSet(parameterizedTypes);                     \n\n}",
        "summary_tokens": [
            "find",
            "the",
            "set",
            "of",
            "parameterized",
            "type"
        ]
    },
    {
        "id": 365,
        "code": "public static <T> Set<Class<T>> findHierarchicalTypes(Class<?> sourceClass, Class<T> matchType) {\n    if (sourceClass == null) {\n        return Collections.emptySet();\n    }\n\n    Set<Class<T>> hierarchicalTypes = new LinkedHashSet<>();\n\n    if (matchType.isAssignableFrom(sourceClass)) {\n        hierarchicalTypes.add((Class<T>) sourceClass);\n    }\n\n        \n    hierarchicalTypes.addAll(findHierarchicalTypes(sourceClass.getSuperclass(), matchType));\n\n    return unmodifiableSet(hierarchicalTypes);\n}",
        "summary_tokens": [
            "find",
            "the",
            "hierarchical",
            "types",
            "from",
            "the",
            "source",
            "class",
            "class",
            "by",
            "specified",
            "class",
            "type"
        ]
    },
    {
        "id": 366,
        "code": "public static <T> T getProperty(Object bean, String methodName) {\n    Class<?> beanClass = bean.getClass();\n    BeanInfo beanInfo = null;\n    T propertyValue = null;\n\n    try {\n        beanInfo = Introspector.getBeanInfo(beanClass);\n        propertyValue = (T) Stream.of(beanInfo.getMethodDescriptors())\n                .filter(methodDescriptor -> methodName.equals(methodDescriptor.getName()))\n                .findFirst()\n                .map(method -> {\n                    try {\n                        return method.getMethod().invoke(bean);\n                    } catch (Exception e) {\n                            \n                    }\n                    return null;\n                }).get();\n    } catch (Exception e) {\n\n    }\n    return propertyValue;\n}",
        "summary_tokens": [
            "get",
            "the",
            "value",
            "from",
            "the",
            "specified",
            "bean",
            "and",
            "its",
            "getter",
            "method"
        ]
    },
    {
        "id": 367,
        "code": "public static boolean hasMethod(Class<?> beanClass, String methodName) {\n    try {\n        BeanInfo beanInfo = Introspector.getBeanInfo(beanClass);\n        Optional<MethodDescriptor> descriptor = Stream.of(beanInfo.getMethodDescriptors())\n                .filter(methodDescriptor -> methodName.equals(methodDescriptor.getName()))\n                .findFirst();\n        return descriptor.isPresent();\n    } catch (Exception e) {\n\n    }\n    return false;\n}",
        "summary_tokens": [
            "check",
            "target",
            "bean",
            "class",
            "whether",
            "has",
            "specify",
            "method",
            "bean",
            "class",
            "method",
            "name"
        ]
    },
    {
        "id": 368,
        "code": "public static Class[] resolveTypes(Object... values) {\n\n    if (isEmpty(values)) {\n        return EMPTY_CLASS_ARRAY;\n    }\n\n    int size = values.length;\n\n    Class[] types = new Class[size];\n\n    for (int i = 0; i < size; i++) {\n        Object value = values[i];\n        types[i] = value == null ? null : value.getClass();\n    }\n\n    return types;\n}",
        "summary_tokens": [
            "resolve",
            "the",
            "types",
            "of",
            "the",
            "specified",
            "values"
        ]
    },
    {
        "id": 369,
        "code": "public static Set<String> getAllFieldNames(Class<?> type) {\n\n    Set<String> fieldNames = new HashSet<>();\n    for (Field field : type.getDeclaredFields()) {\n        fieldNames.add(field.getName());\n    }\n\n    Set<Class<?>> allSuperClasses = ClassUtils.getAllSuperClasses(type);\n    for (Class<?> aClass : allSuperClasses) {\n        for (Field field : aClass.getDeclaredFields()) {\n            fieldNames.add(field.getName());\n        }\n    }\n    return fieldNames;\n}",
        "summary_tokens": [
            "get",
            "all",
            "field",
            "names",
            "of",
            "target",
            "type",
            "type"
        ]
    },
    {
        "id": 370,
        "code": "public void validateClass(String name) {\n    if(!OPEN_CHECK_CLASS){\n        return;\n    }\n\n    name = name.toLowerCase(Locale.ROOT);\n    if (CACHE == CLASS_ALLOW_LFU_CACHE.get(name)) {\n        return;\n    }\n\n    if (CACHE == CLASS_BLOCK_LFU_CACHE.get(name)) {\n        error(name);\n    }\n\n    for (String allowedPrefix : CLASS_DESERIALIZE_ALLOWED_SET) {\n        if (name.startsWith(allowedPrefix)) {\n            CLASS_ALLOW_LFU_CACHE.put(name, CACHE);\n            return;\n        }\n    }\n\n    for (String blockedPrefix : CLASS_DESERIALIZE_BLOCKED_SET) {\n        if (BLOCK_ALL_CLASS_EXCEPT_ALLOW || name.startsWith(blockedPrefix)) {\n            CLASS_BLOCK_LFU_CACHE.put(name, CACHE);\n            error(name);\n        }\n    }\n\n    CLASS_ALLOW_LFU_CACHE.put(name, CACHE);\n}",
        "summary_tokens": [
            "check",
            "if",
            "a",
            "class",
            "is",
            "in",
            "block",
            "list",
            "using",
            "prefix",
            "match"
        ]
    },
    {
        "id": 371,
        "code": "public String resolveInterfaceClassName() {\n\n    Class interfaceClass;\n        \n    String interfaceName = resolveAttribute(\"interfaceName\");\n\n    if (isEmpty(interfaceName)) { \n        interfaceClass = resolveAttribute(\"interfaceClass\");\n    } else {\n        interfaceClass = resolveClass(interfaceName, getClass().getClassLoader());\n    }\n\n    if (isGenericClass(interfaceClass)) {\n        interfaceName = interfaceClass.getName();\n    } else {\n        interfaceName = null;\n    }\n\n    if (isEmpty(interfaceName)) { \n        Class[] interfaces = serviceType.getInterfaces();\n        if (isNotEmpty(interfaces)) {\n            interfaceName = interfaces[0].getName();\n        }\n    }\n\n    return interfaceName;\n}",
        "summary_tokens": [
            "resolve",
            "the",
            "class",
            "name",
            "of",
            "interface"
        ]
    },
    {
        "id": 372,
        "code": "public static int length(final CharSequence cs) {\n    return cs == null ? 0 : cs.length();\n}",
        "summary_tokens": [
            "gets",
            "a",
            "char",
            "sequence",
            "length",
            "or",
            "0",
            "if",
            "the",
            "char",
            "sequence",
            "is",
            "null"
        ]
    },
    {
        "id": 373,
        "code": "public static String repeat(final char ch, final int repeat) {\n    final char[] buf = new char[repeat];\n    for (int i = repeat - 1; i >= 0; i--) {\n        buf[i] = ch;\n    }\n    return new String(buf);\n}",
        "summary_tokens": [
            "p",
            "returns",
            "padding",
            "using",
            "the",
            "specified",
            "delimiter",
            "repeated",
            "to",
            "a",
            "given",
            "length"
        ]
    },
    {
        "id": 374,
        "code": "public static String removeEnd(final String str, final String remove) {\n    if (isAnyEmpty(str, remove)) {\n        return str;\n    }\n    if (str.endsWith(remove)) {\n        return str.substring(0, str.length() - remove.length());\n    }\n    return str;\n}",
        "summary_tokens": [
            "p",
            "removes",
            "a",
            "substring",
            "only",
            "if",
            "it",
            "is",
            "at",
            "the",
            "end",
            "of",
            "a",
            "source",
            "string",
            "otherwise",
            "returns",
            "the",
            "source",
            "string"
        ]
    },
    {
        "id": 375,
        "code": "public static String stripEnd(final String str, final String stripChars) {\n    int end;\n    if (str == null || (end = str.length()) == 0) {\n        return str;\n    }\n\n    if (stripChars == null) {\n        while (end != 0 && Character.isWhitespace(str.charAt(end - 1))) {\n            end--;\n        }\n    } else if (stripChars.isEmpty()) {\n        return str;\n    } else {\n        while (end != 0 && stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND) {\n            end--;\n        }\n    }\n    return str.substring(0, end);\n}",
        "summary_tokens": [
            "p",
            "strips",
            "any",
            "of",
            "a",
            "set",
            "of",
            "characters",
            "from",
            "the",
            "end",
            "of",
            "a",
            "string"
        ]
    },
    {
        "id": 376,
        "code": "public static String replace(final String text, final String searchString, final String replacement, int max) {\n    if (isAnyEmpty(text, searchString) || replacement == null || max == 0) {\n        return text;\n    }\n    int start = 0;\n    int end = text.indexOf(searchString, start);\n    if (end == INDEX_NOT_FOUND) {\n        return text;\n    }\n    final int replLength = searchString.length();\n    int increase = replacement.length() - replLength;\n    increase = increase < 0 ? 0 : increase;\n    increase *= max < 0 ? 16 : max > 64 ? 64 : max;\n    final StringBuilder buf = new StringBuilder(text.length() + increase);\n    while (end != INDEX_NOT_FOUND) {\n        buf.append(text, start, end).append(replacement);\n        start = end + replLength;\n        if (--max == 0) {\n            break;\n        }\n        end = text.indexOf(searchString, start);\n    }\n    buf.append(text.substring(start));\n    return buf.toString();\n}",
        "summary_tokens": [
            "p",
            "replaces",
            "a",
            "string",
            "with",
            "another",
            "string",
            "inside",
            "a",
            "larger",
            "string",
            "for",
            "the",
            "first",
            "max",
            "values",
            "of",
            "the",
            "search",
            "string"
        ]
    },
    {
        "id": 377,
        "code": "public static boolean isNotBlank(CharSequence cs) {\n    return !isBlank(cs);\n}",
        "summary_tokens": [
            "is",
            "not",
            "blank",
            "string"
        ]
    },
    {
        "id": 378,
        "code": "public static boolean hasText(CharSequence cs) {\n    return !isBlank(cs);\n}",
        "summary_tokens": [
            "check",
            "the",
            "cs",
            "string",
            "whether",
            "contains",
            "non",
            "whitespace",
            "characters"
        ]
    },
    {
        "id": 379,
        "code": "public static boolean isNoneEmpty(final String... ss) {\n    if (ArrayUtils.isEmpty(ss)) {\n        return false;\n    }\n    for (final String s : ss) {\n        if (isEmpty(s)) {\n            return false;\n        }\n    }\n    return true;\n}",
        "summary_tokens": [
            "p",
            "checks",
            "if",
            "the",
            "strings",
            "contain",
            "empty",
            "or",
            "null",
            "elements"
        ]
    },
    {
        "id": 380,
        "code": "public static boolean isAnyEmpty(final String... ss) {\n    return !isNoneEmpty(ss);\n}",
        "summary_tokens": [
            "p",
            "checks",
            "if",
            "the",
            "strings",
            "contain",
            "at",
            "least",
            "on",
            "empty",
            "or",
            "null",
            "element"
        ]
    },
    {
        "id": 381,
        "code": "public static boolean isNotEmpty(String str) {\n    return !isEmpty(str);\n}",
        "summary_tokens": [
            "is",
            "not",
            "empty",
            "string"
        ]
    },
    {
        "id": 382,
        "code": "public static boolean isEquals(String s1, String s2) {\n    if (s1 == null && s2 == null) {\n        return true;\n    }\n    if (s1 == null || s2 == null) {\n        return false;\n    }\n    return s1.equals(s2);\n}",
        "summary_tokens": [
            "if",
            "s",
            "0",
            "is",
            "null",
            "and",
            "s",
            "0",
            "is",
            "null",
            "then",
            "return",
            "true"
        ]
    },
    {
        "id": 383,
        "code": "public static boolean isNumber(String str) {\n    return isNotEmpty(str) && NUM_PATTERN.matcher(str).matches();\n}",
        "summary_tokens": [
            "is",
            "positive",
            "integer",
            "or",
            "zero",
            "string"
        ]
    },
    {
        "id": 384,
        "code": "public static int parseInteger(String str) {\n    return isNumber(str) ? Integer.parseInt(str) : 0;\n}",
        "summary_tokens": [
            "parse",
            "str",
            "to",
            "integer",
            "if",
            "str",
            "is",
            "not",
            "number",
            "or",
            "n",
            "0",
            "then",
            "return",
            "0"
        ]
    },
    {
        "id": 385,
        "code": "public static long parseLong(String str) {\n    return isNumber(str) ? Long.parseLong(str) : 0;\n}",
        "summary_tokens": [
            "parse",
            "str",
            "to",
            "long",
            "if",
            "str",
            "is",
            "not",
            "number",
            "or",
            "n",
            "0",
            "then",
            "return",
            "0"
        ]
    },
    {
        "id": 386,
        "code": "public static boolean isJavaIdentifier(String s) {\n    if (isEmpty(s) || !Character.isJavaIdentifierStart(s.charAt(0))) {\n        return false;\n    }\n    for (int i = 1; i < s.length(); i++) {\n        if (!Character.isJavaIdentifierPart(s.charAt(i))) {\n            return false;\n        }\n    }\n    return true;\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "s",
            "is",
            "a",
            "legal",
            "java",
            "identifier"
        ]
    },
    {
        "id": 387,
        "code": "public static List<String> splitToList(String str, char ch) {\n    if (isEmpty(str)) {\n        return Collections.emptyList();\n    }\n    return splitToList0(str, ch);\n}",
        "summary_tokens": [
            "splits",
            "string",
            "around",
            "matches",
            "of",
            "the",
            "given",
            "character"
        ]
    },
    {
        "id": 388,
        "code": "public static Set<String> splitToSet(String value, char separatorChar, boolean trimElements) {\n    List<String> values = splitToList(value, separatorChar);\n    int size = values.size();\n\n    if (size < 1) { \n        return emptySet();\n    }\n\n    if (!trimElements) { \n        return new LinkedHashSet(values);\n    }\n\n    return unmodifiableSet(values\n        .stream()\n        .map(String::trim)\n        .collect(LinkedHashSet::new, Set::add, Set::addAll));\n}",
        "summary_tokens": [
            "split",
            "the",
            "specified",
            "value",
            "to",
            "be",
            "a",
            "set"
        ]
    },
    {
        "id": 389,
        "code": "public static String join(String[] array, String split) {\n    if (ArrayUtils.isEmpty(array)) {\n        return EMPTY_STRING;\n    }\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < array.length; i++) {\n        if (i > 0) {\n            sb.append(split);\n        }\n        sb.append(array[i]);\n    }\n    return sb.toString();\n}",
        "summary_tokens": [
            "join",
            "string",
            "like",
            "javascript"
        ]
    },
    {
        "id": 390,
        "code": "private static Map<String, String> parseKeyValuePair(String str, String itemSeparator) {\n    String[] tmp = str.split(itemSeparator);\n    Map<String, String> map = new HashMap<String, String>(tmp.length);\n    for (int i = 0; i < tmp.length; i++) {\n        Matcher matcher = KVP_PATTERN.matcher(tmp[i]);\n        if (!matcher.matches()) {\n            continue;\n        }\n        map.put(matcher.group(1), matcher.group(2));\n    }\n    return map;\n}",
        "summary_tokens": [
            "parse",
            "key",
            "value",
            "pair"
        ]
    },
    {
        "id": 391,
        "code": "public static Map<String, String> parseQueryString(String qs) {\n    if (isEmpty(qs)) {\n        return new HashMap<String, String>();\n    }\n    return parseKeyValuePair(qs, \"\\\\&\");\n}",
        "summary_tokens": [
            "parse",
            "query",
            "string",
            "to",
            "parameters"
        ]
    },
    {
        "id": 392,
        "code": "public static String snakeToSplitName(String snakeName, String split) {\n    String lowerCase = snakeName.toLowerCase();\n    if (isSnakeCase(snakeName)) {\n        return replace(lowerCase, \"_\", split);\n    }\n    return snakeName;\n}",
        "summary_tokens": [
            "convert",
            "snake",
            "case",
            "or",
            "snake",
            "case",
            "to",
            "kebab",
            "case"
        ]
    },
    {
        "id": 393,
        "code": "public static String convertToSplitName(String str, String split) {\n    if (isSnakeCase(str)) {\n        return snakeToSplitName(str, split);\n    } else {\n        return camelToSplitName(str, split);\n    }\n}",
        "summary_tokens": [
            "convert",
            "camel",
            "case",
            "or",
            "snake",
            "case",
            "snake",
            "case",
            "to",
            "kebab",
            "case"
        ]
    },
    {
        "id": 394,
        "code": "public static Map<String, String> parseParameters(String rawParameters) {\n    if (StringUtils.isBlank(rawParameters)) {\n        return Collections.emptyMap();\n    }\n    Matcher matcher = PARAMETERS_PATTERN.matcher(rawParameters);\n    if (!matcher.matches()) {\n        return Collections.emptyMap();\n    }\n\n    String pairs = matcher.group(1);\n    String[] pairArr = pairs.split(\"\\\\s*,\\\\s*\");\n\n    Map<String, String> parameters = new HashMap<>();\n    for (String pair : pairArr) {\n        Matcher pairMatcher = PAIR_PARAMETERS_PATTERN.matcher(pair);\n        if (pairMatcher.matches()) {\n            parameters.put(pairMatcher.group(1), pairMatcher.group(2));\n        }\n    }\n    return parameters;\n}",
        "summary_tokens": [
            "decode",
            "parameters",
            "string",
            "to",
            "map"
        ]
    },
    {
        "id": 395,
        "code": "public static String encodeParameters(Map<String, String> params) {\n    if (params == null || params.isEmpty()) {\n        return null;\n    }\n\n    StringBuilder sb = new StringBuilder();\n    sb.append('[');\n    params.forEach((key, value) -> {\n            \n        if (hasText(value)) {\n            sb.append('{').append(key).append(':').append(value).append(\"},\");\n        }\n    });\n        \n    if (sb.charAt(sb.length() - 1) == ',') {\n        sb.deleteCharAt(sb.length() - 1);\n    }\n    sb.append(']');\n    return sb.toString();\n}",
        "summary_tokens": [
            "encode",
            "parameters",
            "map",
            "to",
            "string",
            "like",
            "a",
            "b",
            "c",
            "d"
        ]
    },
    {
        "id": 396,
        "code": "public static byte decodeHexByte(CharSequence s, int pos) {\n    int hi = decodeHexNibble(s.charAt(pos));\n    int lo = decodeHexNibble(s.charAt(pos + 1));\n    if (hi == -1 || lo == -1) {\n        throw new IllegalArgumentException(String.format(\n            \"invalid hex byte '%s' at index %d of '%s'\", s.subSequence(pos, pos + 2), pos, s));\n    }\n    return (byte) ((hi << 4) + lo);\n}",
        "summary_tokens": [
            "decode",
            "a",
            "0",
            "digit",
            "hex",
            "byte",
            "from",
            "within",
            "a",
            "string"
        ]
    },
    {
        "id": 397,
        "code": "public static String toCommaDelimitedString(String one, String... others) {\n    String another = arrayToDelimitedString(others, COMMA_SEPARATOR);\n    return isEmpty(another) ? one : one + COMMA_SEPARATOR + another;\n}",
        "summary_tokens": [
            "create",
            "the",
            "common",
            "delimited",
            "string",
            "by",
            "one",
            "or",
            "more",
            "string",
            "members"
        ]
    },
    {
        "id": 398,
        "code": "public static boolean startsWithIgnoreCase(String str, String prefix) {\n    if (str == null || prefix == null || str.length() < prefix.length()) {\n        return false;\n    }\n        \n    return str.regionMatches(true, 0, prefix, 0, prefix.length());\n}",
        "summary_tokens": [
            "test",
            "str",
            "whether",
            "starts",
            "with",
            "the",
            "prefix",
            "ignore",
            "case"
        ]
    },
    {
        "id": 399,
        "code": "static List<ParameterizedType> getGenericTypes(Type type, Predicate<ParameterizedType>... typeFilters) {\n\n    Class<?> rawClass = getRawClass(type);\n\n    if (rawClass == null) {\n        return emptyList();\n    }\n\n    List<Type> genericTypes = new LinkedList<>();\n\n    genericTypes.add(rawClass.getGenericSuperclass());\n    genericTypes.addAll(asList(rawClass.getGenericInterfaces()));\n\n    return unmodifiableList(\n            filterList(genericTypes, TypeUtils::isParameterizedType)\n                    .stream()\n                    .map(ParameterizedType.class::cast)\n                    .filter(and(typeFilters))\n                    .collect(toList())\n    );\n}",
        "summary_tokens": [
            "get",
            "the",
            "specified",
            "types",
            "generic",
            "types",
            "including",
            "super",
            "classes",
            "and",
            "interfaces",
            "that",
            "are",
            "assignable",
            "from",
            "parameterized",
            "type",
            "interface"
        ]
    },
    {
        "id": 400,
        "code": "static List<ParameterizedType> getAllGenericTypes(Type type, Predicate<ParameterizedType>... typeFilters) {\n    List<ParameterizedType> allGenericTypes = new LinkedList<>();\n        \n    allGenericTypes.addAll(getAllGenericSuperClasses(type, typeFilters));\n        \n    allGenericTypes.addAll(getAllGenericInterfaces(type, typeFilters));\n        \n    return unmodifiableList(allGenericTypes);\n}",
        "summary_tokens": [
            "get",
            "all",
            "generic",
            "types",
            "including",
            "super",
            "classes",
            "and",
            "interfaces",
            "that",
            "are",
            "assignable",
            "from",
            "parameterized",
            "type",
            "interface"
        ]
    },
    {
        "id": 401,
        "code": "static List<ParameterizedType> getAllGenericSuperClasses(Type type, Predicate<ParameterizedType>... typeFilters) {\n\n    Class<?> rawClass = getRawClass(type);\n\n    if (rawClass == null || rawClass.isInterface()) {\n        return emptyList();\n    }\n\n    List<Class<?>> allTypes = new LinkedList<>();\n        \n    allTypes.add(rawClass);\n        \n    allTypes.addAll(getAllSuperClasses(rawClass, NON_OBJECT_TYPE_FILTER));\n\n    List<ParameterizedType> allGenericSuperClasses = allTypes\n            .stream()\n            .map(Class::getGenericSuperclass)\n            .filter(TypeUtils::isParameterizedType)\n            .map(ParameterizedType.class::cast)\n            .collect(Collectors.toList());\n\n    return unmodifiableList(filterAll(allGenericSuperClasses, typeFilters));\n}",
        "summary_tokens": [
            "get",
            "all",
            "generic",
            "super",
            "classes",
            "that",
            "are",
            "assignable",
            "from",
            "parameterized",
            "type",
            "interface"
        ]
    },
    {
        "id": 402,
        "code": "static List<ParameterizedType> getAllGenericInterfaces(Type type, Predicate<ParameterizedType>... typeFilters) {\n\n    Class<?> rawClass = getRawClass(type);\n\n    if (rawClass == null) {\n        return emptyList();\n    }\n\n    List<Class<?>> allTypes = new LinkedList<>();\n        \n    allTypes.add(rawClass);\n        \n    allTypes.addAll(getAllSuperClasses(rawClass, NON_OBJECT_TYPE_FILTER));\n        \n    allTypes.addAll(getAllInterfaces(rawClass));\n\n    List<ParameterizedType> allGenericInterfaces = allTypes\n            .stream()\n            .map(Class::getGenericInterfaces)\n            .map(Arrays::asList)\n            .flatMap(Collection::stream)\n            .filter(TypeUtils::isParameterizedType)\n            .map(ParameterizedType.class::cast)\n            .collect(toList());\n\n    return unmodifiableList(filterAll(allGenericInterfaces, typeFilters));\n}",
        "summary_tokens": [
            "get",
            "all",
            "generic",
            "interfaces",
            "that",
            "are",
            "assignable",
            "from",
            "parameterized",
            "type",
            "interface"
        ]
    },
    {
        "id": 403,
        "code": "public static boolean hasServiceDiscoveryRegistryTypeKey(Map<String, String> parameters) {\n    if (CollectionUtils.isEmptyMap(parameters)) {\n        return false;\n    }\n    return SERVICE_REGISTRY_TYPE.equals(parameters.get(REGISTRY_TYPE_KEY));\n}",
        "summary_tokens": [
            "the",
            "specified",
            "parameters",
            "of",
            "url",
            "is",
            "service",
            "discovery",
            "registry",
            "type",
            "or",
            "not"
        ]
    },
    {
        "id": 404,
        "code": "static boolean isItemMatch(String pattern, String value) {\n    if (StringUtils.isEmpty(pattern)) {\n        return value == null;\n    } else {\n        return \"*\".equals(pattern) || pattern.equals(value);\n    }\n}",
        "summary_tokens": [
            "check",
            "if",
            "the",
            "given",
            "value",
            "matches",
            "the",
            "given",
            "pattern"
        ]
    },
    {
        "id": 405,
        "code": "public static String[] parseServiceKey(String serviceKey) {\n    String[] arr = new String[3];\n    int i = serviceKey.indexOf('/');\n    if (i > 0) {\n        arr[0] = serviceKey.substring(0, i);\n        serviceKey = serviceKey.substring(i + 1);\n    }\n\n    int j = serviceKey.indexOf(':');\n    if (j > 0) {\n        arr[2] = serviceKey.substring(j + 1);\n        serviceKey = serviceKey.substring(0, j);\n    }\n    arr[1] = serviceKey;\n    return arr;\n}",
        "summary_tokens": [
            "service",
            "key",
            "group",
            "interface",
            "name",
            "version",
            "group",
            "interface",
            "name",
            "version"
        ]
    },
    {
        "id": 406,
        "code": "public static URL valueOf(String url) {\n    if (url == null || (url = url.trim()).length() == 0) {\n        throw new IllegalArgumentException(\"url == null\");\n    }\n    String protocol = null;\n    String username = null;\n    String password = null;\n    String host = null;\n    int port = 0;\n    String path = null;\n    Map<String, String> parameters = null;\n    int i = url.indexOf('?'); \n    if (i >= 0) {\n        String[] parts = url.substring(i + 1).split(\"&\");\n        parameters = new HashMap<>();\n        for (String part : parts) {\n            part = part.trim();\n            if (part.length() > 0) {\n                int j = part.indexOf('=');\n                if (j >= 0) {\n                    String key = part.substring(0, j);\n                    String value = part.substring(j + 1);\n                    parameters.put(key, value);\n                        \n                    if (key.startsWith(DEFAULT_KEY_PREFIX)) {\n                        parameters.putIfAbsent(key.substring(DEFAULT_KEY_PREFIX.length()), value);\n                    }\n                } else {\n                    parameters.put(part, part);\n                }\n            }\n        }\n        url = url.substring(0, i);\n    }\n    i = url.indexOf(\"://\");\n    if (i >= 0) {\n        if (i == 0) {\n            throw new IllegalStateException(\"url missing protocol: \\\"\" + url + \"\\\"\");\n        }\n        protocol = url.substring(0, i);\n        url = url.substring(i + 3);\n    } else {\n            \n        i = url.indexOf(\":/\");\n        if (i >= 0) {\n            if (i == 0) {\n                throw new IllegalStateException(\"url missing protocol: \\\"\" + url + \"\\\"\");\n            }\n            protocol = url.substring(0, i);\n            url = url.substring(i + 1);\n        }\n    }\n\n    i = url.indexOf('/');\n    if (i >= 0) {\n        path = url.substring(i + 1);\n        url = url.substring(0, i);\n    }\n    i = url.lastIndexOf('@');\n    if (i >= 0) {\n        username = url.substring(0, i);\n        int j = username.indexOf(':');\n        if (j >= 0) {\n            password = username.substring(j + 1);\n            username = username.substring(0, j);\n        }\n        url = url.substring(i + 1);\n    }\n    i = url.lastIndexOf(':');\n    if (i >= 0 && i < url.length() - 1) {\n        if (url.lastIndexOf('%') > i) {\n                \n                \n                \n                \n        } else {\n            port = Integer.parseInt(url.substring(i + 1));\n            url = url.substring(0, i);\n        }\n    }\n    if (url.length() > 0) {\n        host = url;\n    }\n\n    return new ServiceConfigURL(protocol, username, password, host, port, path, parameters);\n}",
        "summary_tokens": [
            "notice",
            "this",
            "method",
            "allocate",
            "too",
            "much",
            "objects",
            "we",
            "can",
            "use",
            "urlstr",
            "parser",
            "parse",
            "decoded",
            "str",
            "string",
            "instead"
        ]
    },
    {
        "id": 407,
        "code": "public static void appendAttributes(Map<String, String> parameters, Object config) {\n    appendParameters0(parameters, config, null, false);\n}",
        "summary_tokens": [
            "put",
            "attributes",
            "of",
            "specify",
            "config",
            "into",
            "parameters",
            "argument"
        ]
    },
    {
        "id": 408,
        "code": "protected static Map<String, String> convert(Map<String, String> parameters, String prefix) {\n    if (parameters == null || parameters.isEmpty()) {\n        return Collections.emptyMap();\n    }\n\n    Map<String, String> result = new HashMap<>();\n    String pre = (StringUtils.isNotEmpty(prefix) ? prefix + \".\" : \"\");\n    for (Map.Entry<String, String> entry : parameters.entrySet()) {\n        String key = entry.getKey();\n        String value = entry.getValue();\n        result.put(pre + key, value);\n            \n        if (Arrays.binarySearch(Constants.DOT_COMPATIBLE_KEYS, key) >= 0) {\n            result.put(pre + key.replace('-', '.'), value);\n        }\n    }\n    return result;\n}",
        "summary_tokens": [
            "parameters",
            "the",
            "raw",
            "parameters",
            "prefix",
            "the",
            "prefix",
            "the",
            "parameters",
            "whose",
            "raw",
            "key",
            "will",
            "replace",
            "to"
        ]
    },
    {
        "id": 409,
        "code": "protected void postProcessAfterScopeModelChanged(ScopeModel oldScopeModel, ScopeModel newScopeModel) {\n        \n\n\n\n}",
        "summary_tokens": [
            "subclass",
            "should",
            "override",
            "this",
            "method",
            "to",
            "initialize",
            "its",
            "spi",
            "extensions",
            "and",
            "change",
            "referenced",
            "config",
            "s",
            "scope",
            "model"
        ]
    },
    {
        "id": 410,
        "code": "protected void appendAnnotation(Class<?> annotationClass, Object annotation) {\n    Method[] methods = annotationClass.getMethods();\n    for (Method method : methods) {\n        if (method.getDeclaringClass() != Object.class\n            && method.getDeclaringClass() != Annotation.class\n            && method.getReturnType() != void.class\n            && method.getParameterTypes().length == 0\n            && Modifier.isPublic(method.getModifiers())\n            && !Modifier.isStatic(method.getModifiers())) {\n            try {\n                String property = method.getName();\n                if (\"interfaceClass\".equals(property) || \"interfaceName\".equals(property)) {\n                    property = \"interface\";\n                }\n                String setter = calculatePropertyToSetter(property);\n                Object value = method.invoke(annotation);\n                if (value != null && !value.equals(method.getDefaultValue())) {\n                    Class<?> parameterType = ReflectUtils.getBoxedClass(method.getReturnType());\n                    if (\"filter\".equals(property) || \"listener\".equals(property)) {\n                        parameterType = String.class;\n                        value = StringUtils.join((String[]) value, \",\");\n                    } else if (\"parameters\".equals(property)) {\n                        parameterType = Map.class;\n                        value = CollectionUtils.toStringMap((String[]) value);\n                    }\n                    try {\n                        Method setterMethod = getClass().getMethod(setter, parameterType);\n                        setterMethod.invoke(this, value);\n                    } catch (NoSuchMethodException e) {\n                            \n                    }\n                }\n            } catch (Throwable e) {\n                logger.error(e.getMessage(), e);\n            }\n        }\n    }\n}",
        "summary_tokens": [
            "copy",
            "attributes",
            "from",
            "annotation"
        ]
    },
    {
        "id": 411,
        "code": "public Map<String, String> getMetaData() {\n    return getMetaData(null);\n}",
        "summary_tokens": [
            "p",
            "b",
            "the",
            "new",
            "instance",
            "of",
            "the",
            "abstract",
            "config",
            "subclass",
            "should",
            "return",
            "empty",
            "metadata"
        ]
    },
    {
        "id": 412,
        "code": "public void refresh() {\n    try {\n            \n        preProcessRefresh();\n\n        Environment environment = getScopeModel().getModelEnvironment();\n        List<Map<String, String>> configurationMaps = environment.getConfigurationMaps();\n\n            \n        String preferredPrefix = null;\n        List<String> prefixes = getPrefixes();\n        for (String prefix : prefixes) {\n            if (ConfigurationUtils.hasSubProperties(configurationMaps, prefix)) {\n                preferredPrefix = prefix;\n                break;\n            }\n        }\n        if (preferredPrefix == null) {\n            preferredPrefix = prefixes.get(0);\n        }\n            \n        Collection<Map<String, String>> instanceConfigMaps = environment.getConfigurationMaps(this, preferredPrefix);\n        Map<String, String> subProperties = ConfigurationUtils.getSubProperties(instanceConfigMaps, preferredPrefix);\n        InmemoryConfiguration subPropsConfiguration = new InmemoryConfiguration(subProperties);\n\n        if (logger.isDebugEnabled()) {\n            String idOrName = \"\";\n            if (StringUtils.hasText(this.getId())) {\n                idOrName = \"[id=\" + this.getId() + \"]\";\n            } else {\n                String name = ReflectUtils.getProperty(this, \"getName\");\n                if (StringUtils.hasText(name)) {\n                    idOrName = \"[name=\" + name + \"]\";\n                }\n            }\n            logger.debug(\"Refreshing \" + this.getClass().getSimpleName() + idOrName +\n                \" with prefix [\" + preferredPrefix +\n                \"], extracted props: \" + subProperties);\n        }\n\n        assignProperties(this, environment, subProperties, subPropsConfiguration);\n\n            \n        processExtraRefresh(preferredPrefix, subPropsConfiguration);\n\n    } catch (Exception e) {\n        logger.error(\"Failed to override field value of config bean: \" + this, e);\n        throw new IllegalStateException(\"Failed to override field value of config bean: \" + this, e);\n    }\n\n    postProcessRefresh();\n    refreshed.set(true);\n}",
        "summary_tokens": [
            "dubbo",
            "config",
            "property",
            "override"
        ]
    },
    {
        "id": 413,
        "code": "protected void checkDefault() {\n}",
        "summary_tokens": [
            "check",
            "and",
            "set",
            "default",
            "value",
            "for",
            "some",
            "fields"
        ]
    },
    {
        "id": 414,
        "code": "public boolean isValid() {\n    return true;\n}",
        "summary_tokens": [
            "fixme",
            "check",
            "required",
            "true",
            "and",
            "any",
            "conditions",
            "that",
            "need",
            "to",
            "match"
        ]
    },
    {
        "id": 415,
        "code": "protected List<Method> computeAttributedMethods() {\n    Class<? extends AbstractConfig> cls = this.getClass();\n    BeanInfo beanInfo = getBeanInfo(cls);\n    List<Method> methods = new ArrayList<>(beanInfo.getMethodDescriptors().length);\n    for (MethodDescriptor methodDescriptor : beanInfo.getMethodDescriptors()) {\n        Method method = methodDescriptor.getMethod();\n        if (MethodUtils.isGetter(method) || isParametersGetter(method)) {\n                \n            Parameter parameter = method.getAnnotation(Parameter.class);\n            if (parameter != null && !parameter.attribute()) {\n                continue;\n            }\n            String propertyName = calculateAttributeFromGetter(method.getName());\n                \n            if (!isWritableProperty(beanInfo, propertyName)) {\n                continue;\n            }\n            methods.add(method);\n        }\n    }\n    return methods;\n}",
        "summary_tokens": [
            "compute",
            "attributed",
            "getter",
            "methods",
            "subclass",
            "can",
            "override",
            "this",
            "method",
            "to",
            "add",
            "remove",
            "attributed",
            "methods"
        ]
    },
    {
        "id": 416,
        "code": "public void setMock(Object mock) {\n    if (mock == null) {\n        return;\n    }\n    this.setMock(String.valueOf(mock));\n}",
        "summary_tokens": [
            "set",
            "the",
            "property",
            "mock"
        ]
    },
    {
        "id": 417,
        "code": "public Boolean isGeneric() {\n    return this.generic != null ? ProtocolUtils.isGeneric(generic) : null;\n}",
        "summary_tokens": [
            "replace",
            "to",
            "abstract",
            "reference",
            "config",
            "get",
            "generic"
        ]
    },
    {
        "id": 418,
        "code": "public void setGeneric(Boolean generic) {\n    if (generic != null) {\n        this.generic = generic.toString();\n    }\n}",
        "summary_tokens": [
            "replace",
            "to",
            "abstract",
            "reference",
            "config",
            "set",
            "generic",
            "string"
        ]
    },
    {
        "id": 419,
        "code": "public Boolean isInjvm() {\n    return injvm;\n}",
        "summary_tokens": [
            "instead",
            "use",
            "the",
            "parameter",
            "b",
            "scope",
            "to",
            "judge",
            "if",
            "it",
            "s",
            "in",
            "jvm",
            "scope",
            "local"
        ]
    },
    {
        "id": 420,
        "code": "public void setInjvm(Boolean injvm) {\n    this.injvm = injvm;\n}",
        "summary_tokens": [
            "injvm",
            "instead",
            "use",
            "the",
            "parameter",
            "b",
            "scope",
            "b",
            "to",
            "judge",
            "if",
            "it",
            "s",
            "in",
            "jvm",
            "scope",
            "local"
        ]
    },
    {
        "id": 421,
        "code": "public Boolean getQosEnableCompatible() {\n    return getQosEnable();\n}",
        "summary_tokens": [
            "the",
            "format",
            "is",
            "the",
            "same",
            "as",
            "the",
            "springboot",
            "including",
            "get",
            "qos",
            "enable",
            "compatible",
            "get",
            "qos",
            "port",
            "compatible",
            "get",
            "qos",
            "accept",
            "foreign",
            "ip",
            "compatible"
        ]
    },
    {
        "id": 422,
        "code": "public void setReferBackground(Boolean referBackground) {\n    this.referBackground = referBackground;\n}",
        "summary_tokens": [
            "whether",
            "refer",
            "should",
            "run",
            "in",
            "background",
            "or",
            "not"
        ]
    },
    {
        "id": 423,
        "code": "public static List<MethodConfig> constructMethodConfig(Method[] methods) {\n    if (methods != null && methods.length != 0) {\n        List<MethodConfig> methodConfigs = new ArrayList<>(methods.length);\n        for (int i = 0; i < methods.length; i++) {\n            MethodConfig methodConfig = new MethodConfig(methods[i]);\n            methodConfigs.add(methodConfig);\n        }\n        return methodConfigs;\n    }\n    return Collections.emptyList();\n}",
        "summary_tokens": [
            "todo",
            "remove",
            "construct",
            "method",
            "config"
        ]
    },
    {
        "id": 424,
        "code": "protected void checkDefault() {\n    super.checkDefault();\n\n        \n        \n    if (isReturn() == null) {\n        setReturn(true);\n    }\n\n        \n    if (getSent() == null) {\n        setSent(true);\n    }\n}",
        "summary_tokens": [
            "set",
            "default",
            "field",
            "values",
            "of",
            "method",
            "config"
        ]
    },
    {
        "id": 425,
        "code": "public void setBackground(Boolean background) {\n    this.background = background;\n}",
        "summary_tokens": [
            "whether",
            "start",
            "module",
            "in",
            "background"
        ]
    },
    {
        "id": 426,
        "code": "public String getDispather() {\n    return getDispatcher();\n}",
        "summary_tokens": [
            "typo",
            "switch",
            "to",
            "use",
            "get",
            "dispatcher"
        ]
    },
    {
        "id": 427,
        "code": "public void setDispather(String dispather) {\n    setDispatcher(dispather);\n}",
        "summary_tokens": [
            "typo",
            "switch",
            "to",
            "use",
            "get",
            "dispatcher"
        ]
    },
    {
        "id": 428,
        "code": "public String getDispather() {\n    return getDispatcher();\n}",
        "summary_tokens": [
            "typo",
            "switch",
            "to",
            "use",
            "get",
            "dispatcher"
        ]
    },
    {
        "id": 429,
        "code": "public void setDispather(String dispather) {\n    setDispatcher(dispather);\n}",
        "summary_tokens": [
            "typo",
            "switch",
            "to",
            "use",
            "get",
            "dispatcher"
        ]
    },
    {
        "id": 430,
        "code": "public void setExportBackground(Boolean exportBackground) {\n    this.exportBackground = exportBackground;\n}",
        "summary_tokens": [
            "whether",
            "export",
            "should",
            "run",
            "in",
            "background",
            "or",
            "not"
        ]
    },
    {
        "id": 431,
        "code": "public Class<?> getServiceInterfaceClass() {\n    Class<?> actualInterface = interfaceClass;\n    if (interfaceClass == GenericService.class) {\n        try {\n            if (getInterfaceClassLoader() != null) {\n                actualInterface = Class.forName(interfaceName, false, getInterfaceClassLoader());\n            } else {\n                actualInterface = Class.forName(interfaceName);\n            }\n        } catch (ClassNotFoundException e) {\n            return null;\n        }\n    }\n    return actualInterface;\n}",
        "summary_tokens": [
            "get",
            "service",
            "interface",
            "class",
            "of",
            "this",
            "reference"
        ]
    },
    {
        "id": 432,
        "code": "public Class<?> getInterfaceClass() {\n    if (interfaceClass != null) {\n        return interfaceClass;\n    }\n\n    String generic = getGeneric();\n    if (StringUtils.isBlank(generic) && getConsumer() != null) {\n        generic = getConsumer().getGeneric();\n    }\n    if (getInterfaceClassLoader() != null) {\n        interfaceClass = determineInterfaceClass(generic, interfaceName, getInterfaceClassLoader());\n    } else {\n        interfaceClass = determineInterfaceClass(generic, interfaceName);\n    }\n    return interfaceClass;\n}",
        "summary_tokens": [
            "get",
            "proxy",
            "interface",
            "class",
            "of",
            "this",
            "reference"
        ]
    },
    {
        "id": 433,
        "code": "public static Class<?> determineInterfaceClass(String generic, String interfaceName) {\n    return determineInterfaceClass(generic, interfaceName, ClassUtils.getClassLoader());\n}",
        "summary_tokens": [
            "determine",
            "the",
            "interface",
            "of",
            "the",
            "proxy",
            "class",
            "generic",
            "interface",
            "name"
        ]
    },
    {
        "id": 434,
        "code": "public final <T extends AbstractConfig> T addConfig(AbstractConfig config) {\n    if (config == null) {\n        return null;\n    }\n        \n    if (!isSupportConfigType(config.getClass())) {\n        throw new IllegalArgumentException(\"Unsupported config type: \" + config);\n    }\n\n    if (config.getScopeModel() != scopeModel) {\n        config.setScopeModel(scopeModel);\n    }\n\n    Map<String, AbstractConfig> configsMap = configsCache.computeIfAbsent(getTagName(config.getClass()), type -> new ConcurrentHashMap<>());\n\n        \n    if (!(config instanceof ReferenceConfigBase || config instanceof ServiceConfigBase)) {\n        for (AbstractConfig value : configsMap.values()) {\n            if (value.equals(config)) {\n                return (T) value;\n            }\n        }\n    }\n\n        \n    synchronized (configsMap) {\n        return (T) addIfAbsent(config, configsMap);\n    }\n}",
        "summary_tokens": [
            "add",
            "the",
            "dubbo",
            "abstract",
            "config",
            "config"
        ]
    },
    {
        "id": 435,
        "code": "protected <C extends AbstractConfig> C getConfigById(String configType, String id) {\n    return (C) getConfigsMap(configType).get(id);\n}",
        "summary_tokens": [
            "get",
            "config",
            "by",
            "id"
        ]
    },
    {
        "id": 436,
        "code": "public <T extends AbstractConfig> Optional<T> getConfig(Class<T> cls, String idOrName) {\n    T config = getConfigById(getTagName(cls), idOrName);\n    if (config == null) {\n        config = getConfigByName(cls, idOrName);\n    }\n    return ofNullable(config);\n}",
        "summary_tokens": [
            "get",
            "config",
            "instance",
            "by",
            "id",
            "or",
            "by",
            "name"
        ]
    },
    {
        "id": 437,
        "code": "protected <C extends AbstractConfig> C getConfigByName(Class<? extends C> cls, String name) {\n    Map<String, ? extends C> configsMap = getConfigsMap(cls);\n    if (configsMap.isEmpty()) {\n        return null;\n    }\n        \n    if (ReflectUtils.hasMethod(cls, CONFIG_NAME_READ_METHOD)) {\n        List<C> list = configsMap.values().stream()\n            .filter(cfg -> name.equals(getConfigName(cfg)))\n            .collect(Collectors.toList());\n        if (list.size() > 1) {\n            throw new IllegalStateException(\"Found more than one config by name: \" + name +\n                \", instances: \" + list + \". Please remove redundant configs or get config by id.\");\n        } else if (list.size() == 1) {\n            return list.get(0);\n        }\n    }\n    return null;\n}",
        "summary_tokens": [
            "get",
            "config",
            "by",
            "name",
            "if",
            "existed"
        ]
    },
    {
        "id": 438,
        "code": "private Set<String> getConfigIdsFromProps(Class<? extends AbstractConfig> clazz) {\n    String prefix = CommonConstants.DUBBO + \".\" + AbstractConfig.getPluralTagName(clazz) + \".\";\n    return ConfigurationUtils.getSubIds(environment.getConfigurationMaps(), prefix);\n}",
        "summary_tokens": [
            "search",
            "props",
            "and",
            "extract",
            "config",
            "ids",
            "of",
            "specify",
            "type"
        ]
    },
    {
        "id": 439,
        "code": "protected <T extends AbstractConfig> boolean isNeedValidation(T config) {\n    if (config instanceof MetadataReportConfig) {\n        return false;\n    }\n    return true;\n}",
        "summary_tokens": [
            "the",
            "component",
            "configuration",
            "that",
            "does",
            "not",
            "affect",
            "the",
            "main",
            "process",
            "does",
            "not",
            "need",
            "to",
            "be",
            "verified"
        ]
    },
    {
        "id": 440,
        "code": "protected <T extends AbstractConfig> boolean isRequired(Class<T> clazz) {\n    if (clazz == RegistryConfig.class ||\n        clazz == MetadataReportConfig.class ||\n        clazz == MonitorConfig.class ||\n        clazz == MetricsConfig.class) {\n        return false;\n    }\n    return true;\n}",
        "summary_tokens": [
            "the",
            "configuration",
            "that",
            "does",
            "not",
            "affect",
            "the",
            "main",
            "process",
            "is",
            "not",
            "necessary"
        ]
    },
    {
        "id": 441,
        "code": "public boolean removeConfig(AbstractConfig config) {\n    if (config == null) {\n        return false;\n    }\n\n    Map<String, AbstractConfig> configs = configsCache.get(getTagName(config.getClass()));\n    if (CollectionUtils.isNotEmptyMap(configs)) {\n            \n        synchronized (configs) {\n            return removeIfAbsent(config, configs);\n        }\n    }\n    return false;\n}",
        "summary_tokens": [
            "in",
            "some",
            "scenario",
            "we",
            "may",
            "need",
            "to",
            "add",
            "and",
            "remove",
            "service",
            "config",
            "or",
            "reference",
            "config",
            "dynamically"
        ]
    },
    {
        "id": 442,
        "code": "public Optional<ProviderConfig> getDefaultProvider() {\n    List<ProviderConfig> providerConfigs = getDefaultConfigs(getConfigsMap(getTagName(ProviderConfig.class)));\n    if (CollectionUtils.isNotEmpty(providerConfigs)) {\n        return Optional.of(providerConfigs.get(0));\n    }\n    return Optional.empty();\n}",
        "summary_tokens": [
            "only",
            "allows",
            "one",
            "default",
            "provider",
            "config"
        ]
    },
    {
        "id": 443,
        "code": "public Optional<ConsumerConfig> getDefaultConsumer() {\n    List<ConsumerConfig> consumerConfigs = getDefaultConfigs(getConfigsMap(getTagName(ConsumerConfig.class)));\n    if (CollectionUtils.isNotEmpty(consumerConfigs)) {\n        return Optional.of(consumerConfigs.get(0));\n    }\n    return Optional.empty();\n}",
        "summary_tokens": [
            "only",
            "allows",
            "one",
            "default",
            "consumer",
            "config"
        ]
    },
    {
        "id": 444,
        "code": "private AbstractInterfaceConfig findDuplicatedInterfaceConfig(AbstractInterfaceConfig config) {\n    String uniqueServiceName;\n    Map<String, AbstractInterfaceConfig> configCache;\n    if (config instanceof ReferenceConfigBase) {\n        return null;\n    } else if (config instanceof ServiceConfigBase) {\n        ServiceConfigBase serviceConfig = (ServiceConfigBase) config;\n        uniqueServiceName = serviceConfig.getUniqueServiceName();\n        configCache = serviceConfigCache;\n    } else {\n        throw new IllegalArgumentException(\"Illegal type of parameter 'config' : \" + config.getClass().getName());\n    }\n\n    AbstractInterfaceConfig prevConfig = configCache.putIfAbsent(uniqueServiceName, config);\n    if (prevConfig != null) {\n        if (prevConfig == config) {\n            return prevConfig;\n        }\n\n        if (prevConfig.equals(config)) {\n                \n            if (logger.isWarnEnabled() && duplicatedConfigs.add(config)) {\n                logger.warn(\"Ignore duplicated and equal config: \" + config);\n            }\n            return prevConfig;\n        }\n\n        String configType = config.getClass().getSimpleName();\n        String msg = \"Found multiple \" + configType + \"s with unique service name [\" +\n            uniqueServiceName + \"], previous: \" + prevConfig + \", later: \" + config + \". \" +\n            \"There can only be one instance of \" + configType + \" with the same triple (group, interface, version). \" +\n            \"If multiple instances are required for the same interface, please use a different group or version.\";\n\n        if (logger.isWarnEnabled() && duplicatedConfigs.add(config)) {\n            logger.warn(msg);\n        }\n        if (!this.ignoreDuplicatedInterface) {\n            throw new IllegalStateException(msg);\n        }\n    }\n    return prevConfig;\n}",
        "summary_tokens": [
            "check",
            "duplicated",
            "reference",
            "config",
            "service",
            "config"
        ]
    },
    {
        "id": 445,
        "code": "public MethodDefinition build(Method method) {\n\n    MethodDefinition md = new MethodDefinition();\n    md.setName(method.getName());\n\n        \n    Class<?>[] paramTypes = method.getParameterTypes();\n    Type[] genericParamTypes = method.getGenericParameterTypes();\n\n    int paramSize = paramTypes.length;\n    String[] parameterTypes = new String[paramSize];\n    List<TypeDefinition> parameters = new ArrayList<>(paramSize);\n    for (int i = 0; i < paramSize; i++) {\n        TypeDefinition parameter = builder.build(genericParamTypes[i], paramTypes[i]);\n        parameterTypes[i] = parameter.getType();\n        parameters.add(parameter);\n    }\n\n    md.setParameterTypes(parameterTypes);\n    md.setParameters(parameters);\n\n        \n    TypeDefinition td = builder.build(method.getGenericReturnType(), method.getReturnType());\n    md.setReturnType(td.getType());\n\n    return md;\n}",
        "summary_tokens": [
            "build",
            "the",
            "instance",
            "of",
            "method",
            "definition"
        ]
    },
    {
        "id": 446,
        "code": "public static ServiceDefinition build(final Class<?> interfaceClass) {\n    ServiceDefinition sd = new ServiceDefinition();\n    build(sd, interfaceClass);\n    return sd;\n}",
        "summary_tokens": [
            "describe",
            "a",
            "java",
            "interface",
            "in",
            "service",
            "definition"
        ]
    },
    {
        "id": 447,
        "code": "public static String schema(final Class<?> clazz) {\n    ServiceDefinition sd = build(clazz);\n    return JsonUtils.getJson().toJson(sd);\n}",
        "summary_tokens": [
            "describe",
            "a",
            "java",
            "interface",
            "in",
            "json",
            "schema"
        ]
    },
    {
        "id": 448,
        "code": "public static String[] formatTypes(String[] types) {\n    String[] newTypes = new String[types.length];\n    for (int i = 0; i < types.length; i++) {\n        newTypes[i] = formatType(types[i]);\n    }\n    return newTypes;\n}",
        "summary_tokens": [
            "format",
            "the",
            "string",
            "array",
            "presenting",
            "java",
            "types"
        ]
    },
    {
        "id": 449,
        "code": "public static String formatType(String type) {\n    if (isGenericType(type)) {\n        return formatGenericType(type);\n    }\n    return type;\n}",
        "summary_tokens": [
            "format",
            "the",
            "string",
            "presenting",
            "java",
            "type"
        ]
    },
    {
        "id": 450,
        "code": "private static String formatGenericType(String type) {\n    return replace(type, \", \", \",\");\n}",
        "summary_tokens": [
            "replacing",
            "code",
            "code",
            "to",
            "code",
            "code",
            "will",
            "not",
            "change",
            "the",
            "semantic",
            "of",
            "parameterized",
            "type",
            "to",
            "string"
        ]
    },
    {
        "id": 451,
        "code": "public static String getCodeSource(Class<?> clazz) {\n    ProtectionDomain protectionDomain = clazz.getProtectionDomain();\n    if (protectionDomain == null || protectionDomain.getCodeSource() == null) {\n        return null;\n    }\n\n    CodeSource codeSource = clazz.getProtectionDomain().getCodeSource();\n    URL location = codeSource.getLocation();\n    if (location == null) {\n        return null;\n    }\n\n    String path = location.toExternalForm();\n\n    if (path.endsWith(\".jar\") && path.contains(\"/\")) {\n        return path.substring(path.lastIndexOf('/') + 1);\n    }\n    return path;\n}",
        "summary_tokens": [
            "get",
            "the",
            "code",
            "source",
            "file",
            "or",
            "class",
            "path",
            "of",
            "the",
            "class",
            "passed",
            "in"
        ]
    },
    {
        "id": 452,
        "code": "public static List<Field> getNonStaticFields(final Class<?> clazz) {\n    List<Field> result = new ArrayList<>();\n    Class<?> target = clazz;\n    while (target != null) {\n        if (JaketConfigurationUtils.isExcludedType(target)) {\n            break;\n        }\n\n        Field[] fields = target.getDeclaredFields();\n        for (Field field : fields) {\n            int modifiers = field.getModifiers();\n            if (Modifier.isStatic(modifiers) || Modifier.isTransient(modifiers)) {\n                continue;\n            }\n\n            result.add(field);\n        }\n        target = target.getSuperclass();\n    }\n\n    return result;\n}",
        "summary_tokens": [
            "get",
            "all",
            "non",
            "static",
            "fields",
            "of",
            "the",
            "class",
            "passed",
            "in",
            "or",
            "its",
            "super",
            "classes"
        ]
    },
    {
        "id": 453,
        "code": "public static List<Method> getPublicNonStaticMethods(final Class<?> clazz) {\n    List<Method> result = new ArrayList<Method>();\n\n    Method[] methods = clazz.getMethods();\n    for (Method method : methods) {\n        int mod = method.getModifiers();\n        if (Modifier.isPublic(mod) && !Modifier.isStatic(mod)) {\n            result.add(method);\n        }\n    }\n    return result;\n}",
        "summary_tokens": [
            "get",
            "all",
            "public",
            "non",
            "static",
            "methods",
            "of",
            "the",
            "class",
            "passed",
            "in"
        ]
    },
    {
        "id": 454,
        "code": "public static ApplicationModel defaultModel() {\n        \n    return FrameworkModel.defaultModel().defaultApplication();\n}",
        "summary_tokens": [
            "during",
            "destroying",
            "the",
            "default",
            "framework",
            "model",
            "the",
            "framework",
            "model"
        ]
    },
    {
        "id": 455,
        "code": "public static Collection<ConsumerModel> allConsumerModels() {\n    return defaultModel().getApplicationServiceRepository().allConsumerModels();\n}",
        "summary_tokens": [
            "use",
            "service",
            "repository",
            "all",
            "consumer",
            "models"
        ]
    },
    {
        "id": 456,
        "code": "public static Collection<ProviderModel> allProviderModels() {\n    return defaultModel().getApplicationServiceRepository().allProviderModels();\n}",
        "summary_tokens": [
            "use",
            "service",
            "repository",
            "all",
            "provider",
            "models"
        ]
    },
    {
        "id": 457,
        "code": "public static ProviderModel getProviderModel(String serviceKey) {\n    return defaultModel().getDefaultModule().getServiceRepository().lookupExportedService(serviceKey);\n}",
        "summary_tokens": [
            "use",
            "framework",
            "service",
            "repository",
            "lookup",
            "exported",
            "service",
            "string"
        ]
    },
    {
        "id": 458,
        "code": "public static ConsumerModel getConsumerModel(String serviceKey) {\n    return defaultModel().getDefaultModule().getServiceRepository().lookupReferredService(serviceKey);\n}",
        "summary_tokens": [
            "consumer",
            "model",
            "should",
            "fetch",
            "from",
            "context"
        ]
    },
    {
        "id": 459,
        "code": "public static Environment getEnvironment() {\n    return defaultModel().getModelEnvironment();\n}",
        "summary_tokens": [
            "replace",
            "to",
            "scope",
            "model",
            "get",
            "model",
            "environment"
        ]
    },
    {
        "id": 460,
        "code": "public static ConfigManager getConfigManager() {\n    return defaultModel().getApplicationConfigManager();\n}",
        "summary_tokens": [
            "replace",
            "to",
            "application",
            "model",
            "get",
            "application",
            "config",
            "manager"
        ]
    },
    {
        "id": 461,
        "code": "public static ServiceRepository getServiceRepository() {\n    return defaultModel().getApplicationServiceRepository();\n}",
        "summary_tokens": [
            "replace",
            "to",
            "application",
            "model",
            "get",
            "application",
            "service",
            "repository"
        ]
    },
    {
        "id": 462,
        "code": "public static ExecutorRepository getExecutorRepository() {\n    return defaultModel().getApplicationExecutorRepository();\n}",
        "summary_tokens": [
            "replace",
            "to",
            "application",
            "model",
            "get",
            "application",
            "executor",
            "repository"
        ]
    },
    {
        "id": 463,
        "code": "public static ApplicationConfig getApplicationConfig() {\n    return defaultModel().getCurrentConfig();\n}",
        "summary_tokens": [
            "replace",
            "to",
            "application",
            "model",
            "get",
            "current",
            "config"
        ]
    },
    {
        "id": 464,
        "code": "public static String getName() {\n    return defaultModel().getCurrentConfig().getName();\n}",
        "summary_tokens": [
            "replace",
            "to",
            "application",
            "model",
            "get",
            "application",
            "name"
        ]
    },
    {
        "id": 465,
        "code": "public static String getApplication() {\n    return getName();\n}",
        "summary_tokens": [
            "replace",
            "to",
            "application",
            "model",
            "get",
            "application",
            "name"
        ]
    },
    {
        "id": 466,
        "code": "public ConsumerMethodModel getMethodModel(String method, String[] argsType) {\n    Optional<ConsumerMethodModel> consumerMethodModel = methodModels.entrySet().stream()\n        .filter(entry -> entry.getKey().getName().equals(method))\n        .map(Map.Entry::getValue).filter(methodModel -> Arrays.equals(argsType, methodModel.getParameterTypes()))\n        .findFirst();\n    return consumerMethodModel.orElse(null);\n}",
        "summary_tokens": [
            "method",
            "method",
            "name",
            "args",
            "type",
            "method",
            "arguments",
            "type"
        ]
    },
    {
        "id": 467,
        "code": "public List<ConsumerMethodModel> getAllMethodModels() {\n    return new ArrayList<>(methodModels.values());\n}",
        "summary_tokens": [
            "return",
            "all",
            "method",
            "models",
            "for",
            "the",
            "current",
            "service"
        ]
    },
    {
        "id": 468,
        "code": "public static FrameworkModel defaultModel() {\n    FrameworkModel instance = defaultInstance;\n    if (instance == null) {\n        synchronized (globalLock) {\n            resetDefaultFrameworkModel();\n            if (defaultInstance == null) {\n                defaultInstance = new FrameworkModel();\n            }\n            instance = defaultInstance;\n        }\n    }\n    Assert.notNull(instance, \"Default FrameworkModel is null\");\n    return instance;\n}",
        "summary_tokens": [
            "during",
            "destroying",
            "the",
            "default",
            "framework",
            "model",
            "the",
            "framework",
            "model"
        ]
    },
    {
        "id": 469,
        "code": "public static List<FrameworkModel> getAllInstances() {\n    return Collections.unmodifiableList(new ArrayList<>(allInstances));\n}",
        "summary_tokens": [
            "get",
            "all",
            "framework",
            "model",
            "instances"
        ]
    },
    {
        "id": 470,
        "code": "public static void destroyAll() {\n    for (FrameworkModel frameworkModel : new ArrayList<>(allInstances)) {\n        frameworkModel.destroy();\n    }\n}",
        "summary_tokens": [
            "destroy",
            "all",
            "framework",
            "model",
            "instances",
            "shutdown",
            "dubbo",
            "engine",
            "completely"
        ]
    },
    {
        "id": 471,
        "code": "public ApplicationModel defaultApplication() {\n    ApplicationModel appModel = this.defaultAppModel;\n    if (appModel == null) {\n            \n        checkDestroyed();\n        resetDefaultAppModel();\n        if ((appModel = this.defaultAppModel) == null) {\n            synchronized (instLock) {\n                if (this.defaultAppModel == null) {\n                    this.defaultAppModel = newApplication();\n                }\n                appModel = this.defaultAppModel;\n            }\n        }\n    }\n    Assert.notNull(appModel, \"Default ApplicationModel is null\");\n    return appModel;\n}",
        "summary_tokens": [
            "get",
            "or",
            "create",
            "default",
            "application",
            "model"
        ]
    },
    {
        "id": 472,
        "code": "void tryDestroyProtocols() {\n    synchronized (instLock) {\n        if (pubApplicationModels.size() == 0) {\n            notifyProtocolDestroy();\n        }\n    }\n}",
        "summary_tokens": [
            "protocols",
            "are",
            "special",
            "resources",
            "that",
            "need",
            "to",
            "be",
            "destroyed",
            "as",
            "soon",
            "as",
            "possible"
        ]
    },
    {
        "id": 473,
        "code": "public List<ApplicationModel> getApplicationModels() {\n    return Collections.unmodifiableList(pubApplicationModels);\n}",
        "summary_tokens": [
            "get",
            "all",
            "application",
            "models",
            "except",
            "for",
            "the",
            "internal",
            "application",
            "model"
        ]
    },
    {
        "id": 474,
        "code": "public List<ApplicationModel> getAllApplicationModels() {\n    return Collections.unmodifiableList(applicationModels);\n}",
        "summary_tokens": [
            "get",
            "all",
            "application",
            "models",
            "including",
            "the",
            "internal",
            "application",
            "model"
        ]
    },
    {
        "id": 475,
        "code": "public void registerConsumer(String serviceKey,\n                             ServiceDescriptor serviceDescriptor,\n                             ReferenceConfigBase<?> rc,\n                             Object proxy,\n                             ServiceMetadata serviceMetadata) {\n    ClassLoader classLoader = null;\n    if (rc != null) {\n        classLoader = rc.getInterfaceClassLoader();\n    }\n    ConsumerModel consumerModel = new ConsumerModel(serviceMetadata.getServiceKey(), proxy, serviceDescriptor,\n        serviceMetadata, null, classLoader);\n    this.registerConsumer(consumerModel);\n}",
        "summary_tokens": [
            "replaced",
            "to",
            "module",
            "service",
            "repository",
            "register",
            "consumer",
            "consumer",
            "model"
        ]
    },
    {
        "id": 476,
        "code": "public void registerProvider(String serviceKey,\n                             Object serviceInstance,\n                             ServiceDescriptor serviceModel,\n                             ServiceConfigBase<?> serviceConfig,\n                             ServiceMetadata serviceMetadata) {\n    ClassLoader classLoader = null;\n    Class<?> cla = null;\n    if (serviceConfig != null) {\n        classLoader = serviceConfig.getInterfaceClassLoader();\n        cla = serviceConfig.getInterfaceClass();\n    }\n    ProviderModel providerModel = new ProviderModel(serviceKey, serviceInstance, serviceModel,\n        serviceMetadata, classLoader);\n    this.registerProvider(providerModel);\n}",
        "summary_tokens": [
            "replaced",
            "to",
            "module",
            "service",
            "repository",
            "register",
            "provider",
            "provider",
            "model"
        ]
    },
    {
        "id": 477,
        "code": "public ServiceDescriptor registerService(String path, Class<?> interfaceClass) {\n    ServiceDescriptor serviceDescriptor = registerService(interfaceClass);\n        \n    if (!interfaceClass.getName().equals(path)) {\n        List<ServiceDescriptor> serviceDescriptors = services.computeIfAbsent(path,\n            _k -> new CopyOnWriteArrayList<>());\n        synchronized (serviceDescriptors) {\n            Optional<ServiceDescriptor> previous = serviceDescriptors.stream()\n                .filter(s -> s.getServiceInterfaceClass().equals(serviceDescriptor.getServiceInterfaceClass())).findFirst();\n            if (previous.isPresent()) {\n                return previous.get();\n            } else {\n                serviceDescriptors.add(serviceDescriptor);\n                return serviceDescriptor;\n            }\n        }\n    }\n    return serviceDescriptor;\n}",
        "summary_tokens": [
            "see",
            "register",
            "service",
            "class",
            "p",
            "we",
            "assume",
            "0"
        ]
    },
    {
        "id": 478,
        "code": "public ConsumerModel lookupReferredService(String serviceKey) {\n    if (consumers.containsKey(serviceKey)) {\n        List<ConsumerModel> consumerModels = consumers.get(serviceKey);\n        return consumerModels.size() > 0 ? consumerModels.get(0) : null;\n    } else {\n        return null;\n    }\n}",
        "summary_tokens": [
            "replaced",
            "to",
            "module",
            "service",
            "repository",
            "lookup",
            "referred",
            "services",
            "string"
        ]
    },
    {
        "id": 479,
        "code": "public MethodDescriptor getMethod(String methodName, Class<?>[] paramTypes) {\n    List<MethodDescriptor> methodModels = methods.get(methodName);\n    if (CollectionUtils.isNotEmpty(methodModels)) {\n        for (MethodDescriptor descriptor : methodModels) {\n            if (Arrays.equals(paramTypes, descriptor.getParameterClasses())) {\n                return descriptor;\n            }\n        }\n    }\n    return null;\n}",
        "summary_tokens": [
            "does",
            "not",
            "use",
            "optional",
            "as",
            "return",
            "type",
            "to",
            "avoid",
            "potential",
            "performance",
            "decrease"
        ]
    },
    {
        "id": 480,
        "code": "protected void initialize() {\n    this.extensionDirector = new ExtensionDirector(parent != null ? parent.getExtensionDirector() : null, scope, this);\n    this.extensionDirector.addExtensionPostProcessor(new ScopeModelAwareExtensionProcessor(this));\n    this.beanFactory = new ScopeBeanFactory(parent != null ? parent.getBeanFactory() : null, extensionDirector);\n    this.destroyListeners = new LinkedList<>();\n    this.classLoaderListeners = new LinkedList<>();\n    this.attributes = new ConcurrentHashMap<>();\n    this.classLoaders = new ConcurrentHashSet<>();\n\n        \n    ClassLoader dubboClassLoader = ScopeModel.class.getClassLoader();\n    if (dubboClassLoader != null) {\n        this.addClassLoader(dubboClassLoader);\n    }\n}",
        "summary_tokens": [
            "note",
            "ol",
            "li",
            "the",
            "initialize",
            "method",
            "only",
            "be",
            "called",
            "in",
            "subclass"
        ]
    },
    {
        "id": 481,
        "code": "public String getDesc() {\n    if (this.desc == null) {\n        this.desc = buildDesc();\n    }\n    return this.desc;\n}",
        "summary_tokens": [
            "to",
            "describe",
            "string",
            "of",
            "this",
            "scope",
            "model"
        ]
    },
    {
        "id": 482,
        "code": "default void setScopeModel(ScopeModel scopeModel) {\n}",
        "summary_tokens": [
            "override",
            "this",
            "method",
            "if",
            "you",
            "need",
            "get",
            "the",
            "scope",
            "model",
            "maybe",
            "one",
            "of",
            "framework",
            "model",
            "application",
            "model",
            "module",
            "model"
        ]
    },
    {
        "id": 483,
        "code": "default void setFrameworkModel(FrameworkModel frameworkModel) {\n}",
        "summary_tokens": [
            "override",
            "this",
            "method",
            "if",
            "you",
            "just",
            "need",
            "framework",
            "model",
            "framework",
            "model"
        ]
    },
    {
        "id": 484,
        "code": "default void setApplicationModel(ApplicationModel applicationModel) {\n}",
        "summary_tokens": [
            "override",
            "this",
            "method",
            "if",
            "you",
            "just",
            "need",
            "application",
            "model",
            "application",
            "model"
        ]
    },
    {
        "id": 485,
        "code": "default void setModuleModel(ModuleModel moduleModel) {\n}",
        "summary_tokens": [
            "override",
            "this",
            "method",
            "if",
            "you",
            "just",
            "need",
            "module",
            "model",
            "module",
            "model"
        ]
    },
    {
        "id": 486,
        "code": "public ReferenceConfigBase<?> getReferenceConfig() {\n    if (config == null) {\n        return null;\n    }\n    if (config instanceof ReferenceConfigBase) {\n        return (ReferenceConfigBase<?>) config;\n    } else {\n        throw new IllegalArgumentException(\"Current ServiceModel is not a ConsumerModel\");\n    }\n}",
        "summary_tokens": [
            "service",
            "model",
            "should",
            "be",
            "decoupled",
            "from",
            "abstract",
            "interface",
            "config",
            "and",
            "removed",
            "in",
            "a",
            "future",
            "version"
        ]
    },
    {
        "id": 487,
        "code": "public ServiceConfigBase<?> getServiceConfig() {\n    if (config == null) {\n        return null;\n    }\n    if (config instanceof ServiceConfigBase) {\n        return (ServiceConfigBase<?>) config;\n    } else {\n        throw new IllegalArgumentException(\"Current ServiceModel is not a ProviderModel\");\n    }\n}",
        "summary_tokens": [
            "service",
            "model",
            "should",
            "be",
            "decoupled",
            "from",
            "abstract",
            "interface",
            "config",
            "and",
            "removed",
            "in",
            "a",
            "future",
            "version"
        ]
    },
    {
        "id": 488,
        "code": "public Set<MethodDescriptor> getAllMethods() {\n    return serviceModel.getAllMethods();\n}",
        "summary_tokens": [
            "return",
            "all",
            "method",
            "models",
            "for",
            "the",
            "current",
            "service"
        ]
    },
    {
        "id": 489,
        "code": "public MethodDescriptor getMethod(String methodName, Class<?>[] paramTypes) {\n    List<MethodDescriptor> methodModels = methods.get(methodName);\n    if (CollectionUtils.isNotEmpty(methodModels)) {\n        for (MethodDescriptor descriptor : methodModels) {\n            if (Arrays.equals(paramTypes, descriptor.getParameterClasses())) {\n                return descriptor;\n            }\n        }\n    }\n    return null;\n}",
        "summary_tokens": [
            "does",
            "not",
            "use",
            "optional",
            "as",
            "return",
            "type",
            "to",
            "avoid",
            "potential",
            "performance",
            "decrease"
        ]
    },
    {
        "id": 490,
        "code": "public void testGetParameters() {\n    URL url = URL.valueOf(\"10.20.130.230:20880/context/path?interface=org.apache.dubbo.test.interfaceName&group=group&version=1.0.0\");\n    Map<String, String> parameters = url.getParameters(i -> \"version\".equals(i));\n    String version = parameters.get(\"version\");\n    assertEquals(1, parameters.size());\n    assertEquals(\"1.0.0\", version);\n}",
        "summary_tokens": [
            "test",
            "url",
            "get",
            "parameters",
            "predicate",
            "method"
        ]
    },
    {
        "id": 491,
        "code": "public void testCompileJavaClass0() throws Exception {\n    boolean ignoreWithoutPackage = shouldIgnoreWithoutPackage();\n    JavassistCompiler compiler = new JavassistCompiler();\n\n    if (ignoreWithoutPackage) {\n        Assertions.assertThrows(RuntimeException.class, () -> compiler.compile(null, getSimpleCodeWithoutPackage(), JavassistCompiler.class.getClassLoader()));\n    } else {\n        Class<?> clazz = compiler.compile(null, getSimpleCodeWithoutPackage(), JavassistCompiler.class.getClassLoader());\n        Object instance = clazz.newInstance();\n        Method sayHello = instance.getClass().getMethod(\"sayHello\");\n        Assertions.assertEquals(\"Hello world!\", sayHello.invoke(instance));\n    }\n}",
        "summary_tokens": [
            "javassist",
            "compile",
            "will",
            "find",
            "hello",
            "service",
            "in",
            "classpath"
        ]
    },
    {
        "id": 492,
        "code": "void testGetMemProperty() {\n    Assertions.assertNull(memConfig.getInternalProperty(MOCK_KEY));\n    Assertions.assertFalse(memConfig.containsKey(MOCK_KEY));\n    Assertions.assertNull(memConfig.getString(MOCK_KEY));\n    Assertions.assertNull(memConfig.getProperty(MOCK_KEY));\n    memConfig.addProperty(MOCK_KEY, MOCK_VALUE);\n    Assertions.assertTrue(memConfig.containsKey(MOCK_KEY));\n    Assertions.assertEquals(MOCK_VALUE, memConfig.getInternalProperty(MOCK_KEY));\n    Assertions.assertEquals(MOCK_VALUE, memConfig.getString(MOCK_KEY, MOCK_VALUE));\n    Assertions.assertEquals(MOCK_VALUE, memConfig.getProperty(MOCK_KEY, MOCK_VALUE));\n}",
        "summary_tokens": [
            "test",
            "get",
            "mem",
            "property"
        ]
    },
    {
        "id": 493,
        "code": "public void testGetSysProperty() {\n    Assertions.assertNull(sysConfig.getInternalProperty(MOCK_KEY));\n    Assertions.assertFalse(sysConfig.containsKey(MOCK_KEY));\n    Assertions.assertNull(sysConfig.getString(MOCK_KEY));\n    Assertions.assertNull(sysConfig.getProperty(MOCK_KEY));\n    System.setProperty(MOCK_KEY, MOCK_STRING_VALUE);\n    Assertions.assertTrue(sysConfig.containsKey(MOCK_KEY));\n    Assertions.assertEquals(MOCK_STRING_VALUE, sysConfig.getInternalProperty(MOCK_KEY));\n    Assertions.assertEquals(MOCK_STRING_VALUE, sysConfig.getString(MOCK_KEY, MOCK_STRING_VALUE));\n    Assertions.assertEquals(MOCK_STRING_VALUE, sysConfig.getProperty(MOCK_KEY, MOCK_STRING_VALUE));\n}",
        "summary_tokens": [
            "test",
            "get",
            "sys",
            "property"
        ]
    },
    {
        "id": 494,
        "code": "public void testGetGroupAndGetDefaultGroup() {\n    assertEquals(configuration.getGroup(), configuration.getDefaultGroup());\n    assertEquals(DEFAULT_GROUP, configuration.getDefaultGroup());\n}",
        "summary_tokens": [
            "test",
            "abstract",
            "dynamic",
            "configuration",
            "get",
            "group",
            "and",
            "abstract",
            "dynamic",
            "configuration",
            "get",
            "default",
            "group",
            "methods"
        ]
    },
    {
        "id": 495,
        "code": "public void testGetTimeoutAndGetDefaultTimeout() {\n    assertEquals(configuration.getTimeout(), configuration.getDefaultTimeout());\n    assertEquals(-1L, configuration.getDefaultTimeout());\n}",
        "summary_tokens": [
            "test",
            "abstract",
            "dynamic",
            "configuration",
            "get",
            "timeout",
            "and",
            "abstract",
            "dynamic",
            "configuration",
            "get",
            "default",
            "timeout",
            "methods"
        ]
    },
    {
        "id": 496,
        "code": "public void testRemoveConfigAndDoRemoveConfig() throws Exception {\n    String key = null;\n    String group = null;\n    assertEquals(configuration.removeConfig(key, group), configuration.doRemoveConfig(key, group));\n    assertFalse(configuration.removeConfig(key, group));\n}",
        "summary_tokens": [
            "test",
            "abstract",
            "dynamic",
            "configuration",
            "remove",
            "config",
            "string",
            "string",
            "and",
            "abstract",
            "dynamic",
            "configuration",
            "do",
            "remove",
            "config",
            "string",
            "string",
            "methods"
        ]
    },
    {
        "id": 497,
        "code": "public void testPerformanceTradition() {\n    final ThreadLocal<String>[] caches1 = new ThreadLocal[PERFORMANCE_THREAD_COUNT];\n    final Thread mainThread = Thread.currentThread();\n    for (int i = 0; i < PERFORMANCE_THREAD_COUNT; i++) {\n        caches1[i] = new ThreadLocal<String>();\n    }\n    Thread t1 = new Thread(new Runnable() {\n        @Override\n        public void run() {\n            for (int i = 0; i < PERFORMANCE_THREAD_COUNT; i++) {\n                caches1[i].set(\"float.lu\");\n            }\n            long start = System.nanoTime();\n            for (int i = 0; i < PERFORMANCE_THREAD_COUNT; i++) {\n                for (int j = 0; j < GET_COUNT; j++) {\n                    caches1[i].get();\n                }\n            }\n            long end = System.nanoTime();\n            System.out.println(\"take[\" + TimeUnit.NANOSECONDS.toMillis(end - start) +\n                    \"]ms\");\n            LockSupport.unpark(mainThread);\n        }\n    });\n    t1.start();\n    LockSupport.park(mainThread);\n}",
        "summary_tokens": [
            "print",
            "take",
            "0",
            "ms",
            "p",
            "p",
            "this",
            "test",
            "is",
            "based",
            "on",
            "a",
            "machine",
            "with",
            "0",
            "core",
            "and",
            "0",
            "g",
            "memory"
        ]
    },
    {
        "id": 498,
        "code": "public void testPerformance() {\n    final InternalThreadLocal<String>[] caches = new InternalThreadLocal[PERFORMANCE_THREAD_COUNT];\n    final Thread mainThread = Thread.currentThread();\n    for (int i = 0; i < PERFORMANCE_THREAD_COUNT; i++) {\n        caches[i] = new InternalThreadLocal<String>();\n    }\n    Thread t = new InternalThread(new Runnable() {\n        @Override\n        public void run() {\n            for (int i = 0; i < PERFORMANCE_THREAD_COUNT; i++) {\n                caches[i].set(\"float.lu\");\n            }\n            long start = System.nanoTime();\n            for (int i = 0; i < PERFORMANCE_THREAD_COUNT; i++) {\n                for (int j = 0; j < GET_COUNT; j++) {\n                    caches[i].get();\n                }\n            }\n            long end = System.nanoTime();\n            System.out.println(\"take[\" + TimeUnit.NANOSECONDS.toMillis(end - start) +\n                    \"]ms\");\n            LockSupport.unpark(mainThread);\n        }\n    });\n    t.start();\n    LockSupport.park(mainThread);\n}",
        "summary_tokens": [
            "print",
            "take",
            "0",
            "ms",
            "p",
            "p",
            "this",
            "test",
            "is",
            "based",
            "on",
            "a",
            "machine",
            "with",
            "0",
            "core",
            "and",
            "0",
            "g",
            "memory"
        ]
    },
    {
        "id": 499,
        "code": "public void testEagerThreadPool() throws Exception {\n    String name = \"eager-tf\";\n    int queues = 5;\n    int cores = 5;\n    int threads = 10;\n        \n    long alive = 1000;\n\n        \n    TaskQueue<Runnable> taskQueue = new TaskQueue<Runnable>(queues);\n    final EagerThreadPoolExecutor executor = new EagerThreadPoolExecutor(cores,\n            threads,\n            alive,\n            TimeUnit.MILLISECONDS,\n            taskQueue,\n            new NamedThreadFactory(name, true),\n            new AbortPolicyWithReport(name, URL));\n    taskQueue.setExecutor(executor);\n\n    for (int i = 0; i < 15; i++) {\n        Thread.sleep(50);\n        executor.execute(() -> {\n            System.out.println(\"thread number in current pool\uff1a\" + executor.getPoolSize() + \",  task number in task queue\uff1a\" + executor.getQueue()\n                    .size() + \" executor size: \" + executor.getPoolSize());\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n    }\n    Thread.sleep(5000);\n        \n    Assertions.assertEquals(executor.getPoolSize(), cores, \"more than cores threads alive!\");\n}",
        "summary_tokens": [
            "it",
            "print",
            "like",
            "this",
            "thread",
            "number",
            "in",
            "current",
            "pool",
            "0",
            "task",
            "number",
            "in",
            "task",
            "queue",
            "0",
            "executor",
            "size",
            "0",
            "thread",
            "number",
            "in",
            "current",
            "pool",
            "0",
            "task",
            "number",
            "in",
            "task",
            "queue",
            "0",
            "executor",
            "size",
            "0",
            "thread",
            "number",
            "in",
            "current",
            "pool",
            "0",
            "task",
            "number",
            "in",
            "task",
            "queue",
            "0",
            "executor",
            "size",
            "0",
            "thread",
            "number",
            "in",
            "current",
            "pool",
            "0",
            "task",
            "number",
            "in",
            "task",
            "queue",
            "0",
            "executor",
            "size",
            "0",
            "thread",
            "number",
            "in",
            "current",
            "pool",
            "0",
            "task",
            "number",
            "in",
            "task",
            "queue",
            "0",
            "executor",
            "size",
            "0",
            "thread",
            "number",
            "in",
            "current",
            "pool",
            "0",
            "task",
            "number",
            "in",
            "task",
            "queue",
            "0",
            "executor",
            "size",
            "0",
            "thread",
            "number",
            "in",
            "current",
            "pool",
            "0",
            "task",
            "number",
            "in",
            "task",
            "queue",
            "0",
            "executor",
            "size",
            "0",
            "thread",
            "number",
            "in",
            "current",
            "pool",
            "0",
            "task",
            "number",
            "in",
            "task",
            "queue",
            "0",
            "executor",
            "size",
            "0",
            "thread",
            "number",
            "in",
            "current",
            "pool",
            "0",
            "task",
            "number",
            "in",
            "task",
            "queue",
            "0",
            "executor",
            "size",
            "0",
            "thread",
            "number",
            "in",
            "current",
            "pool",
            "0",
            "task",
            "number",
            "in",
            "task",
            "queue",
            "0",
            "executor",
            "size",
            "0",
            "thread",
            "number",
            "in",
            "current",
            "pool",
            "0",
            "task",
            "number",
            "in",
            "task",
            "queue",
            "0",
            "executor",
            "size",
            "0",
            "thread",
            "number",
            "in",
            "current",
            "pool",
            "0",
            "task",
            "number",
            "in",
            "task",
            "queue",
            "0",
            "executor",
            "size",
            "0",
            "thread",
            "number",
            "in",
            "current",
            "pool",
            "0",
            "task",
            "number",
            "in",
            "task",
            "queue",
            "0",
            "executor",
            "size",
            "0",
            "thread",
            "number",
            "in",
            "current",
            "pool",
            "0",
            "task",
            "number",
            "in",
            "task",
            "queue",
            "0",
            "executor",
            "size",
            "0",
            "thread",
            "number",
            "in",
            "current",
            "pool",
            "0",
            "task",
            "number",
            "in",
            "task",
            "queue",
            "0",
            "executor",
            "size",
            "0",
            "p",
            "we",
            "can",
            "see",
            "when",
            "the",
            "core",
            "threads",
            "are",
            "in",
            "busy",
            "the",
            "thread",
            "pool",
            "create",
            "thread",
            "but",
            "thread",
            "nums",
            "always",
            "less",
            "than",
            "max",
            "instead",
            "of",
            "put",
            "task",
            "into",
            "queue"
        ]
    },
    {
        "id": 500,
        "code": "public void testMergeValuesDelete() {\n    List<String> merged = ConfigUtils.mergeValues(ApplicationModel.defaultModel().getExtensionDirector(), ThreadPool.class, \"-fixed,aaa\", asList(\"fixed\", \"default.limited\", \"cached\"));\n    assertEquals(asList(\"cached\", \"aaa\"), merged);\n}",
        "summary_tokens": [
            "the",
            "user",
            "configures",
            "default",
            "which",
            "will",
            "delete",
            "all",
            "the",
            "default",
            "parameters"
        ]
    },
    {
        "id": 501,
        "code": "void testNormalizeV6Address() {\n    Inet6Address address = mock(Inet6Address.class);\n    when(address.getHostAddress()).thenReturn(\"fe80:0:0:0:894:aeec:f37d:23e1%en0\");\n    when(address.getScopeId()).thenReturn(5);\n    InetAddress normalized = NetUtils.normalizeV6Address(address);\n    assertThat(normalized.getHostAddress(), equalTo(\"fe80:0:0:0:894:aeec:f37d:23e1%5\"));\n}",
        "summary_tokens": [
            "mockito",
            "starts",
            "to",
            "support",
            "mocking",
            "final",
            "classes",
            "since",
            "0"
        ]
    },
    {
        "id": 502,
        "code": "public void testSplitToSet() {\n    String value = \"1# 2#3 #4#3\";\n    Set<String> values = splitToSet(value, '#', false);\n    assertEquals(ofSet(\"1\", \" 2\", \"3 \", \"4\", \"3\"), values);\n\n    values = splitToSet(value, '#', true);\n    assertEquals(ofSet(\"1\", \"2\", \"3\", \"4\"), values);\n}",
        "summary_tokens": [
            "test",
            "string",
            "utils",
            "split",
            "to",
            "set",
            "string",
            "char",
            "boolean"
        ]
    },
    {
        "id": 503,
        "code": "public void testToCommaDelimitedString() {\n    String value = toCommaDelimitedString(null);\n    assertNull(value);\n\n    value = toCommaDelimitedString(null, null);\n    assertNull(value);\n\n    value = toCommaDelimitedString(\"\");\n    assertEquals(\"\", value);\n\n    value = toCommaDelimitedString(\"one\");\n    assertEquals(\"one\", value);\n\n    value = toCommaDelimitedString(\"one\", \"two\");\n    assertEquals(\"one,two\", value);\n\n    value = toCommaDelimitedString(\"one\", \"two\", \"three\");\n    assertEquals(\"one,two,three\", value);\n}",
        "summary_tokens": [
            "test",
            "string",
            "utils",
            "to",
            "comma",
            "delimited",
            "string",
            "string",
            "string"
        ]
    },
    {
        "id": 504,
        "code": "public <T> T getResponse(Class<T> clazz) {\n    return newRpcContext.getResponse(clazz);\n}",
        "summary_tokens": [
            "get",
            "the",
            "response",
            "object",
            "of",
            "the",
            "underlying",
            "rpc",
            "protocol",
            "e"
        ]
    },
    {
        "id": 505,
        "code": "public void asyncCall(Runnable runnable) {\n    try {\n        setAttachment(Constants.RETURN_KEY, Boolean.FALSE.toString());\n        runnable.run();\n    } catch (Throwable e) {\n            \n        throw new RpcException(\"oneway call error .\" + e.getMessage(), e);\n    } finally {\n        removeAttachment(Constants.RETURN_KEY);\n    }\n}",
        "summary_tokens": [
            "one",
            "way",
            "async",
            "call",
            "send",
            "request",
            "only",
            "and",
            "result",
            "is",
            "not",
            "required"
        ]
    },
    {
        "id": 506,
        "code": "public static void attachInvocationIdIfAsync(URL url, Invocation inv) {\n    org.apache.dubbo.rpc.support.RpcUtils.attachInvocationIdIfAsync(url.getOriginalURL(), inv);\n}",
        "summary_tokens": [
            "idempotent",
            "operation",
            "invocation",
            "id",
            "will",
            "be",
            "added",
            "in",
            "async",
            "operation",
            "by",
            "default"
        ]
    },
    {
        "id": 507,
        "code": "public void register() {\n    if (!ignoreListenShutdownHook && registered.compareAndSet(false, true)) {\n        try {\n            Runtime.getRuntime().addShutdownHook(this);\n        } catch (IllegalStateException e) {\n            logger.warn(\"5-2\", \"\", \"\", \"register shutdown hook failed: \" + e.getMessage(), e);\n        } catch (Exception e) {\n            logger.warn(\"5-2\", \"\", \"\", \"register shutdown hook failed: \" + e.getMessage(), e);\n        }\n    }\n}",
        "summary_tokens": [
            "register",
            "the",
            "shutdown",
            "hook"
        ]
    },
    {
        "id": 508,
        "code": "public void unregister() {\n    if (!ignoreListenShutdownHook && registered.compareAndSet(true, false)) {\n        if (this.isAlive()) {\n                \n            return;\n        }\n        try {\n            Runtime.getRuntime().removeShutdownHook(this);\n        } catch (IllegalStateException e) {\n            logger.warn(\"5-2\", \"\", \"\", \"unregister shutdown hook failed: \" + e.getMessage(), e);\n        } catch (Exception e) {\n            logger.warn(\"5-2\", \"\", \"\", \"unregister shutdown hook failed: \" + e.getMessage(), e);\n        }\n    }\n}",
        "summary_tokens": [
            "unregister",
            "the",
            "shutdown",
            "hook"
        ]
    },
    {
        "id": 509,
        "code": "public String getServices() {\n    return services;\n}",
        "summary_tokens": [
            "get",
            "a",
            "string",
            "presenting",
            "the",
            "service",
            "names",
            "that",
            "the",
            "dubbo",
            "interface",
            "subscribed"
        ]
    },
    {
        "id": 510,
        "code": "public Set<String> getSubscribedServices() {\n    return splitToSet(getServices(), COMMA_SEPARATOR_CHAR);\n}",
        "summary_tokens": [
            "it",
            "s",
            "an",
            "alias",
            "method",
            "for",
            "get",
            "services",
            "but",
            "the",
            "more",
            "convenient"
        ]
    },
    {
        "id": 511,
        "code": "public void setServices(String services) {\n    this.services = services;\n}",
        "summary_tokens": [
            "set",
            "the",
            "service",
            "names",
            "that",
            "the",
            "dubbo",
            "interface",
            "subscribed"
        ]
    },
    {
        "id": 512,
        "code": "private Map<String, AsyncMethodInfo> createAsyncMethodInfo() {\n    Map<String, AsyncMethodInfo> attributes = null;\n    if (CollectionUtils.isNotEmpty(getMethods())) {\n        attributes = new HashMap<>(16);\n        for (MethodConfig methodConfig : getMethods()) {\n            AsyncMethodInfo asyncMethodInfo = methodConfig.convertMethodConfig2AsyncInfo();\n            if (asyncMethodInfo != null) {\n                attributes.put(methodConfig.getName(), asyncMethodInfo);\n            }\n        }\n    }\n\n    return attributes;\n}",
        "summary_tokens": [
            "convert",
            "and",
            "aggregate",
            "async",
            "method",
            "info"
        ]
    },
    {
        "id": 513,
        "code": "private Map<String, String> appendConfig() {\n    Map<String, String> map = new HashMap<>(16);\n\n    map.put(INTERFACE_KEY, interfaceName);\n    map.put(SIDE_KEY, CONSUMER_SIDE);\n\n    ReferenceConfigBase.appendRuntimeParameters(map);\n\n    if (!ProtocolUtils.isGeneric(generic)) {\n        String revision = Version.getVersion(interfaceClass, version);\n        if (StringUtils.isNotEmpty(revision)) {\n            map.put(REVISION_KEY, revision);\n        }\n\n        String[] methods = methods(interfaceClass);\n        if (methods.length == 0) {\n            logger.warn(\"5-4\", \"\", \"\", \"No method found in service interface: \" + interfaceClass.getName());\n            map.put(METHODS_KEY, ANY_VALUE);\n        } else {\n            map.put(METHODS_KEY, StringUtils.join(new HashSet<>(Arrays.asList(methods)), COMMA_SEPARATOR));\n        }\n    }\n\n    AbstractConfig.appendParameters(map, getApplication());\n    AbstractConfig.appendParameters(map, getModule());\n    AbstractConfig.appendParameters(map, consumer);\n    AbstractConfig.appendParameters(map, this);\n    appendMetricsCompatible(map);\n\n    String hostToRegistry = ConfigUtils.getSystemProperty(DUBBO_IP_TO_REGISTRY);\n    if (StringUtils.isEmpty(hostToRegistry)) {\n        hostToRegistry = NetUtils.getLocalHost();\n    } else if (isInvalidLocalHost(hostToRegistry)) {\n        throw new IllegalArgumentException(\n                \"Specified invalid registry ip from property:\" + DUBBO_IP_TO_REGISTRY + \", value:\" + hostToRegistry);\n    }\n\n    map.put(REGISTER_IP_KEY, hostToRegistry);\n\n    if (CollectionUtils.isNotEmpty(getMethods())) {\n        for (MethodConfig methodConfig : getMethods()) {\n            AbstractConfig.appendParameters(map, methodConfig, methodConfig.getName());\n            String retryKey = methodConfig.getName() + \".retry\";\n            if (map.containsKey(retryKey)) {\n                String retryValue = map.remove(retryKey);\n                if (\"false\".equals(retryValue)) {\n                    map.put(methodConfig.getName() + \".retries\", \"0\");\n                }\n            }\n        }\n    }\n\n    return map;\n}",
        "summary_tokens": [
            "append",
            "all",
            "configuration",
            "required",
            "for",
            "service",
            "reference"
        ]
    },
    {
        "id": 514,
        "code": "private void meshModeHandleUrl(Map<String, String> referenceParameters) {\n    if (!checkMeshConfig(referenceParameters)) {\n        return;\n    }\n    if (StringUtils.isNotEmpty(url)) {\n            \n        if (logger.isInfoEnabled()) {\n            logger.info(\"The url already exists, mesh no longer processes url: \" + url);\n        }\n        return;\n    }\n        \n    String podNamespace;\n    if (StringUtils.isEmpty(System.getenv(\"POD_NAMESPACE\"))) {\n        if (logger.isWarnEnabled()) {\n            logger.warn(\"5-5\", \"\", \"\", \"Can not get env variable: POD_NAMESPACE, it may not be running in the K8S environment , \" +\n                \"finally use 'default' replace.\");\n        }\n        podNamespace = \"default\";\n    } else {\n        podNamespace = System.getenv(\"POD_NAMESPACE\");\n    }\n\n        \n    String providedBy = referenceParameters.get(PROVIDED_BY);\n        \n    String clusterDomain = Optional.ofNullable(System.getenv(\"CLUSTER_DOMAIN\")).orElse(DEFAULT_CLUSTER_DOMAIN);\n        \n    Integer meshPort = Optional.ofNullable(getProviderPort()).orElse(DEFAULT_MESH_PORT);\n        \n    meshPort = meshPort > -1 ? meshPort : DEFAULT_MESH_PORT;\n        \n    url = TRIPLE + \"://\" + providedBy + \".\" + podNamespace + SVC + clusterDomain + \":\" + meshPort;\n}",
        "summary_tokens": [
            "if",
            "enable",
            "mesh",
            "mode",
            "handle",
            "url"
        ]
    },
    {
        "id": 515,
        "code": "private boolean checkMeshConfig(Map<String, String> referenceParameters) {\n    if (!\"true\".equals(referenceParameters.getOrDefault(MESH_ENABLE, \"false\"))) {\n            \n        referenceParameters.put(UNLOAD_CLUSTER_RELATED, \"false\");\n        return false;\n    }\n\n    getScopeModel().getConfigManager().getProtocol(TRIPLE)\n            .orElseThrow(() -> new IllegalStateException(\"In mesh mode, a triple protocol must be specified\"));\n\n    String providedBy = referenceParameters.get(PROVIDED_BY);\n    if (StringUtils.isEmpty(providedBy)) {\n        throw new IllegalStateException(\"In mesh mode, the providedBy of ReferenceConfig is must be set\");\n    }\n\n    return true;\n}",
        "summary_tokens": [
            "check",
            "if",
            "mesh",
            "config",
            "is",
            "correct"
        ]
    },
    {
        "id": 516,
        "code": "private void createInvokerForLocal(Map<String, String> referenceParameters) {\n    URL url = new ServiceConfigURL(LOCAL_PROTOCOL, LOCALHOST_VALUE, 0, interfaceClass.getName(), referenceParameters);\n    url = url.setScopeModel(getScopeModel());\n    url = url.setServiceModel(consumerModel);\n    Invoker<?> withFilter = protocolSPI.refer(interfaceClass, url);\n        \n    List<Invoker<?>> invokers = new ArrayList<>();\n    invokers.add(withFilter);\n    invoker = Cluster.getCluster(url.getScopeModel(), Cluster.DEFAULT).join(new StaticDirectory(url, invokers), true);\n\n    if (logger.isInfoEnabled()) {\n        logger.info(\"Using in jvm service \" + interfaceClass.getName());\n    }\n}",
        "summary_tokens": [
            "make",
            "a",
            "local",
            "reference",
            "create",
            "a",
            "local",
            "invoker"
        ]
    },
    {
        "id": 517,
        "code": "private void parseUrl(Map<String, String> referenceParameters) {\n    String[] us = SEMICOLON_SPLIT_PATTERN.split(url);\n    if (ArrayUtils.isNotEmpty(us)) {\n        for (String u : us) {\n            URL url = URL.valueOf(u);\n            if (StringUtils.isEmpty(url.getPath())) {\n                url = url.setPath(interfaceName);\n            }\n            url = url.setScopeModel(getScopeModel());\n            url = url.setServiceModel(consumerModel);\n            if (UrlUtils.isRegistry(url)) {\n                urls.add(url.putAttribute(REFER_KEY, referenceParameters));\n            } else {\n                URL peerUrl = getScopeModel().getApplicationModel().getBeanFactory().getBean(ClusterUtils.class).mergeUrl(url, referenceParameters);\n                peerUrl = peerUrl.putAttribute(PEER_KEY, true);\n                urls.add(peerUrl);\n            }\n        }\n    }\n}",
        "summary_tokens": [
            "parse",
            "the",
            "directly",
            "configured",
            "url"
        ]
    },
    {
        "id": 518,
        "code": "private void aggregateUrlFromRegistry(Map<String, String> referenceParameters) {\n    checkRegistry();\n    List<URL> us = ConfigValidationUtils.loadRegistries(this, false);\n    if (CollectionUtils.isNotEmpty(us)) {\n        for (URL u : us) {\n            URL monitorUrl = ConfigValidationUtils.loadMonitor(this, u);\n            if (monitorUrl != null) {\n                u = u.putAttribute(MONITOR_KEY, monitorUrl);\n            }\n            u = u.setScopeModel(getScopeModel());\n            u = u.setServiceModel(consumerModel);\n            urls.add(u.putAttribute(REFER_KEY, referenceParameters));\n        }\n    }\n    if (urls.isEmpty()) {\n        throw new IllegalStateException(\n                \"No such any registry to reference \" + interfaceName + \" on the consumer \" + NetUtils.getLocalHost() +\n                        \" use dubbo version \" + Version.getVersion() +\n                        \", please config <dubbo:registry address=\\\"...\\\" /> to your spring config.\");\n    }\n}",
        "summary_tokens": [
            "get",
            "urls",
            "from",
            "the",
            "registry",
            "and",
            "aggregate",
            "them"
        ]
    },
    {
        "id": 519,
        "code": "private void createInvokerForRemote() {\n    if (urls.size() == 1) {\n        URL curUrl = urls.get(0);\n        invoker = protocolSPI.refer(interfaceClass, curUrl);\n            \n        if (!UrlUtils.isRegistry(curUrl) &&\n                !curUrl.getParameter(UNLOAD_CLUSTER_RELATED, false)) {\n            List<Invoker<?>> invokers = new ArrayList<>();\n            invokers.add(invoker);\n            invoker = Cluster.getCluster(scopeModel, Cluster.DEFAULT).join(new StaticDirectory(curUrl, invokers), true);\n        }\n    } else {\n        List<Invoker<?>> invokers = new ArrayList<>();\n        URL registryUrl = null;\n        for (URL url : urls) {\n                \n                \n            invokers.add(protocolSPI.refer(interfaceClass, url));\n\n            if (UrlUtils.isRegistry(url)) {\n                    \n                registryUrl = url;\n            }\n        }\n\n        if (registryUrl != null) {\n                \n                \n            String cluster = registryUrl.getParameter(CLUSTER_KEY, ZoneAwareCluster.NAME);\n                \n                \n            invoker = Cluster.getCluster(registryUrl.getScopeModel(), cluster, false).join(new StaticDirectory(registryUrl, invokers), false);\n        } else {\n                \n            if (CollectionUtils.isEmpty(invokers)) {\n                throw new IllegalArgumentException(\"invokers == null\");\n            }\n            URL curUrl = invokers.get(0).getUrl();\n            String cluster = curUrl.getParameter(CLUSTER_KEY, Cluster.DEFAULT);\n            invoker = Cluster.getCluster(scopeModel, cluster).join(new StaticDirectory(curUrl, invokers), true);\n        }\n    }\n}",
        "summary_tokens": [
            "make",
            "a",
            "remote",
            "reference",
            "create",
            "a",
            "remote",
            "reference",
            "invoker"
        ]
    },
    {
        "id": 520,
        "code": "protected void checkAndUpdateSubConfigs() {\n    if (StringUtils.isEmpty(interfaceName)) {\n        throw new IllegalStateException(\"<dubbo:reference interface=\\\"\\\" /> interface not allow null!\");\n    }\n\n        \n    completeCompoundConfigs();\n\n        \n    List<ConfigInitializer> configInitializers = this.getExtensionLoader(ConfigInitializer.class)\n            .getActivateExtension(URL.valueOf(\"configInitializer://\"), (String[]) null);\n    configInitializers.forEach(e -> e.initReferConfig(this));\n\n    if (getGeneric() == null && getConsumer() != null) {\n        setGeneric(getConsumer().getGeneric());\n    }\n    if (ProtocolUtils.isGeneric(generic)) {\n        if (interfaceClass != null && !interfaceClass.equals(GenericService.class)) {\n            logger.warn(\"5-6\", \"\", \"\", String.format(\"Found conflicting attributes for interface type: [interfaceClass=%s] and [generic=%s], \" +\n                    \"because the 'generic' attribute has higher priority than 'interfaceClass', so change 'interfaceClass' to '%s'. \" +\n                    \"Note: it will make this reference bean as a candidate bean of type '%s' instead of '%s' when resolving dependency in Spring.\",\n                interfaceClass.getName(), generic, GenericService.class.getName(), GenericService.class.getName(), interfaceClass.getName()));\n        }\n        interfaceClass = GenericService.class;\n    } else {\n        try {\n            if (getInterfaceClassLoader() != null && (interfaceClass == null || interfaceClass.getClassLoader() != getInterfaceClassLoader())) {\n                interfaceClass = Class.forName(interfaceName, true, getInterfaceClassLoader());\n            } else if (interfaceClass == null) {\n                interfaceClass = Class.forName(interfaceName, true, Thread.currentThread()\n                        .getContextClassLoader());\n            }\n        } catch (ClassNotFoundException e) {\n            throw new IllegalStateException(e.getMessage(), e);\n        }\n    }\n\n    checkStubAndLocal(interfaceClass);\n    ConfigValidationUtils.checkMock(interfaceClass, this);\n\n    resolveFile();\n    ConfigValidationUtils.validateReferenceConfig(this);\n    postProcessConfig();\n}",
        "summary_tokens": [
            "this",
            "method",
            "should",
            "be",
            "called",
            "right",
            "after",
            "the",
            "creation",
            "of",
            "this",
            "class",
            "s",
            "instance",
            "before",
            "any",
            "property",
            "in",
            "other",
            "config",
            "modules",
            "is",
            "used"
        ]
    },
    {
        "id": 521,
        "code": "protected boolean shouldJvmRefer(Map<String, String> map) {\n    boolean isJvmRefer;\n    if (isInjvm() == null) {\n            \n        if (StringUtils.isNotEmpty(url)) {\n            isJvmRefer = false;\n        } else {\n                \n            URL tmpUrl = new ServiceConfigURL(\"temp\", \"localhost\", 0, map);\n            isJvmRefer = InjvmProtocol.getInjvmProtocol(getScopeModel()).isInjvmRefer(tmpUrl);\n        }\n    } else {\n        isJvmRefer = isInjvm();\n    }\n    return isJvmRefer;\n}",
        "summary_tokens": [
            "figure",
            "out",
            "should",
            "refer",
            "the",
            "service",
            "in",
            "the",
            "same",
            "jvm",
            "from",
            "configurations"
        ]
    },
    {
        "id": 522,
        "code": "public void init() {\n    if (this.initialized.compareAndSet(false, true)) {\n            \n        ExtensionLoader<ServiceListener> extensionLoader = this.getExtensionLoader(ServiceListener.class);\n        this.serviceListeners.addAll(extensionLoader.getSupportedExtensionInstances());\n    }\n    initServiceMetadata(provider);\n    serviceMetadata.setServiceType(getInterfaceClass());\n    serviceMetadata.setTarget(getRef());\n    serviceMetadata.generateServiceKey();\n}",
        "summary_tokens": [
            "for",
            "early",
            "init",
            "service",
            "metadata"
        ]
    },
    {
        "id": 523,
        "code": "private boolean isOnlyInJvm() {\n    return getProtocols().size() == 1\n        && LOCAL_PROTOCOL.equalsIgnoreCase(getProtocols().get(0).getName());\n}",
        "summary_tokens": [
            "determine",
            "if",
            "it",
            "is",
            "injvm"
        ]
    },
    {
        "id": 524,
        "code": "private static String findConfiguredHosts(ProtocolConfig protocolConfig,\n                                          ProviderConfig provider,\n                                          Map<String, String> map) {\n    boolean anyhost = false;\n\n    String hostToBind = getValueFromConfig(protocolConfig, DUBBO_IP_TO_BIND);\n    if (StringUtils.isNotEmpty(hostToBind) && isInvalidLocalHost(hostToBind)) {\n        throw new IllegalArgumentException(\"Specified invalid bind ip from property:\" + DUBBO_IP_TO_BIND + \", value:\" + hostToBind);\n    }\n\n        \n    if (StringUtils.isEmpty(hostToBind)) {\n        hostToBind = protocolConfig.getHost();\n        if (provider != null && StringUtils.isEmpty(hostToBind)) {\n            hostToBind = provider.getHost();\n        }\n        if (isInvalidLocalHost(hostToBind)) {\n            anyhost = true;\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"No valid ip found from environment, try to get local host.\");\n            }\n            hostToBind = getLocalHost();\n        }\n    }\n\n    map.put(BIND_IP_KEY, hostToBind);\n\n        \n    String hostToRegistry = getValueFromConfig(protocolConfig, DUBBO_IP_TO_REGISTRY);\n    if (StringUtils.isNotEmpty(hostToRegistry) && isInvalidLocalHost(hostToRegistry)) {\n        throw new IllegalArgumentException(\"Specified invalid registry ip from property:\" + DUBBO_IP_TO_REGISTRY + \", value:\" + hostToRegistry);\n    } else if (StringUtils.isEmpty(hostToRegistry)) {\n            \n        hostToRegistry = hostToBind;\n    }\n\n    map.put(ANYHOST_KEY, String.valueOf(anyhost));\n\n    return hostToRegistry;\n}",
        "summary_tokens": [
            "register",
            "bind",
            "ip",
            "address",
            "for",
            "service",
            "provider",
            "can",
            "be",
            "configured",
            "separately"
        ]
    },
    {
        "id": 525,
        "code": "private static synchronized Integer findConfiguredPort(ProtocolConfig protocolConfig,\n                                                       ProviderConfig provider,\n                                                       ExtensionLoader<Protocol> extensionLoader,\n                                                       String name, Map<String, String> map) {\n    Integer portToBind;\n\n        \n    String port = getValueFromConfig(protocolConfig, DUBBO_PORT_TO_BIND);\n    portToBind = parsePort(port);\n\n        \n    if (portToBind == null) {\n        portToBind = protocolConfig.getPort();\n        if (provider != null && (portToBind == null || portToBind == 0)) {\n            portToBind = provider.getPort();\n        }\n        final int defaultPort = extensionLoader.getExtension(name).getDefaultPort();\n        if (portToBind == null || portToBind == 0) {\n            portToBind = defaultPort;\n        }\n        if (portToBind <= 0) {\n            portToBind = getRandomPort(name);\n            if (portToBind == null || portToBind < 0) {\n                portToBind = getAvailablePort(defaultPort);\n                putRandomPort(name, portToBind);\n            }\n        }\n    }\n\n        \n    map.put(BIND_PORT_KEY, String.valueOf(portToBind));\n\n        \n    String portToRegistryStr = getValueFromConfig(protocolConfig, DUBBO_PORT_TO_REGISTRY);\n    Integer portToRegistry = parsePort(portToRegistryStr);\n    if (portToRegistry == null) {\n        portToRegistry = portToBind;\n    }\n\n    return portToRegistry;\n}",
        "summary_tokens": [
            "register",
            "port",
            "and",
            "bind",
            "port",
            "for",
            "the",
            "provider",
            "can",
            "be",
            "configured",
            "separately",
            "configuration",
            "priority",
            "environment",
            "variable",
            "java",
            "system",
            "properties",
            "port",
            "property",
            "in",
            "protocol",
            "config",
            "file",
            "protocol",
            "default",
            "port"
        ]
    },
    {
        "id": 526,
        "code": "public static DubboBootstrap getInstance() {\n    if (instance == null) {\n        synchronized (DubboBootstrap.class) {\n            if (instance == null) {\n                instance = DubboBootstrap.getInstance(ApplicationModel.defaultModel());\n            }\n        }\n    }\n    return instance;\n}",
        "summary_tokens": [
            "see",
            "application",
            "model",
            "and",
            "extension",
            "loader",
            "for",
            "why",
            "dubbo",
            "bootstrap",
            "is",
            "designed",
            "to",
            "be",
            "singleton"
        ]
    },
    {
        "id": 527,
        "code": "public static void reset(boolean destroy) {\n    if (destroy) {\n        if (instance != null) {\n            instance.destroy();\n            instance = null;\n        }\n        FrameworkModel.destroyAll();\n    } else {\n        instance = null;\n    }\n\n    ApplicationModel.reset();\n}",
        "summary_tokens": [
            "try",
            "reset",
            "dubbo",
            "status",
            "for",
            "new",
            "instance"
        ]
    },
    {
        "id": 528,
        "code": "public DubboBootstrap start(boolean wait) {\n    Future future = applicationDeployer.start();\n    if (wait) {\n        try {\n            future.get();\n        } catch (Exception e) {\n            throw new IllegalStateException(\"await dubbo application start finish failure\", e);\n        }\n    }\n    return this;\n}",
        "summary_tokens": [
            "start",
            "dubbo",
            "application",
            "wait",
            "if",
            "true",
            "wait",
            "for",
            "startup",
            "to",
            "complete",
            "or",
            "else",
            "no",
            "waiting"
        ]
    },
    {
        "id": 529,
        "code": "public Future asyncStart() {\n    return applicationDeployer.start();\n}",
        "summary_tokens": [
            "start",
            "dubbo",
            "application",
            "but",
            "no",
            "wait",
            "for",
            "finish"
        ]
    },
    {
        "id": 530,
        "code": "public DubboBootstrap stop() throws IllegalStateException {\n    destroy();\n    return this;\n}",
        "summary_tokens": [
            "stop",
            "dubbo",
            "application",
            "illegal",
            "state",
            "exception"
        ]
    },
    {
        "id": 531,
        "code": "public boolean isRunning() {\n    return applicationDeployer.isRunning();\n}",
        "summary_tokens": [
            "true",
            "if",
            "the",
            "dubbo",
            "application",
            "is",
            "starting",
            "or",
            "has",
            "been",
            "started"
        ]
    },
    {
        "id": 532,
        "code": "public boolean isStarting() {\n    return applicationDeployer.isStarting();\n}",
        "summary_tokens": [
            "true",
            "if",
            "the",
            "dubbo",
            "application",
            "is",
            "starting"
        ]
    },
    {
        "id": 533,
        "code": "public boolean isStarted() {\n    return applicationDeployer.isStarted();\n}",
        "summary_tokens": [
            "true",
            "if",
            "the",
            "dubbo",
            "application",
            "has",
            "been",
            "started"
        ]
    },
    {
        "id": 534,
        "code": "public boolean isStopping() {\n    return applicationDeployer.isStopping();\n}",
        "summary_tokens": [
            "true",
            "if",
            "the",
            "dubbo",
            "application",
            "is",
            "stopping"
        ]
    },
    {
        "id": 535,
        "code": "public boolean isStopped() {\n    return applicationDeployer.isStopped();\n}",
        "summary_tokens": [
            "true",
            "if",
            "the",
            "dubbo",
            "application",
            "is",
            "stopping"
        ]
    },
    {
        "id": 536,
        "code": "public DubboBootstrap await() {\n        \n    if (!awaited.get()) {\n        if (!isStopped()) {\n            executeMutually(() -> {\n                while (!awaited.get()) {\n                    if (logger.isInfoEnabled()) {\n                        logger.info(NAME + \" awaiting ...\");\n                    }\n                    try {\n                        condition.await();\n                    } catch (InterruptedException e) {\n                        Thread.currentThread().interrupt();\n                    }\n                }\n            });\n        }\n    }\n    return this;\n}",
        "summary_tokens": [
            "block",
            "current",
            "thread",
            "to",
            "be",
            "await"
        ]
    },
    {
        "id": 537,
        "code": "public DubboBootstrap application(ApplicationConfig applicationConfig) {\n    applicationConfig.setScopeModel(applicationModel);\n    configManager.setApplication(applicationConfig);\n    return this;\n}",
        "summary_tokens": [
            "set",
            "the",
            "application",
            "config"
        ]
    },
    {
        "id": 538,
        "code": "public DubboBootstrap registry(RegistryConfig registryConfig) {\n    registryConfig.setScopeModel(applicationModel);\n    configManager.addRegistry(registryConfig);\n    return this;\n}",
        "summary_tokens": [
            "add",
            "an",
            "instance",
            "of",
            "registry",
            "config"
        ]
    },
    {
        "id": 539,
        "code": "public DubboBootstrap registries(List<RegistryConfig> registryConfigs) {\n    if (CollectionUtils.isEmpty(registryConfigs)) {\n        return this;\n    }\n    registryConfigs.forEach(this::registry);\n    return this;\n}",
        "summary_tokens": [
            "add",
            "an",
            "instance",
            "of",
            "registry",
            "config"
        ]
    },
    {
        "id": 540,
        "code": "public ReferenceBuilder<T> services(String service, String... otherServices) {\n    this.services = toCommaDelimitedString(service, otherServices);\n    return getThis();\n}",
        "summary_tokens": [
            "service",
            "one",
            "service",
            "name",
            "other",
            "services",
            "other",
            "service",
            "names",
            "reference",
            "builder",
            "0"
        ]
    },
    {
        "id": 541,
        "code": "public RegistryBuilder parameter(String name, String value) {\n    return appendParameter(name, value);\n}",
        "summary_tokens": [
            "name",
            "the",
            "parameter",
            "name",
            "value",
            "the",
            "parameter",
            "value",
            "registry",
            "builder",
            "0"
        ]
    },
    {
        "id": 542,
        "code": "private boolean isRegisterConsumerInstance() {\n    Boolean registerConsumer = getApplication().getRegisterConsumer();\n    if (registerConsumer == null) {\n        return true;\n    }\n    return Boolean.TRUE.equals(registerConsumer);\n}",
        "summary_tokens": [
            "close",
            "registration",
            "of",
            "instance",
            "for",
            "pure",
            "consumer",
            "process",
            "by",
            "setting",
            "register",
            "consumer",
            "to",
            "false",
            "by",
            "default",
            "is",
            "true"
        ]
    },
    {
        "id": 543,
        "code": "private void useRegistryAsConfigCenterIfNecessary() {\n        \n    if (environment.getDynamicConfiguration().isPresent()) {\n        return;\n    }\n\n    if (CollectionUtils.isNotEmpty(configManager.getConfigCenters())) {\n        return;\n    }\n\n        \n    configManager.loadConfigsOfTypeFromProps(RegistryConfig.class);\n\n    List<RegistryConfig> defaultRegistries = configManager.getDefaultRegistries();\n    if (defaultRegistries.size() > 0) {\n        defaultRegistries\n            .stream()\n            .filter(this::isUsedRegistryAsConfigCenter)\n            .map(this::registryAsConfigCenter)\n            .forEach(configCenter -> {\n                if (configManager.getConfigCenter(configCenter.getId()).isPresent()) {\n                    return;\n                }\n                configManager.addConfigCenter(configCenter);\n                logger.info(\"use registry as config-center: \" + configCenter);\n\n            });\n    }\n}",
        "summary_tokens": [
            "for",
            "compatibility",
            "purpose",
            "use",
            "registry",
            "as",
            "the",
            "default",
            "config",
            "center",
            "when",
            "there",
            "s",
            "no",
            "config",
            "center",
            "specified",
            "explicitly",
            "and",
            "use",
            "as",
            "config",
            "center",
            "of",
            "registry",
            "config",
            "is",
            "null",
            "or",
            "true"
        ]
    },
    {
        "id": 544,
        "code": "private boolean isUsedRegistryAsCenter(RegistryConfig registryConfig, Supplier<Boolean> usedRegistryAsCenter,\n                                       String centerType,\n                                       Class<?> extensionClass) {\n    final boolean supported;\n\n    Boolean configuredValue = usedRegistryAsCenter.get();\n    if (configuredValue != null) { \n        supported = configuredValue.booleanValue();\n    } else {                       \n        String protocol = registryConfig.getProtocol();\n        supported = supportsExtension(extensionClass, protocol);\n        if (logger.isInfoEnabled()) {\n            logger.info(format(\"No value is configured in the registry, the %s extension[name : %s] %s as the %s center\"\n                , extensionClass.getSimpleName(), protocol, supported ? \"supports\" : \"does not support\", centerType));\n        }\n    }\n\n    if (logger.isInfoEnabled()) {\n        logger.info(format(\"The registry[%s] will be %s as the %s center\", registryConfig,\n            supported ? \"used\" : \"not used\", centerType));\n    }\n    return supported;\n}",
        "summary_tokens": [
            "is",
            "used",
            "the",
            "specified",
            "registry",
            "as",
            "a",
            "center",
            "infrastructure"
        ]
    },
    {
        "id": 545,
        "code": "private boolean supportsExtension(Class<?> extensionClass, String name) {\n    if (isNotEmpty(name)) {\n        ExtensionLoader extensionLoader = getExtensionLoader(extensionClass);\n        return extensionLoader.hasExtension(name);\n    }\n    return false;\n}",
        "summary_tokens": [
            "supports",
            "the",
            "extension",
            "with",
            "the",
            "specified",
            "class",
            "and",
            "name"
        ]
    },
    {
        "id": 546,
        "code": "private DynamicConfiguration getDynamicConfiguration(URL connectionURL) {\n    String protocol = connectionURL.getProtocol();\n\n    DynamicConfigurationFactory factory = ConfigurationUtils.getDynamicConfigurationFactory(applicationModel, protocol);\n    return factory.getDynamicConfiguration(connectionURL);\n}",
        "summary_tokens": [
            "get",
            "the",
            "instance",
            "of",
            "dynamic",
            "configuration",
            "by",
            "the",
            "specified",
            "connection",
            "url",
            "of",
            "config",
            "center"
        ]
    },
    {
        "id": 547,
        "code": "public void prepare() {\n    applicationDeployer.initialize();\n    this.initialize();\n}",
        "summary_tokens": [
            "prepare",
            "for",
            "export",
            "refer",
            "service",
            "trigger",
            "initializing",
            "application",
            "and",
            "module"
        ]
    },
    {
        "id": 548,
        "code": "private void destroyFrameworkResources(FrameworkModel frameworkModel) {\n        \n    destroyProtocols(frameworkModel);\n}",
        "summary_tokens": [
            "destroy",
            "all",
            "framework",
            "resources"
        ]
    },
    {
        "id": 549,
        "code": "private void destroyProtocols(FrameworkModel frameworkModel) {\n    if (protocolDestroyed.compareAndSet(false, true)) {\n        ExtensionLoader<Protocol> loader = frameworkModel.getExtensionLoader(Protocol.class);\n        for (String protocolName : loader.getLoadedExtensions()) {\n            try {\n                Protocol protocol = loader.getLoadedExtension(protocolName);\n                if (protocol != null) {\n                    protocol.destroy();\n                }\n            } catch (Throwable t) {\n                logger.warn(t.getMessage(), t);\n            }\n        }\n    }\n}",
        "summary_tokens": [
            "destroy",
            "all",
            "the",
            "protocols"
        ]
    },
    {
        "id": 550,
        "code": "private List<MethodConfig> generateMethodConfig() {\n    MethodConfig methodConfig = new MethodConfig();\n    methodConfig.setName(\"getAndListenInstanceMetadata\");\n\n    ArgumentConfig argumentConfig = new ArgumentConfig();\n    argumentConfig.setIndex(1);\n    argumentConfig.setCallback(true);\n\n    methodConfig.setArguments(Collections.singletonList(argumentConfig));\n\n    return Collections.singletonList(methodConfig);\n}",
        "summary_tokens": [
            "generate",
            "method",
            "config",
            "for",
            "service",
            "discovery",
            "metadata",
            "p",
            "p",
            "make",
            "metadata",
            "service",
            "support",
            "argument",
            "callback",
            "used",
            "to",
            "notify",
            "org"
        ]
    },
    {
        "id": 551,
        "code": "public static void checkMock(Class<?> interfaceClass, AbstractInterfaceConfig config) {\n    String mock = config.getMock();\n    if (ConfigUtils.isEmpty(mock)) {\n        return;\n    }\n\n    String normalizedMock = MockInvoker.normalizeMock(mock);\n    if (normalizedMock.startsWith(RETURN_PREFIX)) {\n        normalizedMock = normalizedMock.substring(RETURN_PREFIX.length()).trim();\n        try {\n                \n            MockInvoker.parseMockValue(normalizedMock);\n        } catch (Exception e) {\n            throw new IllegalStateException(\"Illegal mock return in <dubbo:service/reference ... \" +\n                \"mock=\\\"\" + mock + \"\\\" />\");\n        }\n    } else if (normalizedMock.startsWith(THROW_PREFIX)) {\n        normalizedMock = normalizedMock.substring(THROW_PREFIX.length()).trim();\n        if (ConfigUtils.isNotEmpty(normalizedMock)) {\n            try {\n                    \n                MockInvoker.getThrowable(normalizedMock);\n            } catch (Exception e) {\n                throw new IllegalStateException(\"Illegal mock throw in <dubbo:service/reference ... \" +\n                    \"mock=\\\"\" + mock + \"\\\" />\");\n            }\n        }\n    } else {\n            \n        MockInvoker.getMockObject(config.getScopeModel().getExtensionDirector(), normalizedMock, interfaceClass);\n    }\n}",
        "summary_tokens": [
            "legitimacy",
            "check",
            "and",
            "setup",
            "of",
            "local",
            "simulated",
            "operations"
        ]
    },
    {
        "id": 552,
        "code": "public static void checkMultiExtension(ScopeModel scopeModel, Class<?> type, String property, String value) {\n    checkMultiExtension(scopeModel,Collections.singletonList(type), property, value);\n}",
        "summary_tokens": [
            "check",
            "whether",
            "there",
            "is",
            "a",
            "code",
            "extension",
            "code",
            "who",
            "s",
            "name",
            "property",
            "is",
            "code",
            "value",
            "code",
            "special",
            "treatment",
            "is",
            "required"
        ]
    },
    {
        "id": 553,
        "code": "public static SimpleReferenceCache getCache(String name, KeyGenerator keyGenerator) {\n    return CACHE_HOLDER.computeIfAbsent(name, k -> new SimpleReferenceCache(k, keyGenerator));\n}",
        "summary_tokens": [
            "get",
            "the",
            "cache",
            "use",
            "specified",
            "key",
            "generator"
        ]
    },
    {
        "id": 554,
        "code": "public <T> T get(Class<T> type) {\n    List<ReferenceConfigBase<?>> referenceConfigBases = referenceTypeMap.get(type);\n    if (CollectionUtils.isNotEmpty(referenceConfigBases)) {\n        return (T) referenceConfigBases.get(0).get();\n    }\n    return null;\n}",
        "summary_tokens": [
            "check",
            "and",
            "return",
            "existing",
            "reference",
            "config",
            "and",
            "its",
            "corresponding",
            "proxy",
            "instance"
        ]
    },
    {
        "id": 555,
        "code": "public <T> void destroy(ReferenceConfigBase<T> referenceConfig) {\n    String key = generator.generateKey(referenceConfig);\n    Class<?> type = referenceConfig.getInterfaceClass();\n    destroy(key, type);\n}",
        "summary_tokens": [
            "clear",
            "and",
            "destroy",
            "one",
            "reference",
            "config",
            "base",
            "in",
            "the",
            "cache"
        ]
    },
    {
        "id": 556,
        "code": "public void destroyAll() {\n    if (CollectionUtils.isEmptyMap(referenceKeyMap)) {\n        return;\n    }\n\n    referenceKeyMap.forEach((_k, referencesOfKey) -> {\n        for (ReferenceConfigBase<?> rc : referencesOfKey) {\n            destroyReference(rc);\n        }\n    });\n\n    referenceKeyMap.clear();\n    referenceTypeMap.clear();\n}",
        "summary_tokens": [
            "clear",
            "and",
            "destroy",
            "all",
            "reference",
            "config",
            "base",
            "in",
            "the",
            "cache"
        ]
    },
    {
        "id": 557,
        "code": "public void testAppendConfig() {\n\n    ApplicationConfig applicationConfig = new ApplicationConfig();\n    applicationConfig.setName(\"application1\");\n    applicationConfig.setVersion(\"v1\");\n    applicationConfig.setOwner(\"owner1\");\n    applicationConfig.setOrganization(\"bu1\");\n    applicationConfig.setArchitecture(\"architecture1\");\n    applicationConfig.setEnvironment(\"test\");\n    applicationConfig.setCompiler(\"javassist\");\n    applicationConfig.setLogger(\"log4j\");\n    applicationConfig.setDumpDirectory(\"/\");\n    applicationConfig.setQosEnable(false);\n    applicationConfig.setQosHost(\"127.0.0.1\");\n    applicationConfig.setQosPort(77777);\n    applicationConfig.setQosAcceptForeignIp(false);\n    Map<String, String> parameters = new HashMap<>();\n    parameters.put(\"key1\", \"value1\");\n    parameters.put(\"key2\", \"value2\");\n    applicationConfig.setParameters(parameters);\n    applicationConfig.setShutwait(\"5\");\n    applicationConfig.setMetadataType(\"local\");\n    applicationConfig.setRegisterConsumer(false);\n    applicationConfig.setRepository(\"repository1\");\n    applicationConfig.setEnableFileCache(false);\n    applicationConfig.setProtocol(\"dubbo\");\n    applicationConfig.setMetadataServicePort(88888);\n    applicationConfig.setMetadataServiceProtocol(\"tri\");\n    applicationConfig.setLivenessProbe(\"livenessProbe\");\n    applicationConfig.setReadinessProbe(\"readinessProb\");\n    applicationConfig.setStartupProbe(\"startupProbe\");\n\n    ReferenceConfig<DemoService> referenceConfig = new ReferenceConfig<>();\n    referenceConfig.setClient(\"netty\");\n    referenceConfig.setGeneric(Boolean.FALSE.toString());\n    referenceConfig.setProtocol(\"dubbo\");\n    referenceConfig.setInit(true);\n    referenceConfig.setLazy(false);\n    referenceConfig.setInjvm(false);\n    referenceConfig.setReconnect(\"reconnect\");\n    referenceConfig.setSticky(false);\n    referenceConfig.setStub(DEFAULT_STUB_EVENT);\n    referenceConfig.setRouter(\"default\");\n    referenceConfig.setReferAsync(true);\n\n    MonitorConfig monitorConfig = new MonitorConfig();\n    applicationConfig.setMonitor(monitorConfig);\n\n    ModuleConfig moduleConfig = new ModuleConfig();\n    moduleConfig.setMonitor(\"default\");\n    moduleConfig.setName(\"module1\");\n    moduleConfig.setOrganization(\"application1\");\n    moduleConfig.setVersion(\"v1\");\n    moduleConfig.setOwner(\"owner1\");\n\n    ConsumerConfig consumerConfig = new ConsumerConfig();\n    consumerConfig.setClient(\"netty\");\n    consumerConfig.setThreadpool(\"fixed\");\n    consumerConfig.setCorethreads(200);\n    consumerConfig.setQueues(500);\n    consumerConfig.setThreads(300);\n    consumerConfig.setShareconnections(10);\n    consumerConfig.setUrlMergeProcessor(\"default\");\n    consumerConfig.setReferThreadNum(20);\n    consumerConfig.setReferBackground(false);\n    referenceConfig.setConsumer(consumerConfig);\n\n    MethodConfig methodConfig = new MethodConfig();\n    methodConfig.setName(\"sayName\");\n    methodConfig.setStat(1);\n    methodConfig.setRetries(0);\n    methodConfig.setExecutes(10);\n    methodConfig.setDeprecated(false);\n    methodConfig.setSticky(false);\n    methodConfig.setReturn(false);\n    methodConfig.setService(\"service\");\n    methodConfig.setServiceId(DemoService.class.getName());\n    methodConfig.setParentPrefix(\"demo\");\n\n    referenceConfig.setMethods(Collections.singletonList(methodConfig));\n\n    referenceConfig.setInterface(DemoService.class);\n    referenceConfig.getInterfaceClass();\n    referenceConfig.setCheck(false);\n    RegistryConfig registry = new RegistryConfig();\n    registry.setAddress(zkUrl1);\n    applicationConfig.setRegistries(Collections.singletonList(registry));\n    applicationConfig.setRegistryIds(registry.getId());\n    moduleConfig.setRegistries(Collections.singletonList(registry));\n\n    referenceConfig.setRegistry(registry);\n\n    DubboBootstrap dubboBootstrap = DubboBootstrap.newInstance(FrameworkModel.defaultModel());\n    dubboBootstrap.application(applicationConfig)\n        .reference(referenceConfig)\n        .registry(registry)\n        .module(moduleConfig)\n        .initialize();\n\n    referenceConfig.init();\n\n    ServiceMetadata serviceMetadata = referenceConfig.getServiceMetadata();\n\n        \n    Assertions.assertEquals(CONSUMER_SIDE, serviceMetadata.getAttachments().get(SIDE_KEY));\n\n        \n    Assertions.assertEquals(DemoService.class.getName(), serviceMetadata.getAttachments().get(INTERFACE_KEY));\n\n        \n    Assertions.assertEquals(DEFAULT_METADATA_STORAGE_TYPE, serviceMetadata.getAttachments().get(METADATA_KEY));\n\n        \n    Assertions.assertEquals(NetUtils.getLocalHost(), serviceMetadata.getAttachments().get(REGISTER_IP_KEY));\n\n        \n    Assertions.assertEquals(Version.getProtocolVersion(), serviceMetadata.getAttachments().get(DUBBO_VERSION_KEY));\n    Assertions.assertEquals(Version.getVersion(), serviceMetadata.getAttachments().get(RELEASE_KEY));\n    Assertions.assertTrue(serviceMetadata.getAttachments().containsKey(TIMESTAMP_KEY));\n    Assertions.assertEquals(String.valueOf(ConfigUtils.getPid()), serviceMetadata.getAttachments().get(PID_KEY));\n\n        \n    Assertions.assertEquals(applicationConfig.getName(), serviceMetadata.getAttachments().get(APPLICATION_KEY));\n    Assertions.assertEquals(applicationConfig.getOwner(), serviceMetadata.getAttachments().get(\"owner\"));\n    Assertions.assertEquals(applicationConfig.getVersion(),\n        serviceMetadata.getAttachments().get(APPLICATION_VERSION_KEY));\n    Assertions.assertEquals(applicationConfig.getOrganization(),\n        serviceMetadata.getAttachments().get(\"organization\"));\n    Assertions.assertEquals(applicationConfig.getArchitecture(),\n        serviceMetadata.getAttachments().get(\"architecture\"));\n    Assertions.assertEquals(applicationConfig.getEnvironment(),\n        serviceMetadata.getAttachments().get(\"environment\"));\n    Assertions.assertEquals(applicationConfig.getCompiler(), serviceMetadata.getAttachments().get(\"compiler\"));\n    Assertions.assertEquals(applicationConfig.getLogger(), serviceMetadata.getAttachments().get(\"logger\"));\n    Assertions.assertFalse(serviceMetadata.getAttachments().containsKey(\"registries\"));\n    Assertions.assertFalse(serviceMetadata.getAttachments().containsKey(\"registry.ids\"));\n    Assertions.assertFalse(serviceMetadata.getAttachments().containsKey(\"monitor\"));\n    Assertions.assertEquals(applicationConfig.getDumpDirectory(),\n        serviceMetadata.getAttachments().get(DUMP_DIRECTORY));\n    Assertions.assertEquals(applicationConfig.getQosEnable().toString(),\n        serviceMetadata.getAttachments().get(QOS_ENABLE));\n    Assertions.assertEquals(applicationConfig.getQosHost(),\n        serviceMetadata.getAttachments().get(QOS_HOST));\n    Assertions.assertEquals(applicationConfig.getQosPort().toString(),\n        serviceMetadata.getAttachments().get(QOS_PORT));\n    Assertions.assertEquals(applicationConfig.getQosAcceptForeignIp().toString(),\n        serviceMetadata.getAttachments().get(ACCEPT_FOREIGN_IP));\n    Assertions.assertEquals(applicationConfig.getParameters().get(\"key1\"),\n        serviceMetadata.getAttachments().get(\"key1\"));\n    Assertions.assertEquals(applicationConfig.getParameters().get(\"key2\"),\n        serviceMetadata.getAttachments().get(\"key2\"));\n    Assertions.assertEquals(applicationConfig.getShutwait(),\n        serviceMetadata.getAttachments().get(\"shutwait\"));\n    Assertions.assertEquals(applicationConfig.getMetadataType(),\n        serviceMetadata.getAttachments().get(METADATA_KEY));\n    Assertions.assertEquals(applicationConfig.getRegisterConsumer().toString(),\n        serviceMetadata.getAttachments().get(\"register.consumer\"));\n    Assertions.assertEquals(applicationConfig.getRepository(),\n        serviceMetadata.getAttachments().get(\"repository\"));\n    Assertions.assertEquals(applicationConfig.getEnableFileCache().toString(),\n        serviceMetadata.getAttachments().get(REGISTRY_LOCAL_FILE_CACHE_ENABLED));\n    Assertions.assertEquals(applicationConfig.getMetadataServicePort().toString(),\n        serviceMetadata.getAttachments().get(METADATA_SERVICE_PORT_KEY));\n    Assertions.assertEquals(applicationConfig.getMetadataServiceProtocol().toString(),\n        serviceMetadata.getAttachments().get(METADATA_SERVICE_PROTOCOL_KEY));\n    Assertions.assertEquals(applicationConfig.getLivenessProbe(),\n        serviceMetadata.getAttachments().get(LIVENESS_PROBE_KEY));\n    Assertions.assertEquals(applicationConfig.getReadinessProbe(),\n        serviceMetadata.getAttachments().get(READINESS_PROBE_KEY));\n    Assertions.assertEquals(applicationConfig.getStartupProbe(),\n        serviceMetadata.getAttachments().get(STARTUP_PROBE));\n\n        \n    Assertions.assertEquals(moduleConfig.getName(), serviceMetadata.getAttachments().get(\"module\"));\n    Assertions.assertFalse(serviceMetadata.getAttachments().containsKey(\"monitor\"));\n    Assertions.assertEquals(moduleConfig.getOrganization(),\n        serviceMetadata.getAttachments().get(\"module.organization\"));\n    Assertions.assertEquals(moduleConfig.getOwner(), serviceMetadata.getAttachments().get(\"module.owner\"));\n    Assertions.assertFalse(serviceMetadata.getAttachments().containsKey(\"registries\"));\n    Assertions.assertEquals(moduleConfig.getVersion(), serviceMetadata.getAttachments().get(\"module.version\"));\n\n        \n    Assertions.assertEquals(consumerConfig.getClient(), serviceMetadata.getAttachments().get(\"client\"));\n    Assertions.assertEquals(consumerConfig.getThreadpool(), serviceMetadata.getAttachments().get(\"threadpool\"));\n    Assertions.assertEquals(consumerConfig.getCorethreads().toString(),\n        serviceMetadata.getAttachments().get(\"corethreads\"));\n    Assertions.assertEquals(consumerConfig.getQueues().toString(),\n        serviceMetadata.getAttachments().get(\"queues\"));\n    Assertions.assertEquals(consumerConfig.getThreads().toString(),\n        serviceMetadata.getAttachments().get(\"threads\"));\n    Assertions.assertEquals(consumerConfig.getShareconnections().toString(),\n        serviceMetadata.getAttachments().get(\"shareconnections\"));\n    Assertions.assertEquals(consumerConfig.getUrlMergeProcessor(),\n        serviceMetadata.getAttachments().get(URL_MERGE_PROCESSOR_KEY));\n    Assertions.assertFalse(serviceMetadata.getAttachments().containsKey(REFER_THREAD_NUM_KEY));\n    Assertions.assertFalse(serviceMetadata.getAttachments().containsKey(REFER_BACKGROUND_KEY));\n\n        \n    Assertions.assertEquals(referenceConfig.getClient(), serviceMetadata.getAttachments().get(\"client\"));\n    Assertions.assertEquals(referenceConfig.getGeneric(), serviceMetadata.getAttachments().get(\"generic\"));\n    Assertions.assertEquals(referenceConfig.getProtocol(), serviceMetadata.getAttachments().get(\"protocol\"));\n    Assertions.assertEquals(referenceConfig.isInit().toString(), serviceMetadata.getAttachments().get(\"init\"));\n    Assertions.assertEquals(referenceConfig.getLazy().toString(), serviceMetadata.getAttachments().get(\"lazy\"));\n    Assertions.assertEquals(referenceConfig.isInjvm().toString(), serviceMetadata.getAttachments().get(\"injvm\"));\n    Assertions.assertEquals(referenceConfig.getReconnect(), serviceMetadata.getAttachments().get(\"reconnect\"));\n    Assertions.assertEquals(referenceConfig.getSticky().toString(), serviceMetadata.getAttachments().get(\"sticky\"));\n    Assertions.assertEquals(referenceConfig.getStub(), serviceMetadata.getAttachments().get(\"stub\"));\n    Assertions.assertEquals(referenceConfig.getProvidedBy(), serviceMetadata.getAttachments().get(\"provided-by\"));\n    Assertions.assertEquals(referenceConfig.getRouter(), serviceMetadata.getAttachments().get(\"router\"));\n    Assertions.assertEquals(referenceConfig.getReferAsync().toString(),\n        serviceMetadata.getAttachments().get(REFER_ASYNC_KEY));\n\n        \n    Assertions.assertFalse(serviceMetadata.getAttachments().containsKey(\"name\"));\n    Assertions.assertEquals(methodConfig.getStat().toString(),\n        serviceMetadata.getAttachments().get(\"sayName.stat\"));\n    Assertions.assertEquals(methodConfig.getRetries().toString(),\n        serviceMetadata.getAttachments().get(\"sayName.retries\"));\n    Assertions.assertFalse(serviceMetadata.getAttachments().containsKey(\"sayName.reliable\"));\n    Assertions.assertEquals(methodConfig.getExecutes().toString(),\n        serviceMetadata.getAttachments().get(\"sayName.executes\"));\n    Assertions.assertEquals(methodConfig.getDeprecated().toString(),\n        serviceMetadata.getAttachments().get(\"sayName.deprecated\"));\n    Assertions.assertFalse(serviceMetadata.getAttachments().containsKey(\"sayName.stick\"));\n    Assertions.assertEquals(methodConfig.isReturn().toString(),\n        serviceMetadata.getAttachments().get(\"sayName.return\"));\n    Assertions.assertFalse(serviceMetadata.getAttachments().containsKey(\"sayName.service\"));\n    Assertions.assertFalse(serviceMetadata.getAttachments().containsKey(\"sayName.service.id\"));\n    Assertions.assertFalse(serviceMetadata.getAttachments().containsKey(\"sayName.parent.prefix\"));\n\n        \n    Assertions.assertEquals(Version.getVersion(referenceConfig.getInterfaceClass(), referenceConfig.getVersion()),\n        serviceMetadata.getAttachments().get(REVISION_KEY));\n    Assertions.assertTrue(serviceMetadata.getAttachments().containsKey(METHODS_KEY));\n    Assertions.assertEquals(DemoService.class.getMethods().length,\n        StringUtils.split((String) serviceMetadata.getAttachments().get(METHODS_KEY), ',').length);\n\n    dubboBootstrap.stop();\n}",
        "summary_tokens": [
            "test",
            "whether",
            "the",
            "configuration",
            "required",
            "for",
            "the",
            "aggregation",
            "service",
            "reference",
            "meets",
            "expectations"
        ]
    },
    {
        "id": 558,
        "code": "public void testCreateInvokerForRemoteRefer() {\n\n    ReferenceConfig<DemoService> referenceConfig = new ReferenceConfig<>();\n    referenceConfig.setGeneric(Boolean.FALSE.toString());\n    referenceConfig.setProtocol(\"dubbo\");\n    referenceConfig.setInit(true);\n    referenceConfig.setLazy(false);\n    referenceConfig.setInjvm(false);\n\n    DubboBootstrap dubboBootstrap = DubboBootstrap.newInstance(FrameworkModel.defaultModel());\n\n    ApplicationConfig applicationConfig = new ApplicationConfig();\n    applicationConfig.setName(\"application1\");\n    Map<String, String> parameters = new HashMap<>();\n    parameters.put(\"key1\", \"value1\");\n    parameters.put(\"key2\", \"value2\");\n    applicationConfig.setParameters(parameters);\n\n    referenceConfig.refreshed.set(true);\n    referenceConfig.setInterface(DemoService.class);\n    referenceConfig.getInterfaceClass();\n    referenceConfig.setCheck(false);\n    RegistryConfig registry = new RegistryConfig();\n    registry.setAddress(zkUrl1);\n    applicationConfig.setRegistries(Collections.singletonList(registry));\n    applicationConfig.setRegistryIds(registry.getId());\n\n    referenceConfig.setRegistry(registry);\n\n    dubboBootstrap\n        .application(applicationConfig)\n        .reference(referenceConfig)\n        .initialize();\n\n    referenceConfig.init();\n    Assertions.assertTrue(referenceConfig.getInvoker() instanceof MigrationInvoker);\n\n    dubboBootstrap.destroy();\n}",
        "summary_tokens": [
            "verify",
            "the",
            "configuration",
            "of",
            "the",
            "registry",
            "protocol",
            "for",
            "remote",
            "reference"
        ]
    },
    {
        "id": 559,
        "code": "public void testCreateInvokerWithRemoteUrlForRemoteRefer() {\n\n    ReferenceConfig<DemoService> referenceConfig = new ReferenceConfig<>();\n    referenceConfig.setGeneric(Boolean.FALSE.toString());\n    referenceConfig.setProtocol(\"dubbo\");\n    referenceConfig.setInit(true);\n    referenceConfig.setLazy(false);\n    referenceConfig.setInjvm(false);\n\n    DubboBootstrap dubboBootstrap = DubboBootstrap.newInstance(FrameworkModel.defaultModel());\n\n    ApplicationConfig applicationConfig = new ApplicationConfig();\n    applicationConfig.setName(\"application1\");\n    Map<String, String> parameters = new HashMap<>();\n    parameters.put(\"key1\", \"value1\");\n    parameters.put(\"key2\", \"value2\");\n    applicationConfig.setParameters(parameters);\n\n    referenceConfig.refreshed.set(true);\n    referenceConfig.setInterface(DemoService.class);\n    referenceConfig.getInterfaceClass();\n    referenceConfig.setCheck(false);\n\n    referenceConfig.setUrl(\"dubbo://127.0.0.1:20880\");\n\n    dubboBootstrap\n        .application(applicationConfig)\n        .reference(referenceConfig)\n        .initialize();\n\n    referenceConfig.init();\n    Assertions.assertTrue(referenceConfig.getInvoker() instanceof MockClusterInvoker);\n    Assertions.assertEquals(Boolean.TRUE, referenceConfig.getInvoker().getUrl().getAttribute(PEER_KEY));\n    dubboBootstrap.destroy();\n\n}",
        "summary_tokens": [
            "verify",
            "that",
            "the",
            "remote",
            "url",
            "is",
            "directly",
            "configured",
            "for",
            "remote",
            "reference"
        ]
    },
    {
        "id": 560,
        "code": "public void testCreateInvokerWithRegistryUrlForRemoteRefer() {\n\n    ReferenceConfig<DemoService> referenceConfig = new ReferenceConfig<>();\n    referenceConfig.setGeneric(Boolean.FALSE.toString());\n    referenceConfig.setProtocol(\"dubbo\");\n    referenceConfig.setInit(true);\n    referenceConfig.setLazy(false);\n    referenceConfig.setInjvm(false);\n\n    DubboBootstrap dubboBootstrap = DubboBootstrap.newInstance(FrameworkModel.defaultModel());\n\n    ApplicationConfig applicationConfig = new ApplicationConfig();\n    applicationConfig.setName(\"application1\");\n    Map<String, String> parameters = new HashMap<>();\n    parameters.put(\"key1\", \"value1\");\n    parameters.put(\"key2\", \"value2\");\n    applicationConfig.setParameters(parameters);\n\n    referenceConfig.refreshed.set(true);\n    referenceConfig.setInterface(DemoService.class);\n    referenceConfig.getInterfaceClass();\n    referenceConfig.setCheck(false);\n\n    referenceConfig.setUrl(registryUrl1);\n\n    dubboBootstrap\n        .application(applicationConfig)\n        .reference(referenceConfig)\n        .initialize();\n\n    referenceConfig.init();\n    Assertions.assertTrue(referenceConfig.getInvoker() instanceof MigrationInvoker);\n    dubboBootstrap.destroy();\n\n}",
        "summary_tokens": [
            "verify",
            "that",
            "the",
            "registry",
            "url",
            "is",
            "directly",
            "configured",
            "for",
            "remote",
            "reference"
        ]
    },
    {
        "id": 561,
        "code": "public void testMultipleRegistryForRemoteRefer() {\n    ReferenceConfig<DemoService> referenceConfig = new ReferenceConfig<>();\n    referenceConfig.setGeneric(Boolean.FALSE.toString());\n    referenceConfig.setProtocol(\"dubbo\");\n    referenceConfig.setInit(true);\n    referenceConfig.setLazy(false);\n    referenceConfig.setInjvm(false);\n\n    DubboBootstrap dubboBootstrap = DubboBootstrap.newInstance(FrameworkModel.defaultModel());\n\n    ApplicationConfig applicationConfig = new ApplicationConfig();\n    applicationConfig.setName(\"application1\");\n    Map<String, String> parameters = new HashMap<>();\n    parameters.put(\"key1\", \"value1\");\n    parameters.put(\"key2\", \"value2\");\n    applicationConfig.setParameters(parameters);\n\n    referenceConfig.refreshed.set(true);\n    referenceConfig.setInterface(DemoService.class);\n    referenceConfig.getInterfaceClass();\n    referenceConfig.setCheck(false);\n    RegistryConfig registry1 = new RegistryConfig();\n    registry1.setAddress(zkUrl1);\n    registry1.setId(\"zk1\");\n\n    RegistryConfig registry2 = new RegistryConfig();\n    registry2.setAddress(zkUrl2);\n    registry2.setId(\"zk2\");\n\n    List<RegistryConfig> registryConfigs = new ArrayList<>();\n    registryConfigs.add(registry1);\n    registryConfigs.add(registry2);\n    applicationConfig.setRegistries(registryConfigs);\n    applicationConfig.setRegistryIds(\"zk1,zk2\");\n\n    referenceConfig.setRegistries(registryConfigs);\n\n    dubboBootstrap\n        .application(applicationConfig)\n        .reference(referenceConfig)\n        .initialize();\n\n    referenceConfig.init();\n    Assertions.assertTrue(referenceConfig.getInvoker() instanceof ZoneAwareClusterInvoker);\n\n    dubboBootstrap.destroy();\n}",
        "summary_tokens": [
            "verify",
            "the",
            "service",
            "reference",
            "of",
            "multiple",
            "registries"
        ]
    },
    {
        "id": 562,
        "code": "public void test1ReferenceRetry() {\n    ApplicationConfig application = new ApplicationConfig();\n    application.setName(\"test-reference-retry\");\n    application.setEnableFileCache(false);\n    ApplicationModel.defaultModel().getApplicationConfigManager().setApplication(application);\n\n    RegistryConfig registry = new RegistryConfig();\n    registry.setAddress(zkUrl1);\n\n    ReferenceConfig<DemoService> rc = new ReferenceConfig<>();\n    rc.setRegistry(registry);\n    rc.setInterface(DemoService.class.getName());\n\n    boolean success = false;\n    DemoService demoService = null;\n    try {\n        demoService = rc.get();\n        success = true;\n    } catch (Exception e) {\n            \n    }\n    Assertions.assertFalse(success);\n    Assertions.assertNull(demoService);\n\n    try {\n        System.setProperty(\"java.net.preferIPv4Stack\", \"true\");\n        ProxyFactory proxy = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();\n        DemoService service = new DemoServiceImpl();\n        URL url = URL.valueOf(\"dubbo://127.0.0.1/DemoService\")\n            .addParameter(INTERFACE_KEY, DemoService.class.getName());\n        InjvmProtocol.getInjvmProtocol(FrameworkModel.defaultModel()).export(proxy.getInvoker(service, DemoService.class, url));\n        demoService = rc.get();\n        success = true;\n    } catch (Exception e) {\n            \n    } finally {\n        rc.destroy();\n        InjvmProtocol.getInjvmProtocol(FrameworkModel.defaultModel()).destroy();\n        System.clearProperty(\"java.net.preferIPv4Stack\");\n\n    }\n    Assertions.assertTrue(success);\n    Assertions.assertNotNull(demoService);\n\n}",
        "summary_tokens": [
            "unit",
            "test",
            "for",
            "dubbo",
            "0"
        ]
    },
    {
        "id": 563,
        "code": "public List<Exporter<?>> getExportedExporters() {\n    return Collections.unmodifiableList(exportedExporters);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "exported",
            "exporters"
        ]
    },
    {
        "id": 564,
        "code": "private FilterChainBuilder.CopyOfFilterChainNode getFilterChainNode(FilterChainBuilder.CallbackRegistrationInvoker callbackRegistrationInvoker) {\n    if (callbackRegistrationInvoker != null) {\n        Field field = null;\n        try {\n            field = callbackRegistrationInvoker.getClass().getDeclaredField(\"filterInvoker\");\n            field.setAccessible(true);\n            return (FilterChainBuilder.CopyOfFilterChainNode) field.get(callbackRegistrationInvoker);\n        } catch (NoSuchFieldException | IllegalAccessException e) {\n                \n        }\n    }\n    return null;\n}",
        "summary_tokens": [
            "use",
            "reflection",
            "to",
            "obtain",
            "filter"
        ]
    },
    {
        "id": 565,
        "code": "private Filter getFilter(FilterChainBuilder.CopyOfFilterChainNode filterChainNode) {\n    if (filterChainNode != null) {\n        Field field = null;\n        try {\n            field = filterChainNode.getClass().getDeclaredField(\"filter\");\n            field.setAccessible(true);\n            return (Filter) field.get(filterChainNode);\n        } catch (NoSuchFieldException | IllegalAccessException e) {\n                \n        }\n    }\n    return null;\n}",
        "summary_tokens": [
            "use",
            "reflection",
            "to",
            "obtain",
            "filter"
        ]
    },
    {
        "id": 566,
        "code": "private FilterChainBuilder.CopyOfFilterChainNode getNextNode(FilterChainBuilder.CopyOfFilterChainNode filterChainNode) {\n    if (filterChainNode != null) {\n        Field field = null;\n        try {\n            field = filterChainNode.getClass().getDeclaredField(\"nextNode\");\n            field.setAccessible(true);\n            Object object = field.get(filterChainNode);\n            if (object instanceof FilterChainBuilder.CopyOfFilterChainNode) {\n                return (FilterChainBuilder.CopyOfFilterChainNode) object;\n            }\n        } catch (NoSuchFieldException | IllegalAccessException e) {\n                \n        }\n    }\n    return null;\n}",
        "summary_tokens": [
            "use",
            "reflection",
            "to",
            "obtain",
            "filter",
            "chain",
            "builder"
        ]
    },
    {
        "id": 567,
        "code": "public List<ServiceConfig> getExportedServices() {\n    return Collections.unmodifiableList(exportedServices);\n}",
        "summary_tokens": [
            "return",
            "all",
            "exported",
            "services"
        ]
    },
    {
        "id": 568,
        "code": "private String generateKey(String host, int port) {\n    return String.format(\"%s:%d\", host, port);\n}",
        "summary_tokens": [
            "generate",
            "the",
            "key",
            "for",
            "storage"
        ]
    },
    {
        "id": 569,
        "code": "protected Class<?> getInterface() {\n    return MetadataService.class;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "interface",
            "of",
            "exported",
            "service"
        ]
    },
    {
        "id": 570,
        "code": "private void beforeExport() {\n        \n    serviceListener = (MultipleRegistryCenterExportMetadataServiceListener) ExtensionLoader.getExtensionLoader(ServiceListener.class).getExtension(SPI_NAME);\n    exporterListener = (MultipleRegistryCenterExportMetadataExporterListener) ExtensionLoader.getExtensionLoader(ExporterListener.class).getExtension(SPI_NAME);\n\n        \n        \n    Assertions.assertTrue(serviceListener.getExportedServices().isEmpty());\n        \n    Assertions.assertTrue(exporterListener.getExportedExporters().isEmpty());\n        \n    Assertions.assertFalse(serviceConfig.isExported());\n}",
        "summary_tokens": [
            "define",
            "service",
            "listener",
            "exporter",
            "listener",
            "and",
            "filter",
            "for",
            "helping",
            "check"
        ]
    },
    {
        "id": 571,
        "code": "private void afterExport() {\n        \n    Assertions.assertEquals(serviceListener.getExportedServices().size(), 1);\n        \n    Assertions.assertEquals(serviceListener.getExportedServices().get(0).getInterfaceClass(),\n        MetadataService.class);\n        \n    Assertions.assertTrue(serviceListener.getExportedServices().get(0).isExported());\n        \n        \n        \n        \n        \n        \n    Assertions.assertEquals(exporterListener.getExportedExporters().size(), 2);\n        \n    Exporter<?> injvmExporter = (Exporter<?>) exporterListener.getExportedExporters()\n        .stream()\n        .filter(\n            exporter -> PROTOCOL_NAME.equalsIgnoreCase(exporter.getInvoker().getUrl().getProtocol())\n        )\n        .findFirst()\n        .get();\n        \n    Exporter<?> metadataExporter = (Exporter<?>) exporterListener.getExportedExporters()\n        .stream()\n        .filter(\n            exporter -> !PROTOCOL_NAME.equalsIgnoreCase(exporter.getInvoker().getUrl().getProtocol())\n        )\n        .filter(\n            exporter -> exporter.getInvoker().getInterface().equals(MetadataService.class)\n        )\n        .findFirst()\n        .get();\n        \n    Assertions.assertNotNull(injvmExporter);\n        \n    Assertions.assertNotNull(metadataExporter);\n}",
        "summary_tokens": [
            "there",
            "are",
            "some",
            "checkpoints",
            "need",
            "to",
            "check",
            "after",
            "exported",
            "as",
            "follow",
            "ul",
            "li",
            "the",
            "metadata",
            "service",
            "is",
            "only",
            "one",
            "or",
            "not",
            "li",
            "li",
            "the",
            "exported",
            "service",
            "is",
            "metadata",
            "service",
            "or",
            "not",
            "li",
            "li",
            "the",
            "metadata",
            "service",
            "is",
            "exported",
            "or",
            "not",
            "li",
            "li",
            "the",
            "exported",
            "exporters",
            "are",
            "right",
            "or",
            "not",
            "li",
            "ul"
        ]
    },
    {
        "id": 572,
        "code": "protected Class<?> getInterface() {\n    return MultipleRegistryCenterExportProviderService.class;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "interface",
            "of",
            "exported",
            "service"
        ]
    },
    {
        "id": 573,
        "code": "public boolean hasCalled() {\n    return called;\n}",
        "summary_tokens": [
            "returns",
            "if",
            "the",
            "filter",
            "has",
            "called"
        ]
    },
    {
        "id": 574,
        "code": "public boolean hasError() {\n    return error;\n}",
        "summary_tokens": [
            "returns",
            "if",
            "there",
            "exists",
            "error"
        ]
    },
    {
        "id": 575,
        "code": "private void beforeExport() {\n    registryProtocolListener = (MultipleRegistryCenterExportProviderRegistryProtocolListener) ExtensionLoader\n        .getExtensionLoader(RegistryProtocolListener.class)\n        .getExtension(SPI_NAME);\n    exporterListener = (MultipleRegistryCenterExportProviderExporterListener) ExtensionLoader\n        .getExtensionLoader(ExporterListener.class)\n        .getExtension(SPI_NAME);\n    filter = (MultipleRegistryCenterExportProviderFilter) ExtensionLoader\n        .getExtensionLoader(Filter.class)\n        .getExtension(SPI_NAME);\n    serviceListener = (MultipleRegistryCenterExportProviderServiceListener) ExtensionLoader\n        .getExtensionLoader(ServiceListener.class)\n        .getExtension(SPI_NAME);\n        \n        \n    Assertions.assertFalse(serviceConfig.isExported());\n        \n        \n    Assertions.assertNotNull(registryProtocolListener);\n    Assertions.assertFalse(registryProtocolListener.isExported());\n        \n    Assertions.assertTrue(serviceListener.getExportedServices().isEmpty());\n        \n    Assertions.assertTrue(exporterListener.getExportedExporters().isEmpty());\n}",
        "summary_tokens": [
            "there",
            "are",
            "some",
            "checkpoints",
            "need",
            "to",
            "verify",
            "as",
            "follow",
            "ul",
            "li",
            "service",
            "config",
            "is",
            "exported",
            "or",
            "not",
            "li",
            "li",
            "multiple",
            "registry",
            "center",
            "export",
            "provider",
            "registry",
            "protocol",
            "listener",
            "is",
            "null",
            "or",
            "not",
            "li",
            "li",
            "there",
            "is",
            "nothing",
            "in",
            "service",
            "listener",
            "or",
            "not",
            "li",
            "li",
            "there",
            "is",
            "nothing",
            "in",
            "exporter",
            "listener",
            "or",
            "not",
            "li",
            "ul"
        ]
    },
    {
        "id": 576,
        "code": "private void afterExport() {\n        \n    Assertions.assertTrue(registryProtocolListener.isExported());\n        \n    Assertions.assertEquals(serviceListener.getExportedServices().size(), 1);\n        \n    Assertions.assertEquals(serviceListener.getExportedServices().get(0).getInterfaceClass(),\n        MultipleRegistryCenterExportProviderService.class);\n        \n    Assertions.assertTrue(serviceListener.getExportedServices().get(0).isExported());\n        \n        \n        \n        \n    Assertions.assertEquals(exporterListener.getExportedExporters().size(), 3);\n        \n    Assertions.assertTrue(exporterListener.getFilters().contains(filter));\n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n    ConfigItem configItem = ApplicationModel.defaultModel().getBeanFactory().getBean(MetadataReportInstance.class).getMetadataReport(CommonConstants.DEFAULT_KEY)\n        .getConfigItem(serviceConfig.getInterface()\n            , ServiceNameMapping.DEFAULT_MAPPING_GROUP);\n        \n    Assertions.assertNotNull(configItem);\n        \n    Assertions.assertEquals(PROVIDER_APPLICATION_NAME,configItem.getContent());\n        \n    Assertions.assertNotNull(configItem.getTicket());\n}",
        "summary_tokens": [
            "there",
            "are",
            "some",
            "checkpoints",
            "need",
            "to",
            "check",
            "after",
            "exported",
            "as",
            "follow",
            "ul",
            "li",
            "the",
            "exporter",
            "is",
            "exported",
            "or",
            "not",
            "li",
            "li",
            "the",
            "exported",
            "exporter",
            "are",
            "three",
            "li",
            "li",
            "the",
            "exported",
            "service",
            "is",
            "multiple",
            "registry",
            "center",
            "export",
            "provider",
            "service",
            "or",
            "not",
            "li",
            "li",
            "the",
            "multiple",
            "registry",
            "center",
            "export",
            "provider",
            "service",
            "is",
            "exported",
            "or",
            "not",
            "li",
            "li",
            "the",
            "exported",
            "exporter",
            "contains",
            "multiple",
            "registry",
            "center",
            "export",
            "provider",
            "filter",
            "or",
            "not",
            "li",
            "ul"
        ]
    },
    {
        "id": 577,
        "code": "private void afterInvoke() {\n        \n    Assertions.assertTrue(filter.hasCalled());\n        \n    Assertions.assertFalse(filter.hasError());\n        \n    Assertions.assertEquals(\"Hello \" + PROVIDER_APPLICATION_NAME, filter.getResponse());\n}",
        "summary_tokens": [
            "there",
            "are",
            "some",
            "checkpoints",
            "need",
            "to",
            "check",
            "after",
            "invoked",
            "as",
            "follow",
            "ul",
            "li",
            "the",
            "multiple",
            "registry",
            "center",
            "export",
            "provider",
            "filter",
            "has",
            "called",
            "or",
            "not",
            "li",
            "li",
            "the",
            "multiple",
            "registry",
            "center",
            "export",
            "provider",
            "filter",
            "exists",
            "error",
            "after",
            "invoked",
            "li",
            "li",
            "the",
            "multiple",
            "registry",
            "center",
            "export",
            "provider",
            "filter",
            "s",
            "response",
            "is",
            "right",
            "or",
            "not",
            "li",
            "ul"
        ]
    },
    {
        "id": 578,
        "code": "public boolean isExported() {\n    return exported;\n}",
        "summary_tokens": [
            "returns",
            "if",
            "this",
            "exporter",
            "is",
            "exported"
        ]
    },
    {
        "id": 579,
        "code": "public boolean hasCalled() {\n    return called;\n}",
        "summary_tokens": [
            "returns",
            "if",
            "the",
            "filter",
            "has",
            "called"
        ]
    },
    {
        "id": 580,
        "code": "public boolean hasError() {\n    return error;\n}",
        "summary_tokens": [
            "returns",
            "if",
            "there",
            "exists",
            "error"
        ]
    },
    {
        "id": 581,
        "code": "private void beforeExport() {\n        \n    serviceListener = (MultipleRegistryCenterInjvmServiceListener) ExtensionLoader.getExtensionLoader(ServiceListener.class).getExtension(SPI_NAME);\n    exporterListener = (MultipleRegistryCenterInjvmExporterListener) ExtensionLoader.getExtensionLoader(ExporterListener.class).getExtension(SPI_NAME);\n    filter = (MultipleRegistryCenterInjvmFilter) ExtensionLoader.getExtensionLoader(Filter.class).getExtension(SPI_NAME);\n\n        \n        \n    Assertions.assertTrue(serviceListener.getExportedServices().isEmpty());\n        \n    Assertions.assertTrue(exporterListener.getExportedExporters().isEmpty());\n        \n    Assertions.assertFalse(serviceConfig.isExported());\n}",
        "summary_tokens": [
            "define",
            "service",
            "listener",
            "exporter",
            "listener",
            "and",
            "filter",
            "for",
            "helping",
            "check"
        ]
    },
    {
        "id": 582,
        "code": "private void afterExport() {\n        \n    Assertions.assertEquals(serviceListener.getExportedServices().size(), 1);\n        \n    Assertions.assertEquals(serviceListener.getExportedServices().get(0).getInterfaceClass(),\n        MultipleRegistryCenterInjvmService.class);\n        \n    Assertions.assertTrue(serviceListener.getExportedServices().get(0).isExported());\n        \n    Assertions.assertEquals(exporterListener.getExportedExporters().size(), 1);\n        \n    Assertions.assertTrue(exporterListener.getFilters().contains(filter));\n}",
        "summary_tokens": [
            "there",
            "are",
            "some",
            "checkpoints",
            "need",
            "to",
            "check",
            "after",
            "exported",
            "as",
            "follow",
            "ul",
            "li",
            "the",
            "exported",
            "service",
            "is",
            "only",
            "one",
            "or",
            "not",
            "li",
            "li",
            "the",
            "exported",
            "service",
            "is",
            "multiple",
            "registry",
            "center",
            "injvm",
            "service",
            "or",
            "not",
            "li",
            "li",
            "the",
            "multiple",
            "registry",
            "center",
            "injvm",
            "service",
            "is",
            "exported",
            "or",
            "not",
            "li",
            "li",
            "the",
            "exported",
            "exporter",
            "is",
            "only",
            "one",
            "or",
            "not",
            "li",
            "li",
            "the",
            "exported",
            "exporter",
            "contains",
            "multiple",
            "registry",
            "center",
            "injvm",
            "filter",
            "or",
            "not",
            "li",
            "ul"
        ]
    },
    {
        "id": 583,
        "code": "private void afterInvoke() {\n        \n    Assertions.assertTrue(filter.hasCalled());\n        \n    Assertions.assertFalse(filter.hasError());\n        \n    Assertions.assertEquals(\"Hello Dubbo in multiple registry center\",\n        filter.getResponse());\n}",
        "summary_tokens": [
            "there",
            "are",
            "some",
            "checkpoints",
            "need",
            "to",
            "check",
            "after",
            "invoked",
            "as",
            "follow",
            "ul",
            "li",
            "the",
            "multiple",
            "registry",
            "center",
            "injvm",
            "filter",
            "has",
            "called",
            "or",
            "not",
            "li",
            "li",
            "the",
            "multiple",
            "registry",
            "center",
            "injvm",
            "filter",
            "exists",
            "error",
            "after",
            "invoked",
            "li",
            "li",
            "the",
            "multiple",
            "registry",
            "center",
            "injvm",
            "filter",
            "s",
            "response",
            "is",
            "right",
            "or",
            "not",
            "li",
            "ul"
        ]
    },
    {
        "id": 584,
        "code": "private void beforeExport() {\n        \n        \n    Assertions.assertFalse(serviceConfig.isExported());\n\n        \n    Assertions.assertEquals(registryServiceListener.getStorage().size(), 0);\n}",
        "summary_tokens": [
            "define",
            "a",
            "registry",
            "service",
            "listener",
            "for",
            "helping",
            "check"
        ]
    },
    {
        "id": 585,
        "code": "private void afterExport() {\n        \n    Assertions.assertEquals(registryServiceListener.getStorage().size(), 2);\n        \n    for (int port : ports) {\n        Assertions.assertTrue(registryServiceListener.getStorage().contains(HOST, port));\n        ServiceDiscoveryRegistryInfoWrapper serviceDiscoveryRegistryInfoWrapper = registryServiceListener.getStorage().get(HOST, port);\n            \n        Assertions.assertTrue(serviceDiscoveryRegistryInfoWrapper.isRegistered());\n            \n        Assertions.assertFalse(serviceDiscoveryRegistryInfoWrapper.isSubscribed());\n        MetadataServiceDelegation metadataService = DubboBootstrap.getInstance().getApplicationModel().getBeanFactory().getBean(MetadataServiceDelegation.class);\n            \n        Assertions.assertEquals(metadataService.getExportedURLs().size(), 1);\n            \n        Assertions.assertTrue(metadataService.getExportedURLs()\n            .first()\n            .contains(MultipleRegistryCenterServiceDiscoveryRegistryService.class.getName()));\n            \n        Assertions.assertEquals(2, metadataService.getMetadataInfos().size());\n    }\n}",
        "summary_tokens": [
            "there",
            "are",
            "some",
            "checkpoints",
            "need",
            "to",
            "check",
            "after",
            "exported",
            "as",
            "follow",
            "ul",
            "li",
            "service",
            "discovery",
            "registry",
            "is",
            "right",
            "or",
            "not",
            "li",
            "li",
            "all",
            "register",
            "center",
            "has",
            "been",
            "registered",
            "and",
            "subscribed",
            "li",
            "ul"
        ]
    },
    {
        "id": 586,
        "code": "private void afterInvoke() {\n\n}",
        "summary_tokens": [
            "there",
            "are",
            "some",
            "checkpoints",
            "need",
            "to",
            "check",
            "after",
            "invoked",
            "as",
            "follow"
        ]
    },
    {
        "id": 587,
        "code": "private ServiceDiscoveryRegistryInfoWrapper createServiceDiscoveryRegistryInfoWrapper(ServiceDiscoveryRegistry serviceDiscoveryRegistry){\n    URL url = serviceDiscoveryRegistry.getUrl();\n    String host = url.getHost();\n    int port = url.getPort();\n    ServiceDiscoveryRegistryInfoWrapper serviceDiscoveryRegistryInfoWrapper = new ServiceDiscoveryRegistryInfoWrapper();\n    serviceDiscoveryRegistryInfoWrapper.setHost(host);\n    serviceDiscoveryRegistryInfoWrapper.setPort(port);\n    serviceDiscoveryRegistryInfoWrapper.setServiceDiscoveryRegistry(serviceDiscoveryRegistry);\n    serviceDiscoveryRegistryInfoWrapper.setRegistered(true);\n    return serviceDiscoveryRegistryInfoWrapper;\n}",
        "summary_tokens": [
            "create",
            "an",
            "service",
            "discovery",
            "registry",
            "info",
            "wrapper",
            "instance"
        ]
    },
    {
        "id": 588,
        "code": "private boolean isCheckedApplication(Registry registry){\n    return registry.getUrl().getApplication()\n        .equals(MultipleRegistryCenterServiceDiscoveryRegistryIntegrationTest\n            .PROVIDER_APPLICATION_NAME);\n}",
        "summary_tokens": [
            "checks",
            "if",
            "the",
            "registry",
            "is",
            "checked",
            "application"
        ]
    },
    {
        "id": 589,
        "code": "public ServiceDiscoveryRegistryStorage getStorage() {\n    return storage;\n}",
        "summary_tokens": [
            "return",
            "the",
            "stored",
            "service",
            "discovery",
            "registry",
            "info",
            "wrapper",
            "instances"
        ]
    },
    {
        "id": 590,
        "code": "private void beforeExport() {\n        \n    Assertions.assertFalse(serviceConfig.isExported());\n        \n    Assertions.assertEquals(serviceConfig.getExportedUrls().size(), 0);\n        \n    Assertions.assertTrue(DubboBootstrap.getInstance().isPending());\n        \n    Assertions.assertFalse(DubboBootstrap.getInstance().isInitialized());\n        \n    Assertions.assertFalse(DubboBootstrap.getInstance().isStarted());\n        \n    Assertions.assertFalse(DubboBootstrap.getInstance().isStopped());\n        \n    Assertions.assertNull(singleRegistryCenterExportedServiceListener);\n}",
        "summary_tokens": [
            "there",
            "are",
            "some",
            "checkpoints",
            "needed",
            "to",
            "check",
            "as",
            "follow",
            "ul",
            "li",
            "service",
            "config",
            "is",
            "exported",
            "or",
            "not",
            "li",
            "li",
            "service",
            "config",
            "s",
            "exported",
            "url",
            "has",
            "values",
            "or",
            "not",
            "li",
            "li",
            "dubbo",
            "bootstrap",
            "is",
            "initialized",
            "or",
            "not",
            "li",
            "li",
            "dubbo",
            "bootstrap",
            "is",
            "started",
            "or",
            "not",
            "li",
            "li",
            "dubbo",
            "bootstrap",
            "is",
            "shutdown",
            "or",
            "not",
            "li",
            "li",
            "the",
            "service",
            "listener",
            "is",
            "loaded",
            "by",
            "spi",
            "or",
            "not",
            "li",
            "ul"
        ]
    },
    {
        "id": 591,
        "code": "private void afterExport() {\n        \n    Assertions.assertTrue(DubboBootstrap.getInstance().isInitialized());\n        \n    Assertions.assertFalse(DubboBootstrap.getInstance().isPending());\n        \n    Assertions.assertTrue(DubboBootstrap.getInstance().isStarted());\n        \n    Assertions.assertFalse(DubboBootstrap.getInstance().isStopped());\n        \n    Assertions.assertTrue(this.serviceConfig.isExported());\n        \n    Assertions.assertEquals(this.serviceConfig.getExportedUrls().size(), 1);\n    URL exportedUrl = this.serviceConfig.getExportedUrls().get(0);\n        \n    Assertions.assertEquals(exportedUrl.getProtocol(), PROTOCOL_NAME);\n        \n    Assertions.assertEquals(exportedUrl.getPort(), PROTOCOL_PORT);\n        \n    Assertions.assertEquals(exportedUrl.getApplication(), PROVIDER_APPLICATION_NAME);\n\n        \n    ServiceDiscoveryRegistry serviceDiscoveryRegistry = this.getServiceDiscoveryRegistry();\n        \n    Assertions.assertNotNull(serviceDiscoveryRegistry);\n        \n    Assertions.assertTrue(serviceDiscoveryRegistry.getServiceDiscovery() instanceof ZookeeperServiceDiscovery);\n        \n    ZookeeperServiceDiscovery zookeeperServiceDiscovery = (ZookeeperServiceDiscovery) serviceDiscoveryRegistry.getServiceDiscovery();\n        \n    Set<String> services = zookeeperServiceDiscovery.getServices();\n        \n    Assertions.assertTrue(!services.isEmpty());\n        \n    Assertions.assertTrue(services.contains(PROVIDER_APPLICATION_NAME));\n\n        \n    MetadataServiceDelegation inMemoryWritableMetadataService = (MetadataServiceDelegation) serviceConfig.getScopeModel().getBeanFactory().getBean(MetadataService.class);\n        \n    Assertions.assertEquals(inMemoryWritableMetadataService.getExportedURLs().size(), 1);\n        \n    Assertions.assertFalse(inMemoryWritableMetadataService.getMetadataInfos().isEmpty());\n        \n    Assertions.assertFalse(inMemoryWritableMetadataService.getMetadataInfos().get(0).getServices().isEmpty());\n        \n    Assertions.assertEquals(inMemoryWritableMetadataService.getMetadataInfos().get(0).getServices().size(), 1);\n        \n    String key = SingleRegistryCenterIntegrationService.class.getName() + \":\" + PROTOCOL_NAME;\n    MetadataInfo.ServiceInfo serviceInfo = inMemoryWritableMetadataService.getMetadataInfos().get(0).getServices().get(key);\n        \n    Assertions.assertNotNull(serviceInfo);\n        \n    Assertions.assertEquals(serviceInfo.getName(), SingleRegistryCenterIntegrationService.class.getName());\n        \n    Assertions.assertNull(serviceInfo.getGroup());\n        \n    Assertions.assertNull(serviceInfo.getVersion());\n        \n    Assertions.assertEquals(serviceInfo.getProtocol(), PROTOCOL_NAME);\n        \n    Assertions.assertEquals(serviceInfo.getServiceKey(), SingleRegistryCenterIntegrationService.class.getName());\n        \n    Assertions.assertEquals(serviceInfo.getMatchKey(), key);\n        \n        \n        \n        \n    singleRegistryCenterExportedServiceListener = (SingleRegistryCenterExportedServiceListener) ExtensionLoader.getExtensionLoader(ServiceListener.class).getExtension(\"exported\");\n    Assertions.assertNotNull(singleRegistryCenterExportedServiceListener);\n    Assertions.assertEquals(singleRegistryCenterExportedServiceListener.getExportedServices().size(), 1);\n    Assertions.assertEquals(SingleRegistryCenterIntegrationService.class,\n        singleRegistryCenterExportedServiceListener.getExportedServices().get(0).getInterfaceClass());\n    ServiceConfig singleRegistryCenterServiceConfig = singleRegistryCenterExportedServiceListener.getExportedServices().get(0);\n    Assertions.assertNotNull(singleRegistryCenterServiceConfig);\n    Assertions.assertTrue(singleRegistryCenterServiceConfig.isExported());\n}",
        "summary_tokens": [
            "there",
            "are",
            "some",
            "checkpoints",
            "needed",
            "to",
            "check",
            "as",
            "follow",
            "ul",
            "li",
            "dubbo",
            "bootstrap",
            "is",
            "initialized",
            "or",
            "not",
            "li",
            "li",
            "dubbo",
            "bootstrap",
            "is",
            "started",
            "or",
            "not",
            "li",
            "li",
            "dubbo",
            "bootstrap",
            "is",
            "shutdown",
            "or",
            "not",
            "li",
            "li",
            "service",
            "has",
            "been",
            "exported",
            "or",
            "not",
            "li",
            "li",
            "there",
            "is",
            "exported",
            "urls",
            "or",
            "not",
            "li",
            "li",
            "protocol",
            "name",
            "is",
            "right",
            "or",
            "not",
            "li",
            "li",
            "protocol",
            "port",
            "is",
            "right",
            "or",
            "not",
            "li",
            "li",
            "service",
            "discovery",
            "registry",
            "s",
            "protocol",
            "is",
            "right",
            "or",
            "not",
            "li",
            "li",
            "registered",
            "service",
            "in",
            "registry",
            "center",
            "is",
            "right",
            "or",
            "not",
            "li",
            "li",
            "metadata",
            "info",
            "has",
            "reported",
            "or",
            "not",
            "li",
            "li",
            "metadata",
            "info",
            "has",
            "reported",
            "or",
            "not",
            "has",
            "service",
            "or",
            "not",
            "li",
            "li",
            "metadata",
            "info",
            "s",
            "application",
            "name",
            "is",
            "right",
            "or",
            "not",
            "li",
            "li",
            "metadata",
            "info",
            "s",
            "service",
            "exists",
            "or",
            "not",
            "li",
            "li",
            "the",
            "name",
            "of",
            "metadata",
            "info",
            "s",
            "service",
            "is",
            "right",
            "or",
            "not",
            "li",
            "li",
            "the",
            "group",
            "of",
            "metadata",
            "info",
            "s",
            "service",
            "is",
            "right",
            "or",
            "not",
            "li",
            "li",
            "the",
            "version",
            "of",
            "metadata",
            "info",
            "s",
            "service",
            "is",
            "right",
            "or",
            "not",
            "li",
            "li",
            "the",
            "protocol",
            "of",
            "metadata",
            "info",
            "s",
            "service",
            "is",
            "right",
            "or",
            "not",
            "li",
            "li",
            "the",
            "service",
            "key",
            "of",
            "metadata",
            "info",
            "s",
            "service",
            "is",
            "right",
            "or",
            "not",
            "li",
            "li",
            "the",
            "match",
            "key",
            "of",
            "metadata",
            "info",
            "s",
            "service",
            "is",
            "right",
            "or",
            "not",
            "li",
            "li",
            "the",
            "exported",
            "service",
            "are",
            "right",
            "or",
            "not",
            "li",
            "ul"
        ]
    },
    {
        "id": 592,
        "code": "private ServiceDiscoveryRegistry getServiceDiscoveryRegistry() {\n    Collection<Registry> registries = RegistryManager.getInstance(ApplicationModel.defaultModel()).getRegistries();\n    for (Registry registry : registries) {\n        if(registry instanceof ServiceDiscoveryRegistry) {\n            return (ServiceDiscoveryRegistry) registry;\n        }\n    }\n    return null;\n}",
        "summary_tokens": [
            "returns",
            "service",
            "discovery",
            "registry",
            "instance"
        ]
    },
    {
        "id": 593,
        "code": "private void beforeRefer() {\n        \n    Assertions.assertEquals(referenceConfig.getScopeModel(), DubboBootstrap.getInstance().getApplicationModel().getDefaultModule());\n}",
        "summary_tokens": [
            "there",
            "are",
            "some",
            "checkpoints",
            "needed",
            "to",
            "check",
            "before",
            "referring",
            "as",
            "follow",
            "ul",
            "li",
            "reference",
            "config",
            "has",
            "integrated",
            "into",
            "dubbo",
            "bootstrap",
            "or",
            "not",
            "li",
            "ul"
        ]
    },
    {
        "id": 594,
        "code": "private void afterRefer() {\n        \n    Assertions.assertNotNull(singleRegistryCenterIntegrationService);\n        \n    Assertions.assertNotNull(referenceConfig.getInvoker());\n    Assertions.assertTrue(referenceConfig.getInvoker() instanceof MigrationInvoker);\n        \n    Assertions.assertEquals(\"Hello Reference\",\n        singleRegistryCenterIntegrationService.hello(\"Reference\"));\n        \n    Directory directory = ((MigrationInvoker) referenceConfig.getInvoker()).getDirectory();\n        \n    Assertions.assertNotNull(directory);\n        \n    Assertions.assertTrue(directory instanceof ServiceDiscoveryRegistryDirectory);\n        \n    Assertions.assertEquals(directory.getInterface(), SingleRegistryCenterIntegrationService.class);\n        \n    Assertions.assertTrue(directory.isAvailable());\n        \n    Assertions.assertFalse(directory.isDestroyed());\n        \n    Assertions.assertTrue(directory.isNotificationReceived());\n    ServiceDiscoveryRegistryDirectory serviceDiscoveryRegistryDirectory = (ServiceDiscoveryRegistryDirectory) directory;\n        \n    Assertions.assertTrue(serviceDiscoveryRegistryDirectory.isShouldRegister());\n        \n    Assertions.assertEquals(serviceDiscoveryRegistryDirectory.getRegisteredConsumerUrl().getCategory(), CONSUMERS_CATEGORY);\n        \n    Assertions.assertTrue(serviceDiscoveryRegistryDirectory.getRegistry() instanceof ListenerRegistryWrapper);\n        \n    Assertions.assertEquals(serviceDiscoveryRegistryDirectory.getAllInvokers().size(), 1);\n    Assertions.assertEquals(serviceDiscoveryRegistryDirectory.getInvokers(), serviceDiscoveryRegistryDirectory.getAllInvokers());\n}",
        "summary_tokens": [
            "there",
            "are",
            "some",
            "checkpoints",
            "needed",
            "to",
            "check",
            "after",
            "referred",
            "as",
            "follow",
            "ul",
            "li",
            "single",
            "registry",
            "center",
            "integration",
            "service",
            "instance",
            "can",
            "t",
            "be",
            "null",
            "li",
            "li",
            "rpc",
            "works",
            "well",
            "or",
            "not",
            "li",
            "li",
            "invoker",
            "is",
            "right",
            "or",
            "not",
            "li",
            "li",
            "directory",
            "is",
            "null",
            "or",
            "not",
            "li",
            "li",
            "registered",
            "interface",
            "is",
            "right",
            "or",
            "not",
            "li",
            "li",
            "directory",
            "is",
            "available",
            "or",
            "not",
            "li",
            "li",
            "directory",
            "is",
            "destroyed",
            "or",
            "not",
            "li",
            "li",
            "directory",
            "has",
            "received",
            "notification",
            "or",
            "not",
            "li",
            "li",
            "service",
            "discovery",
            "registry",
            "directory",
            "should",
            "register",
            "or",
            "not",
            "li",
            "li",
            "service",
            "discovery",
            "registry",
            "directory",
            "s",
            "registered",
            "consumer",
            "url",
            "is",
            "right",
            "or",
            "not",
            "li",
            "li",
            "service",
            "discovery",
            "registry",
            "directory",
            "s",
            "registry",
            "is",
            "right",
            "or",
            "not",
            "li",
            "li",
            "directory",
            "s",
            "invokers",
            "are",
            "right",
            "or",
            "not",
            "li",
            "ul"
        ]
    },
    {
        "id": 595,
        "code": "protected Class<?> getInterface() {\n    return MetadataService.class;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "interface",
            "of",
            "exported",
            "service"
        ]
    },
    {
        "id": 596,
        "code": "private void beforeExport() {\n        \n    serviceListener = (SingleRegistryCenterExportMetadataServiceListener) ExtensionLoader.getExtensionLoader(ServiceListener.class).getExtension(SPI_NAME);\n    exporterListener = (SingleRegistryCenterExportMetadataExporterListener) ExtensionLoader.getExtensionLoader(ExporterListener.class).getExtension(SPI_NAME);\n\n        \n        \n    Assertions.assertTrue(serviceListener.getExportedServices().isEmpty());\n        \n    Assertions.assertTrue(exporterListener.getExportedExporters().isEmpty());\n        \n    Assertions.assertFalse(serviceConfig.isExported());\n}",
        "summary_tokens": [
            "define",
            "service",
            "listener",
            "exporter",
            "listener",
            "and",
            "filter",
            "for",
            "helping",
            "check"
        ]
    },
    {
        "id": 597,
        "code": "private void afterExport() {\n        \n    Assertions.assertEquals(serviceListener.getExportedServices().size(), 1);\n        \n    Assertions.assertEquals(serviceListener.getExportedServices().get(0).getInterfaceClass(),\n        MetadataService.class);\n        \n    Assertions.assertTrue(serviceListener.getExportedServices().get(0).isExported());\n        \n        \n        \n    Assertions.assertEquals(exporterListener.getExportedExporters().size(), 2);\n        \n    Exporter<?> injvmExporter = (Exporter<?>) exporterListener.getExportedExporters()\n        .stream()\n        .filter(\n            exporter -> PROTOCOL_NAME.equalsIgnoreCase(exporter.getInvoker().getUrl().getProtocol())\n        )\n        .findFirst()\n        .get();\n        \n    Exporter<?> metadataExporter = (Exporter<?>) exporterListener.getExportedExporters()\n        .stream()\n        .filter(\n            exporter -> !PROTOCOL_NAME.equalsIgnoreCase(exporter.getInvoker().getUrl().getProtocol())\n        )\n        .filter(\n            exporter -> exporter.getInvoker().getInterface().equals(MetadataService.class)\n        )\n        .findFirst()\n        .get();\n        \n    Assertions.assertNotNull(injvmExporter);\n        \n    Assertions.assertNotNull(metadataExporter);\n}",
        "summary_tokens": [
            "there",
            "are",
            "some",
            "checkpoints",
            "need",
            "to",
            "check",
            "after",
            "exported",
            "as",
            "follow",
            "ul",
            "li",
            "the",
            "metadata",
            "service",
            "is",
            "only",
            "one",
            "or",
            "not",
            "li",
            "li",
            "the",
            "exported",
            "service",
            "is",
            "metadata",
            "service",
            "or",
            "not",
            "li",
            "li",
            "the",
            "metadata",
            "service",
            "is",
            "exported",
            "or",
            "not",
            "li",
            "li",
            "the",
            "exported",
            "exporters",
            "are",
            "right",
            "or",
            "not",
            "li",
            "ul"
        ]
    },
    {
        "id": 598,
        "code": "protected Class<?> getInterface() {\n    return SingleRegistryCenterExportProviderService.class;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "interface",
            "of",
            "exported",
            "service"
        ]
    },
    {
        "id": 599,
        "code": "public boolean hasCalled() {\n    return called;\n}",
        "summary_tokens": [
            "returns",
            "if",
            "the",
            "filter",
            "has",
            "called"
        ]
    },
    {
        "id": 600,
        "code": "public boolean hasError() {\n    return error;\n}",
        "summary_tokens": [
            "returns",
            "if",
            "there",
            "exists",
            "error"
        ]
    },
    {
        "id": 601,
        "code": "private void beforeExport() {\n    registryProtocolListener = (SingleRegistryCenterExportProviderRegistryProtocolListener) ExtensionLoader\n        .getExtensionLoader(RegistryProtocolListener.class)\n        .getExtension(SINGLE_CONFIG_CENTER_EXPORT_PROVIDER);\n    exporterListener = (SingleRegistryCenterExportProviderExporterListener) ExtensionLoader\n        .getExtensionLoader(ExporterListener.class)\n        .getExtension(SINGLE_CONFIG_CENTER_EXPORT_PROVIDER);\n    filter = (SingleRegistryCenterExportProviderFilter) ExtensionLoader\n        .getExtensionLoader(Filter.class)\n        .getExtension(SINGLE_CONFIG_CENTER_EXPORT_PROVIDER);\n    serviceListener = (SingleRegistryCenterExportProviderServiceListener) ExtensionLoader\n        .getExtensionLoader(ServiceListener.class)\n        .getExtension(SINGLE_CONFIG_CENTER_EXPORT_PROVIDER);\n        \n        \n    Assertions.assertFalse(serviceConfig.isExported());\n        \n        \n    Assertions.assertNotNull(registryProtocolListener);\n    Assertions.assertFalse(registryProtocolListener.isExported());\n        \n    Assertions.assertTrue(serviceListener.getExportedServices().isEmpty());\n        \n    Assertions.assertTrue(exporterListener.getExportedExporters().isEmpty());\n}",
        "summary_tokens": [
            "there",
            "are",
            "some",
            "checkpoints",
            "need",
            "to",
            "verify",
            "as",
            "follow",
            "ul",
            "li",
            "service",
            "config",
            "is",
            "exported",
            "or",
            "not",
            "li",
            "li",
            "single",
            "registry",
            "center",
            "export",
            "provider",
            "registry",
            "protocol",
            "listener",
            "is",
            "null",
            "or",
            "not",
            "li",
            "li",
            "there",
            "is",
            "nothing",
            "in",
            "service",
            "listener",
            "or",
            "not",
            "li",
            "li",
            "there",
            "is",
            "nothing",
            "in",
            "exporter",
            "listener",
            "or",
            "not",
            "li",
            "ul"
        ]
    },
    {
        "id": 602,
        "code": "private void afterExport() {\n        \n    Assertions.assertTrue(registryProtocolListener.isExported());\n        \n    Assertions.assertEquals(serviceListener.getExportedServices().size(), 1);\n        \n    Assertions.assertEquals(serviceListener.getExportedServices().get(0).getInterfaceClass(),\n        SingleRegistryCenterExportProviderService.class);\n        \n    Assertions.assertTrue(serviceListener.getExportedServices().get(0).isExported());\n        \n        \n        \n        \n    Assertions.assertEquals(exporterListener.getExportedExporters().size(), 3);\n        \n    Assertions.assertTrue(exporterListener.getFilters().contains(filter));\n        \n        \n        \n        \n        \n        \n        \n        \n    ConfigItem configItem = ApplicationModel.defaultModel().getBeanFactory().getBean(MetadataReportInstance.class).getMetadataReport(CommonConstants.DEFAULT_KEY)\n        .getConfigItem(serviceConfig.getInterface()\n            , ServiceNameMapping.DEFAULT_MAPPING_GROUP);\n        \n    Assertions.assertNotNull(configItem);\n        \n    Assertions.assertEquals(PROVIDER_APPLICATION_NAME,configItem.getContent());\n        \n    Assertions.assertNotNull(configItem.getTicket());\n}",
        "summary_tokens": [
            "there",
            "are",
            "some",
            "checkpoints",
            "need",
            "to",
            "check",
            "after",
            "exported",
            "as",
            "follow",
            "ul",
            "li",
            "the",
            "exporter",
            "is",
            "exported",
            "or",
            "not",
            "li",
            "li",
            "the",
            "exported",
            "exporter",
            "are",
            "three",
            "li",
            "li",
            "the",
            "exported",
            "service",
            "is",
            "single",
            "registry",
            "center",
            "export",
            "provider",
            "service",
            "or",
            "not",
            "li",
            "li",
            "the",
            "single",
            "registry",
            "center",
            "export",
            "provider",
            "service",
            "is",
            "exported",
            "or",
            "not",
            "li",
            "li",
            "the",
            "exported",
            "exporter",
            "contains",
            "single",
            "registry",
            "center",
            "export",
            "provider",
            "filter",
            "or",
            "not",
            "li",
            "li",
            "the",
            "metadata",
            "mapping",
            "info",
            "is",
            "right",
            "or",
            "not",
            "li",
            "ul"
        ]
    },
    {
        "id": 603,
        "code": "private void afterInvoke() {\n        \n    Assertions.assertTrue(filter.hasCalled());\n        \n    Assertions.assertFalse(filter.hasError());\n        \n    Assertions.assertEquals(\"Hello \" + PROVIDER_APPLICATION_NAME, filter.getResponse());\n}",
        "summary_tokens": [
            "there",
            "are",
            "some",
            "checkpoints",
            "need",
            "to",
            "check",
            "after",
            "invoked",
            "as",
            "follow",
            "ul",
            "li",
            "the",
            "single",
            "registry",
            "center",
            "export",
            "provider",
            "filter",
            "has",
            "called",
            "or",
            "not",
            "li",
            "li",
            "the",
            "single",
            "registry",
            "center",
            "export",
            "provider",
            "filter",
            "exists",
            "error",
            "after",
            "invoked",
            "li",
            "li",
            "the",
            "single",
            "registry",
            "center",
            "export",
            "provider",
            "filter",
            "s",
            "response",
            "is",
            "right",
            "or",
            "not",
            "li",
            "ul"
        ]
    },
    {
        "id": 604,
        "code": "public boolean isExported() {\n    return exported;\n}",
        "summary_tokens": [
            "returns",
            "if",
            "this",
            "exporter",
            "is",
            "exported"
        ]
    },
    {
        "id": 605,
        "code": "protected Class<?> getInterface() {\n    return SingleRegistryCenterInjvmService.class;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "interface",
            "of",
            "exported",
            "service"
        ]
    },
    {
        "id": 606,
        "code": "public boolean hasCalled() {\n    return called;\n}",
        "summary_tokens": [
            "returns",
            "if",
            "the",
            "filter",
            "has",
            "called"
        ]
    },
    {
        "id": 607,
        "code": "public boolean hasError() {\n    return error;\n}",
        "summary_tokens": [
            "returns",
            "if",
            "there",
            "exists",
            "error"
        ]
    },
    {
        "id": 608,
        "code": "private void beforeExport() {\n        \n    serviceListener = (SingleRegistryCenterInjvmServiceListener) ExtensionLoader.getExtensionLoader(ServiceListener.class).getExtension(SPI_NAME);\n    exporterListener = (SingleRegistryCenterInjvmExporterListener) ExtensionLoader.getExtensionLoader(ExporterListener.class).getExtension(SPI_NAME);\n    filter = (SingleRegistryCenterInjvmFilter) ExtensionLoader.getExtensionLoader(Filter.class).getExtension(SPI_NAME);\n\n        \n        \n    Assertions.assertTrue(serviceListener.getExportedServices().isEmpty());\n        \n    Assertions.assertTrue(exporterListener.getExportedExporters().isEmpty());\n        \n    Assertions.assertFalse(serviceConfig.isExported());\n}",
        "summary_tokens": [
            "define",
            "service",
            "listener",
            "exporter",
            "listener",
            "and",
            "filter",
            "for",
            "helping",
            "check"
        ]
    },
    {
        "id": 609,
        "code": "private void afterExport() {\n        \n    Assertions.assertEquals(serviceListener.getExportedServices().size(), 1);\n        \n    Assertions.assertEquals(serviceListener.getExportedServices().get(0).getInterfaceClass(),\n        SingleRegistryCenterInjvmService.class);\n        \n    Assertions.assertTrue(serviceListener.getExportedServices().get(0).isExported());\n        \n    Assertions.assertEquals(exporterListener.getExportedExporters().size(), 1);\n        \n    Assertions.assertTrue(exporterListener.getFilters().contains(filter));\n}",
        "summary_tokens": [
            "there",
            "are",
            "some",
            "checkpoints",
            "need",
            "to",
            "check",
            "after",
            "exported",
            "as",
            "follow",
            "ul",
            "li",
            "the",
            "exported",
            "service",
            "is",
            "only",
            "one",
            "or",
            "not",
            "li",
            "li",
            "the",
            "exported",
            "service",
            "is",
            "single",
            "registry",
            "center",
            "injvm",
            "service",
            "or",
            "not",
            "li",
            "li",
            "the",
            "single",
            "registry",
            "center",
            "injvm",
            "service",
            "is",
            "exported",
            "or",
            "not",
            "li",
            "li",
            "the",
            "exported",
            "exporter",
            "is",
            "only",
            "one",
            "or",
            "not",
            "li",
            "li",
            "the",
            "exported",
            "exporter",
            "contains",
            "single",
            "registry",
            "center",
            "injvm",
            "filter",
            "or",
            "not",
            "li",
            "ul"
        ]
    },
    {
        "id": 610,
        "code": "private void afterInvoke() {\n        \n    Assertions.assertTrue(filter.hasCalled());\n        \n    Assertions.assertFalse(filter.hasError());\n        \n    Assertions.assertEquals(\"Hello Dubbo\", filter.getResponse());\n}",
        "summary_tokens": [
            "there",
            "are",
            "some",
            "checkpoints",
            "need",
            "to",
            "check",
            "after",
            "invoked",
            "as",
            "follow",
            "ul",
            "li",
            "the",
            "single",
            "registry",
            "center",
            "injvm",
            "filter",
            "has",
            "called",
            "or",
            "not",
            "li",
            "li",
            "the",
            "single",
            "registry",
            "center",
            "injvm",
            "filter",
            "exists",
            "error",
            "after",
            "invoked",
            "li",
            "li",
            "the",
            "single",
            "registry",
            "center",
            "injvm",
            "filter",
            "s",
            "response",
            "is",
            "right",
            "or",
            "not",
            "li",
            "ul"
        ]
    },
    {
        "id": 611,
        "code": "protected void assertUrlStringWithLocalTable(String paramStringFromDb,\n                                             Object[][] dataTable, String configName, int column) {\n    final String FAILLOG_HEADER = \"The following config items are not found in URLONE: \";\n\n    log.warn(\"Verifying service url for \" + configName + \"... \");\n    log.warn(\"Consumer url string: \" + paramStringFromDb);\n\n    String failLog = FAILLOG_HEADER;\n    for (Object[] row : dataTable) {\n\n        String targetString = genParamString(row[URL_KEY], row[column]);\n\n        log.warn(\"Checking \" + (String) row[KEY] + \"for\" + targetString);\n        if (paramStringFromDb.contains(targetString)) {\n            log.warn((String) row[KEY] + \" --> \" + targetString + \" OK!\");\n        } else {\n            failLog += targetString + \", \";\n        }\n    }\n\n    if (!failLog.equals(FAILLOG_HEADER)) {\n        fail(failLog);\n    }\n}",
        "summary_tokens": [
            "param",
            "string",
            "from",
            "db",
            "data",
            "table",
            "config",
            "name",
            "column"
        ]
    },
    {
        "id": 612,
        "code": "public Class<?> getInterfaceClass() {\n        \n    return interfaceClass;\n}",
        "summary_tokens": [
            "the",
            "interface",
            "of",
            "this",
            "reference",
            "bean",
            "for",
            "injection",
            "purpose"
        ]
    },
    {
        "id": 613,
        "code": "public String getServiceInterface() {\n    return interfaceName;\n}",
        "summary_tokens": [
            "the",
            "interface",
            "of",
            "remote",
            "service"
        ]
    },
    {
        "id": 614,
        "code": "public String getGroup() {\n        \n    return referenceConfig.getGroup();\n}",
        "summary_tokens": [
            "the",
            "group",
            "of",
            "the",
            "service"
        ]
    },
    {
        "id": 615,
        "code": "public String getVersion() {\n        \n    return referenceConfig.getVersion();\n}",
        "summary_tokens": [
            "the",
            "version",
            "of",
            "the",
            "service"
        ]
    },
    {
        "id": 616,
        "code": "private void createLazyProxy() {\n\n        \n        \n    ProxyFactory proxyFactory = new ProxyFactory();\n    proxyFactory.setTargetSource(new DubboReferenceLazyInitTargetSource());\n    proxyFactory.addInterface(interfaceClass);\n    Class<?>[] internalInterfaces = AbstractProxyFactory.getInternalInterfaces();\n    for (Class<?> anInterface : internalInterfaces) {\n        proxyFactory.addInterface(anInterface);\n    }\n    if (!StringUtils.isEquals(interfaceClass.getName(), interfaceName)) {\n            \n        try {\n            Class<?> serviceInterface = ClassUtils.forName(interfaceName, beanClassLoader);\n            proxyFactory.addInterface(serviceInterface);\n        } catch (ClassNotFoundException e) {\n                \n        }\n    }\n\n    this.lazyProxy = proxyFactory.getProxy(this.beanClassLoader);\n}",
        "summary_tokens": [
            "create",
            "lazy",
            "proxy",
            "for",
            "reference"
        ]
    },
    {
        "id": 617,
        "code": "public String getBeanName() {\n    return this.beanName;\n}",
        "summary_tokens": [
            "get",
            "the",
            "name",
            "of",
            "service",
            "bean"
        ]
    },
    {
        "id": 618,
        "code": "public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) {\n    this.applicationEventPublisher = applicationEventPublisher;\n}",
        "summary_tokens": [
            "application",
            "event",
            "publisher",
            "0"
        ]
    },
    {
        "id": 619,
        "code": "protected Object getInjectedObject(AnnotationAttributes attributes, Object bean, String beanName, Class<?> injectedType,\n                                   AnnotatedInjectElement injectedElement) throws Exception {\n    return doGetInjectedBean(attributes, bean, beanName, injectedType, injectedElement);\n}",
        "summary_tokens": [
            "get",
            "injected",
            "object",
            "from",
            "specified",
            "annotation",
            "attributes",
            "annotation",
            "attributes",
            "and",
            "bean",
            "class"
        ]
    },
    {
        "id": 620,
        "code": "protected void prepareInjection(AnnotatedInjectionMetadata metadata) throws Exception {\n}",
        "summary_tokens": [
            "prepare",
            "injection",
            "data",
            "after",
            "found",
            "injection",
            "elements",
            "metadata",
            "exception"
        ]
    },
    {
        "id": 621,
        "code": "private boolean isAnnotatedReferenceBean(BeanDefinition beanDefinition) {\n    if (beanDefinition instanceof AnnotatedBeanDefinition) {\n        AnnotatedBeanDefinition annotatedBeanDefinition = (AnnotatedBeanDefinition) beanDefinition;\n        String beanClassName = SpringCompatUtils.getFactoryMethodReturnType(annotatedBeanDefinition);\n        if (beanClassName != null && ReferenceBean.class.getName().equals(beanClassName)) {\n            return true;\n        }\n    }\n    return false;\n}",
        "summary_tokens": [
            "check",
            "whether",
            "is",
            "at",
            "java",
            "config",
            "method"
        ]
    },
    {
        "id": 622,
        "code": "private void processReferenceAnnotatedBeanDefinition(String beanName, AnnotatedBeanDefinition beanDefinition) {\n\n    MethodMetadata factoryMethodMetadata = SpringCompatUtils.getFactoryMethodMetadata(beanDefinition);\n\n        \n        \n    Class beanClass = getBeanFactory().getType(beanName);\n    if (beanClass == Object.class) {\n        beanClass = SpringCompatUtils.getGenericTypeOfReturnType(factoryMethodMetadata);\n    }\n    if (beanClass == Object.class) {\n            \n        return;\n    }\n\n    if (beanClass == null) {\n        String beanMethodSignature = factoryMethodMetadata.getDeclaringClassName() + \"#\" + factoryMethodMetadata.getMethodName() + \"()\";\n        throw new BeanCreationException(\"The ReferenceBean is missing necessary generic type, which returned by the @Bean method of Java-config class. \" +\n            \"The generic type of the returned ReferenceBean must be specified as the referenced interface type, \" +\n            \"such as ReferenceBean<DemoService>. Please check bean method: \" + beanMethodSignature);\n    }\n\n        \n    Map<String, Object> annotationAttributes = null;\n        \n    for (Class<? extends Annotation> annotationType : getAnnotationTypes()) {\n        if (factoryMethodMetadata.isAnnotated(annotationType.getName())) {\n                \n                \n                \n            annotationAttributes = factoryMethodMetadata.getAnnotationAttributes(annotationType.getName());\n            annotationAttributes = filterDefaultValues(annotationType, annotationAttributes);\n            break;\n        }\n    }\n\n    if (annotationAttributes != null) {\n            \n        LinkedHashMap<String, Object> attributes = new LinkedHashMap<>(annotationAttributes);\n            \n        attributes.put(ReferenceAttributes.ID, beanName);\n            \n        ReferenceBeanSupport.convertReferenceProps(attributes, beanClass);\n\n            \n        String interfaceName = (String) attributes.get(ReferenceAttributes.INTERFACE);\n\n            \n        if (!StringUtils.isEquals(interfaceName, beanClass.getName()) && beanClass != GenericService.class) {\n            String beanMethodSignature = factoryMethodMetadata.getDeclaringClassName() + \"#\" + factoryMethodMetadata.getMethodName() + \"()\";\n            throw new BeanCreationException(\"The 'interfaceClass' or 'interfaceName' attribute value of @DubboReference annotation \" +\n                \"is inconsistent with the generic type of the ReferenceBean returned by the bean method. \" +\n                \"The interface class of @DubboReference is: \" + interfaceName + \", but return ReferenceBean<\" + beanClass.getName() + \">. \" +\n                \"Please remove the 'interfaceClass' and 'interfaceName' attributes from @DubboReference annotation. \" +\n                \"Please check bean method: \" + beanMethodSignature);\n        }\n\n        Class interfaceClass = beanClass;\n\n            \n        beanDefinition.setAttribute(Constants.REFERENCE_PROPS, attributes);\n        beanDefinition.setAttribute(ReferenceAttributes.INTERFACE_CLASS, interfaceClass);\n        beanDefinition.setAttribute(ReferenceAttributes.INTERFACE_NAME, interfaceName);\n    } else {\n            \n            \n        beanDefinition.setAttribute(ReferenceAttributes.INTERFACE_CLASS, beanClass);\n        if (beanClass != GenericService.class) {\n            beanDefinition.setAttribute(ReferenceAttributes.INTERFACE_NAME, beanClass.getName());\n        }\n    }\n\n        \n    beanDefinition.getPropertyValues().add(ReferenceAttributes.ID, beanName);\n}",
        "summary_tokens": [
            "process",
            "at",
            "java",
            "config",
            "method",
            "pre",
            "class",
            "code",
            "0",
            "configuration",
            "public",
            "class",
            "consumer",
            "config"
        ]
    },
    {
        "id": 623,
        "code": "public Collection<ReferenceBean<?>> getReferenceBeans() {\n    return Collections.emptyList();\n}",
        "summary_tokens": [
            "gets",
            "all",
            "beans",
            "of",
            "reference",
            "bean",
            "use",
            "reference",
            "bean",
            "manager"
        ]
    },
    {
        "id": 624,
        "code": "public Map<InjectionMetadata.InjectedElement, ReferenceBean<?>> getInjectedFieldReferenceBeanMap() {\n    Map<InjectionMetadata.InjectedElement, ReferenceBean<?>> map = new HashMap<>();\n    for (Map.Entry<InjectionMetadata.InjectedElement, String> entry : injectedFieldReferenceBeanCache.entrySet()) {\n        map.put(entry.getKey(), referenceBeanManager.getById(entry.getValue()));\n    }\n    return Collections.unmodifiableMap(map);\n}",
        "summary_tokens": [
            "get",
            "reference",
            "bean",
            "map",
            "in",
            "injected",
            "field"
        ]
    },
    {
        "id": 625,
        "code": "public Map<InjectionMetadata.InjectedElement, ReferenceBean<?>> getInjectedMethodReferenceBeanMap() {\n    Map<InjectionMetadata.InjectedElement, ReferenceBean<?>> map = new HashMap<>();\n    for (Map.Entry<InjectionMetadata.InjectedElement, String> entry : injectedMethodReferenceBeanCache.entrySet()) {\n        map.put(entry.getKey(), referenceBeanManager.getById(entry.getValue()));\n    }\n    return Collections.unmodifiableMap(map);\n}",
        "summary_tokens": [
            "get",
            "reference",
            "bean",
            "map",
            "in",
            "injected",
            "method"
        ]
    },
    {
        "id": 626,
        "code": "private void scanServiceBeans(Set<String> packagesToScan, BeanDefinitionRegistry registry) {\n\n    scanned = true;\n    if (CollectionUtils.isEmpty(packagesToScan)) {\n        if (logger.isWarnEnabled()) {\n            logger.warn(\"packagesToScan is empty , ServiceBean registry will be ignored!\");\n        }\n        return;\n    }\n\n    DubboClassPathBeanDefinitionScanner scanner =\n            new DubboClassPathBeanDefinitionScanner(registry, environment, resourceLoader);\n\n    BeanNameGenerator beanNameGenerator = resolveBeanNameGenerator(registry);\n    scanner.setBeanNameGenerator(beanNameGenerator);\n    for (Class<? extends Annotation> annotationType : serviceAnnotationTypes) {\n        scanner.addIncludeFilter(new AnnotationTypeFilter(annotationType));\n    }\n\n    ScanExcludeFilter scanExcludeFilter = new ScanExcludeFilter();\n    scanner.addExcludeFilter(scanExcludeFilter);\n\n    for (String packageToScan : packagesToScan) {\n\n            \n        if (servicePackagesHolder.isPackageScanned(packageToScan)) {\n            if (logger.isInfoEnabled()) {\n                logger.info(\"Ignore package who has already bean scanned: \" + packageToScan);\n            }\n            continue;\n        }\n\n            \n        scanner.scan(packageToScan);\n\n            \n        Set<BeanDefinitionHolder> beanDefinitionHolders =\n                findServiceBeanDefinitionHolders(scanner, packageToScan, registry, beanNameGenerator);\n\n        if (!CollectionUtils.isEmpty(beanDefinitionHolders)) {\n            if (logger.isInfoEnabled()) {\n                List<String> serviceClasses = new ArrayList<>(beanDefinitionHolders.size());\n                for (BeanDefinitionHolder beanDefinitionHolder : beanDefinitionHolders) {\n                    serviceClasses.add(beanDefinitionHolder.getBeanDefinition().getBeanClassName());\n                }\n                logger.info(\"Found \" + beanDefinitionHolders.size() + \" classes annotated by Dubbo @Service under package [\" + packageToScan + \"]: \" + serviceClasses);\n            }\n\n            for (BeanDefinitionHolder beanDefinitionHolder : beanDefinitionHolders) {\n                processScannedBeanDefinition(beanDefinitionHolder);\n                servicePackagesHolder.addScannedClass(beanDefinitionHolder.getBeanDefinition().getBeanClassName());\n            }\n        } else {\n            if (logger.isWarnEnabled()) {\n                logger.warn(\"No class annotated by Dubbo @Service was found under package [\"\n                        + packageToScan + \"], ignore re-scanned classes: \" + scanExcludeFilter.getExcludedCount());\n            }\n        }\n\n        servicePackagesHolder.addScannedPackage(packageToScan);\n    }\n}",
        "summary_tokens": [
            "scan",
            "and",
            "registers",
            "service",
            "beans",
            "whose",
            "classes",
            "was",
            "annotated",
            "service"
        ]
    },
    {
        "id": 627,
        "code": "private BeanNameGenerator resolveBeanNameGenerator(BeanDefinitionRegistry registry) {\n\n    BeanNameGenerator beanNameGenerator = null;\n\n    if (registry instanceof SingletonBeanRegistry) {\n        SingletonBeanRegistry singletonBeanRegistry = SingletonBeanRegistry.class.cast(registry);\n        beanNameGenerator = (BeanNameGenerator) singletonBeanRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n    }\n\n    if (beanNameGenerator == null) {\n\n        if (logger.isInfoEnabled()) {\n\n            logger.info(\"BeanNameGenerator bean can't be found in BeanFactory with name [\"\n                    + CONFIGURATION_BEAN_NAME_GENERATOR + \"]\");\n            logger.info(\"BeanNameGenerator will be a instance of \" +\n                    AnnotationBeanNameGenerator.class.getName() +\n                    \" , it maybe a potential problem on bean name generation.\");\n        }\n\n        beanNameGenerator = new AnnotationBeanNameGenerator();\n\n    }\n\n    return beanNameGenerator;\n\n}",
        "summary_tokens": [
            "it",
            "d",
            "be",
            "better",
            "to",
            "use",
            "bean",
            "name",
            "generator",
            "instance",
            "that",
            "should",
            "reference",
            "configuration",
            "class",
            "post",
            "processor",
            "component",
            "scan",
            "bean",
            "name",
            "generator",
            "thus",
            "it",
            "maybe",
            "a",
            "potential",
            "problem",
            "on",
            "bean",
            "name",
            "generation"
        ]
    },
    {
        "id": 628,
        "code": "private Set<BeanDefinitionHolder> findServiceBeanDefinitionHolders(\n        ClassPathBeanDefinitionScanner scanner, String packageToScan, BeanDefinitionRegistry registry,\n        BeanNameGenerator beanNameGenerator) {\n\n    Set<BeanDefinition> beanDefinitions = scanner.findCandidateComponents(packageToScan);\n\n    Set<BeanDefinitionHolder> beanDefinitionHolders = new LinkedHashSet<>(beanDefinitions.size());\n\n    for (BeanDefinition beanDefinition : beanDefinitions) {\n\n        String beanName = beanNameGenerator.generateBeanName(beanDefinition, registry);\n        BeanDefinitionHolder beanDefinitionHolder = new BeanDefinitionHolder(beanDefinition, beanName);\n        beanDefinitionHolders.add(beanDefinitionHolder);\n\n    }\n\n    return beanDefinitionHolders;\n\n}",
        "summary_tokens": [
            "finds",
            "a",
            "set",
            "of",
            "bean",
            "definition",
            "holder",
            "bean",
            "definition",
            "holders",
            "whose",
            "bean",
            "type",
            "annotated",
            "service",
            "annotation"
        ]
    },
    {
        "id": 629,
        "code": "private void processScannedBeanDefinition(BeanDefinitionHolder beanDefinitionHolder) {\n\n    Class<?> beanClass = resolveClass(beanDefinitionHolder);\n\n    Annotation service = findServiceAnnotation(beanClass);\n\n        \n    Map<String, Object> serviceAnnotationAttributes = AnnotationUtils.getAttributes(service, true);\n\n    String serviceInterface = resolveInterfaceName(serviceAnnotationAttributes, beanClass);\n\n    String annotatedServiceBeanName = beanDefinitionHolder.getBeanName();\n\n        \n    String beanName = generateServiceBeanName(serviceAnnotationAttributes, serviceInterface);\n\n    AbstractBeanDefinition serviceBeanDefinition =\n            buildServiceBeanDefinition(serviceAnnotationAttributes, serviceInterface, annotatedServiceBeanName);\n\n    registerServiceBeanDefinition(beanName, serviceBeanDefinition, serviceInterface);\n\n}",
        "summary_tokens": [
            "registers",
            "service",
            "bean",
            "from",
            "new",
            "annotated",
            "service",
            "bean",
            "definition"
        ]
    },
    {
        "id": 630,
        "code": "private Annotation findServiceAnnotation(Class<?> beanClass) {\n    return serviceAnnotationTypes\n            .stream()\n            .map(annotationType -> findAnnotation(beanClass, annotationType))\n            .filter(Objects::nonNull)\n            .findFirst()\n            .orElse(null);\n}",
        "summary_tokens": [
            "find",
            "the",
            "annotation",
            "annotation",
            "of"
        ]
    },
    {
        "id": 631,
        "code": "private String generateServiceBeanName(Map<String, Object> serviceAnnotationAttributes, String serviceInterface) {\n    ServiceBeanNameBuilder builder = create(serviceInterface, environment)\n            .group((String) serviceAnnotationAttributes.get(\"group\"))\n            .version((String) serviceAnnotationAttributes.get(\"version\"));\n    return builder.build();\n}",
        "summary_tokens": [
            "generates",
            "the",
            "bean",
            "name",
            "of",
            "service",
            "bean"
        ]
    },
    {
        "id": 632,
        "code": "private AbstractBeanDefinition buildServiceBeanDefinition(Map<String, Object> serviceAnnotationAttributes,\n                                                          String serviceInterface,\n                                                          String refServiceBeanName) {\n\n    BeanDefinitionBuilder builder = rootBeanDefinition(ServiceBean.class);\n\n    AbstractBeanDefinition beanDefinition = builder.getBeanDefinition();\n\n    MutablePropertyValues propertyValues = beanDefinition.getPropertyValues();\n\n    String[] ignoreAttributeNames = of(\"provider\", \"monitor\", \"application\", \"module\", \"registry\", \"protocol\",\n            \"methods\", \"interfaceName\", \"parameters\");\n\n    propertyValues.addPropertyValues(new AnnotationPropertyValuesAdapter(serviceAnnotationAttributes, environment, ignoreAttributeNames));\n\n        \n        \n        \n    addPropertyReference(builder, \"ref\", refServiceBeanName);\n        \n    builder.addPropertyValue(\"interface\", serviceInterface);\n        \n    builder.addPropertyValue(\"parameters\", DubboAnnotationUtils.convertParameters((String[]) serviceAnnotationAttributes.get(\"parameters\")));\n        \n    List<MethodConfig> methodConfigs = convertMethodConfigs(serviceAnnotationAttributes.get(\"methods\"));\n    if (!methodConfigs.isEmpty()) {\n        builder.addPropertyValue(\"methods\", methodConfigs);\n    }\n\n        \n    String providerConfigId = (String) serviceAnnotationAttributes.get(\"provider\");\n    if (StringUtils.hasText(providerConfigId)) {\n        addPropertyValue(builder, \"providerIds\", providerConfigId);\n    }\n\n        \n    String[] registryConfigIds = (String[]) serviceAnnotationAttributes.get(\"registry\");\n    if (registryConfigIds != null && registryConfigIds.length > 0) {\n        resolveStringArray(registryConfigIds);\n        builder.addPropertyValue(\"registryIds\", StringUtils.join(registryConfigIds, ','));\n    }\n\n        \n    String[] protocolConfigIds = (String[]) serviceAnnotationAttributes.get(\"protocol\");\n    if (protocolConfigIds != null && protocolConfigIds.length > 0) {\n        resolveStringArray(protocolConfigIds);\n        builder.addPropertyValue(\"protocolIds\", StringUtils.join(protocolConfigIds, ','));\n    }\n\n        \n        \n    String monitorConfigId = (String) serviceAnnotationAttributes.get(\"monitor\");\n    if (StringUtils.hasText(monitorConfigId)) {\n        addPropertyReference(builder, \"monitor\", monitorConfigId);\n    }\n\n        \n    String moduleConfigId = (String) serviceAnnotationAttributes.get(\"module\");\n    if (StringUtils.hasText(moduleConfigId)) {\n        addPropertyReference(builder, \"module\", moduleConfigId);\n    }\n\n    return builder.getBeanDefinition();\n\n}",
        "summary_tokens": [
            "build",
            "the",
            "abstract",
            "bean",
            "definition",
            "bean",
            "definition"
        ]
    },
    {
        "id": 633,
        "code": "private Map<String, Object> getServiceAnnotationAttributes(BeanDefinition beanDefinition) {\n    if (beanDefinition instanceof AnnotatedBeanDefinition) {\n        AnnotatedBeanDefinition annotatedBeanDefinition = (AnnotatedBeanDefinition) beanDefinition;\n        MethodMetadata factoryMethodMetadata = SpringCompatUtils.getFactoryMethodMetadata(annotatedBeanDefinition);\n        if (factoryMethodMetadata != null) {\n                \n            for (Class<? extends Annotation> annotationType : serviceAnnotationTypes) {\n                if (factoryMethodMetadata.isAnnotated(annotationType.getName())) {\n                        \n                        \n                        \n                    Map<String, Object> annotationAttributes = factoryMethodMetadata.getAnnotationAttributes(annotationType.getName());\n                    return filterDefaultValues(annotationType, annotationAttributes);\n                }\n            }\n        }\n    }\n    return null;\n}",
        "summary_tokens": [
            "get",
            "dubbo",
            "service",
            "annotation",
            "class",
            "at",
            "java",
            "config",
            "method",
            "return",
            "service",
            "annotation",
            "attributes",
            "map",
            "if",
            "found",
            "or",
            "return",
            "null",
            "if",
            "not",
            "found"
        ]
    },
    {
        "id": 634,
        "code": "private void processAnnotatedBeanDefinition(String refServiceBeanName, AnnotatedBeanDefinition refServiceBeanDefinition, Map<String, Object> attributes) {\n\n    Map<String, Object> serviceAnnotationAttributes = new LinkedHashMap<>(attributes);\n\n        \n    String returnTypeName = SpringCompatUtils.getFactoryMethodReturnType(refServiceBeanDefinition);\n    Class<?> beanClass = resolveClassName(returnTypeName, classLoader);\n\n    String serviceInterface = resolveInterfaceName(serviceAnnotationAttributes, beanClass);\n\n        \n    String serviceBeanName = generateServiceBeanName(serviceAnnotationAttributes, serviceInterface);\n\n    AbstractBeanDefinition serviceBeanDefinition = buildServiceBeanDefinition(serviceAnnotationAttributes, serviceInterface, refServiceBeanName);\n\n        \n    serviceBeanDefinition.getPropertyValues().add(Constants.ID, serviceBeanName);\n\n    registerServiceBeanDefinition(serviceBeanName, serviceBeanDefinition, serviceInterface);\n}",
        "summary_tokens": [
            "process",
            "at",
            "java",
            "config",
            "method",
            "pre",
            "class",
            "code",
            "0",
            "configuration",
            "public",
            "class",
            "provider",
            "config"
        ]
    },
    {
        "id": 635,
        "code": "public static ServiceBeanNameBuilder create(AnnotationAttributes attributes, Class<?> defaultInterfaceClass, Environment environment) {\n    return new ServiceBeanNameBuilder(attributes, defaultInterfaceClass, environment);\n}",
        "summary_tokens": [
            "attributes",
            "default",
            "interface",
            "class",
            "environment",
            "0"
        ]
    },
    {
        "id": 636,
        "code": "private boolean isSubPackage(String testPkg, String parent) {\n        \n    return testPkg.startsWith(parent);\n}",
        "summary_tokens": [
            "whether",
            "test",
            "package",
            "is",
            "sub",
            "package",
            "of",
            "parent",
            "package",
            "test",
            "pkg",
            "parent"
        ]
    },
    {
        "id": 637,
        "code": "default void setSource(BeanMetadataElement beanMetadataElement) {\n    if (beanMetadataElement instanceof BeanMetadataAttributeAccessor) {\n        BeanMetadataAttributeAccessor.class.cast(beanMetadataElement).setSource(this);\n    }\n}",
        "summary_tokens": [
            "set",
            "the",
            "source",
            "into",
            "the",
            "specified",
            "bean",
            "metadata",
            "element"
        ]
    },
    {
        "id": 638,
        "code": "private boolean isOriginalEventSource(ApplicationEvent event) {\n\n    boolean originalEventSource = nullSafeEquals(getApplicationContext(), event.getSource());\n    return originalEventSource;\n}",
        "summary_tokens": [
            "is",
            "original",
            "application",
            "context",
            "as",
            "the",
            "event",
            "source",
            "event",
            "application",
            "event",
            "if",
            "original",
            "return",
            "code",
            "true",
            "code",
            "or",
            "code",
            "false",
            "code"
        ]
    },
    {
        "id": 639,
        "code": "private void prepareDubboConfigBeans() {\n    logger.info(\"loading dubbo config beans ...\");\n\n        \n        \n    loadConfigBeansOfType(ApplicationConfig.class, configManager);\n    loadConfigBeansOfType(RegistryConfig.class, configManager);\n    loadConfigBeansOfType(ProtocolConfig.class, configManager);\n    loadConfigBeansOfType(MonitorConfig.class, configManager);\n    loadConfigBeansOfType(ConfigCenterBean.class, configManager);\n    loadConfigBeansOfType(MetadataReportConfig.class, configManager);\n    loadConfigBeansOfType(MetricsConfig.class, configManager);\n    loadConfigBeansOfType(SslConfig.class, configManager);\n\n        \n    loadConfigBeansOfType(ModuleConfig.class, moduleModel.getConfigManager());\n    loadConfigBeansOfType(ProviderConfig.class, moduleModel.getConfigManager());\n    loadConfigBeansOfType(ConsumerConfig.class, moduleModel.getConfigManager());\n\n        \n    List<ConfigCenterBean> configCenterBeans = configManager.loadConfigsOfTypeFromProps(ConfigCenterBean.class);\n    for (ConfigCenterBean configCenterBean : configCenterBeans) {\n        String beanName = configCenterBean.getId() != null ? configCenterBean.getId() : \"configCenterBean\";\n        beanFactory.initializeBean(configCenterBean, beanName);\n    }\n\n    logger.info(\"dubbo config beans are loaded.\");\n}",
        "summary_tokens": [
            "initializes",
            "there",
            "dubbo",
            "s",
            "config",
            "beans",
            "before",
            "bean",
            "autowiring"
        ]
    },
    {
        "id": 640,
        "code": "public void setModuleModel(ModuleModel moduleModel) {\n    if (bound) {\n        throw new IllegalStateException(\"Cannot change ModuleModel after bound context\");\n    }\n    this.moduleModel = moduleModel;\n}",
        "summary_tokens": [
            "change",
            "the",
            "binding",
            "module",
            "model",
            "the",
            "module",
            "model",
            "and",
            "dubbo",
            "bootstrap",
            "must",
            "be",
            "matched"
        ]
    },
    {
        "id": 641,
        "code": "public void setKeepRunningOnSpringClosed(boolean keepRunningOnSpringClosed) {\n    this.setModuleAttribute(ModelConstants.KEEP_RUNNING_ON_SPRING_CLOSED, keepRunningOnSpringClosed);\n}",
        "summary_tokens": [
            "keep",
            "dubbo",
            "running",
            "when",
            "spring",
            "is",
            "stopped",
            "keep",
            "running",
            "on",
            "spring",
            "closed"
        ]
    },
    {
        "id": 642,
        "code": "private void registerServiceAnnotationPostProcessor(Set<String> packagesToScan, BeanDefinitionRegistry registry) {\n\n    BeanDefinitionBuilder builder = rootBeanDefinition(ServiceAnnotationPostProcessor.class);\n    builder.addConstructorArgValue(packagesToScan);\n    builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n    AbstractBeanDefinition beanDefinition = builder.getBeanDefinition();\n    BeanDefinitionReaderUtils.registerWithGeneratedName(beanDefinition, registry);\n\n}",
        "summary_tokens": [
            "registers",
            "service",
            "annotation",
            "post",
            "processor"
        ]
    },
    {
        "id": 643,
        "code": "public final ApplicationContext getApplicationContext() {\n    return (ApplicationContext) getSource();\n}",
        "summary_tokens": [
            "get",
            "the",
            "application",
            "context",
            "that",
            "the",
            "event",
            "was",
            "raised",
            "for"
        ]
    },
    {
        "id": 644,
        "code": "public ServiceBean getServiceBean() {\n    return (ServiceBean) super.getSource();\n}",
        "summary_tokens": [
            "get",
            "service",
            "bean",
            "instance"
        ]
    },
    {
        "id": 645,
        "code": "protected Iterable<PropertySource<?>> getPropertySources() {\n    return propertySources;\n}",
        "summary_tokens": [
            "get",
            "multiple",
            "property",
            "source",
            "property",
            "sources"
        ]
    },
    {
        "id": 646,
        "code": "public ReferenceBeanBuilder setInjvm(Boolean injvm) {\n    attributes.put(ReferenceAttributes.INJVM, injvm);\n    return this;\n}",
        "summary_tokens": [
            "injvm",
            "instead",
            "use",
            "the",
            "parameter",
            "b",
            "scope",
            "b",
            "to",
            "judge",
            "if",
            "it",
            "s",
            "in",
            "jvm",
            "scope",
            "local"
        ]
    },
    {
        "id": 647,
        "code": "public void prepareReferenceBeans() throws Exception {\n    initialized = true;\n    for (ReferenceBean referenceBean : getReferences()) {\n        initReferenceBean(referenceBean);\n    }\n}",
        "summary_tokens": [
            "initialize",
            "all",
            "reference",
            "beans",
            "call",
            "at",
            "dubbo",
            "starting"
        ]
    },
    {
        "id": 648,
        "code": "private synchronized void initReferenceBean(ReferenceBean referenceBean) throws Exception {\n\n    if (referenceBean.getReferenceConfig() != null) {\n        return;\n    }\n\n        \n\n        \n    String referenceKey = getReferenceKeyByBeanName(referenceBean.getId());\n    if (StringUtils.isEmpty(referenceKey)) {\n        referenceKey = ReferenceBeanSupport.generateReferenceKey(referenceBean, applicationContext);\n    }\n\n    ReferenceConfig referenceConfig = referenceConfigMap.get(referenceKey);\n    if (referenceConfig == null) {\n            \n        Map<String, Object> referenceAttributes = ReferenceBeanSupport.getReferenceAttributes(referenceBean);\n        referenceConfig = ReferenceCreator.create(referenceAttributes, applicationContext)\n                .defaultInterfaceClass(referenceBean.getObjectType())\n                .build();\n\n            \n        if (referenceBean.getId() != null && !referenceBean.getId().contains(\"#\")) {\n            referenceConfig.setId(referenceBean.getId());\n        }\n\n            \n        referenceConfigMap.put(referenceKey, referenceConfig);\n\n            \n        moduleModel.getConfigManager().addReference(referenceConfig);\n    }\n\n        \n    referenceBean.setKeyAndReferenceConfig(referenceKey, referenceConfig);\n}",
        "summary_tokens": [
            "note",
            "this",
            "method",
            "should",
            "only",
            "call",
            "after",
            "all",
            "dubbo",
            "config",
            "beans",
            "and",
            "all",
            "property",
            "resolvers",
            "is",
            "loaded"
        ]
    },
    {
        "id": 649,
        "code": "public static Map<String, Object> convertPropertyValues(MutablePropertyValues propertyValues) {\n    Map<String, Object> referenceProps = new LinkedHashMap<>();\n    for (PropertyValue propertyValue : propertyValues.getPropertyValueList()) {\n        String propertyName = propertyValue.getName();\n        Object value = propertyValue.getValue();\n        if (ReferenceAttributes.METHODS.equals(propertyName) || ReferenceAttributes.ARGUMENTS.equals(propertyName)) {\n            ManagedList managedList = (ManagedList) value;\n            List<Map<String, Object>> elementList = new ArrayList<>();\n            for (Object el : managedList) {\n                Map<String, Object> element = convertPropertyValues(((BeanDefinitionHolder) el).getBeanDefinition().getPropertyValues());\n                element.remove(ReferenceAttributes.ID);\n                elementList.add(element);\n            }\n            value = elementList.toArray(new Object[0]);\n        } else if (ReferenceAttributes.PARAMETERS.equals(propertyName)) {\n            value = createParameterMap((ManagedMap) value);\n        }\n            \n        if (value instanceof RuntimeBeanReference) {\n            RuntimeBeanReference beanReference = (RuntimeBeanReference) value;\n            value = beanReference.getBeanName();\n        }\n\n        if (value == null ||\n                (value instanceof String && StringUtils.isBlank((String) value))\n        ) {\n                \n            continue;\n        }\n\n        referenceProps.put(propertyName, value);\n    }\n\n    return referenceProps;\n}",
        "summary_tokens": [
            "convert",
            "to",
            "raw",
            "props",
            "without",
            "parsing",
            "nested",
            "config",
            "objects"
        ]
    },
    {
        "id": 650,
        "code": "protected void doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder) {\n\n    String packageToScan = element.getAttribute(\"package\");\n\n    String[] packagesToScan = trimArrayElements(commaDelimitedListToStringArray(packageToScan));\n\n    builder.addConstructorArgValue(packagesToScan);\n\n    builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\n        \n        \n}",
        "summary_tokens": [
            "parse",
            "prev",
            "lt",
            "dubbo",
            "annotation",
            "package",
            "gt",
            "prev"
        ]
    },
    {
        "id": 651,
        "code": "public BeanDefinition parse(Element element, ParserContext parserContext) {\n    BeanDefinitionRegistry registry = parserContext.getRegistry();\n    registerAnnotationConfigProcessors(registry);\n\n        \n    DubboSpringInitializer.initialize(parserContext.getRegistry());\n\n    BeanDefinition beanDefinition = super.parse(element, parserContext);\n    setSource(beanDefinition);\n    return beanDefinition;\n}",
        "summary_tokens": [
            "override",
            "namespace",
            "handler",
            "support",
            "parse",
            "element",
            "parser",
            "context",
            "method"
        ]
    },
    {
        "id": 652,
        "code": "private void registerAnnotationConfigProcessors(BeanDefinitionRegistry registry) {\n    AnnotationConfigUtils.registerAnnotationConfigProcessors(registry);\n}",
        "summary_tokens": [
            "register",
            "the",
            "processors",
            "for",
            "the",
            "spring",
            "annotation",
            "driven",
            "features"
        ]
    },
    {
        "id": 653,
        "code": "public static String resolveInterfaceName(Map<String, Object> attributes, Class<?> defaultInterfaceClass) {\n        \n    String interfaceClassName = getAttribute(attributes, \"interfaceName\");\n    if (StringUtils.hasText(interfaceClassName)) {\n        if (GenericService.class.getName().equals(interfaceClassName) ||\n            com.alibaba.dubbo.rpc.service.GenericService.class.getName().equals(interfaceClassName)) {\n            throw new IllegalStateException(\"@Service interfaceName() cannot be GenericService: \" + interfaceClassName);\n        }\n        return interfaceClassName;\n    }\n\n        \n    Class<?> interfaceClass = getAttribute(attributes, \"interfaceClass\");\n    if (interfaceClass == null || void.class.equals(interfaceClass)) { \n        interfaceClass = null;\n    } else  if (GenericService.class.isAssignableFrom(interfaceClass)) {\n        throw new IllegalStateException(\"@Service interfaceClass() cannot be GenericService :\" + interfaceClass.getName());\n    }\n\n        \n    if (interfaceClass == null && defaultInterfaceClass != null  && !GenericService.class.isAssignableFrom(defaultInterfaceClass)) {\n            \n            \n        Class<?>[] allInterfaces = getAllInterfacesForClass(defaultInterfaceClass);\n        if (allInterfaces.length > 0) {\n            interfaceClass = allInterfaces[0];\n        }\n    }\n\n    Assert.notNull(interfaceClass, \"@Service interfaceClass() or interfaceName() or interface class must be present!\");\n    Assert.isTrue(interfaceClass.isInterface(), \"The annotated type must be an interface!\");\n    return interfaceClass.getName();\n}",
        "summary_tokens": [
            "resolve",
            "the",
            "service",
            "interface",
            "name",
            "from",
            "annotation",
            "attributes"
        ]
    },
    {
        "id": 654,
        "code": "public static Map<String, String> convertParameters(String[] parameters) {\n    if (ArrayUtils.isEmpty(parameters)) {\n        return Collections.emptyMap();\n    }\n\n    List<String> compatibleParameterArray = Arrays.stream(parameters)\n        .map(String::trim)\n        .reduce(new ArrayList<>(parameters.length), (list, parameter) ->\n            {\n                if (list.size() % 2 == 1) {\n                        \n                    list.add(parameter);\n                    return list;\n                }\n\n                String[] sp1 = parameter.split(\":\");\n                if (sp1.length > 0 && sp1.length % 2 == 0) {\n                        \n                    list.addAll(Arrays.stream(sp1).map(String::trim).collect(Collectors.toList()));\n                    return list;\n                }\n                sp1 = parameter.split(\"=\");\n                if (sp1.length > 0 && sp1.length % 2 == 0) {\n                    list.addAll(Arrays.stream(sp1).map(String::trim).collect(Collectors.toList()));\n                    return list;\n                }\n                list.add(parameter);\n                return list;\n            }\n            , (a, b) -> a);\n\n    return CollectionUtils.toStringMap(compatibleParameterArray.toArray(new String[0]));\n}",
        "summary_tokens": [
            "resolve",
            "the",
            "parameters",
            "of",
            "org"
        ]
    },
    {
        "id": 655,
        "code": "static void registerCommonBeans(BeanDefinitionRegistry registry) {\n\n    registerInfrastructureBean(registry, ServicePackagesHolder.BEAN_NAME, ServicePackagesHolder.class);\n\n    registerInfrastructureBean(registry, ReferenceBeanManager.BEAN_NAME, ReferenceBeanManager.class);\n\n        \n    registerInfrastructureBean(registry, ReferenceAnnotationBeanPostProcessor.BEAN_NAME,\n        ReferenceAnnotationBeanPostProcessor.class);\n\n        \n        \n    registerInfrastructureBean(registry, DubboConfigAliasPostProcessor.BEAN_NAME,\n        DubboConfigAliasPostProcessor.class);\n\n        \n    registerInfrastructureBean(registry, DubboDeployApplicationListener.class.getName(), DubboDeployApplicationListener.class);\n    registerInfrastructureBean(registry, DubboConfigApplicationListener.class.getName(), DubboConfigApplicationListener.class);\n\n        \n    registerInfrastructureBean(registry, DubboConfigDefaultPropertyValueBeanPostProcessor.BEAN_NAME,\n        DubboConfigDefaultPropertyValueBeanPostProcessor.class);\n\n        \n    registerInfrastructureBean(registry, DubboConfigBeanInitializer.BEAN_NAME, DubboConfigBeanInitializer.class);\n\n        \n    registerInfrastructureBean(registry, DubboInfraBeanRegisterPostProcessor.BEAN_NAME, DubboInfraBeanRegisterPostProcessor.class);\n}",
        "summary_tokens": [
            "register",
            "the",
            "common",
            "beans"
        ]
    },
    {
        "id": 656,
        "code": "static void registerPlaceholderConfigurerBeanIfNotExists(ConfigurableListableBeanFactory beanFactory, BeanDefinitionRegistry registry) {\n        \n        \n    if (!checkBeanExists(beanFactory, PropertySourcesPlaceholderConfigurer.class)) {\n        Map<String, Object> propertySourcesPlaceholderPropertyValues = new HashMap<>();\n        propertySourcesPlaceholderPropertyValues.put(\"ignoreUnresolvablePlaceholders\", true);\n\n        registerBeanDefinition(registry, PropertySourcesPlaceholderConfigurer.class.getName(),\n            PropertySourcesPlaceholderConfigurer.class, propertySourcesPlaceholderPropertyValues);\n    }\n}",
        "summary_tokens": [
            "register",
            "a",
            "placeholder",
            "configurer",
            "beans",
            "if",
            "not",
            "exists"
        ]
    },
    {
        "id": 657,
        "code": "public static Map<String, Object> extractProperties(ConfigurableEnvironment environment) {\n    return Collections.unmodifiableMap(doExtraProperties(environment));\n}",
        "summary_tokens": [
            "extras",
            "the",
            "properties",
            "from",
            "configurable",
            "environment"
        ]
    },
    {
        "id": 658,
        "code": "public static SortedMap<String, String> filterDubboProperties(ConfigurableEnvironment environment) {\n\n    SortedMap<String, String> dubboProperties = new TreeMap<>();\n\n    Map<String, Object> properties = extractProperties(environment);\n\n    for (Map.Entry<String, Object> entry : properties.entrySet()) {\n        String propertyName = entry.getKey();\n\n        if (propertyName.startsWith(DUBBO_PREFIX + PROPERTY_NAME_SEPARATOR)\n                && entry.getValue() != null) {\n            dubboProperties.put(propertyName, environment.resolvePlaceholders(entry.getValue().toString()));\n        }\n    }\n\n    return Collections.unmodifiableSortedMap(dubboProperties);\n}",
        "summary_tokens": [
            "filters",
            "dubbo",
            "properties",
            "from",
            "configurable",
            "environment"
        ]
    },
    {
        "id": 659,
        "code": "public static Class getGenericTypeOfReturnType(MethodMetadata factoryMethodMetadata) {\n    if (factoryMethodMetadata instanceof StandardMethodMetadata) {\n        Method introspectedMethod = ((StandardMethodMetadata) factoryMethodMetadata).getIntrospectedMethod();\n        Type returnType = introspectedMethod.getGenericReturnType();\n        if (returnType instanceof ParameterizedType) {\n            ParameterizedType parameterizedType = (ParameterizedType) returnType;\n            Type actualTypeArgument = parameterizedType.getActualTypeArguments()[0];\n            if (actualTypeArgument instanceof Class) {\n                return (Class) actualTypeArgument;\n            }\n        }\n    }\n    return null;\n}",
        "summary_tokens": [
            "get",
            "the",
            "generic",
            "type",
            "of",
            "return",
            "type",
            "of",
            "the",
            "method"
        ]
    },
    {
        "id": 660,
        "code": "public int getClientPort() {\n    return this.clientPort;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "port",
            "that",
            "clients",
            "should",
            "use",
            "to",
            "connect",
            "to",
            "this",
            "embedded",
            "server"
        ]
    },
    {
        "id": 661,
        "code": "public void setAutoStartup(boolean autoStartup) {\n    this.autoStartup = autoStartup;\n}",
        "summary_tokens": [
            "specify",
            "whether",
            "to",
            "start",
            "automatically"
        ]
    },
    {
        "id": 662,
        "code": "public void setPhase(int phase) {\n    this.phase = phase;\n}",
        "summary_tokens": [
            "specify",
            "the",
            "lifecycle",
            "phase",
            "for",
            "the",
            "embedded",
            "server"
        ]
    },
    {
        "id": 663,
        "code": "public synchronized void start() {\n    if (zkServerThread == null) {\n        zkServerThread = new Thread(new ServerRunnable(), \"ZooKeeper Server Starter\");\n        zkServerThread.setDaemon(daemon);\n        zkServerThread.start();\n    }\n}",
        "summary_tokens": [
            "start",
            "the",
            "zoo",
            "keeper",
            "server",
            "in",
            "a",
            "background",
            "thread"
        ]
    },
    {
        "id": 664,
        "code": "public void stop(Runnable callback) {\n    stop();\n    callback.run();\n}",
        "summary_tokens": [
            "stop",
            "the",
            "server",
            "if",
            "running",
            "and",
            "invoke",
            "the",
            "callback",
            "when",
            "complete"
        ]
    },
    {
        "id": 665,
        "code": "public void setErrorHandler(ErrorHandler errorHandler) {\n    this.errorHandler = errorHandler;\n}",
        "summary_tokens": [
            "provide",
            "an",
            "error",
            "handler",
            "to",
            "be",
            "invoked",
            "if",
            "an",
            "exception",
            "is",
            "thrown",
            "from",
            "the",
            "zoo",
            "keeper",
            "server",
            "thread"
        ]
    },
    {
        "id": 666,
        "code": "public ApplicationConfig applicationConfig() {\n    ApplicationConfig applicationConfig = new ApplicationConfig();\n    applicationConfig.setName(\"dubbo-demo-application\");\n    return applicationConfig;\n}",
        "summary_tokens": [
            "current",
            "application",
            "configuration",
            "to",
            "replace",
            "xml",
            "config",
            "prev",
            "lt",
            "dubbo",
            "application",
            "name",
            "dubbo",
            "demo",
            "application",
            "gt",
            "prev"
        ]
    },
    {
        "id": 667,
        "code": "public RegistryConfig registryConfig() {\n    RegistryConfig registryConfig = new RegistryConfig();\n    registryConfig.setAddress(\"N/A\");\n    return registryConfig;\n}",
        "summary_tokens": [
            "current",
            "registry",
            "center",
            "configuration",
            "to",
            "replace",
            "xml",
            "config",
            "prev",
            "lt",
            "dubbo",
            "registry",
            "id",
            "my",
            "registry",
            "address",
            "n",
            "a",
            "gt",
            "prev"
        ]
    },
    {
        "id": 668,
        "code": "public ProtocolConfig protocolConfig() {\n    ProtocolConfig protocolConfig = new ProtocolConfig();\n    protocolConfig.setName(\"dubbo\");\n    protocolConfig.setPort(12345);\n    return protocolConfig;\n}",
        "summary_tokens": [
            "current",
            "protocol",
            "configuration",
            "to",
            "replace",
            "xml",
            "config",
            "prev",
            "lt",
            "dubbo",
            "protocol",
            "name",
            "dubbo",
            "port",
            "0",
            "gt",
            "prev"
        ]
    },
    {
        "id": 669,
        "code": "public ApplicationConfig applicationConfig() {\n    ApplicationConfig applicationConfig = new ApplicationConfig();\n    applicationConfig.setName(\"dubbo-demo-application\");\n    return applicationConfig;\n}",
        "summary_tokens": [
            "current",
            "application",
            "configuration",
            "to",
            "replace",
            "xml",
            "config",
            "prev",
            "lt",
            "dubbo",
            "application",
            "name",
            "dubbo",
            "demo",
            "application",
            "gt",
            "prev"
        ]
    },
    {
        "id": 670,
        "code": "public RegistryConfig registryConfig() {\n    RegistryConfig registryConfig = new RegistryConfig();\n    registryConfig.setAddress(\"N/A\");\n    return registryConfig;\n}",
        "summary_tokens": [
            "current",
            "registry",
            "center",
            "configuration",
            "to",
            "replace",
            "xml",
            "config",
            "prev",
            "lt",
            "dubbo",
            "registry",
            "address",
            "n",
            "a",
            "gt",
            "prev"
        ]
    },
    {
        "id": 671,
        "code": "public ApplicationConfig applicationConfig() {\n    ApplicationConfig applicationConfig = new ApplicationConfig();\n    applicationConfig.setName(\"dubbo-demo-application\");\n    return applicationConfig;\n}",
        "summary_tokens": [
            "current",
            "application",
            "configuration",
            "to",
            "replace",
            "xml",
            "config",
            "prev",
            "lt",
            "dubbo",
            "application",
            "name",
            "dubbo",
            "demo",
            "application",
            "gt",
            "prev"
        ]
    },
    {
        "id": 672,
        "code": "public RegistryConfig registryConfig() {\n    RegistryConfig registryConfig = new RegistryConfig();\n    registryConfig.setAddress(\"N/A\");\n    return registryConfig;\n}",
        "summary_tokens": [
            "current",
            "registry",
            "center",
            "configuration",
            "to",
            "replace",
            "xml",
            "config",
            "prev",
            "lt",
            "dubbo",
            "registry",
            "id",
            "my",
            "registry",
            "address",
            "n",
            "a",
            "gt",
            "prev"
        ]
    },
    {
        "id": 673,
        "code": "public ProtocolConfig protocolConfig() {\n    ProtocolConfig protocolConfig = new ProtocolConfig();\n    protocolConfig.setName(\"dubbo\");\n    protocolConfig.setPort(12345);\n    return protocolConfig;\n}",
        "summary_tokens": [
            "current",
            "protocol",
            "configuration",
            "to",
            "replace",
            "xml",
            "config",
            "prev",
            "lt",
            "dubbo",
            "protocol",
            "name",
            "dubbo",
            "port",
            "0",
            "gt",
            "prev"
        ]
    },
    {
        "id": 674,
        "code": "public int getOrder() {\n    return HIGHEST_PRECEDENCE;\n}",
        "summary_tokens": [
            "call",
            "before",
            "property",
            "placeholder",
            "configurer"
        ]
    },
    {
        "id": 675,
        "code": "public void addListener(String key, String group, ConfigurationListener listener) {\n    ApolloListener apolloListener = listeners.computeIfAbsent(group + key, k -> createTargetListener(key, group));\n    apolloListener.addListener(listener);\n    dubboConfig.addChangeListener(apolloListener, Collections.singleton(key));\n}",
        "summary_tokens": [
            "since",
            "all",
            "governance",
            "rules",
            "will",
            "lay",
            "under",
            "dubbo",
            "group",
            "this",
            "method",
            "now",
            "always",
            "uses",
            "the",
            "default",
            "dubbo",
            "config",
            "and",
            "ignores",
            "the",
            "group",
            "parameter"
        ]
    },
    {
        "id": 676,
        "code": "public String getProperties(String key, String group, long timeout) throws IllegalStateException {\n    if (StringUtils.isEmpty(group)) {\n        return dubboConfigFile.getContent();\n    }\n    if (group.equals(url.getApplication())) {\n        return ConfigService.getConfigFile(APOLLO_APPLICATION_KEY, ConfigFileFormat.Properties).getContent();\n    }\n\n    ConfigFile configFile = ConfigService.getConfigFile(group, ConfigFileFormat.Properties);\n    if (configFile == null) {\n        throw new IllegalStateException(\"There is no namespace named \" + group + \" in Apollo.\");\n    }\n    return configFile.getContent();\n}",
        "summary_tokens": [
            "recommend",
            "specify",
            "namespace",
            "and",
            "group",
            "when",
            "using",
            "apollo"
        ]
    },
    {
        "id": 677,
        "code": "public String getInternalProperty(String key) {\n    return dubboConfig.getProperty(key, null);\n}",
        "summary_tokens": [
            "this",
            "method",
            "will",
            "be",
            "used",
            "by",
            "configuration",
            "to",
            "get",
            "valid",
            "value",
            "at",
            "runtime"
        ]
    },
    {
        "id": 678,
        "code": "private ApolloListener createTargetListener(String key, String group) {\n    return new ApolloListener();\n}",
        "summary_tokens": [
            "ignores",
            "the",
            "group",
            "parameter"
        ]
    },
    {
        "id": 679,
        "code": "public void testGetInternalProperty() throws InterruptedException {\n    String mockKey = \"mockKey2\";\n    String mockValue = String.valueOf(new Random().nextInt());\n    putMockRuleData(mockKey, mockValue, DEFAULT_NAMESPACE);\n    TimeUnit.MILLISECONDS.sleep(1000);\n    apolloDynamicConfiguration = new ApolloDynamicConfiguration(url);\n    assertEquals(mockValue, apolloDynamicConfiguration.getInternalProperty(mockKey));\n\n    mockValue = \"mockValue2\";\n    System.setProperty(mockKey, mockValue);\n    assertEquals(mockValue, apolloDynamicConfiguration.getInternalProperty(mockKey));\n\n    mockKey = \"notExistKey\";\n    assertNull(apolloDynamicConfiguration.getInternalProperty(mockKey));\n}",
        "summary_tokens": [
            "test",
            "get",
            "internal",
            "property"
        ]
    },
    {
        "id": 680,
        "code": "private Map<String, String> mergeOverriddenProperties(String namespace, Map<String, String> configurations) {\n    if (addedOrModifiedPropertiesOfNamespace.containsKey(namespace)) {\n        configurations.putAll(addedOrModifiedPropertiesOfNamespace.get(namespace));\n    }\n    if (deletedKeysOfNamespace.containsKey(namespace)) {\n        for (String k : deletedKeysOfNamespace.get(namespace)) {\n            configurations.remove(k);\n        }\n    }\n    return configurations;\n}",
        "summary_tokens": [
            "incorporate",
            "user",
            "modifications",
            "to",
            "namespace"
        ]
    },
    {
        "id": 681,
        "code": "public void addOrModifyProperty(String namespace, String someKey, String someValue) {\n    if (addedOrModifiedPropertiesOfNamespace.containsKey(namespace)) {\n        addedOrModifiedPropertiesOfNamespace.get(namespace).put(someKey, someValue);\n    } else {\n        Map<String, String> m = Maps.newConcurrentMap();\n        m.put(someKey, someValue);\n        addedOrModifiedPropertiesOfNamespace.put(namespace, m);\n    }\n}",
        "summary_tokens": [
            "add",
            "new",
            "property",
            "or",
            "update",
            "existed",
            "property"
        ]
    },
    {
        "id": 682,
        "code": "private NacosConfigListener createTargetListener(String key, String group) {\n    NacosConfigListener configListener = new NacosConfigListener();\n    configListener.fillContext(key, group);\n    return configListener;\n}",
        "summary_tokens": [
            "ignores",
            "the",
            "group",
            "parameter"
        ]
    },
    {
        "id": 683,
        "code": "public static void main(String[] args) throws Exception {\n    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"spring/dubbo-consumer.xml\");\n    context.start();\n    DemoService demoService = context.getBean(\"demoService\", DemoService.class);\n    GreetingService greetingService = context.getBean(\"greetingService\", GreetingService.class);\n    RestDemoService restDemoService = context.getBean(\"restDemoService\", RestDemoService.class);\n    TripleService tripleService = context.getBean(\"tripleService\", TripleService.class);\n\n    new Thread(() -> {\n        while (true) {\n            try {\n                String greetings = greetingService.hello();\n                System.out.println(greetings + \" from separated thread.\");\n            } catch (Exception e) {\n\n            }\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n            }\n        }\n    }).start();\n\n    new Thread(() -> {\n        while (true) {\n            try {\n                String restResult = restDemoService.sayHello(\"rest\");\n                System.out.println(restResult + \" from separated thread.\");\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n            }\n        }\n    }).start();\n\n    new Thread(() -> {\n        while (true) {\n            try {\n                String restResult = tripleService.hello();\n                System.out.println(restResult + \" from separated thread.\");\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n            }\n        }\n    }).start();\n\n    while (true) {\n        try {\n            CompletableFuture<String> hello = demoService.sayHelloAsync(\"world\");\n            System.out.println(\"result: \" + hello.get());\n\n            String greetings = greetingService.hello();\n            System.out.println(\"result: \" + greetings);\n        } catch (Exception e) {\n\n        }\n\n        Thread.sleep(5000);\n    }\n}",
        "summary_tokens": [
            "in",
            "order",
            "to",
            "make",
            "sure",
            "multicast",
            "registry",
            "works",
            "need",
            "to",
            "specify",
            "djava"
        ]
    },
    {
        "id": 684,
        "code": "public void setCacheFactory(CacheFactory cacheFactory) {\n    this.cacheFactory = cacheFactory;\n}",
        "summary_tokens": [
            "dubbo",
            "will",
            "populate",
            "and",
            "set",
            "the",
            "cache",
            "factory",
            "instance",
            "based",
            "on",
            "service",
            "method",
            "consumer",
            "provider",
            "configured",
            "cache",
            "attribute",
            "value"
        ]
    },
    {
        "id": 685,
        "code": "public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {\n    if (cacheFactory == null || ConfigUtils.isEmpty(invoker.getUrl().getMethodParameter(invocation.getMethodName(), CACHE_KEY))) {\n        return invoker.invoke(invocation);\n    }\n    Cache cache = cacheFactory.getCache(invoker.getUrl(), invocation);\n    if (cache == null) {\n        return invoker.invoke(invocation);\n    }\n    String key = StringUtils.toArgumentString(invocation.getArguments());\n    Object value = cache.get(key);\n    return (value != null) ? onCacheValuePresent(invocation, value) : onCacheValueNotPresent(invoker, invocation, cache, key);\n}",
        "summary_tokens": [
            "if",
            "cache",
            "is",
            "configured",
            "dubbo",
            "will",
            "invoke",
            "method",
            "on",
            "each",
            "method",
            "call"
        ]
    },
    {
        "id": 686,
        "code": "public Cache getCache(URL url, Invocation invocation) {\n    url = url.addParameter(METHOD_KEY, invocation.getMethodName());\n    String key = url.getServiceKey() + invocation.getMethodName();\n    Cache cache = caches.get(key);\n\n        \n    if (null != cache) {\n        return cache;\n    }\n\n    synchronized (MONITOR) {\n            \n        cache = caches.get(key);\n        if (null != cache) {\n            return cache;\n        }\n\n        cache = createCache(url);\n        caches.put(key, cache);\n    }\n\n    return cache;\n}",
        "summary_tokens": [
            "takes",
            "url",
            "and",
            "invocation",
            "instance",
            "and",
            "return",
            "cache",
            "instance",
            "for",
            "a",
            "given",
            "url"
        ]
    },
    {
        "id": 687,
        "code": "public void put(Object key, Object value) {\n    store.put(key, value);\n}",
        "summary_tokens": [
            "api",
            "to",
            "store",
            "value",
            "against",
            "a",
            "key",
            "in",
            "the",
            "calling",
            "thread",
            "scope"
        ]
    },
    {
        "id": 688,
        "code": "public Object get(Object key) {\n    return store.get(key);\n}",
        "summary_tokens": [
            "api",
            "to",
            "return",
            "stored",
            "value",
            "using",
            "a",
            "key",
            "against",
            "the",
            "calling",
            "thread",
            "specific",
            "store"
        ]
    },
    {
        "id": 689,
        "code": "protected Cache createCache(URL url) {\n    return new ExpiringCache(url);\n}",
        "summary_tokens": [
            "takes",
            "url",
            "as",
            "an",
            "method",
            "argument",
            "and",
            "return",
            "new",
            "instance",
            "of",
            "cache",
            "store",
            "implemented",
            "by",
            "jcache"
        ]
    },
    {
        "id": 690,
        "code": "protected Cache createCache(URL url) {\n    return new JCache(url);\n}",
        "summary_tokens": [
            "takes",
            "url",
            "as",
            "an",
            "method",
            "argument",
            "and",
            "return",
            "new",
            "instance",
            "of",
            "cache",
            "store",
            "implemented",
            "by",
            "jcache"
        ]
    },
    {
        "id": 691,
        "code": "public void put(Object key, Object value) {\n    store.put(key, value);\n}",
        "summary_tokens": [
            "api",
            "to",
            "store",
            "value",
            "against",
            "a",
            "key",
            "in",
            "the",
            "calling",
            "thread",
            "scope"
        ]
    },
    {
        "id": 692,
        "code": "public Object get(Object key) {\n    return store.get(key);\n}",
        "summary_tokens": [
            "api",
            "to",
            "return",
            "stored",
            "value",
            "using",
            "a",
            "key",
            "against",
            "the",
            "calling",
            "thread",
            "specific",
            "store"
        ]
    },
    {
        "id": 693,
        "code": "protected Cache createCache(URL url) {\n    return new LfuCache(url);\n}",
        "summary_tokens": [
            "takes",
            "url",
            "as",
            "an",
            "method",
            "argument",
            "and",
            "return",
            "new",
            "instance",
            "of",
            "cache",
            "store",
            "implemented",
            "by",
            "lfu",
            "cache"
        ]
    },
    {
        "id": 694,
        "code": "public void put(Object key, Object value) {\n    store.put(key, value);\n}",
        "summary_tokens": [
            "api",
            "to",
            "store",
            "value",
            "against",
            "a",
            "key",
            "in",
            "the",
            "calling",
            "thread",
            "scope"
        ]
    },
    {
        "id": 695,
        "code": "public Object get(Object key) {\n    return store.get(key);\n}",
        "summary_tokens": [
            "api",
            "to",
            "return",
            "stored",
            "value",
            "using",
            "a",
            "key",
            "against",
            "the",
            "calling",
            "thread",
            "specific",
            "store"
        ]
    },
    {
        "id": 696,
        "code": "protected Cache createCache(URL url) {\n    return new LruCache(url);\n}",
        "summary_tokens": [
            "takes",
            "url",
            "as",
            "an",
            "method",
            "argument",
            "and",
            "return",
            "new",
            "instance",
            "of",
            "cache",
            "store",
            "implemented",
            "by",
            "lru",
            "cache"
        ]
    },
    {
        "id": 697,
        "code": "public void put(Object key, Object value) {\n    store.get().put(key, value);\n}",
        "summary_tokens": [
            "api",
            "to",
            "store",
            "value",
            "against",
            "a",
            "key",
            "in",
            "the",
            "calling",
            "thread",
            "scope"
        ]
    },
    {
        "id": 698,
        "code": "public Object get(Object key) {\n    return store.get().get(key);\n}",
        "summary_tokens": [
            "api",
            "to",
            "return",
            "stored",
            "value",
            "using",
            "a",
            "key",
            "against",
            "the",
            "calling",
            "thread",
            "specific",
            "store"
        ]
    },
    {
        "id": 699,
        "code": "protected Cache createCache(URL url) {\n    return new ThreadLocalCache(url);\n}",
        "summary_tokens": [
            "takes",
            "url",
            "as",
            "an",
            "method",
            "argument",
            "and",
            "return",
            "new",
            "instance",
            "of",
            "cache",
            "store",
            "implemented",
            "by",
            "thread",
            "local",
            "cache"
        ]
    },
    {
        "id": 700,
        "code": "public void setValidation(Validation validation) {\n    this.validation = validation;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "validation",
            "instance",
            "for",
            "validation",
            "filter"
        ]
    },
    {
        "id": 701,
        "code": "public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {\n    if (validation != null && !invocation.getMethodName().startsWith(\"$\")\n        && ConfigUtils.isNotEmpty(invoker.getUrl().getMethodParameter(invocation.getMethodName(), VALIDATION_KEY))) {\n        try {\n            Validator validator = validation.getValidator(invoker.getUrl());\n            if (validator != null) {\n                validator.validate(invocation.getMethodName(), invocation.getParameterTypes(), invocation.getArguments());\n            }\n        } catch (RpcException e) {\n            throw e;\n        } catch (Throwable t) {\n            return AsyncRpcResult.newDefaultAsyncResult(t, invocation);\n        }\n    }\n    return invoker.invoke(invocation);\n}",
        "summary_tokens": [
            "perform",
            "the",
            "validation",
            "of",
            "before",
            "invoking",
            "the",
            "actual",
            "method",
            "based",
            "on",
            "b",
            "validation",
            "b",
            "attribute",
            "value"
        ]
    },
    {
        "id": 702,
        "code": "protected Validator createValidator(URL url) {\n    return new JValidator(url);\n}",
        "summary_tokens": [
            "return",
            "new",
            "instance",
            "of",
            "jvalidator",
            "url",
            "valid",
            "url",
            "instance",
            "instance",
            "of",
            "jvalidator"
        ]
    },
    {
        "id": 703,
        "code": "protected Validator createValidator(URL url) {\n    return new JValidatorNew(url);\n}",
        "summary_tokens": [
            "return",
            "new",
            "instance",
            "of",
            "jvalidator",
            "url",
            "valid",
            "url",
            "instance",
            "instance",
            "of",
            "jvalidator"
        ]
    },
    {
        "id": 704,
        "code": "private static Class<?> generateMethodParameterClass(Class<?> clazz, Method method, String parameterClassName)\n    throws Exception {\n    ClassPool pool = ClassGenerator.getClassPool(clazz.getClassLoader());\n    synchronized (parameterClassName.intern()) {\n        CtClass ctClass = null;\n        try {\n            ctClass = pool.getCtClass(parameterClassName);\n        } catch (NotFoundException ignore) {\n        }\n\n        if (null == ctClass) {\n            ctClass = pool.makeClass(parameterClassName);\n            ClassFile classFile = ctClass.getClassFile();\n            classFile.setVersionToJava5();\n            ctClass.addConstructor(CtNewConstructor.defaultConstructor(pool.getCtClass(parameterClassName)));\n                \n            Class<?>[] parameterTypes = method.getParameterTypes();\n            Annotation[][] parameterAnnotations = method.getParameterAnnotations();\n            for (int i = 0; i < parameterTypes.length; i++) {\n                Class<?> type = parameterTypes[i];\n                Annotation[] annotations = parameterAnnotations[i];\n                AnnotationsAttribute attribute = new AnnotationsAttribute(classFile.getConstPool(), AnnotationsAttribute.visibleTag);\n                for (Annotation annotation : annotations) {\n                    if (annotation.annotationType().isAnnotationPresent(Constraint.class)) {\n                        javassist.bytecode.annotation.Annotation ja = new javassist.bytecode.annotation.Annotation(\n                            classFile.getConstPool(), pool.getCtClass(annotation.annotationType().getName()));\n                        Method[] members = annotation.annotationType().getMethods();\n                        for (Method member : members) {\n                            if (Modifier.isPublic(member.getModifiers())\n                                && member.getParameterTypes().length == 0\n                                && member.getDeclaringClass() == annotation.annotationType()) {\n                                Object value = member.invoke(annotation);\n                                if (null != value) {\n                                    MemberValue memberValue = createMemberValue(\n                                        classFile.getConstPool(), pool.get(member.getReturnType().getName()), value);\n                                    ja.addMemberValue(member.getName(), memberValue);\n                                }\n                            }\n                        }\n                        attribute.addAnnotation(ja);\n                    }\n                }\n                String fieldName = method.getName() + \"Argument\" + i;\n                CtField ctField = CtField.make(\"public \" + type.getCanonicalName() + \" \" + fieldName + \";\", pool.getCtClass(parameterClassName));\n                ctField.getFieldInfo().addAttribute(attribute);\n                ctClass.addField(ctField);\n            }\n            return ctClass.toClass(clazz.getClassLoader(), null);\n        } else {\n            return Class.forName(parameterClassName, true, clazz.getClassLoader());\n        }\n    }\n}",
        "summary_tokens": [
            "try",
            "to",
            "generate",
            "method",
            "parameter",
            "class"
        ]
    },
    {
        "id": 705,
        "code": "private static Class<?> generateMethodParameterClass(Class<?> clazz, Method method, String parameterClassName)\n    throws Exception {\n    ClassPool pool = ClassGenerator.getClassPool(clazz.getClassLoader());\n    synchronized (parameterClassName.intern()) {\n        CtClass ctClass = null;\n        try {\n            ctClass = pool.getCtClass(parameterClassName);\n        } catch (NotFoundException ignore) {\n        }\n\n        if (null == ctClass) {\n            ctClass = pool.makeClass(parameterClassName);\n            ClassFile classFile = ctClass.getClassFile();\n            classFile.setVersionToJava5();\n            ctClass.addConstructor(CtNewConstructor.defaultConstructor(pool.getCtClass(parameterClassName)));\n                \n            Class<?>[] parameterTypes = method.getParameterTypes();\n            Annotation[][] parameterAnnotations = method.getParameterAnnotations();\n            for (int i = 0; i < parameterTypes.length; i++) {\n                Class<?> type = parameterTypes[i];\n                Annotation[] annotations = parameterAnnotations[i];\n                AnnotationsAttribute attribute = new AnnotationsAttribute(classFile.getConstPool(), AnnotationsAttribute.visibleTag);\n                for (Annotation annotation : annotations) {\n                    if (annotation.annotationType().isAnnotationPresent(Constraint.class)) {\n                        javassist.bytecode.annotation.Annotation ja = new javassist.bytecode.annotation.Annotation(\n                            classFile.getConstPool(), pool.getCtClass(annotation.annotationType().getName()));\n                        Method[] members = annotation.annotationType().getMethods();\n                        for (Method member : members) {\n                            if (Modifier.isPublic(member.getModifiers())\n                                && member.getParameterTypes().length == 0\n                                && member.getDeclaringClass() == annotation.annotationType()) {\n                                Object value = member.invoke(annotation);\n                                if (null != value) {\n                                    MemberValue memberValue = createMemberValue(\n                                        classFile.getConstPool(), pool.get(member.getReturnType().getName()), value);\n                                    ja.addMemberValue(member.getName(), memberValue);\n                                }\n                            }\n                        }\n                        attribute.addAnnotation(ja);\n                    }\n                }\n                String fieldName = method.getName() + \"Argument\" + i;\n                CtField ctField = CtField.make(\"public \" + type.getCanonicalName() + \" \" + fieldName + \";\", pool.getCtClass(parameterClassName));\n                ctField.getFieldInfo().addAttribute(attribute);\n                ctClass.addField(ctField);\n            }\n            return ctClass.toClass(clazz.getClassLoader(), null);\n        } else {\n            return Class.forName(parameterClassName, true, clazz.getClassLoader());\n        }\n    }\n}",
        "summary_tokens": [
            "try",
            "to",
            "generate",
            "method",
            "parameter",
            "class"
        ]
    },
    {
        "id": 706,
        "code": "public void doUpdate(ServiceInstance serviceInstance) throws RuntimeException {\n    reportMetadata(serviceInstance.getServiceMetadata());\n    this.doRegister(serviceInstance);\n}",
        "summary_tokens": [
            "comparing",
            "to",
            "abstract",
            "service",
            "discovery",
            "do",
            "update",
            "service",
            "instance",
            "unregister",
            "is",
            "unnecessary",
            "here"
        ]
    },
    {
        "id": 707,
        "code": "default String echo(String msg) {\n    return msg;\n}",
        "summary_tokens": [
            "echo",
            "test",
            "used",
            "to",
            "check",
            "consumer",
            "still",
            "online"
        ]
    },
    {
        "id": 708,
        "code": "public void init() {\n    if (!initiated.compareAndSet(false, true)) {\n        return;\n    }\n    if (CollectionUtils.isNotEmptyMap(services)) {\n        services.forEach((_k, serviceInfo) -> {\n            serviceInfo.init();\n                \n            if (subscribedServices == null) {\n                subscribedServices = new HashMap<>();\n            }\n            Set<ServiceInfo> serviceInfos = subscribedServices.computeIfAbsent(serviceInfo.getServiceKey(), _key -> new HashSet<>());\n            serviceInfos.add(serviceInfo);\n        });\n    }\n}",
        "summary_tokens": [
            "initialize",
            "is",
            "needed",
            "when",
            "metadata",
            "info",
            "is",
            "created",
            "from",
            "deserialization",
            "on",
            "the",
            "consumer",
            "side",
            "before",
            "being",
            "used",
            "for",
            "rpc",
            "call"
        ]
    },
    {
        "id": 709,
        "code": "public synchronized String calAndGetRevision() {\n    if (revision != null && !updated) {\n        return revision;\n    }\n\n    updated = false;\n\n    if (CollectionUtils.isEmptyMap(services)) {\n        this.revision = EMPTY_REVISION;\n    } else {\n        StringBuilder sb = new StringBuilder();\n        sb.append(app);\n        for (Map.Entry<String, ServiceInfo> entry : new TreeMap<>(services).entrySet()) {\n            sb.append(entry.getValue().toDescString());\n        }\n        String tempRevision = RevisionResolver.calRevision(sb.toString());\n        if (!StringUtils.isEquals(this.revision, tempRevision)) {\n            if (logger.isInfoEnabled()) {\n                logger.info(String.format(\"metadata revision changed: %s -> %s, app: %s, services: %d\", this.revision, tempRevision, this.app, this.services.size()));\n            }\n            this.revision = tempRevision;\n            this.rawMetadataInfo = JsonUtils.getJson().toJson(this);\n        }\n    }\n    return revision;\n}",
        "summary_tokens": [
            "calculation",
            "of",
            "this",
            "instance",
            "s",
            "status",
            "like",
            "revision",
            "and",
            "modification",
            "of",
            "the",
            "same",
            "instance",
            "must",
            "be",
            "synchronized",
            "among",
            "different",
            "threads"
        ]
    },
    {
        "id": 710,
        "code": "public ServiceInfo getServiceInfo(String protocolServiceKey) {\n    return services.get(protocolServiceKey);\n}",
        "summary_tokens": [
            "get",
            "service",
            "info",
            "of",
            "an",
            "interface",
            "with",
            "specified",
            "group",
            "version",
            "and",
            "protocol",
            "protocol",
            "service",
            "key",
            "key",
            "is",
            "of",
            "format",
            "group",
            "interface",
            "name",
            "version",
            "protocol",
            "the",
            "specific",
            "service",
            "info",
            "related",
            "to",
            "protocol",
            "service",
            "key"
        ]
    },
    {
        "id": 711,
        "code": "public ServiceInfo getNoProtocolServiceInfo(String serviceKeyWithoutProtocol) {\n    if (CollectionUtils.isEmptyMap(subscribedServices)) {\n        return null;\n    }\n    Set<ServiceInfo> subServices = subscribedServices.get(serviceKeyWithoutProtocol);\n    if (CollectionUtils.isNotEmpty(subServices)) {\n       return subServices.iterator().next();\n    }\n    return null;\n}",
        "summary_tokens": [
            "get",
            "service",
            "infos",
            "of",
            "an",
            "interface",
            "with",
            "specified",
            "group",
            "version"
        ]
    },
    {
        "id": 712,
        "code": "default String[] serviceParamsIncluded() {\n    return new String[0];\n}",
        "summary_tokens": [
            "params",
            "that",
            "need",
            "to",
            "be",
            "sent",
            "to",
            "metadata",
            "center"
        ]
    },
    {
        "id": 713,
        "code": "default String[] serviceParamsExcluded() {\n    return new String[0];\n}",
        "summary_tokens": [
            "params",
            "that",
            "need",
            "to",
            "be",
            "excluded",
            "before",
            "sending",
            "to",
            "metadata",
            "center"
        ]
    },
    {
        "id": 714,
        "code": "default String[] instanceParamsIncluded() {\n    return new String[0];\n}",
        "summary_tokens": [
            "params",
            "that",
            "need",
            "to",
            "be",
            "sent",
            "to",
            "registry",
            "center"
        ]
    },
    {
        "id": 715,
        "code": "default String[] instanceParamsExcluded() {\n    return new String[0];\n}",
        "summary_tokens": [
            "params",
            "that",
            "need",
            "to",
            "be",
            "excluded",
            "before",
            "sending",
            "to",
            "registry",
            "center"
        ]
    },
    {
        "id": 716,
        "code": "default String version() {\n    return VERSION;\n}",
        "summary_tokens": [
            "gets",
            "the",
            "version",
            "of",
            "metadata",
            "service",
            "that",
            "always",
            "equals",
            "version"
        ]
    },
    {
        "id": 717,
        "code": "default SortedSet<String> getSubscribedURLs() {\n    throw new UnsupportedOperationException(\"This operation is not supported for consumer.\");\n}",
        "summary_tokens": [
            "the",
            "list",
            "of",
            "string",
            "that",
            "presents",
            "all",
            "dubbo",
            "subscribed",
            "url",
            "urls"
        ]
    },
    {
        "id": 718,
        "code": "default SortedSet<String> getExportedURLs(String serviceInterface, String group, String version) {\n    return getExportedURLs(serviceInterface, group, version, null);\n}",
        "summary_tokens": [
            "get",
            "the",
            "sorted",
            "set",
            "sorted",
            "set",
            "of",
            "string",
            "that",
            "presents",
            "the",
            "specified",
            "dubbo",
            "exported",
            "url",
            "urls",
            "by",
            "the",
            "code",
            "service",
            "interface",
            "code",
            "code",
            "group",
            "code",
            "and",
            "code",
            "version",
            "code"
        ]
    },
    {
        "id": 719,
        "code": "static SortedSet<String> toSortedStrings(Stream<URL> stream) {\n    return unmodifiableSortedSet(stream.map(URL::toFullString).collect(TreeSet::new, Set::add, Set::addAll));\n}",
        "summary_tokens": [
            "convert",
            "the",
            "specified",
            "stream",
            "of",
            "url",
            "urls",
            "to",
            "be",
            "the",
            "url",
            "to",
            "full",
            "string",
            "strings",
            "presenting",
            "the",
            "url",
            "urls"
        ]
    },
    {
        "id": 720,
        "code": "static ServiceNameMapping getDefaultExtension(ScopeModel scopeModel) {\n    return ScopeModelUtil.getApplicationModel(scopeModel).getDefaultExtension(ServiceNameMapping.class);\n}",
        "summary_tokens": [
            "get",
            "the",
            "default",
            "extension",
            "of",
            "service",
            "name",
            "mapping"
        ]
    },
    {
        "id": 721,
        "code": "default Set<String> getServiceAppMapping(String serviceKey, MappingListener listener, URL url) {\n    return Collections.emptySet();\n}",
        "summary_tokens": [
            "service",
            "application",
            "mapping",
            "start"
        ]
    },
    {
        "id": 722,
        "code": "public boolean retry() {\n    return doHandleMetadataCollection(failedReports);\n}",
        "summary_tokens": [
            "if",
            "need",
            "to",
            "continue"
        ]
    },
    {
        "id": 723,
        "code": "long calculateStartTime() {\n    Calendar calendar = Calendar.getInstance();\n    long nowMill = calendar.getTimeInMillis();\n    calendar.set(Calendar.HOUR_OF_DAY, 0);\n    calendar.set(Calendar.MINUTE, 0);\n    calendar.set(Calendar.SECOND, 0);\n    calendar.set(Calendar.MILLISECOND, 0);\n    long subtract = calendar.getTimeInMillis() + ONE_DAY_IN_MILLISECONDS - nowMill;\n    return subtract + (FOUR_HOURS_IN_MILLISECONDS / 2) + ThreadLocalRandom.current().nextInt(FOUR_HOURS_IN_MILLISECONDS);\n}",
        "summary_tokens": [
            "between",
            "0",
            "0",
            "am",
            "to",
            "0",
            "0",
            "am",
            "the",
            "time",
            "is",
            "random"
        ]
    },
    {
        "id": 724,
        "code": "protected void processServiceRestMetadata(ServiceRestMetadata serviceRestMetadata, Class<?> serviceType) {\n    ServiceAnnotationResolver resolver = new ServiceAnnotationResolver(serviceType);\n    serviceRestMetadata.setServiceInterface(resolver.resolveInterfaceClassName());\n    serviceRestMetadata.setVersion(resolver.resolveVersion());\n    serviceRestMetadata.setGroup(resolver.resolveGroup());\n}",
        "summary_tokens": [
            "process",
            "the",
            "service",
            "type",
            "including",
            "the",
            "sub",
            "routines",
            "ul",
            "li",
            "service",
            "rest",
            "metadata",
            "set",
            "service",
            "interface",
            "string",
            "li",
            "li",
            "service",
            "rest",
            "metadata",
            "set",
            "version",
            "string",
            "li",
            "li",
            "service",
            "rest",
            "metadata",
            "set",
            "group",
            "string",
            "li",
            "ul"
        ]
    },
    {
        "id": 725,
        "code": "protected void processAllRestMethodMetadata(ServiceRestMetadata serviceRestMetadata, Class<?> serviceType) {\n    Class<?> serviceInterfaceClass = resolveServiceInterfaceClass(serviceRestMetadata, serviceType);\n    Map<Method, Method> serviceMethodsMap = resolveServiceMethodsMap(serviceType, serviceInterfaceClass);\n    for (Map.Entry<Method, Method> entry : serviceMethodsMap.entrySet()) {\n            \n        Method serviceMethod = entry.getKey();\n            \n        if (!processRestMethodMetadata(serviceMethod, serviceType, serviceInterfaceClass, serviceRestMetadata.getMeta()::add)) {\n            Method declaredServiceMethod = entry.getValue();\n            processRestMethodMetadata(declaredServiceMethod, serviceType, serviceInterfaceClass,\n                    serviceRestMetadata.getMeta()::add);\n        }\n    }\n}",
        "summary_tokens": [
            "process",
            "all",
            "rest",
            "method",
            "metadata"
        ]
    },
    {
        "id": 726,
        "code": "protected Map<Method, Method> resolveServiceMethodsMap(Class<?> serviceType, Class<?> serviceInterfaceClass) {\n    Map<Method, Method> serviceMethodsMap = new LinkedHashMap<>();\n        \n    List<Method> declaredServiceMethods = new ArrayList<>(getAllMethods(serviceInterfaceClass, excludedDeclaredClass(Object.class)));\n    List<Method> serviceMethods = new ArrayList<>(getAllMethods(serviceType, excludedDeclaredClass(Object.class)));\n\n        \n    sort(declaredServiceMethods, MethodComparator.INSTANCE);\n    sort(serviceMethods, MethodComparator.INSTANCE);\n\n    for (Method declaredServiceMethod : declaredServiceMethods) {\n        for (Method serviceMethod : serviceMethods) {\n            if (overrides(serviceMethod, declaredServiceMethod)) {\n                serviceMethodsMap.put(serviceMethod, declaredServiceMethod);\n                continue;\n            }\n        }\n    }\n        \n    return unmodifiableMap(serviceMethodsMap);\n}",
        "summary_tokens": [
            "resolve",
            "a",
            "map",
            "of",
            "all",
            "public",
            "services",
            "methods",
            "from",
            "the",
            "specified",
            "service",
            "type",
            "and",
            "its",
            "interface",
            "class",
            "whose",
            "key",
            "is",
            "the",
            "declared",
            "method",
            "and",
            "the",
            "value",
            "is",
            "the",
            "overrider",
            "method"
        ]
    },
    {
        "id": 727,
        "code": "protected Class<?> resolveServiceInterfaceClass(ServiceRestMetadata serviceRestMetadata, Class<?> serviceType) {\n    return execute(serviceType.getClassLoader(), classLoader -> {\n        String serviceInterface = serviceRestMetadata.getServiceInterface();\n        return forName(serviceInterface, classLoader);\n    });\n}",
        "summary_tokens": [
            "resolve",
            "the",
            "class",
            "of",
            "dubbo",
            "service",
            "interface"
        ]
    },
    {
        "id": 728,
        "code": "protected boolean processRestMethodMetadata(Method serviceMethod, Class<?> serviceType,\n                                            Class<?> serviceInterfaceClass,\n                                            Consumer<RestMethodMetadata> metadataToProcess) {\n\n    if (!isRestCapableMethod(serviceMethod, serviceType, serviceInterfaceClass)) {\n        return false;\n    }\n\n    String requestPath = resolveRequestPath(serviceMethod, serviceType, serviceInterfaceClass); \n\n    if (requestPath == null) {\n        return false;\n    }\n\n    String requestMethod = resolveRequestMethod(serviceMethod, serviceType, serviceInterfaceClass); \n\n    if (requestMethod == null) {\n        return false;\n    }\n\n    RestMethodMetadata metadata = new RestMethodMetadata();\n\n    MethodDefinition methodDefinition = resolveMethodDefinition(serviceMethod, serviceType, serviceInterfaceClass);\n        \n    metadata.setMethod(methodDefinition);\n\n        \n    processAnnotatedMethodParameters(serviceMethod, serviceType, serviceInterfaceClass, metadata);\n\n        \n    Set<String> produces = new LinkedHashSet<>();\n    processProduces(serviceMethod, serviceType, serviceInterfaceClass, produces);\n\n        \n    Set<String> consumes = new LinkedHashSet<>();\n    processConsumes(serviceMethod, serviceType, serviceInterfaceClass, consumes);\n\n        \n    RequestMetadata request = metadata.getRequest();\n    request.setPath(requestPath);\n    request.setMethod(requestMethod);\n    request.setProduces(produces);\n    request.setConsumes(consumes);\n\n        \n    postResolveRestMethodMetadata(serviceMethod, serviceType, serviceInterfaceClass, metadata);\n\n        \n    metadataToProcess.accept(metadata);\n\n    return true;\n}",
        "summary_tokens": [
            "process",
            "the",
            "single",
            "rest",
            "method",
            "metadata",
            "by",
            "the",
            "specified",
            "consumer",
            "if",
            "present"
        ]
    },
    {
        "id": 729,
        "code": "protected MethodDefinition resolveMethodDefinition(Method serviceMethod, Class<?> serviceType,\n                                                   Class<?> serviceInterfaceClass) {\n    MethodDefinitionBuilder builder = new MethodDefinitionBuilder();\n    return builder.build(serviceMethod);\n}",
        "summary_tokens": [
            "resolve",
            "the",
            "method",
            "definition"
        ]
    },
    {
        "id": 730,
        "code": "static String buildDefaultValue(int parameterIndex) {\n    return \"{\" + parameterIndex + \"}\";\n}",
        "summary_tokens": [
            "build",
            "the",
            "default",
            "value"
        ]
    },
    {
        "id": 731,
        "code": "public String[] instanceParamsIncluded() {\n    return new String[0];\n}",
        "summary_tokens": [
            "not",
            "included",
            "in",
            "this",
            "test"
        ]
    },
    {
        "id": 732,
        "code": "public String[] instanceParamsIncluded() {\n    return new String[0];\n}",
        "summary_tokens": [
            "not",
            "included",
            "in",
            "this",
            "test"
        ]
    },
    {
        "id": 733,
        "code": "public String[] instanceParamsIncluded() {\n    return new String[0];\n}",
        "summary_tokens": [
            "not",
            "included",
            "in",
            "this",
            "test"
        ]
    },
    {
        "id": 734,
        "code": "public void testBuild() {\n    assertEquals(\"/A/B/C\", KeyTypeEnum.PATH.build(\"/A\", \"/B\", \"C\"));\n    assertEquals(\"A:B:C\", KeyTypeEnum.UNIQUE_KEY.build(\"A\", \"B\", \"C\"));\n}",
        "summary_tokens": [
            "key",
            "type",
            "enum",
            "build",
            "string",
            "string"
        ]
    },
    {
        "id": 735,
        "code": "private String generateSimpleFiledName(String methodName) {\n    return toCamelCase(methodName.substring(3));\n}",
        "summary_tokens": [
            "get",
            "un",
            "collection",
            "un",
            "map",
            "property",
            "name",
            "from",
            "setting",
            "method"
        ]
    },
    {
        "id": 736,
        "code": "private String generateMapFieldName(String methodName) {\n    return toCamelCase(methodName.substring(6));\n}",
        "summary_tokens": [
            "get",
            "map",
            "property",
            "name",
            "from",
            "setting",
            "method"
        ]
    },
    {
        "id": 737,
        "code": "private String generateListFieldName(String methodName) {\n    return toCamelCase(methodName.substring(3, methodName.length() - 4));\n}",
        "summary_tokens": [
            "get",
            "list",
            "property",
            "name",
            "from",
            "setting",
            "method"
        ]
    },
    {
        "id": 738,
        "code": "private boolean isSimplePropertySettingMethod(Method method) {\n    String methodName = method.getName();\n    Class<?>[] types = method.getParameterTypes();\n\n    if (!methodName.startsWith(\"set\") || types.length != 1) {\n        return false;\n    }\n\n        \n        \n        \n        \n    if (\"setField\".equals(methodName) && types[0].equals(Descriptors.FieldDescriptor.class)\n            || \"setUnknownFields\".equals(methodName) && types[0].equals(UnknownFieldSet.class)\n            || \"setRepeatedField\".equals(methodName) && types[0].equals(Descriptors.FieldDescriptor.class)) {\n        return false;\n    }\n\n        \n        \n        \n    if (methodName.endsWith(\"Bytes\") && types[0].equals(ByteString.class)) {\n        return false;\n    }\n\n        \n        \n        \n    if (GeneratedMessageV3.Builder.class.isAssignableFrom(types[0])) {\n        return false;\n    }\n\n        \n        \n        \n    if (methodName.endsWith(\"Value\") && types[0] == int.class) {\n        return false;\n    }\n\n    return true;\n}",
        "summary_tokens": [
            "judge",
            "custom",
            "type",
            "or",
            "primitive",
            "type",
            "property",
            "br",
            "0"
        ]
    },
    {
        "id": 739,
        "code": "boolean isListPropertyGettingMethod(Method method) {\n    String methodName = method.getName();\n    Class<?> type = method.getReturnType();\n\n\n    if (!methodName.startsWith(\"get\") || !methodName.endsWith(\"List\")) {\n        return false;\n    }\n\n        \n    if (methodName.endsWith(\"BuilderList\")) {\n        return false;\n    }\n\n        \n    if (!List.class.isAssignableFrom(type)) {\n        return false;\n    }\n\n    return true;\n}",
        "summary_tokens": [
            "judge",
            "list",
            "property",
            "br",
            "proto",
            "0",
            "grammar",
            "ex",
            "repeated",
            "string",
            "names",
            "br",
            "generated",
            "getting",
            "method",
            "list",
            "string",
            "get",
            "names",
            "list"
        ]
    },
    {
        "id": 740,
        "code": "private boolean isMapPropertySettingMethod(Method methodTemp) {\n    String methodName = methodTemp.getName();\n    Class[] parameters = methodTemp.getParameterTypes();\n    if (methodName.startsWith(\"putAll\") && parameters.length == 1 && Map.class.isAssignableFrom(parameters[0])) {\n        return true;\n    }\n\n    return false;\n}",
        "summary_tokens": [
            "judge",
            "map",
            "property",
            "br",
            "proto",
            "0",
            "grammar",
            "map",
            "string",
            "string",
            "card",
            "0",
            "br",
            "generated",
            "setting",
            "method",
            "put",
            "all",
            "cards",
            "java"
        ]
    },
    {
        "id": 741,
        "code": "static TypeDefinition build(ProcessingEnvironment processingEnv, TypeMirror type, Map<String, TypeDefinition> typeCache) {\n        \n\n    TypeDefinition typeDefinition = getExtensionLoader(TypeBuilder.class)\n            .getSupportedExtensionInstances()\n            .stream()\n\n            .filter(builder -> builder.accept(processingEnv, type))\n            .findFirst()\n            .map(builder -> {\n                return builder.build(processingEnv, type, typeCache);\n                    \n            }).orElse(null);\n\n    if (typeDefinition != null) {\n        typeCache.put(typeDefinition.getType(), typeDefinition);\n    }\n    return typeDefinition;\n}",
        "summary_tokens": [
            "build",
            "the",
            "instance",
            "of",
            "type",
            "definition",
            "from",
            "the",
            "specified",
            "type",
            "mirror",
            "type"
        ]
    },
    {
        "id": 742,
        "code": "private ExecutableElement findRestCapableMethod(ProcessingEnvironment processingEnv,\n                                                TypeElement serviceType,\n                                                TypeElement serviceInterfaceType,\n                                                ExecutableElement serviceMethod) {\n        \n    ExecutableElement overrideMethod = getOverrideMethod(processingEnv, serviceType, serviceMethod);\n    if (supports(processingEnv, serviceType, serviceInterfaceType, overrideMethod)) {\n        return overrideMethod;\n    }\n        \n    return supports(processingEnv, serviceType, serviceInterfaceType, serviceMethod) ? serviceMethod : null;\n}",
        "summary_tokens": [
            "find",
            "the",
            "method",
            "with",
            "the",
            "capable",
            "for",
            "rest",
            "from",
            "the",
            "specified",
            "service",
            "method",
            "and",
            "its",
            "override",
            "method"
        ]
    },
    {
        "id": 743,
        "code": "protected void postProcessRestMethodMetadata(ProcessingEnvironment processingEnv, TypeElement serviceType,\n                                             ExecutableElement method, RestMethodMetadata metadata) {\n}",
        "summary_tokens": [
            "post",
            "process",
            "for",
            "rest",
            "method",
            "metadata",
            "sub",
            "type",
            "could",
            "override",
            "this",
            "method",
            "for",
            "further",
            "works"
        ]
    },
    {
        "id": 744,
        "code": "static String buildDefaultValue(int parameterIndex) {\n    return \"{\" + parameterIndex + \"}\";\n}",
        "summary_tokens": [
            "build",
            "the",
            "default",
            "value"
        ]
    },
    {
        "id": 745,
        "code": "private boolean supportsPathVariableType(TypeMirror parameterType) {\n    String className = parameterType.toString();\n    ClassLoader classLoader = getClass().getClassLoader();\n    boolean supported;\n    try {\n        Class<?> targetType = forName(className, classLoader);\n        supported = FrameworkModel.defaultModel().getBeanFactory().getBean(ConverterUtil.class).getConverter(String.class, targetType) != null;\n    } catch (ClassNotFoundException e) {\n        supported = false;\n    }\n    return supported;\n}",
        "summary_tokens": [
            "supports",
            "the",
            "type",
            "of",
            "parameter",
            "or",
            "not",
            "based",
            "by",
            "converter",
            "s",
            "conversion",
            "feature"
        ]
    },
    {
        "id": 746,
        "code": "static boolean isEnumMemberField(VariableElement field) {\n    if (field == null || !isEnumType(field.getEnclosingElement())) {\n        return false;\n    }\n    return ENUM_CONSTANT.equals(field.getKind());\n}",
        "summary_tokens": [
            "is",
            "enum",
            "s",
            "member",
            "field",
            "or",
            "not"
        ]
    },
    {
        "id": 747,
        "code": "public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {\n    if (invoker.getUrl().hasAttribute(MONITOR_KEY)) {\n        invocation.put(MONITOR_FILTER_START_TIME, System.currentTimeMillis());\n        invocation.put(MONITOR_REMOTE_HOST_STORE, RpcContext.getServiceContext().getRemoteHost());\n            \n        getConcurrent(invoker, invocation).incrementAndGet();\n    }\n        \n    return invoker.invoke(invocation);\n}",
        "summary_tokens": [
            "the",
            "invocation",
            "interceptor",
            "it",
            "will",
            "collect",
            "the",
            "invoke",
            "data",
            "about",
            "this",
            "invocation",
            "and",
            "send",
            "it",
            "to",
            "monitor",
            "center"
        ]
    },
    {
        "id": 748,
        "code": "private void collect(Invoker<?> invoker, Invocation invocation, Result result, String remoteHost, long start, boolean error) {\n    try {\n        Object monitorUrl;\n        monitorUrl = invoker.getUrl().getAttribute(MONITOR_KEY);\n        if (monitorUrl instanceof URL) {\n            Monitor monitor = monitorFactory.getMonitor((URL) monitorUrl);\n            if (monitor == null) {\n                return;\n            }\n            URL statisticsUrl = createStatisticsUrl(invoker, invocation, result, remoteHost, start, error);\n            monitor.collect(statisticsUrl.toSerializableURL());\n        }\n    } catch (Throwable t) {\n        logger.warn(\"Failed to monitor count service \" + invoker.getUrl() + \", cause: \" + t.getMessage(), t);\n    }\n}",
        "summary_tokens": [
            "the",
            "collector",
            "logic",
            "it",
            "will",
            "be",
            "handled",
            "by",
            "the",
            "default",
            "monitor"
        ]
    },
    {
        "id": 749,
        "code": "public void start() throws Throwable {\n    if (!started.compareAndSet(false, true)) {\n        return;\n    }\n    boss = new NioEventLoopGroup(1, new DefaultThreadFactory(\"qos-boss\", true));\n    worker = new NioEventLoopGroup(0, new DefaultThreadFactory(\"qos-worker\", true));\n    ServerBootstrap serverBootstrap = new ServerBootstrap();\n    serverBootstrap.group(boss, worker);\n    serverBootstrap.channel(NioServerSocketChannel.class);\n    serverBootstrap.option(ChannelOption.SO_REUSEADDR, true);\n    serverBootstrap.childOption(ChannelOption.TCP_NODELAY, true);\n    serverBootstrap.childHandler(new ChannelInitializer<Channel>() {\n\n        @Override\n        protected void initChannel(Channel ch) throws Exception {\n            ch.pipeline().addLast(new QosProcessHandler(frameworkModel, welcome, acceptForeignIp));\n        }\n    });\n    try {\n        if (StringUtils.isBlank(host)) {\n            serverBootstrap.bind(port).sync();\n        } else {\n            serverBootstrap.bind(host, port).sync();\n        }\n\n        logger.info(\"qos-server bind localhost:\" + port);\n    } catch (Throwable throwable) {\n        logger.error(\"qos-server can not bind localhost:\" + port, throwable);\n        throw throwable;\n    }\n}",
        "summary_tokens": [
            "start",
            "server",
            "bind",
            "port"
        ]
    },
    {
        "id": 750,
        "code": "private int indexLastCol(final int[] widthCacheArray) {\n    for (int colIndex = widthCacheArray.length - 1; colIndex >= 0; colIndex--) {\n        final int width = widthCacheArray[colIndex];\n        if (width <= 0) {\n            continue;\n        }\n        return colIndex;\n    }\n    return 0;\n}",
        "summary_tokens": [
            "position",
            "to",
            "last",
            "column"
        ]
    },
    {
        "id": 751,
        "code": "private static String replaceTab(String string) {\n    return replace(string, \"\\t\", \"    \");\n}",
        "summary_tokens": [
            "replace",
            "tab",
            "to",
            "four",
            "spaces"
        ]
    },
    {
        "id": 752,
        "code": "private static int width(String string) {\n    int maxWidth = 0;\n    try (Scanner scanner = new Scanner(new StringReader(string))) {\n        while (scanner.hasNextLine()) {\n            maxWidth = max(length(scanner.nextLine()), maxWidth);\n        }\n    }\n    return maxWidth;\n}",
        "summary_tokens": [
            "visible",
            "width",
            "for",
            "the",
            "given",
            "string"
        ]
    },
    {
        "id": 753,
        "code": "public TTree begin(Object data) {\n    current = new Node(current, data);\n    current.markBegin();\n    return this;\n}",
        "summary_tokens": [
            "create",
            "a",
            "branch",
            "node"
        ]
    },
    {
        "id": 754,
        "code": "public TTree end() {\n    if (current.isRoot()) {\n        throw new IllegalStateException(\"current node is root.\");\n    }\n    current.markEnd();\n    current = current.parent;\n    return this;\n}",
        "summary_tokens": [
            "end",
            "a",
            "branch",
            "node"
        ]
    },
    {
        "id": 755,
        "code": "public void testListClient() throws Exception {\n    ExchangeClient client1 = Exchangers.connect(\"dubbo://127.0.0.1:\" + availablePort + \"/demo\");\n    ExchangeClient client2 = Exchangers.connect(\"dubbo://127.0.0.1:\" + availablePort + \"/demo\");\n    Thread.sleep(100);\n    String result = port.execute(mockCommandContext, new String[]{\"-l\", availablePort + \"\"});\n    String client1Addr = client1.getLocalAddress().toString();\n    String client2Addr = client2.getLocalAddress().toString();\n    System.out.printf(\"Result: %s %n\", result);\n    System.out.printf(\"Client 1 Address %s %n\", client1Addr);\n    System.out.printf(\"Client 2 Address %s %n\", client2Addr);\n    assertTrue(result.contains(String.valueOf(client1.getLocalAddress().getPort())));\n    assertTrue(result.contains(String.valueOf(client2.getLocalAddress().getPort())));\n}",
        "summary_tokens": [
            "in",
            "nat",
            "network",
            "scenario",
            "server",
            "s",
            "channel"
        ]
    },
    {
        "id": 756,
        "code": "public synchronized void update() throws RuntimeException {\n    if (isDestroy) {\n        return;\n    }\n\n    if (this.serviceInstance == null) {\n        this.serviceInstance = createServiceInstance(this.metadataInfo);\n    } else if (!isValidInstance(this.serviceInstance)) {\n        ServiceInstanceMetadataUtils.customizeInstance(this.serviceInstance, this.applicationModel);\n    }\n\n    if (!isValidInstance(this.serviceInstance)) {\n        return;\n    }\n\n    boolean revisionUpdated = calOrUpdateInstanceRevision(this.serviceInstance);\n    if (revisionUpdated) {\n        logger.info(String.format(\"Metadata of instance changed, updating instance with revision %s.\", this.serviceInstance.getServiceMetadata().getRevision()));\n        doUpdate(this.serviceInstance);\n    }\n}",
        "summary_tokens": [
            "update",
            "assumes",
            "that",
            "default",
            "service",
            "instance",
            "and",
            "its",
            "attributes",
            "will",
            "never",
            "get",
            "updated",
            "once",
            "created"
        ]
    },
    {
        "id": 757,
        "code": "public String getServiceMethodParameter(String protocolServiceKey, String method, String key) {\n    if (consumerParamFirst(key)) {\n        URL consumerUrl = RpcContext.getServiceContext().getConsumerUrl();\n        if (consumerUrl != null) {\n            String v = consumerUrl.getServiceMethodParameter(protocolServiceKey, method, key);\n            if (StringUtils.isNotEmpty(v)) {\n                return v;\n            }\n        }\n    }\n\n    MetadataInfo.ServiceInfo serviceInfo = getServiceInfo(protocolServiceKey);\n    if (null == serviceInfo) {\n        return getParameter(key);\n    }\n\n    String value = serviceInfo.getMethodParameter(method, key, null);\n    if (StringUtils.isNotEmpty(value)) {\n        return value;\n    }\n    return getParameter(key);\n}",
        "summary_tokens": [
            "method",
            "parameter",
            "only",
            "exists",
            "in",
            "service",
            "info"
        ]
    },
    {
        "id": 758,
        "code": "public boolean hasServiceMethodParameter(String protocolServiceKey, String method) {\n    URL consumerUrl = RpcContext.getServiceContext().getConsumerUrl();\n    if (consumerUrl != null) {\n        if (consumerUrl.hasServiceMethodParameter(protocolServiceKey, method)) {\n            return true;\n        }\n    }\n\n    MetadataInfo.ServiceInfo serviceInfo = getServiceInfo(protocolServiceKey);\n    if (null == serviceInfo) {\n        return false;\n    }\n\n    return serviceInfo.hasMethodParameter(method);\n}",
        "summary_tokens": [
            "method",
            "parameter",
            "only",
            "exists",
            "in",
            "service",
            "info"
        ]
    },
    {
        "id": 759,
        "code": "public Map<String, String> getServiceParameters(String protocolServiceKey) {\n    Map<String, String> instanceParams = getInstance().getAllParams();\n    Map<String, String> metadataParams = (metadataInfo == null ? new HashMap<>() : metadataInfo.getParameters(protocolServiceKey));\n    int i = instanceParams == null ? 0 : instanceParams.size();\n    int j = metadataParams == null ? 0 : metadataParams.size();\n    Map<String, String> params = new HashMap<>((int) ((i + j) / 0.75) + 1);\n    if (instanceParams != null) {\n        params.putAll(instanceParams);\n    }\n    if (metadataParams != null) {\n        params.putAll(metadataParams);\n    }\n\n    URL consumerUrl = RpcContext.getServiceContext().getConsumerUrl();\n    if (consumerUrl != null) {\n        Map<String, String> consumerParams = new HashMap<>(consumerUrl.getParameters());\n        if (CollectionUtils.isNotEmpty(providerFirstParams)) {\n            providerFirstParams.forEach(consumerParams::remove);\n        }\n        params.putAll(consumerParams);\n    }\n    return params;\n}",
        "summary_tokens": [
            "avoid",
            "calling",
            "this",
            "method",
            "in",
            "rpc",
            "call"
        ]
    },
    {
        "id": 760,
        "code": "public String getAnyMethodParameter(String key) {\n    String suffix = \".\" + key;\n    String protocolServiceKey = getProtocolServiceKey();\n    if (StringUtils.isNotEmpty(protocolServiceKey)) {\n        MetadataInfo.ServiceInfo serviceInfo = getServiceInfo(protocolServiceKey);\n        if (null == serviceInfo) {\n            return null;\n        }\n\n        for (String fullKey : serviceInfo.getAllParams().keySet()) {\n            if (fullKey.endsWith(suffix)) {\n                return getParameter(fullKey);\n            }\n        }\n    }\n    return null;\n}",
        "summary_tokens": [
            "gets",
            "method",
            "level",
            "value",
            "of",
            "the",
            "specified",
            "key"
        ]
    },
    {
        "id": 761,
        "code": "default void removeServiceInstancesChangedListener(ServiceInstancesChangedListener listener)",
        "summary_tokens": [
            "unsubscribe",
            "to",
            "instance",
            "change",
            "event"
        ]
    },
    {
        "id": 762,
        "code": "static ServiceDiscoveryFactory getExtension(URL registryURL) {\n    String protocol = registryURL.getProtocol();\n    ExtensionLoader<ServiceDiscoveryFactory> loader = registryURL.getOrDefaultApplicationModel().getExtensionLoader(ServiceDiscoveryFactory.class);\n    return loader.getOrDefaultExtension(protocol);\n}",
        "summary_tokens": [
            "get",
            "the",
            "extension",
            "instance",
            "of",
            "service",
            "discovery",
            "factory",
            "by",
            "url",
            "get",
            "protocol",
            "the",
            "protocol"
        ]
    },
    {
        "id": 763,
        "code": "protected ServiceDiscovery createServiceDiscovery(URL registryURL) {\n    return getServiceDiscovery(registryURL.addParameter(INTERFACE_KEY, ServiceDiscovery.class.getName())\n        .removeParameter(REGISTRY_TYPE_KEY));\n}",
        "summary_tokens": [
            "create",
            "the",
            "service",
            "discovery",
            "from",
            "the",
            "registry",
            "url"
        ]
    },
    {
        "id": 764,
        "code": "private ServiceDiscovery getServiceDiscovery(URL registryURL) {\n    ServiceDiscoveryFactory factory = getExtension(registryURL);\n    return factory.getServiceDiscovery(registryURL);\n}",
        "summary_tokens": [
            "get",
            "the",
            "instance",
            "service",
            "discovery",
            "from",
            "the",
            "registry",
            "url",
            "using",
            "service",
            "discovery",
            "factory",
            "spi"
        ]
    },
    {
        "id": 765,
        "code": "public boolean isNotificationReceived() {\n    return serviceListener == null || serviceListener.isDestroyed()\n        || serviceListener.getAllInstances().size() == serviceListener.getServiceNames().size();\n}",
        "summary_tokens": [
            "this",
            "implementation",
            "makes",
            "sure",
            "all",
            "application",
            "names",
            "related",
            "to",
            "service",
            "listener",
            "received",
            "address",
            "notification"
        ]
    },
    {
        "id": 766,
        "code": "private Map<ProtocolServiceKeyWithAddress, Invoker<T>> toInvokers(Map<ProtocolServiceKeyWithAddress, Invoker<T>> oldUrlInvokerMap, List<URL> urls) {\n    Map<ProtocolServiceKeyWithAddress, Invoker<T>> newUrlInvokerMap = new ConcurrentHashMap<>(urls == null ? 1 : (int) (urls.size() / 0.75f + 1));\n    if (urls == null || urls.isEmpty()) {\n        return newUrlInvokerMap;\n    }\n\n    for (URL url : urls) {\n        InstanceAddressURL instanceAddressURL = (InstanceAddressURL) url;\n        if (EMPTY_PROTOCOL.equals(instanceAddressURL.getProtocol())) {\n            continue;\n        }\n        if (!getUrl().getOrDefaultFrameworkModel().getExtensionLoader(Protocol.class).hasExtension(instanceAddressURL.getProtocol())) {\n\n                \n\n            logger.error(\"4-1\", \"protocol extension does not installed\", \"\", \"Unsupported protocol.\",\n                new IllegalStateException(\"Unsupported protocol \" + instanceAddressURL.getProtocol() +\n                \" in notified url: \" + instanceAddressURL + \" from registry \" + getUrl().getAddress() +\n                \" to consumer \" + NetUtils.getLocalHost() + \", supported protocol: \" +\n                getUrl().getOrDefaultFrameworkModel().getExtensionLoader(Protocol.class).getSupportedExtensions()));\n\n            continue;\n        }\n\n        instanceAddressURL.setProviderFirstParams(providerFirstParams);\n\n            \n        if (enableConfigurationListen) {\n            instanceAddressURL = overrideWithConfigurator(instanceAddressURL);\n        }\n\n            \n        int port = instanceAddressURL.getPort();\n        List<ProtocolServiceKey> matchedProtocolServiceKeys = instanceAddressURL.getMetadataInfo()\n            .getMatchedServiceInfos(consumerProtocolServiceKey)\n            .stream()\n            .filter(serviceInfo -> serviceInfo.getPort() <= 0 || serviceInfo.getPort() == port)\n            .map(MetadataInfo.ServiceInfo::getProtocolServiceKey)\n            .collect(Collectors.toList());\n\n            \n            \n        boolean shouldWrap = matchedProtocolServiceKeys.size() != 1 || !consumerProtocolServiceKey.isSameWith(matchedProtocolServiceKeys.get(0));\n\n        for (ProtocolServiceKey matchedProtocolServiceKey : matchedProtocolServiceKeys) {\n            ProtocolServiceKeyWithAddress protocolServiceKeyWithAddress = new ProtocolServiceKeyWithAddress(matchedProtocolServiceKey, instanceAddressURL.getAddress());\n            Invoker<T> invoker = oldUrlInvokerMap == null ? null : oldUrlInvokerMap.get(protocolServiceKeyWithAddress);\n            if (invoker == null || urlChanged(invoker, instanceAddressURL, matchedProtocolServiceKey)) { \n                try {\n                    boolean enabled;\n                    if (instanceAddressURL.hasParameter(DISABLED_KEY)) {\n                        enabled = !instanceAddressURL.getParameter(DISABLED_KEY, false);\n                    } else {\n                        enabled = instanceAddressURL.getParameter(ENABLED_KEY, true);\n                    }\n                    if (enabled) {\n                        if (shouldWrap) {\n                            URL newConsumerUrl = customizedConsumerUrlMap.computeIfAbsent(matchedProtocolServiceKey,\n                                k -> consumerUrl.setProtocol(k.getProtocol())\n                                    .addParameter(CommonConstants.GROUP_KEY, k.getGroup())\n                                    .addParameter(CommonConstants.VERSION_KEY, k.getVersion()));\n                            RpcContext.getServiceContext().setConsumerUrl(newConsumerUrl);\n                            invoker = new InstanceWrappedInvoker<>(protocol.refer(serviceType, instanceAddressURL), newConsumerUrl, matchedProtocolServiceKey);\n                        } else {\n                            invoker = protocol.refer(serviceType, instanceAddressURL);\n                        }\n                    }\n                } catch (Throwable t) {\n                    logger.error(\"Failed to refer invoker for interface:\" + serviceType + \",url:(\" + instanceAddressURL + \")\" + t.getMessage(), t);\n                }\n                if (invoker != null) { \n                    newUrlInvokerMap.put(protocolServiceKeyWithAddress, invoker);\n                }\n            } else {\n                newUrlInvokerMap.put(protocolServiceKeyWithAddress, invoker);\n                oldUrlInvokerMap.remove(protocolServiceKeyWithAddress, invoker);\n            }\n        }\n    }\n    return newUrlInvokerMap;\n}",
        "summary_tokens": [
            "turn",
            "urls",
            "into",
            "invokers",
            "and",
            "if",
            "url",
            "has",
            "been",
            "refer",
            "will",
            "not",
            "re",
            "reference"
        ]
    },
    {
        "id": 767,
        "code": "private void destroyUnusedInvokers(Map<ProtocolServiceKeyWithAddress, Invoker<T>> oldUrlInvokerMap, Map<ProtocolServiceKeyWithAddress, Invoker<T>> newUrlInvokerMap) {\n    if (newUrlInvokerMap == null || newUrlInvokerMap.size() == 0) {\n        destroyAllInvokers();\n        return;\n    }\n\n    if (oldUrlInvokerMap == null || oldUrlInvokerMap.size() == 0) {\n        return;\n    }\n\n    for (Map.Entry<ProtocolServiceKeyWithAddress, Invoker<T>> entry : oldUrlInvokerMap.entrySet()) {\n        Invoker<T> invoker = entry.getValue();\n        if (invoker != null) {\n            try {\n                invoker.destroyAll();\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"destroy invoker[\" + invoker.getUrl() + \"] success. \");\n                }\n            } catch (Exception e) {\n                logger.warn(\"destroy invoker[\" + invoker.getUrl() + \"] failed. \" + e.getMessage(), e);\n            }\n        }\n    }\n    logger.info(oldUrlInvokerMap.size() + \" deprecated invokers deleted.\");\n}",
        "summary_tokens": [
            "check",
            "whether",
            "the",
            "invoker",
            "in",
            "the",
            "cache",
            "needs",
            "to",
            "be",
            "destroyed",
            "if",
            "set",
            "attribute",
            "of",
            "url",
            "refer"
        ]
    },
    {
        "id": 768,
        "code": "default boolean isEnabled() {\n    return true;\n}",
        "summary_tokens": [
            "the",
            "enabled",
            "status",
            "of",
            "the",
            "registered",
            "service",
            "instance"
        ]
    },
    {
        "id": 769,
        "code": "default boolean isHealthy() {\n    return true;\n}",
        "summary_tokens": [
            "the",
            "registered",
            "service",
            "instance",
            "is",
            "health",
            "or",
            "not"
        ]
    },
    {
        "id": 770,
        "code": "default String getMetadata(String name, String defaultValue) {\n    return getMetadata().getOrDefault(name, defaultValue);\n}",
        "summary_tokens": [
            "get",
            "the",
            "value",
            "of",
            "metadata",
            "by",
            "the",
            "specified",
            "name"
        ]
    },
    {
        "id": 771,
        "code": "public String getServiceName() {\n    return serviceName;\n}",
        "summary_tokens": [
            "the",
            "name",
            "of",
            "service",
            "that",
            "was",
            "changed"
        ]
    },
    {
        "id": 772,
        "code": "public List<ServiceInstance> getServiceInstances() {\n    return serviceInstances;\n}",
        "summary_tokens": [
            "all",
            "service",
            "instance",
            "service",
            "instances"
        ]
    },
    {
        "id": 773,
        "code": "public void onEvent(ServiceInstancesChangedEvent event) {\n    if (destroyed.get() || !accept(event) || isRetryAndExpired(event)) {\n        return;\n    }\n    doOnEvent(event);\n}",
        "summary_tokens": [
            "on",
            "service",
            "instances",
            "changed",
            "event",
            "the",
            "service",
            "instances",
            "change",
            "event"
        ]
    },
    {
        "id": 774,
        "code": "public final Set<String> getServiceNames() {\n    return serviceNames;\n}",
        "summary_tokens": [
            "get",
            "the",
            "correlative",
            "service",
            "name"
        ]
    },
    {
        "id": 775,
        "code": "private boolean accept(ServiceInstancesChangedEvent event) {\n    return serviceNames.contains(event.getServiceName());\n}",
        "summary_tokens": [
            "event",
            "service",
            "instances",
            "changed",
            "event",
            "event",
            "if",
            "service",
            "name",
            "matches",
            "return",
            "code",
            "true",
            "code",
            "or",
            "code",
            "false",
            "code"
        ]
    },
    {
        "id": 776,
        "code": "protected int hasEmptyMetadata(Map<String, List<ServiceInstance>> revisionToInstances) {\n    if (revisionToInstances == null) {\n        return 0;\n    }\n\n    StringBuilder builder = new StringBuilder();\n    int emptyMetadataNum = 0;\n    for (Map.Entry<String, List<ServiceInstance>> entry : revisionToInstances.entrySet()) {\n        DefaultServiceInstance serviceInstance = (DefaultServiceInstance) entry.getValue().get(0);\n        if (serviceInstance == null || serviceInstance.getServiceMetadata() == MetadataInfo.EMPTY) {\n            emptyMetadataNum++;\n        }\n\n        builder.append(entry.getKey());\n        builder.append(' ');\n    }\n\n    if (emptyMetadataNum > 0) {\n        builder.insert(0, emptyMetadataNum + \"/\" + revisionToInstances.size() + \" revisions failed to get metadata from remote: \");\n        logger.error(builder.toString());\n    } else {\n        builder.insert(0, revisionToInstances.size() + \" unique working revisions: \");\n        logger.info(builder.toString());\n    }\n    return emptyMetadataNum;\n}",
        "summary_tokens": [
            "calculate",
            "the",
            "number",
            "of",
            "revisions",
            "that",
            "failed",
            "to",
            "find",
            "metadata",
            "info"
        ]
    },
    {
        "id": 777,
        "code": "protected void notifyAddressChanged() {\n        \n    listeners.forEach((serviceKey, listenerSet) -> {\n            \n        for (NotifyListenerWithKey listenerWithKey : listenerSet) {\n            NotifyListener notifyListener = listenerWithKey.getNotifyListener();\n\n            List<URL> urls = toUrlsWithEmpty(getAddresses(listenerWithKey.getProtocolServiceKey(), notifyListener.getConsumerUrl()));\n            logger.info(\"Notify service \" + listenerWithKey.getProtocolServiceKey() + \" with urls \" + urls.size());\n            notifyListener.notify(urls);\n        }\n    });\n}",
        "summary_tokens": [
            "race",
            "condition",
            "is",
            "protected",
            "by",
            "on",
            "event",
            "do",
            "on",
            "event"
        ]
    },
    {
        "id": 778,
        "code": "public void destroy() {\n    if (destroyed.compareAndSet(false, true)) {\n        logger.info(\"Destroying instance listener of  \" + this.getServiceNames());\n        serviceDiscovery.removeServiceInstancesChangedListener(this);\n        synchronized (this) {\n            allInstances.clear();\n            serviceUrls.clear();\n            listeners.clear();\n            if (retryFuture != null && !retryFuture.isDone()) {\n                retryFuture.cancel(true);\n            }\n        }\n    }\n}",
        "summary_tokens": [
            "since",
            "this",
            "listener",
            "is",
            "shared",
            "among",
            "interfaces",
            "destroy",
            "this",
            "listener",
            "only",
            "when",
            "all",
            "interface",
            "listener",
            "are",
            "unsubscribed"
        ]
    },
    {
        "id": 779,
        "code": "public String serviceName() {\n    return ApplicationModel.ofNullable(applicationModel).getApplicationName();\n}",
        "summary_tokens": [
            "gets",
            "the",
            "current",
            "dubbo",
            "service",
            "name"
        ]
    },
    {
        "id": 780,
        "code": "public boolean map(URL url) {\n    if (CollectionUtils.isEmpty(applicationModel.getApplicationConfigManager().getMetadataConfigs())) {\n        logger.warn(\"No valid metadata config center found for mapping report.\");\n        return false;\n    }\n    String serviceInterface = url.getServiceInterface();\n    if (IGNORED_SERVICE_INTERFACES.contains(serviceInterface)) {\n        return true;\n    }\n\n    boolean result = true;\n    for (Map.Entry<String, MetadataReport> entry : metadataReportInstance.getMetadataReports(true).entrySet()) {\n        MetadataReport metadataReport = entry.getValue();\n        String appName = applicationModel.getApplicationName();\n        try {\n            if (metadataReport.registerServiceAppMapping(serviceInterface, appName, url)) {\n                    \n                continue;\n            }\n\n            boolean succeeded;\n            int currentRetryTimes = 1;\n            String newConfigContent = appName;\n            do {\n                ConfigItem configItem = metadataReport.getConfigItem(serviceInterface, DEFAULT_MAPPING_GROUP);\n                String oldConfigContent = configItem.getContent();\n                if (StringUtils.isNotEmpty(oldConfigContent)) {\n                    boolean contains = StringUtils.isContains(oldConfigContent, appName);\n                    if (contains) {\n                            \n                        succeeded = true;\n                        break;\n                    }\n                    newConfigContent = oldConfigContent + COMMA_SEPARATOR + appName;\n                }\n                succeeded = metadataReport.registerServiceAppMapping(serviceInterface, DEFAULT_MAPPING_GROUP, newConfigContent, configItem.getTicket());\n            } while (!succeeded && currentRetryTimes++ <= CAS_RETRY_TIMES);\n\n            if (!succeeded) {\n                result = false;\n            }\n        } catch (Exception e) {\n            result = false;\n            logger.warn(\"Failed registering mapping to remote.\" + metadataReport, e);\n        }\n    }\n\n    return result;\n}",
        "summary_tokens": [
            "simply",
            "register",
            "to",
            "all",
            "metadata",
            "center"
        ]
    },
    {
        "id": 781,
        "code": "public static String getExportedServicesRevision(ServiceInstance serviceInstance) {\n    return Optional.ofNullable(serviceInstance.getServiceMetadata())\n        .map(MetadataInfo::getRevision)\n        .filter(StringUtils::isNotEmpty)\n        .orElse(serviceInstance.getMetadata(EXPORTED_SERVICES_REVISION_PROPERTY_NAME));\n}",
        "summary_tokens": [
            "the",
            "revision",
            "for",
            "all",
            "exported",
            "dubbo",
            "services",
            "from",
            "the",
            "specified",
            "service",
            "instance"
        ]
    },
    {
        "id": 782,
        "code": "public static String getMetadataStorageType(ServiceInstance serviceInstance) {\n    Map<String, String> metadata = serviceInstance.getMetadata();\n    return metadata.getOrDefault(METADATA_STORAGE_TYPE_PROPERTY_NAME, DEFAULT_METADATA_STORAGE_TYPE);\n}",
        "summary_tokens": [
            "get",
            "the",
            "metadata",
            "storage",
            "type",
            "specified",
            "by",
            "the",
            "peer",
            "instance"
        ]
    },
    {
        "id": 783,
        "code": "public static void setMetadataStorageType(ServiceInstance serviceInstance, String metadataType) {\n    Map<String, String> metadata = serviceInstance.getMetadata();\n    metadata.put(METADATA_STORAGE_TYPE_PROPERTY_NAME, metadataType);\n}",
        "summary_tokens": [
            "set",
            "the",
            "metadata",
            "storage",
            "type",
            "in",
            "specified",
            "service",
            "instance",
            "service",
            "instance"
        ]
    },
    {
        "id": 784,
        "code": "public static Endpoint getEndpoint(ServiceInstance serviceInstance, String protocol) {\n    List<Endpoint> endpoints = ((DefaultServiceInstance) serviceInstance).getEndpoints();\n    if (endpoints != null) {\n        for (Endpoint endpoint : endpoints) {\n            if (endpoint.getProtocol().equals(protocol)) {\n                return endpoint;\n            }\n        }\n    }\n    return null;\n}",
        "summary_tokens": [
            "get",
            "the",
            "property",
            "value",
            "of",
            "port",
            "by",
            "the",
            "specified",
            "service",
            "instance",
            "get",
            "metadata",
            "the",
            "metadata",
            "of",
            "service",
            "instance",
            "and",
            "protocol"
        ]
    },
    {
        "id": 785,
        "code": "private static void setDefaultParams(Map<String, String> params, URL providerURL) {\n    for (String parameterName : DEFAULT_REGISTER_PROVIDER_KEYS) {\n        String parameterValue = providerURL.getParameter(parameterName);\n        if (!isBlank(parameterValue)) {\n            params.put(parameterName, parameterValue);\n        }\n    }\n}",
        "summary_tokens": [
            "set",
            "the",
            "default",
            "parameters",
            "via",
            "the",
            "specified",
            "url",
            "provider",
            "url"
        ]
    },
    {
        "id": 786,
        "code": "public List<URL> build(ServiceInstance serviceInstance) {\n    Map<String, String> paramsMap = getMetadataServiceURLsParams(serviceInstance);\n\n    String serviceName = serviceInstance.getServiceName();\n\n    String host = serviceInstance.getHost();\n\n    URL url;\n    if (paramsMap.isEmpty()) {\n            \n        url = generateUrlWithoutMetadata(serviceName, host, serviceInstance.getPort());\n    } else {\n        url = generateWithMetadata(serviceName, host, paramsMap);\n    }\n\n    url = url.setScopeModel(serviceInstance.getApplicationModel().getInternalModule());\n\n    return Collections.singletonList(url);\n}",
        "summary_tokens": [
            "build",
            "the",
            "url",
            "urls",
            "from",
            "service",
            "instance",
            "get",
            "metadata",
            "the",
            "metadata",
            "of",
            "service",
            "instance"
        ]
    },
    {
        "id": 787,
        "code": "private Map<String, String> getMetadataServiceURLsParams(ServiceInstance serviceInstance) {\n    Map<String, String> metadata = serviceInstance.getMetadata();\n    String param = metadata.get(METADATA_SERVICE_URL_PARAMS_PROPERTY_NAME);\n    return isBlank(param) ? emptyMap() : (Map) JsonUtils.getJson().toJavaObject(param, Map.class);\n}",
        "summary_tokens": [
            "get",
            "the",
            "multiple",
            "url",
            "urls",
            "parameters",
            "of",
            "metadata",
            "service",
            "metadata",
            "service",
            "s",
            "metadata"
        ]
    },
    {
        "id": 788,
        "code": "public URL getConsumerUrl() {\n    return this.consumerUrl;\n}",
        "summary_tokens": [
            "the",
            "currently",
            "effective",
            "consumer",
            "url"
        ]
    },
    {
        "id": 789,
        "code": "public URL getOriginalConsumerUrl() {\n    return this.consumerUrl;\n}",
        "summary_tokens": [
            "the",
            "original",
            "consumer",
            "url"
        ]
    },
    {
        "id": 790,
        "code": "public URL getRegisteredConsumerUrl() {\n    return registeredConsumerUrl;\n}",
        "summary_tokens": [
            "the",
            "url",
            "registered",
            "to",
            "registry",
            "or",
            "metadata",
            "center"
        ]
    },
    {
        "id": 791,
        "code": "public URL getSubscribeUrl() {\n    return subscribeUrl;\n}",
        "summary_tokens": [
            "the",
            "url",
            "used",
            "to",
            "subscribe",
            "from",
            "registry"
        ]
    },
    {
        "id": 792,
        "code": "private void refreshInvoker(List<URL> invokerUrls) {\n    Assert.notNull(invokerUrls, \"invokerUrls should not be null\");\n\n    if (invokerUrls.size() == 1\n        && invokerUrls.get(0) != null\n        && EMPTY_PROTOCOL.equals(invokerUrls.get(0).getProtocol())) {\n        this.forbidden = true; \n        routerChain.setInvokers(BitList.emptyList());\n        destroyAllInvokers(); \n    } else {\n        this.forbidden = false; \n\n        if (invokerUrls == Collections.<URL>emptyList()) {\n            invokerUrls = new ArrayList<>();\n        }\n            \n        Set<URL> localCachedInvokerUrls = this.cachedInvokerUrls;\n        if (invokerUrls.isEmpty() && localCachedInvokerUrls != null) {\n\n                \n            logger.warn(\"1-4\", \"configuration \", \"\",\n                \"Service\" + serviceKey + \" received empty address list with no EMPTY protocol set, trigger empty protection.\");\n\n            invokerUrls.addAll(localCachedInvokerUrls);\n\n        } else {\n            localCachedInvokerUrls = new HashSet<>();\n            localCachedInvokerUrls.addAll(invokerUrls);\n            this.cachedInvokerUrls = localCachedInvokerUrls;\n        }\n        if (invokerUrls.isEmpty()) {\n            return;\n        }\n\n            \n        Map<URL, Invoker<T>> localUrlInvokerMap = this.urlInvokerMap;\n            \n        Map<URL, Invoker<T>> oldUrlInvokerMap = null;\n        if (localUrlInvokerMap != null) {\n                \n            oldUrlInvokerMap = new LinkedHashMap<>(Math.round(1 + localUrlInvokerMap.size() / DEFAULT_HASHMAP_LOAD_FACTOR));\n            localUrlInvokerMap.forEach(oldUrlInvokerMap::put);\n        }\n        Map<URL, Invoker<T>> newUrlInvokerMap = toInvokers(oldUrlInvokerMap, invokerUrls);\n\n            \n        if (CollectionUtils.isEmptyMap(newUrlInvokerMap)) {\n\n                \n\n            logger.error(\n                \"3-1\", \"inconsistency between the client protocol and the protocol of the server\",\n                \"\", \"urls to invokers error\",\n                new IllegalStateException(\n                    \"urls to invokers error. invokerUrls.size :\" +\n                        invokerUrls.size() + \", invoker.size :0. urls :\" + invokerUrls.toString()));\n\n            return;\n        }\n\n        List<Invoker<T>> newInvokers = Collections.unmodifiableList(new ArrayList<>(newUrlInvokerMap.values()));\n        this.setInvokers(multiGroup ? new BitList<>(toMergeInvokerList(newInvokers)) : new BitList<>(newInvokers));\n            \n        routerChain.setInvokers(this.getInvokers());\n        this.urlInvokerMap = newUrlInvokerMap;\n\n        try {\n            destroyUnusedInvokers(oldUrlInvokerMap, newUrlInvokerMap); \n        } catch (Exception e) {\n            logger.warn(\"destroyUnusedInvokers error. \", e);\n        }\n\n            \n        this.invokersChanged();\n    }\n}",
        "summary_tokens": [
            "convert",
            "the",
            "invoker",
            "url",
            "list",
            "to",
            "the",
            "invoker",
            "map"
        ]
    },
    {
        "id": 793,
        "code": "private Optional<List<Router>> toRouters(List<URL> urls) {\n    if (urls == null || urls.isEmpty()) {\n        return Optional.empty();\n    }\n\n    List<Router> routers = new ArrayList<>();\n    for (URL url : urls) {\n        if (EMPTY_PROTOCOL.equals(url.getProtocol())) {\n            continue;\n        }\n        String routerType = url.getParameter(ROUTER_KEY);\n        if (routerType != null && routerType.length() > 0) {\n            url = url.setProtocol(routerType);\n        }\n        try {\n            Router router = routerFactory.getRouter(url);\n            if (!routers.contains(router)) {\n                routers.add(router);\n            }\n        } catch (Throwable t) {\n            logger.error(\"convert router url to router error, url: \" + url, t);\n        }\n    }\n\n    return Optional.of(routers);\n}",
        "summary_tokens": [
            "urls",
            "null",
            "no",
            "routers",
            "do",
            "nothing",
            "else",
            "routers",
            "list"
        ]
    },
    {
        "id": 794,
        "code": "private Map<URL, Invoker<T>> toInvokers(Map<URL, Invoker<T>> oldUrlInvokerMap, List<URL> urls) {\n    Map<URL, Invoker<T>> newUrlInvokerMap = new ConcurrentHashMap<>(urls == null ? 1 : (int) (urls.size() / 0.75f + 1));\n    if (urls == null || urls.isEmpty()) {\n        return newUrlInvokerMap;\n    }\n    String queryProtocols = this.queryMap.get(PROTOCOL_KEY);\n    for (URL providerUrl : urls) {\n        if (!checkProtocolValid(queryProtocols, providerUrl)) {\n            continue;\n        }\n\n        URL url = mergeUrl(providerUrl);\n\n            \n            \n            \n        Invoker<T> invoker = oldUrlInvokerMap == null ? null : oldUrlInvokerMap.remove(url);\n        if (invoker == null) { \n            try {\n                boolean enabled = true;\n                if (url.hasParameter(DISABLED_KEY)) {\n                    enabled = !url.getParameter(DISABLED_KEY, false);\n                } else {\n                    enabled = url.getParameter(ENABLED_KEY, true);\n                }\n                if (enabled) {\n                    invoker = protocol.refer(serviceType, url);\n                }\n            } catch (Throwable t) {\n\n                    \n                if (t instanceof RpcException && t.getMessage().contains(\"serialization optimizer\")) {\n                        \n                    logger.error(\"4-2\", \"typo in optimizer class\", \"\",\n                        \"Failed to refer invoker for interface:\" + serviceType + \",url:(\" + url + \")\" + t.getMessage(), t);\n\n                } else {\n                        \n                    logger.error(\"4-3\", \"\", \"\",\n                        \"Failed to refer invoker for interface:\" + serviceType + \",url:(\" + url + \")\" + t.getMessage(), t);\n                }\n            }\n            if (invoker != null) { \n                newUrlInvokerMap.put(url, invoker);\n            }\n        } else {\n            newUrlInvokerMap.put(url, invoker);\n        }\n    }\n    return newUrlInvokerMap;\n}",
        "summary_tokens": [
            "turn",
            "urls",
            "into",
            "invokers",
            "and",
            "if",
            "url",
            "has",
            "been",
            "referred",
            "will",
            "not",
            "re",
            "reference"
        ]
    },
    {
        "id": 795,
        "code": "public Map<URL, Invoker<T>> getUrlInvokerMap() {\n    return urlInvokerMap;\n}",
        "summary_tokens": [
            "haomin",
            "added",
            "for",
            "test",
            "purpose"
        ]
    },
    {
        "id": 796,
        "code": "protected void notify(URL url, NotifyListener listener, List<URL> urls) {\n    if (url == null) {\n        throw new IllegalArgumentException(\"notify url == null\");\n    }\n    if (listener == null) {\n        throw new IllegalArgumentException(\"notify listener == null\");\n    }\n    if ((CollectionUtils.isEmpty(urls)) && !ANY_VALUE.equals(url.getServiceInterface())) {\n            \n        logger.warn(\"1-4\", \"\", \"\", \"Ignore empty notify urls for subscribe url \" + url);\n        return;\n    }\n    if (logger.isInfoEnabled()) {\n        logger.info(\"Notify urls for subscribe url \" + url + \", url size: \" + urls.size());\n    }\n        \n    Map<String, List<URL>> result = new HashMap<>();\n    for (URL u : urls) {\n        if (UrlUtils.isMatch(url, u)) {\n            String category = u.getCategory(DEFAULT_CATEGORY);\n            List<URL> categoryList = result.computeIfAbsent(category, k -> new ArrayList<>());\n            categoryList.add(u);\n        }\n    }\n    if (result.size() == 0) {\n        return;\n    }\n    Map<String, List<URL>> categoryNotified = notified.computeIfAbsent(url, u -> new ConcurrentHashMap<>());\n    for (Map.Entry<String, List<URL>> entry : result.entrySet()) {\n        String category = entry.getKey();\n        List<URL> categoryList = entry.getValue();\n        categoryNotified.put(category, categoryList);\n        listener.notify(categoryList);\n\n            \n            \n        if (localCacheEnabled) {\n            saveProperties(url);\n        }\n    }\n}",
        "summary_tokens": [
            "notify",
            "changes",
            "from",
            "the",
            "provider",
            "side"
        ]
    },
    {
        "id": 797,
        "code": "protected String createRegistryCacheKey(URL url) {\n    return url.toServiceStringWithoutResolving();\n}",
        "summary_tokens": [
            "create",
            "the",
            "key",
            "for",
            "the",
            "registries",
            "cache"
        ]
    },
    {
        "id": 798,
        "code": "protected ServiceAddressURL createURL(String rawProvider, URL consumerURL, Map<String, String> extraParameters) {\n\n    boolean encoded = true;\n\n        \n    int paramStartIdx = rawProvider.indexOf(ENCODED_QUESTION_MARK);\n\n    if (paramStartIdx == -1) {\n            \n        encoded = false;\n    }\n\n        \n        \n        \n    String[] parts = URLStrParser.parseRawURLToArrays(rawProvider, paramStartIdx);\n\n    if (parts.length <= 1) {\n            \n        logger.warn(\"1-5\", \"\", \"\",\n            \"Received url without any parameters \" + rawProvider);\n\n        return DubboServiceAddressURL.valueOf(rawProvider, consumerURL);\n    }\n\n    String rawAddress = parts[0];\n    String rawParams = parts[1];\n\n        \n    boolean isEncoded = encoded;\n\n        \n    URLAddress address = stringAddress.computeIfAbsent(rawAddress, k -> URLAddress.parse(k, getDefaultURLProtocol(), isEncoded));\n    address.setTimestamp(System.currentTimeMillis());\n\n    URLParam param = stringParam.computeIfAbsent(rawParams, k -> URLParam.parse(k, isEncoded, extraParameters));\n    param.setTimestamp(System.currentTimeMillis());\n\n        \n    ServiceAddressURL cachedServiceAddressURL = createServiceURL(address, param, consumerURL);\n\n    if (isMatch(consumerURL, cachedServiceAddressURL)) {\n        return cachedServiceAddressURL;\n    }\n\n    return null;\n}",
        "summary_tokens": [
            "create",
            "dubbo",
            "service",
            "address",
            "object",
            "using",
            "provider",
            "url",
            "consumer",
            "url",
            "and",
            "extra",
            "parameters"
        ]
    },
    {
        "id": 799,
        "code": "protected Semaphore getSemaphore() {\n    return semaphore;\n}",
        "summary_tokens": [
            "this",
            "method",
            "is",
            "for",
            "unit",
            "test",
            "to",
            "see",
            "if",
            "the",
            "removal",
            "task",
            "has",
            "completed",
            "or",
            "not"
        ]
    },
    {
        "id": 800,
        "code": "public void destroyAll() {\n    if (!destroyed.compareAndSet(false, true)) {\n        return;\n    }\n\n    if (LOGGER.isInfoEnabled()) {\n        LOGGER.info(\"Close all registries \" + getRegistries());\n    }\n        \n    lock.lock();\n    try {\n        for (Registry registry : getRegistries()) {\n            try {\n                registry.destroy();\n            } catch (Throwable e) {\n                LOGGER.warn(e.getMessage(), e);\n            }\n        }\n        registries.clear();\n    } finally {\n            \n        lock.unlock();\n    }\n}",
        "summary_tokens": [
            "close",
            "all",
            "created",
            "registries"
        ]
    },
    {
        "id": 801,
        "code": "public void reset() {\n    destroyed.set(false);\n    registries.clear();\n}",
        "summary_tokens": [
            "reset",
            "state",
            "of",
            "abstract",
            "registry",
            "factory"
        ]
    },
    {
        "id": 802,
        "code": "public void testDoSubscribe() {\n    ApplicationModel applicationModel = spy(ApplicationModel.defaultModel());\n    when(applicationModel.getDefaultExtension(ServiceNameMapping.class)).thenReturn(mapping);\n        \n    when(mapping.getAndListen(any(), any(), any())).thenReturn(Collections.emptySet());\n        \n    try {\n        registryURL = registryURL.setScopeModel(applicationModel);\n        serviceDiscoveryRegistry = new ServiceDiscoveryRegistry(registryURL, serviceDiscovery, mapping);\n        serviceDiscoveryRegistry.doSubscribe(url, testServiceListener);\n    } finally {\n        registryURL = registryURL.setScopeModel(null);\n        serviceDiscoveryRegistry.unsubscribe(url, testServiceListener);\n    }\n\n    URL checkURL = url.addParameter(CHECK_KEY, true);\n\n\n\n\n\n\n\n\n\n\n\n\n        \n    Set<String> singleApp = new HashSet<>();\n    singleApp.add(APP_NAME1);\n    when(mapping.getAndListen(any(), any(), any())).thenReturn(singleApp);\n    try {\n        serviceDiscoveryRegistry.doSubscribe(checkURL, testServiceListener);\n    } finally {\n        serviceDiscoveryRegistry.unsubscribe(checkURL, testServiceListener);\n    }\n}",
        "summary_tokens": [
            "test",
            "subscribe",
            "normal",
            "case",
            "exceptional",
            "case",
            "check",
            "true",
            "check",
            "false"
        ]
    },
    {
        "id": 803,
        "code": "public void testSubscribeURLs() {\n        \n    Set<String> singleApp = new TreeSet<>();\n    singleApp.add(APP_NAME1);\n    serviceDiscoveryRegistry.subscribeURLs(url, testServiceListener, singleApp);\n\n    assertEquals(1, serviceDiscoveryRegistry.getServiceListeners().size());\n    verify(testServiceListener, times(1)).addServiceListener(instanceListener);\n    verify(instanceListener, never()).onEvent(any());\n    verify(serviceDiscovery, times(1)).addServiceInstancesChangedListener(instanceListener);\n\n        \n    Set<String> multiApps = new TreeSet<>();\n    multiApps.add(APP_NAME1);\n    multiApps.add(APP_NAME2);\n    MockServiceInstancesChangedListener multiAppsInstanceListener = spy(new MockServiceInstancesChangedListener(multiApps, serviceDiscovery));\n    doNothing().when(multiAppsInstanceListener).onEvent(any());\n    List<URL> urls = new ArrayList<>();\n    urls.add(URL.valueOf(\"dubbo://127.0.0.1:20880/TestService\"));\n    doReturn(urls).when(multiAppsInstanceListener).getAddresses(any(), any());\n    when(serviceDiscovery.createListener(multiApps)).thenReturn(multiAppsInstanceListener);\n    when(serviceDiscovery.getInstances(APP_NAME1)).thenReturn(instanceList1);\n    when(serviceDiscovery.getInstances(APP_NAME2)).thenReturn(instanceList2);\n    serviceDiscoveryRegistry.subscribeURLs(url, testServiceListener, multiApps);\n\n    assertEquals(2, serviceDiscoveryRegistry.getServiceListeners().size());\n    assertEquals(instanceListener, serviceDiscoveryRegistry.getServiceListeners().get(toStringKeys(singleApp)));\n    assertEquals(multiAppsInstanceListener, serviceDiscoveryRegistry.getServiceListeners().get(toStringKeys(multiApps)));\n    verify(testServiceListener, times(1)).addServiceListener(multiAppsInstanceListener);\n    verify(multiAppsInstanceListener, times(2)).onEvent(any());\n    verify(multiAppsInstanceListener, times(1)).addListenerAndNotify(any(), eq(testServiceListener));\n    verify(serviceDiscovery, times(1)).addServiceInstancesChangedListener(multiAppsInstanceListener);\n    ArgumentCaptor<List<URL>> captor = ArgumentCaptor.forClass(List.class);\n    verify(testServiceListener).notify(captor.capture());\n    assertEquals(urls, captor.getValue());\n\n        \n    NotifyListener testServiceListener2 = mock(NotifyListener.class);\n    URL url2 = URL.valueOf(\"tri://127.0.0.1/TestService2?interface=TestService2&check=false&protocol=tri\");\n    when(testServiceListener2.getConsumerUrl()).thenReturn(url2);\n    serviceDiscoveryRegistry.subscribeURLs(url2, testServiceListener2, multiApps);\n        \n    assertEquals(2, serviceDiscoveryRegistry.getServiceListeners().size());\n    assertEquals(multiAppsInstanceListener, serviceDiscoveryRegistry.getServiceListeners().get(toStringKeys(multiApps)));\n    verify(multiAppsInstanceListener, times(1)).addListenerAndNotify(any(), eq(testServiceListener));\n        \n    verify(serviceDiscovery, times(2)).addServiceInstancesChangedListener(multiAppsInstanceListener);\n        \n    Map<String, Set<ServiceInstancesChangedListener.NotifyListenerWithKey>> serviceListeners = multiAppsInstanceListener.getServiceListeners();\n    assertEquals(2, serviceListeners.size());\n    assertEquals(1, serviceListeners.get(url.getServiceKey()).size());\n    assertEquals(1, serviceListeners.get(url2.getServiceKey()).size());\n    ProtocolServiceKey protocolServiceKey = new ProtocolServiceKey(url2.getServiceInterface(), url2.getVersion(), url2.getGroup(), url2.getParameter(PROTOCOL_KEY, DUBBO));\n    assertTrue(serviceListeners.get(url2.getServiceKey()).contains(new ServiceInstancesChangedListener.NotifyListenerWithKey(protocolServiceKey, testServiceListener2)));\n}",
        "summary_tokens": [
            "test",
            "instance",
            "listener",
            "registration",
            "one",
            "app",
            "multi",
            "apps",
            "repeat",
            "same",
            "multi",
            "apps",
            "instance",
            "listener",
            "shared",
            "protocol",
            "included",
            "in",
            "key",
            "instance",
            "listener",
            "gets",
            "notified",
            "instance",
            "listener",
            "and",
            "service",
            "listener",
            "rightly",
            "mapped"
        ]
    },
    {
        "id": 804,
        "code": "",
        "summary_tokens": [
            "repeat",
            "of",
            "this",
            "test",
            "subscribe",
            "urls",
            "with",
            "multi",
            "threads"
        ]
    },
    {
        "id": 805,
        "code": "public void testSubscribeMultipleProtocols() {\n    Set<String> serviceNames = new HashSet<>();\n    serviceNames.add(\"app1\");\n    listener = new ServiceInstancesChangedListener(serviceNames, serviceDiscovery);\n        \n    NotifyListener demoServiceListener1 = Mockito.mock(NotifyListener.class);\n    when(demoServiceListener1.getConsumerUrl()).thenReturn(noProtocolConsumerURL);\n    listener.addListenerAndNotify(noProtocolConsumerURL, demoServiceListener1);\n        \n    NotifyListener demoServiceListener2 = Mockito.mock(NotifyListener.class);\n    when(demoServiceListener2.getConsumerUrl()).thenReturn(multipleProtocolsConsumerURL);\n    listener.addListenerAndNotify(multipleProtocolsConsumerURL, demoServiceListener2);\n        \n    NotifyListener demoServiceListener3 = Mockito.mock(NotifyListener.class);\n    when(demoServiceListener3.getConsumerUrl()).thenReturn(singleProtocolsConsumerURL);\n    listener.addListenerAndNotify(singleProtocolsConsumerURL, demoServiceListener3);\n\n        \n    ServiceInstancesChangedEvent app1_event = new ServiceInstancesChangedEvent(\"app1\", app1InstancesMultipleProtocols);\n    listener.onEvent(app1_event);\n\n        \n    ArgumentCaptor<List<URL>> default_protocol_captor = ArgumentCaptor.forClass(List.class);\n    Mockito.verify(demoServiceListener1, Mockito.times(1)).notify(default_protocol_captor.capture());\n    List<URL> default_protocol_notifiedUrls = default_protocol_captor.getValue();\n    Assertions.assertEquals(4, default_protocol_notifiedUrls.size());\n        \n    ArgumentCaptor<List<URL>> multi_protocols_captor = ArgumentCaptor.forClass(List.class);\n    Mockito.verify(demoServiceListener2, Mockito.times(1)).notify(multi_protocols_captor.capture());\n    List<URL> multi_protocol_notifiedUrls = multi_protocols_captor.getValue();\n    Assertions.assertEquals(4, multi_protocol_notifiedUrls.size());\n        \n    ArgumentCaptor<List<URL>> single_protocols_captor = ArgumentCaptor.forClass(List.class);\n    Mockito.verify(demoServiceListener3, Mockito.times(1)).notify(single_protocols_captor.capture());\n    List<URL> single_protocol_notifiedUrls = single_protocols_captor.getValue();\n    Assertions.assertEquals(1, single_protocol_notifiedUrls.size());\n}",
        "summary_tokens": [
            "test",
            "subscribe",
            "multiple",
            "protocols"
        ]
    },
    {
        "id": 806,
        "code": "public void testSubscribeMultipleGroups() {\n    Set<String> serviceNames = new HashSet<>();\n    serviceNames.add(\"app1\");\n    listener = new ServiceInstancesChangedListener(serviceNames, serviceDiscovery);\n\n        \n    ServiceInstancesChangedEvent event = new ServiceInstancesChangedEvent(\"app1\", app1Instances);\n    listener.onEvent(event);\n\n    Map<String, List<ServiceInstance>> allInstances = listener.getAllInstances();\n    Assertions.assertEquals(1, allInstances.size());\n    Assertions.assertEquals(3, allInstances.get(\"app1\").size());\n\n    ProtocolServiceKey protocolServiceKey = new ProtocolServiceKey(service1, null, null, \"dubbo\");\n    List<URL> serviceUrls = listener.getAddresses(protocolServiceKey, consumerURL);\n    Assertions.assertEquals(3, serviceUrls.size());\n    assertTrue(serviceUrls.get(0) instanceof InstanceAddressURL);\n\n    protocolServiceKey = new ProtocolServiceKey(service1, null, \"\", \"dubbo\");\n    serviceUrls = listener.getAddresses(protocolServiceKey, consumerURL);\n    Assertions.assertEquals(3, serviceUrls.size());\n    assertTrue(serviceUrls.get(0) instanceof InstanceAddressURL);\n\n    protocolServiceKey = new ProtocolServiceKey(service1, null, \",group1\", \"dubbo\");\n    serviceUrls = listener.getAddresses(protocolServiceKey, consumerURL);\n    Assertions.assertEquals(3, serviceUrls.size());\n    assertTrue(serviceUrls.get(0) instanceof InstanceAddressURL);\n\n    protocolServiceKey = new ProtocolServiceKey(service1, null, \"group1,\", \"dubbo\");\n    serviceUrls = listener.getAddresses(protocolServiceKey, consumerURL);\n    Assertions.assertEquals(3, serviceUrls.size());\n    assertTrue(serviceUrls.get(0) instanceof InstanceAddressURL);\n\n    protocolServiceKey = new ProtocolServiceKey(service1, null, \"*\", \"dubbo\");\n    serviceUrls = listener.getAddresses(protocolServiceKey, consumerURL);\n    Assertions.assertEquals(3, serviceUrls.size());\n    assertTrue(serviceUrls.get(0) instanceof InstanceAddressURL);\n\n    protocolServiceKey = new ProtocolServiceKey(service1, null, \"group1\", \"dubbo\");\n    serviceUrls = listener.getAddresses(protocolServiceKey, consumerURL);\n    Assertions.assertEquals(0, serviceUrls.size());\n\n    protocolServiceKey = new ProtocolServiceKey(service1, null, \"group1,group2\", \"dubbo\");\n    serviceUrls = listener.getAddresses(protocolServiceKey, consumerURL);\n    Assertions.assertEquals(0, serviceUrls.size());\n\n    protocolServiceKey = new ProtocolServiceKey(service1, null, \"group1,,group2\", \"dubbo\");\n    serviceUrls = listener.getAddresses(protocolServiceKey, consumerURL);\n    Assertions.assertEquals(3, serviceUrls.size());\n    assertTrue(serviceUrls.get(0) instanceof InstanceAddressURL);\n}",
        "summary_tokens": [
            "test",
            "subscribe",
            "multiple",
            "groups"
        ]
    },
    {
        "id": 807,
        "code": "public void testSubscribeMultipleVersions() {\n    Set<String> serviceNames = new HashSet<>();\n    serviceNames.add(\"app1\");\n    listener = new ServiceInstancesChangedListener(serviceNames, serviceDiscovery);\n\n        \n    ServiceInstancesChangedEvent event = new ServiceInstancesChangedEvent(\"app1\", app1Instances);\n    listener.onEvent(event);\n\n    Map<String, List<ServiceInstance>> allInstances = listener.getAllInstances();\n    Assertions.assertEquals(1, allInstances.size());\n    Assertions.assertEquals(3, allInstances.get(\"app1\").size());\n\n    ProtocolServiceKey protocolServiceKey = new ProtocolServiceKey(service1, null, null, \"dubbo\");\n    List<URL> serviceUrls = listener.getAddresses(protocolServiceKey, consumerURL);\n    Assertions.assertEquals(3, serviceUrls.size());\n    assertTrue(serviceUrls.get(0) instanceof InstanceAddressURL);\n\n    protocolServiceKey = new ProtocolServiceKey(service1, \"\", null, \"dubbo\");\n    serviceUrls = listener.getAddresses(protocolServiceKey, consumerURL);\n    Assertions.assertEquals(3, serviceUrls.size());\n    assertTrue(serviceUrls.get(0) instanceof InstanceAddressURL);\n\n    protocolServiceKey = new ProtocolServiceKey(service1, \"*\", null, \"dubbo\");\n    serviceUrls = listener.getAddresses(protocolServiceKey, consumerURL);\n    Assertions.assertEquals(3, serviceUrls.size());\n    assertTrue(serviceUrls.get(0) instanceof InstanceAddressURL);\n\n    protocolServiceKey = new ProtocolServiceKey(service1, \",1.0.0\", null, \"dubbo\");\n    serviceUrls = listener.getAddresses(protocolServiceKey, consumerURL);\n    Assertions.assertEquals(3, serviceUrls.size());\n    assertTrue(serviceUrls.get(0) instanceof InstanceAddressURL);\n\n    protocolServiceKey = new ProtocolServiceKey(service1, \"1.0.0,\", null, \"dubbo\");\n    serviceUrls = listener.getAddresses(protocolServiceKey, consumerURL);\n    Assertions.assertEquals(3, serviceUrls.size());\n    assertTrue(serviceUrls.get(0) instanceof InstanceAddressURL);\n\n    protocolServiceKey = new ProtocolServiceKey(service1, \"1.0.0,,1.0.1\", null, \"dubbo\");\n    serviceUrls = listener.getAddresses(protocolServiceKey, consumerURL);\n    Assertions.assertEquals(3, serviceUrls.size());\n    assertTrue(serviceUrls.get(0) instanceof InstanceAddressURL);\n\n    protocolServiceKey = new ProtocolServiceKey(service1, \"1.0.1,1.0.0\", null, \"dubbo\");\n    serviceUrls = listener.getAddresses(protocolServiceKey, consumerURL);\n    Assertions.assertEquals(0, serviceUrls.size());\n}",
        "summary_tokens": [
            "test",
            "subscribe",
            "multiple",
            "versions"
        ]
    },
    {
        "id": 808,
        "code": "public void testGet() {\n    Set<String> set = new HashSet<>();\n    set.add(\"app1\");\n\n    MetadataReportInstance reportInstance = mock(MetadataReportInstance.class);\n    Mockito.when(reportInstance.getMetadataReport(any())).thenReturn(metadataReport);\n    when(metadataReport.getServiceAppMapping(any(), any())).thenReturn(set);\n\n    mapping.metadataReportInstance = reportInstance;\n    Set<String> result = mapping.get(url);\n    assertEquals(set, result);\n}",
        "summary_tokens": [
            "this",
            "test",
            "currently",
            "doesn",
            "t",
            "make",
            "any",
            "sense"
        ]
    },
    {
        "id": 809,
        "code": "",
        "summary_tokens": [
            "same",
            "situation",
            "as",
            "test",
            "get",
            "so",
            "left",
            "empty"
        ]
    },
    {
        "id": 810,
        "code": "public void testCustomizeWithIncludeFilters() {\n    ApplicationModel applicationModel = spy(ApplicationModel.defaultModel());\n    ApplicationConfig applicationConfig = new ApplicationConfig(\"aa\");\n    doReturn(applicationConfig).when(applicationModel).getCurrentConfig();\n\n    DefaultServiceInstance serviceInstance1 = new DefaultServiceInstance(\"ServiceInstanceMetadataCustomizerTest\", applicationModel);\n    MetadataInfo metadataInfo = new MetadataInfo();\n    metadataInfo.addService(URL.valueOf(\"tri://127.1.1.1:50052/org.apache.dubbo.demo.GreetingService?application=ServiceInstanceMetadataCustomizerTest&env=test&side=provider&group=test\"));\n    serviceInstance1.setServiceMetadata(metadataInfo);\n    serviceInstanceMetadataCustomizer.customize(serviceInstance1, applicationModel);\n    Assertions.assertEquals(1, serviceInstance1.getMetadata().size());\n    Assertions.assertEquals(\"provider\", serviceInstance1.getMetadata(SIDE_KEY));\n    Assertions.assertNull( serviceInstance1.getMetadata(\"env\"));\n    Assertions.assertNull( serviceInstance1.getMetadata(\"application\"));\n}",
        "summary_tokens": [
            "only",
            "include",
            "policy",
            "spicified",
            "in",
            "customized",
            "filter",
            "will",
            "take",
            "effect"
        ]
    },
    {
        "id": 811,
        "code": "public void testCustomizeWithExcludeFilters() {\n    ApplicationModel applicationModel = spy(ApplicationModel.defaultModel());\n    ApplicationConfig applicationConfig = new ApplicationConfig(\"aa\");\n    doReturn(applicationConfig).when(applicationModel).getCurrentConfig();\n\n    DefaultServiceInstance serviceInstance1 = new DefaultServiceInstance(\"ServiceInstanceMetadataCustomizerTest\", applicationModel);\n    MetadataInfo metadataInfo = new MetadataInfo();\n    metadataInfo.addService(URL.valueOf(\"tri://127.1.1.1:50052/org.apache.dubbo.demo.GreetingService?application=ServiceInstanceMetadataCustomizerTest&env=test&side=provider&group=test&params-filter=-customized,-dubbo\"));\n    serviceInstance1.setServiceMetadata(metadataInfo);\n    serviceInstanceMetadataCustomizer.customize(serviceInstance1, applicationModel);\n    Assertions.assertEquals(2, serviceInstance1.getMetadata().size());\n    Assertions.assertEquals(\"ServiceInstanceMetadataCustomizerTest\", serviceInstance1.getMetadata(\"application\"));\n    Assertions.assertEquals(\"test\", serviceInstance1.getMetadata(\"env\"));\n\n    Assertions.assertNull( serviceInstance1.getMetadata(\"side\"));\n    Assertions.assertNull( serviceInstance1.getMetadata(\"group\"));\n}",
        "summary_tokens": [
            "only",
            "exclude",
            "policies",
            "specified",
            "in",
            "exclude",
            "filters",
            "will",
            "take",
            "effect"
        ]
    },
    {
        "id": 812,
        "code": "public String[] instanceParamsIncluded() {\n    return new String[]{SIDE_KEY};\n}",
        "summary_tokens": [
            "not",
            "included",
            "in",
            "this",
            "test"
        ]
    },
    {
        "id": 813,
        "code": "public String[] instanceParamsIncluded() {\n    return new String[0];\n}",
        "summary_tokens": [
            "not",
            "included",
            "in",
            "this",
            "test"
        ]
    },
    {
        "id": 814,
        "code": "public String[] instanceParamsIncluded() {\n    return new String[0];\n}",
        "summary_tokens": [
            "not",
            "included",
            "in",
            "this",
            "test"
        ]
    },
    {
        "id": 815,
        "code": "public void test() throws InterruptedException {\n    DynamicConfiguration dynamicConfiguration = Mockito.mock(DynamicConfiguration.class);\n\n    ApplicationModel.reset();\n    ApplicationModel.defaultModel().getDefaultModule().getModelEnvironment().setDynamicConfiguration(dynamicConfiguration);\n    ApplicationModel.defaultModel().getDefaultModule().getModelEnvironment().setLocalMigrationRule(localRule);\n    ApplicationConfig applicationConfig = new ApplicationConfig();\n    applicationConfig.setName(\"demo-consumer\");\n    ApplicationModel.defaultModel().getApplicationConfigManager().setApplication(applicationConfig);\n\n    URL consumerURL = Mockito.mock(URL.class);\n    Mockito.when(consumerURL.getServiceKey()).thenReturn(\"Test\");\n    Mockito.when(consumerURL.getParameter(\"timestamp\")).thenReturn(\"1\");\n\n    System.setProperty(\"dubbo.application.migration.delay\", \"1000\");\n    MigrationRuleHandler<?> handler = Mockito.mock(MigrationRuleHandler.class, Mockito.withSettings().verboseLogging());\n\n    MigrationRuleListener migrationRuleListener = new MigrationRuleListener(ApplicationModel.defaultModel().getDefaultModule());\n\n    MigrationInvoker<?> migrationInvoker = Mockito.mock(MigrationInvoker.class);\n    migrationRuleListener.getHandlers().put(migrationInvoker, handler);\n\n    Thread.sleep(2000);\n    Mockito.verify(handler, Mockito.timeout(5000)).doMigrate(Mockito.any());\n\n    migrationRuleListener.onRefer(null, migrationInvoker, consumerURL, null);\n    Mockito.verify(handler, Mockito.times(2)).doMigrate(Mockito.any());\n\n    ApplicationModel.reset();\n}",
        "summary_tokens": [
            "listener",
            "started",
            "with",
            "config",
            "center",
            "and",
            "local",
            "rule",
            "no",
            "initial",
            "remote",
            "rule"
        ]
    },
    {
        "id": 816,
        "code": "public void testWithInitAndNoLocalRule() {\n    ApplicationModel.defaultModel().getDefaultModule().getModelEnvironment().setDynamicConfiguration(null);\n    ApplicationModel.defaultModel().getDefaultModule().getModelEnvironment().setLocalMigrationRule(\"\");\n    ApplicationConfig applicationConfig = new ApplicationConfig();\n    applicationConfig.setName(\"demo-consumer\");\n    ApplicationModel.defaultModel().getApplicationConfigManager().setApplication(applicationConfig);\n\n    URL consumerURL = Mockito.mock(URL.class);\n    Mockito.when(consumerURL.getServiceKey()).thenReturn(\"Test\");\n    Mockito.when(consumerURL.getParameter(\"timestamp\")).thenReturn(\"1\");\n\n    System.setProperty(\"dubbo.application.migration.delay\", \"1000\");\n    MigrationRuleHandler<?> handler = Mockito.mock(MigrationRuleHandler.class, Mockito.withSettings().verboseLogging());\n\n    MigrationRuleListener migrationRuleListener = new MigrationRuleListener(ApplicationModel.defaultModel().getDefaultModule());\n    MigrationInvoker<?> migrationInvoker = Mockito.mock(MigrationInvoker.class);\n    migrationRuleListener.getHandlers().put(migrationInvoker, handler);\n    migrationRuleListener.onRefer(null, migrationInvoker, consumerURL, null);\n        \n    Mockito.verify(handler, Mockito.times(1)).doMigrate(MigrationRule.getInitRule());\n\n        \n    Assertions.assertNull(migrationRuleListener.localRuleMigrationFuture);\n    Assertions.assertNull(migrationRuleListener.ruleMigrationFuture);\n    Assertions.assertEquals(0, migrationRuleListener.ruleQueue.size());\n\n    ApplicationModel.reset();\n}",
        "summary_tokens": [
            "test",
            "listener",
            "started",
            "without",
            "local",
            "rule",
            "and",
            "config",
            "center",
            "init",
            "should",
            "be",
            "used",
            "and",
            "no",
            "scheduled",
            "task",
            "should",
            "be",
            "started"
        ]
    },
    {
        "id": 817,
        "code": "public void testWithConfigurationListenerAndLocalRule() throws InterruptedException {\n    DynamicConfiguration dynamicConfiguration = Mockito.mock(DynamicConfiguration.class);\n    Mockito.doReturn(remoteRule).when(dynamicConfiguration).getConfig(Mockito.anyString(), Mockito.anyString());\n\n    ApplicationModel.defaultModel().getDefaultModule().getModelEnvironment().setDynamicConfiguration(dynamicConfiguration);\n    ApplicationModel.defaultModel().getDefaultModule().getModelEnvironment().setLocalMigrationRule(localRule);\n    ApplicationConfig applicationConfig = new ApplicationConfig();\n    applicationConfig.setName(\"demo-consumer\");\n    ApplicationModel.defaultModel().getApplicationConfigManager().setApplication(applicationConfig);\n\n    URL consumerURL = Mockito.mock(URL.class);\n    Mockito.when(consumerURL.getServiceKey()).thenReturn(\"Test\");\n    Mockito.when(consumerURL.getParameter(\"timestamp\")).thenReturn(\"1\");\n\n    URL consumerURL2 = Mockito.mock(URL.class);\n    Mockito.when(consumerURL2.getServiceKey()).thenReturn(\"Test2\");\n    Mockito.when(consumerURL2.getParameter(\"timestamp\")).thenReturn(\"2\");\n\n    System.setProperty(\"dubbo.application.migration.delay\", \"1000\");\n    MigrationRuleHandler<?> handler = Mockito.mock(MigrationRuleHandler.class, Mockito.withSettings().verboseLogging());\n    MigrationRuleHandler<?> handler2 = Mockito.mock(MigrationRuleHandler.class, Mockito.withSettings().verboseLogging());\n\n        \n        \n    MigrationRuleListener migrationRuleListener = new MigrationRuleListener(ApplicationModel.defaultModel().getDefaultModule());\n    Assertions.assertNotNull(migrationRuleListener.localRuleMigrationFuture);\n    Assertions.assertNull(migrationRuleListener.ruleMigrationFuture);\n    MigrationInvoker<?> migrationInvoker = Mockito.mock(MigrationInvoker.class);\n    MigrationInvoker<?> migrationInvoker2 = Mockito.mock(MigrationInvoker.class);\n\n        \n    migrationRuleListener.getHandlers().put(migrationInvoker, handler);\n    migrationRuleListener.onRefer(null, migrationInvoker, consumerURL, null);\n\n    MigrationRule tmpRemoteRule = migrationRuleListener.getRule();\n    ArgumentCaptor<MigrationRule> captor = ArgumentCaptor.forClass(MigrationRule.class);\n    Mockito.verify(handler, Mockito.times(1)).doMigrate(captor.capture());\n    Assertions.assertEquals(tmpRemoteRule, captor.getValue());\n\n    Thread.sleep(3000);\n    Assertions.assertNull(migrationRuleListener.ruleMigrationFuture);\n\n\n\n\n\n    ArgumentCaptor<MigrationRule> captor2 = ArgumentCaptor.forClass(MigrationRule.class);\n    migrationRuleListener.getHandlers().put(migrationInvoker2, handler2);\n    migrationRuleListener.onRefer(null, migrationInvoker2, consumerURL2, null);\n    Mockito.verify(handler2, Mockito.times(1)).doMigrate(captor2.capture());\n    Assertions.assertEquals(tmpRemoteRule, captor2.getValue());\n\n\n    migrationRuleListener.process(new ConfigChangedEvent(\"key\", \"group\", dynamicRemoteRule));\n    Thread.sleep(1000);\n    Assertions.assertNotNull(migrationRuleListener.ruleMigrationFuture);\n    ArgumentCaptor<MigrationRule> captor_event = ArgumentCaptor.forClass(MigrationRule.class);\n    Mockito.verify(handler, Mockito.times(2)).doMigrate(captor_event.capture());\n    Assertions.assertEquals(\"APPLICATION_FIRST\", captor_event.getValue().getStep().toString());\n    Mockito.verify(handler2, Mockito.times(2)).doMigrate(captor_event.capture());\n    Assertions.assertEquals(\"APPLICATION_FIRST\", captor_event.getValue().getStep().toString());\n\n    ApplicationModel.reset();\n}",
        "summary_tokens": [
            "listener",
            "with",
            "config",
            "center",
            "initial",
            "remote",
            "rule",
            "and",
            "local",
            "rule",
            "check",
            "0"
        ]
    },
    {
        "id": 818,
        "code": "public void testSimplifiedUrl() {\n\n        \n    Map<String, String> parameters = new HashMap<>();\n    parameters.put(INTERFACE_KEY, DemoService.class.getName());\n    parameters.put(\"registry\", \"zookeeper\");\n    parameters.put(\"register\", \"true\");\n    parameters.put(REGISTER_IP_KEY, \"172.23.236.180\");\n\n\n    Map<String, Object> attributes = new HashMap<>();\n    ServiceConfigURL serviceConfigURLWithoutSimplified = new ServiceConfigURL(\"registry\",\n        \"127.0.0.1\",\n        2181,\n        \"org.apache.dubbo.registry.RegistryService\",\n        parameters);\n    Map<String, String> refer = new HashMap<>();\n    attributes.put(REFER_KEY, refer);\n    attributes.put(\"key1\", \"value1\");\n    URL urlWithoutSimplified = serviceConfigURLWithoutSimplified.addAttributes(attributes);\n\n    DemoDynamicDirectory<DemoService> dynamicDirectoryWithoutSimplified =\n        new DemoDynamicDirectory<>(DemoService.class, urlWithoutSimplified);\n\n    URL registeredConsumerUrlWithoutSimplified = new ServiceConfigURL(\"dubbo\",\n        \"127.0.0.1\",\n        2181,\n        DemoService.class.getName(),\n        parameters);\n\n    dynamicDirectoryWithoutSimplified.setRegisteredConsumerUrl(registeredConsumerUrlWithoutSimplified);\n\n    URL urlForNotSimplified = registeredConsumerUrlWithoutSimplified\n        .addParameters(CATEGORY_KEY, CONSUMERS_CATEGORY, CHECK_KEY, String.valueOf(false));\n\n    Assertions.assertEquals(urlForNotSimplified, dynamicDirectoryWithoutSimplified.getRegisteredConsumerUrl());\n\n        \n    parameters.put(SIMPLIFIED_KEY, \"true\");\n    ServiceConfigURL serviceConfigURLWithSimplified = new ServiceConfigURL(\"registry\",\n        \"127.0.0.1\",\n        2181,\n        \"org.apache.dubbo.registry.RegistryService\",\n        parameters);\n    URL urlWithSimplified = serviceConfigURLWithSimplified.addAttributes(attributes);\n    DemoDynamicDirectory<DemoService> dynamicDirectoryWithSimplified = new DemoDynamicDirectory<>(DemoService.class, urlWithSimplified);\n\n    URL registeredConsumerUrlWithSimplified = new ServiceConfigURL(\"dubbo\",\n        \"127.0.0.1\",\n        2181,\n        DemoService.class.getName(),\n        parameters);\n\n    dynamicDirectoryWithSimplified.setRegisteredConsumerUrl(registeredConsumerUrlWithSimplified);\n\n    URL urlForSimplified = URL.valueOf(\n        registeredConsumerUrlWithSimplified,\n        DEFAULT_REGISTER_CONSUMER_KEYS,\n        null).addParameters(CATEGORY_KEY, CONSUMERS_CATEGORY, CHECK_KEY, String.valueOf(false));\n\n    Assertions.assertEquals(urlForSimplified, dynamicDirectoryWithSimplified.getRegisteredConsumerUrl());\n\n}",
        "summary_tokens": [
            "verify",
            "simplified",
            "consumer",
            "url",
            "information",
            "that",
            "needs",
            "to",
            "be",
            "registered"
        ]
    },
    {
        "id": 819,
        "code": "public void testConsumerUrlWithoutProtocol() {\n    ApplicationConfig applicationConfig = new ApplicationConfig();\n    applicationConfig.setName(\"application1\");\n\n    ConfigManager configManager = mock(ConfigManager.class);\n    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);\n\n    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);\n    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true))\n        .thenReturn(true);\n\n    Map<String, String> parameters = new HashMap<>();\n    parameters.put(INTERFACE_KEY, DemoService.class.getName());\n    parameters.put(\"registry\", \"zookeeper\");\n    parameters.put(\"register\", \"false\");\n    parameters.put(REGISTER_IP_KEY, \"172.23.236.180\");\n\n    Map<String, Object> attributes = new HashMap<>();\n    ServiceConfigURL serviceConfigURL = new ServiceConfigURL(\"registry\",\n        \"127.0.0.1\",\n        2181,\n        \"org.apache.dubbo.registry.RegistryService\",\n        parameters);\n    Map<String, String> refer = new HashMap<>();\n    attributes.put(REFER_KEY, refer);\n    attributes.put(\"key1\", \"value1\");\n    URL url = serviceConfigURL.addAttributes(attributes);\n\n    RegistryFactory registryFactory = mock(RegistryFactory.class);\n    Registry registry = mock(Registry.class);\n\n    RegistryProtocol registryProtocol = new RegistryProtocol();\n\n    MigrationRuleListener migrationRuleListener = mock(MigrationRuleListener.class);\n    List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();\n    registryProtocolListeners.add(migrationRuleListener);\n\n    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());\n    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig(\"application1\"));\n    ExtensionLoader<RegistryProtocolListener> extensionLoaderMock = mock(ExtensionLoader.class);\n    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);\n    Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY))\n        .thenReturn(registryProtocolListeners);\n    url = url.setScopeModel(moduleModel);\n\n    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);\n\n    Cluster cluster = mock(Cluster.class);\n\n    Invoker<?> invoker = registryProtocol.doRefer(cluster, registry, DemoService.class, url, parameters);\n\n    Assertions.assertTrue(invoker instanceof MigrationInvoker);\n\n    URL consumerUrl = ((MigrationInvoker<?>) invoker).getConsumerUrl();\n    Assertions.assertTrue((consumerUrl != null));\n\n        \n    Assertions.assertEquals(\"consumer\", consumerUrl.getProtocol());\n    Assertions.assertEquals(parameters.get(REGISTER_IP_KEY), consumerUrl.getHost());\n    Assertions.assertFalse(consumerUrl.getAttributes().containsKey(REFER_KEY));\n    Assertions.assertEquals(\"value1\", consumerUrl.getAttribute(\"key1\"));\n}",
        "summary_tokens": [
            "verify",
            "the",
            "generated",
            "consumer",
            "url",
            "information"
        ]
    },
    {
        "id": 820,
        "code": "public void testConsumerUrlWithProtocol() {\n    ApplicationConfig applicationConfig = new ApplicationConfig();\n    applicationConfig.setName(\"application1\");\n\n    ConfigManager configManager = mock(ConfigManager.class);\n    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);\n\n    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);\n    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true))\n        .thenReturn(true);\n\n    Map<String, String> parameters = new HashMap<>();\n    parameters.put(INTERFACE_KEY, DemoService.class.getName());\n    parameters.put(\"registry\", \"zookeeper\");\n    parameters.put(\"register\", \"false\");\n    parameters.put(REGISTER_IP_KEY, \"172.23.236.180\");\n    parameters.put(PROTOCOL_KEY, \"tri\");\n    Map<String, Object> attributes = new HashMap<>();\n    ServiceConfigURL serviceConfigURL = new ServiceConfigURL(\"registry\",\n        \"127.0.0.1\",\n        2181,\n        \"org.apache.dubbo.registry.RegistryService\",\n        parameters);\n    Map<String, String> refer = new HashMap<>();\n    attributes.put(REFER_KEY, refer);\n    attributes.put(\"key1\", \"value1\");\n    URL url = serviceConfigURL.addAttributes(attributes);\n\n    RegistryFactory registryFactory = mock(RegistryFactory.class);\n\n    RegistryProtocol registryProtocol = new RegistryProtocol();\n    Registry registry = mock(Registry.class);\n\n    MigrationRuleListener migrationRuleListener = mock(MigrationRuleListener.class);\n    List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();\n    registryProtocolListeners.add(migrationRuleListener);\n\n    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());\n    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig(\"application1\"));\n    ExtensionLoader<RegistryProtocolListener> extensionLoaderMock = mock(ExtensionLoader.class);\n    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);\n    Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY))\n        .thenReturn(registryProtocolListeners);\n    url = url.setScopeModel(moduleModel);\n\n    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);\n\n    Cluster cluster = mock(Cluster.class);\n\n    Invoker<?> invoker = registryProtocol.doRefer(cluster, registry, DemoService.class, url, parameters);\n\n    Assertions.assertTrue(invoker instanceof MigrationInvoker);\n\n    URL consumerUrl = ((MigrationInvoker<?>) invoker).getConsumerUrl();\n    Assertions.assertTrue((consumerUrl != null));\n\n        \n    Assertions.assertEquals(\"tri\", consumerUrl.getProtocol());\n    Assertions.assertEquals(parameters.get(REGISTER_IP_KEY), consumerUrl.getHost());\n    Assertions.assertFalse(consumerUrl.getAttributes().containsKey(REFER_KEY));\n    Assertions.assertEquals(\"value1\", consumerUrl.getAttribute(\"key1\"));\n\n}",
        "summary_tokens": [
            "verify",
            "that",
            "when",
            "the",
            "protocol",
            "is",
            "configured",
            "the",
            "protocol",
            "of",
            "consumer",
            "url",
            "is",
            "the",
            "configured",
            "protocol"
        ]
    },
    {
        "id": 821,
        "code": "public void testReferWithoutGroup() {\n    ApplicationConfig applicationConfig = new ApplicationConfig();\n    applicationConfig.setName(\"application1\");\n\n\n    ConfigManager configManager = mock(ConfigManager.class);\n    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);\n\n    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);\n    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true))\n        .thenReturn(true);\n\n    Map<String, String> parameters = new HashMap<>();\n    parameters.put(INTERFACE_KEY, DemoService.class.getName());\n    parameters.put(\"registry\", \"zookeeper\");\n    parameters.put(\"register\", \"false\");\n\n    Map<String, Object> attributes = new HashMap<>();\n    ServiceConfigURL serviceConfigURL = new ServiceConfigURL(\"registry\",\n        \"127.0.0.1\",\n        2181,\n        \"org.apache.dubbo.registry.RegistryService\",\n        parameters);\n    Map<String, String> refer = new HashMap<>();\n    attributes.put(REFER_KEY, refer);\n    URL url = serviceConfigURL.addAttributes(attributes);\n\n    RegistryFactory registryFactory = mock(RegistryFactory.class);\n    Registry registry = mock(Registry.class);\n\n    MigrationRuleListener migrationRuleListener = mock(MigrationRuleListener.class);\n    List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();\n    registryProtocolListeners.add(migrationRuleListener);\n\n    RegistryProtocol registryProtocol = new RegistryProtocol();\n    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());\n    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig(\"application1\"));\n    ExtensionLoader extensionLoaderMock = mock(ExtensionLoader.class);\n    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);\n    Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY))\n        .thenReturn(registryProtocolListeners);\n    Mockito.when(moduleModel.getExtensionLoader(RegistryFactory.class)).thenReturn(extensionLoaderMock);\n    Mockito.when(extensionLoaderMock.getAdaptiveExtension()).thenReturn(registryFactory);\n    url = url.setScopeModel(moduleModel);\n\n    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);\n\n    Invoker<?> invoker = registryProtocol.refer(DemoService.class, url);\n\n    Assertions.assertTrue(invoker instanceof MigrationInvoker);\n    Assertions.assertTrue(((MigrationInvoker<?>) invoker).getCluster() instanceof MockClusterWrapper);\n    Assertions.assertTrue(\n        ((MockClusterWrapper) ((MigrationInvoker<?>) invoker).getCluster()).getCluster() instanceof FailoverCluster);\n}",
        "summary_tokens": [
            "verify",
            "that",
            "if",
            "multiple",
            "groups",
            "are",
            "not",
            "configured",
            "the",
            "service",
            "reference",
            "of",
            "the",
            "registration",
            "center",
            "the",
            "default",
            "is",
            "failover",
            "cluster"
        ]
    },
    {
        "id": 822,
        "code": "public void testReferWithGroup() {\n    ApplicationConfig applicationConfig = new ApplicationConfig();\n    applicationConfig.setName(\"application1\");\n\n    ConfigManager configManager = mock(ConfigManager.class);\n    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);\n\n    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);\n    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true))\n        .thenReturn(true);\n\n    Map<String, String> parameters = new HashMap<>();\n    parameters.put(INTERFACE_KEY, DemoService.class.getName());\n    parameters.put(\"registry\", \"zookeeper\");\n    parameters.put(\"register\", \"false\");\n\n    Map<String, Object> attributes = new HashMap<>();\n    ServiceConfigURL serviceConfigURL = new ServiceConfigURL(\n        \"registry\",\n        \"127.0.0.1\",\n        2181,\n        \"org.apache.dubbo.registry.RegistryService\",\n        parameters);\n    Map<String, String> refer = new HashMap<>();\n    refer.put(GROUP_KEY, \"group1,group2\");\n    attributes.put(REFER_KEY, refer);\n    URL url = serviceConfigURL.addAttributes(attributes);\n\n    RegistryFactory registryFactory = mock(RegistryFactory.class);\n    Registry registry = mock(Registry.class);\n\n    MigrationRuleListener migrationRuleListener = mock(MigrationRuleListener.class);\n    List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();\n    registryProtocolListeners.add(migrationRuleListener);\n\n    RegistryProtocol registryProtocol = new RegistryProtocol();\n    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());\n    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig(\"application1\"));\n    ExtensionLoader extensionLoaderMock = mock(ExtensionLoader.class);\n    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);\n    Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY))\n        .thenReturn(registryProtocolListeners);\n    Mockito.when(moduleModel.getExtensionLoader(RegistryFactory.class)).thenReturn(extensionLoaderMock);\n    Mockito.when(extensionLoaderMock.getAdaptiveExtension()).thenReturn(registryFactory);\n    url = url.setScopeModel(moduleModel);\n\n    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);\n\n    Invoker<?> invoker = registryProtocol.refer(DemoService.class, url);\n\n    Assertions.assertTrue(invoker instanceof MigrationInvoker);\n\n    Assertions.assertTrue(((MigrationInvoker<?>) invoker).getCluster() instanceof MockClusterWrapper);\n\n    Assertions.assertTrue(\n        ((MockClusterWrapper) ((MigrationInvoker<?>) invoker).getCluster()).getCluster() instanceof MergeableCluster);\n\n}",
        "summary_tokens": [
            "verify",
            "that",
            "if",
            "multiple",
            "groups",
            "are",
            "configured",
            "the",
            "service",
            "reference",
            "of",
            "the",
            "registration",
            "center"
        ]
    },
    {
        "id": 823,
        "code": "public void testInterceptInvokerForMigrationRuleListener() {\n    ApplicationConfig applicationConfig = new ApplicationConfig();\n    applicationConfig.setName(\"application1\");\n\n    ConfigManager configManager = mock(ConfigManager.class);\n    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);\n\n    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);\n    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true))\n        .thenReturn(true);\n\n    Map<String, String> parameters = new HashMap<>();\n    parameters.put(INTERFACE_KEY, DemoService.class.getName());\n    parameters.put(\"registry\", \"zookeeper\");\n    parameters.put(\"register\", \"false\");\n\n    Map<String, Object> attributes = new HashMap<>();\n    ServiceConfigURL serviceConfigURL = new ServiceConfigURL(\n        \"registry\",\n        \"127.0.0.1\",\n        2181,\n        \"org.apache.dubbo.registry.RegistryService\",\n        parameters);\n    Map<String, String> refer = new HashMap<>();\n    refer.put(GROUP_KEY, \"group1,group2\");\n    attributes.put(REFER_KEY, refer);\n    URL url = serviceConfigURL.addAttributes(attributes);\n\n    MigrationInvoker<?> clusterInvoker = mock(MigrationInvoker.class);\n\n    Map<String, Object> consumerAttribute = new HashMap<>(url.getAttributes());\n    consumerAttribute.remove(REFER_KEY);\n    URL consumerUrl = new ServiceConfigURL(parameters.get(PROTOCOL_KEY) == null ? DUBBO : parameters.get(PROTOCOL_KEY),\n        null,\n        null,\n        parameters.get(REGISTER_IP_KEY),\n        0, url.getPath(),\n        parameters,\n        consumerAttribute);\n    url = url.putAttribute(CONSUMER_URL_KEY, consumerUrl);\n    MigrationRuleListener migrationRuleListener = mock(MigrationRuleListener.class);\n    List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();\n    registryProtocolListeners.add(migrationRuleListener);\n\n    RegistryProtocol registryProtocol = new RegistryProtocol();\n    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());\n    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig(\"application1\"));\n    ExtensionLoader<RegistryProtocolListener> extensionLoaderMock = mock(ExtensionLoader.class);\n    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);\n    Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY))\n        .thenReturn(registryProtocolListeners);\n    url = url.setScopeModel(moduleModel);\n\n    registryProtocol.interceptInvoker(clusterInvoker, url, consumerUrl);\n    verify(migrationRuleListener, times(1)).onRefer(registryProtocol, clusterInvoker, consumerUrl, url);\n}",
        "summary_tokens": [
            "verify",
            "that",
            "the",
            "default",
            "registry",
            "protocol",
            "listener",
            "will",
            "be",
            "executed"
        ]
    },
    {
        "id": 824,
        "code": "public void testInterceptInvokerForCustomRegistryProtocolListener() {\n    ApplicationConfig applicationConfig = new ApplicationConfig();\n    applicationConfig.setName(\"application1\");\n\n    ConfigManager configManager = mock(ConfigManager.class);\n    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);\n\n    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);\n    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true))\n        .thenReturn(true);\n\n    Map<String, String> parameters = new HashMap<>();\n    parameters.put(INTERFACE_KEY, DemoService.class.getName());\n    parameters.put(\"registry\", \"zookeeper\");\n    parameters.put(\"register\", \"false\");\n    parameters.put(REGISTRY_PROTOCOL_LISTENER_KEY, \"count\");\n\n    Map<String, Object> attributes = new HashMap<>();\n    ServiceConfigURL serviceConfigURL = new ServiceConfigURL(\n        \"registry\",\n        \"127.0.0.1\",\n        2181,\n        \"org.apache.dubbo.registry.RegistryService\",\n        parameters);\n    Map<String, String> refer = new HashMap<>();\n    refer.put(GROUP_KEY, \"group1,group2\");\n    attributes.put(REFER_KEY, refer);\n    URL url = serviceConfigURL.addAttributes(attributes);\n\n    RegistryProtocol registryProtocol = new RegistryProtocol();\n    MigrationInvoker<?> clusterInvoker = mock(MigrationInvoker.class);\n\n    Map<String, Object> consumerAttribute = new HashMap<>(url.getAttributes());\n    consumerAttribute.remove(REFER_KEY);\n    URL consumerUrl = new ServiceConfigURL(parameters.get(PROTOCOL_KEY) == null ? DUBBO : parameters.get(PROTOCOL_KEY),\n        null,\n        null,\n        parameters.get(REGISTER_IP_KEY),\n        0, url.getPath(),\n        parameters,\n        consumerAttribute);\n    url = url.putAttribute(CONSUMER_URL_KEY, consumerUrl);\n\n    List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();\n    registryProtocolListeners.add(new CountRegistryProtocolListener());\n\n    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());\n    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig(\"application1\"));\n    ExtensionLoader<RegistryProtocolListener> extensionLoaderMock = mock(ExtensionLoader.class);\n    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);\n    Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY))\n        .thenReturn(registryProtocolListeners);\n    url = url.setScopeModel(moduleModel);\n\n    registryProtocol.interceptInvoker(clusterInvoker, url, consumerUrl);\n\n    Assertions.assertEquals(1, CountRegistryProtocolListener.getReferCounter().get());\n}",
        "summary_tokens": [
            "verify",
            "that",
            "if",
            "registry"
        ]
    },
    {
        "id": 825,
        "code": "public void testRegisterConsumerUrl() {\n    ApplicationConfig applicationConfig = new ApplicationConfig();\n    applicationConfig.setName(\"application1\");\n\n    ConfigManager configManager = mock(ConfigManager.class);\n    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);\n\n    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);\n    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true))\n        .thenReturn(true);\n\n    Map<String, String> parameters = new HashMap<>();\n    parameters.put(INTERFACE_KEY, DemoService.class.getName());\n    parameters.put(\"registry\", \"zookeeper\");\n    parameters.put(\"register\", \"true\");\n    parameters.put(REGISTER_IP_KEY, \"172.23.236.180\");\n\n    Map<String, Object> attributes = new HashMap<>();\n    ServiceConfigURL serviceConfigURL = new ServiceConfigURL(\"registry\",\n        \"127.0.0.1\",\n        2181,\n        \"org.apache.dubbo.registry.RegistryService\",\n        parameters);\n    Map<String, String> refer = new HashMap<>();\n    attributes.put(REFER_KEY, refer);\n    attributes.put(\"key1\", \"value1\");\n    URL url = serviceConfigURL.addAttributes(attributes);\n\n    RegistryFactory registryFactory = mock(RegistryFactory.class);\n    Registry registry = mock(Registry.class);\n\n    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());\n    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig(\"application1\"));\n    ExtensionLoader extensionLoaderMock = mock(ExtensionLoader.class);\n    Mockito.when(moduleModel.getExtensionLoader(RegistryFactory.class)).thenReturn(extensionLoaderMock);\n    Mockito.when(extensionLoaderMock.getAdaptiveExtension()).thenReturn(registryFactory);\n    url = url.setScopeModel(moduleModel);\n\n    RegistryProtocol registryProtocol = new RegistryProtocol();\n\n    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);\n\n    Cluster cluster = mock(Cluster.class);\n\n    Invoker<?> invoker = registryProtocol.doRefer(cluster, registry, DemoService.class, url, parameters);\n\n    Assertions.assertTrue(invoker instanceof MigrationInvoker);\n\n    URL consumerUrl = ((MigrationInvoker<?>) invoker).getConsumerUrl();\n    Assertions.assertTrue((consumerUrl != null));\n\n    Map<String, String> urlParameters = consumerUrl.getParameters();\n    URL urlToRegistry = new ServiceConfigURL(\n        urlParameters.get(PROTOCOL_KEY) == null ? CONSUMER : urlParameters.get(PROTOCOL_KEY),\n        urlParameters.remove(REGISTER_IP_KEY), 0, consumerUrl.getPath(), urlParameters);\n\n    URL registeredConsumerUrl = urlToRegistry.addParameters(CATEGORY_KEY, CONSUMERS_CATEGORY, CHECK_KEY,\n        String.valueOf(false)).setScopeModel(moduleModel);\n\n    verify(registry,times(1)).register(registeredConsumerUrl);\n}",
        "summary_tokens": [
            "verify",
            "the",
            "registered",
            "consumer",
            "url"
        ]
    },
    {
        "id": 826,
        "code": "public void testRegistryFactoryIpCache() throws Exception {\n    Registry registry1 = registryFactory.getRegistry(URL.valueOf(\"dubbo://\" + NetUtils.getLocalAddress().getHostName() + \":2233\"));\n    Registry registry2 = registryFactory.getRegistry(URL.valueOf(\"dubbo://\" + NetUtils.getLocalAddress().getHostAddress() + \":2233\"));\n    Assertions.assertEquals(registry1, registry2);\n}",
        "summary_tokens": [
            "registration",
            "center",
            "address",
            "dubbo",
            "does",
            "not",
            "resolve"
        ]
    },
    {
        "id": 827,
        "code": "public void testRegister() throws Exception {\n        \n    abstractRegistry.register(mockUrl);\n    assert abstractRegistry.getRegistered().contains(mockUrl);\n        \n    for (URL url : abstractRegistry.getRegistered()) {\n        abstractRegistry.unregister(url);\n    }\n    List<URL> urlList = getList();\n    for (URL url : urlList) {\n        abstractRegistry.register(url);\n    }\n    MatcherAssert.assertThat(abstractRegistry.getRegistered().size(), Matchers.equalTo(urlList.size()));\n}",
        "summary_tokens": [
            "test",
            "method",
            "for",
            "org"
        ]
    },
    {
        "id": 828,
        "code": "public void testUnregister() {\n        \n    URL url = new ServiceConfigURL(\"dubbo\", \"192.168.0.1\", 2200);\n    abstractRegistry.register(url);\n    abstractRegistry.unregister(url);\n    MatcherAssert.assertThat(false, Matchers.equalTo(abstractRegistry.getRegistered().contains(url)));\n        \n    for (URL u : abstractRegistry.getRegistered()) {\n        abstractRegistry.unregister(u);\n    }\n    List<URL> urlList = getList();\n    for (URL urlSub : urlList) {\n        abstractRegistry.register(urlSub);\n    }\n    for (URL urlSub : urlList) {\n        abstractRegistry.unregister(urlSub);\n    }\n    MatcherAssert.assertThat(0, Matchers.equalTo(abstractRegistry.getRegistered().size()));\n}",
        "summary_tokens": [
            "test",
            "method",
            "for",
            "org"
        ]
    },
    {
        "id": 829,
        "code": "public void testSubscribeAndUnsubscribe() {\n        \n    final AtomicReference<Boolean> notified = new AtomicReference<Boolean>(false);\n    NotifyListener listener = urls -> notified.set(Boolean.TRUE);\n    URL url = new ServiceConfigURL(\"dubbo\", \"192.168.0.1\", 2200);\n    abstractRegistry.subscribe(url, listener);\n    Set<NotifyListener> subscribeListeners = abstractRegistry.getSubscribed().get(url);\n    MatcherAssert.assertThat(true, Matchers.equalTo(subscribeListeners.contains(listener)));\n        \n    abstractRegistry.unsubscribe(url, listener);\n    Set<NotifyListener> unsubscribeListeners = abstractRegistry.getSubscribed().get(url);\n    MatcherAssert.assertThat(false, Matchers.equalTo(unsubscribeListeners.contains(listener)));\n}",
        "summary_tokens": [
            "test",
            "subscribe",
            "and",
            "unsubscribe"
        ]
    },
    {
        "id": 830,
        "code": "public void testSubscribe() {\n        \n    try {\n        abstractRegistry.subscribe(testUrl, null);\n        Assertions.fail();\n    } catch (Exception e) {\n        Assertions.assertTrue(e instanceof IllegalArgumentException);\n    }\n        \n    try {\n        abstractRegistry.subscribe(null, null);\n        Assertions.fail();\n    } catch (Exception e) {\n        Assertions.assertTrue(e instanceof IllegalArgumentException);\n    }\n        \n    Assertions.assertNull(abstractRegistry.getSubscribed().get(testUrl));\n    abstractRegistry.subscribe(testUrl, listener);\n    Assertions.assertNotNull(abstractRegistry.getSubscribed().get(testUrl));\n    Assertions.assertTrue(abstractRegistry.getSubscribed().get(testUrl).contains(listener));\n}",
        "summary_tokens": [
            "test",
            "method",
            "for",
            "org"
        ]
    },
    {
        "id": 831,
        "code": "public void testUnsubscribe() {\n        \n    try {\n        abstractRegistry.unsubscribe(testUrl, null);\n        Assertions.fail();\n    } catch (Exception e) {\n        Assertions.assertTrue(e instanceof IllegalArgumentException);\n    }\n        \n    try {\n        abstractRegistry.unsubscribe(null, null);\n        Assertions.fail();\n    } catch (Exception e) {\n        Assertions.assertTrue(e instanceof IllegalArgumentException);\n    }\n\n    Assertions.assertNull(abstractRegistry.getSubscribed().get(testUrl));\n        \n    abstractRegistry.subscribe(testUrl, listener);\n    abstractRegistry.unsubscribe(testUrl, listener);\n        \n    Assertions.assertNotNull(abstractRegistry.getSubscribed().get(testUrl));\n    Assertions.assertFalse(abstractRegistry.getSubscribed().get(testUrl).contains(listener));\n}",
        "summary_tokens": [
            "test",
            "method",
            "for",
            "org"
        ]
    },
    {
        "id": 832,
        "code": "public void testRecover() throws Exception {\n        \n    abstractRegistry.recover();\n    Assertions.assertFalse(abstractRegistry.getRegistered().contains(testUrl));\n    Assertions.assertNull(abstractRegistry.getSubscribed().get(testUrl));\n\n        \n    abstractRegistry.register(testUrl);\n    abstractRegistry.subscribe(testUrl, listener);\n    abstractRegistry.recover();\n        \n    Assertions.assertTrue(abstractRegistry.getRegistered().contains(testUrl));\n    Assertions.assertNotNull(abstractRegistry.getSubscribed().get(testUrl));\n    Assertions.assertTrue(abstractRegistry.getSubscribed().get(testUrl).contains(listener));\n\n}",
        "summary_tokens": [
            "test",
            "method",
            "for",
            "org"
        ]
    },
    {
        "id": 833,
        "code": "public void testNotify() {\n    final AtomicReference<Boolean> notified = new AtomicReference<Boolean>(false);\n    NotifyListener listener1 = urls -> notified.set(Boolean.TRUE);\n    URL url1 = new ServiceConfigURL(\"dubbo\", \"192.168.0.1\", 2200, parametersConsumer);\n    abstractRegistry.subscribe(url1, listener1);\n    NotifyListener listener2 = urls -> notified.set(Boolean.TRUE);\n    URL url2 = new ServiceConfigURL(\"dubbo\", \"192.168.0.2\", 2201, parametersConsumer);\n    abstractRegistry.subscribe(url2, listener2);\n    NotifyListener listener3 = urls -> notified.set(Boolean.TRUE);\n    URL url3 = new ServiceConfigURL(\"dubbo\", \"192.168.0.3\", 2202, parametersConsumer);\n    abstractRegistry.subscribe(url3, listener3);\n    List<URL> urls = new ArrayList<>();\n    urls.add(url1);\n    urls.add(url2);\n    urls.add(url3);\n    abstractRegistry.notify(url1, listener1, urls);\n    Map<URL, Map<String, List<URL>>> map = abstractRegistry.getNotified();\n    MatcherAssert.assertThat(true, Matchers.equalTo(map.containsKey(url1)));\n    MatcherAssert.assertThat(false, Matchers.equalTo(map.containsKey(url2)));\n    MatcherAssert.assertThat(false, Matchers.equalTo(map.containsKey(url3)));\n}",
        "summary_tokens": [
            "test",
            "method",
            "for",
            "org"
        ]
    },
    {
        "id": 834,
        "code": "public void testNotifyArgs() {\n        \n    try {\n        abstractRegistry.notify(null, null, null);\n        Assertions.fail();\n    } catch (Exception e) {\n        Assertions.assertTrue(e instanceof IllegalArgumentException);\n    }\n        \n    try {\n        abstractRegistry.notify(testUrl, null, null);\n        Assertions.fail();\n    } catch (Exception e) {\n        Assertions.assertTrue(e instanceof IllegalArgumentException);\n    }\n        \n    try {\n        abstractRegistry.notify(null, listener, null);\n        Assertions.fail();\n    } catch (Exception e) {\n        Assertions.assertTrue(e instanceof IllegalArgumentException);\n    }\n\n    Assertions.assertFalse(notifySuccess);\n    abstractRegistry.notify(testUrl, listener, null);\n    Assertions.assertFalse(notifySuccess);\n\n    List<URL> urls = new ArrayList<>();\n    urls.add(testUrl);\n        \n    Assertions.assertFalse(notifySuccess);\n    abstractRegistry.notify(testUrl, listener, urls);\n    Assertions.assertTrue(notifySuccess);\n}",
        "summary_tokens": [
            "test",
            "method",
            "for",
            "org"
        ]
    },
    {
        "id": 835,
        "code": "public void testDoRetry() throws Exception {\n\n    final AtomicReference<Boolean> notified = new AtomicReference<Boolean>(false);\n\n        \n    final CountDownLatch latch = new CountDownLatch(2);\n\n    NotifyListener listener = urls -> notified.set(Boolean.TRUE);\n    URL subscribeUrl = serviceUrl.setProtocol(CONSUMER_PROTOCOL).addParameters(CollectionUtils.toStringMap(\"check\", \"false\"));\n    registry = new MockRegistry(registryUrl, serviceUrl, latch);\n    registry.setBad(true);\n    registry.register(serviceUrl);\n    registry.unregister(serviceUrl);\n    registry.subscribe(subscribeUrl, listener);\n    registry.unsubscribe(subscribeUrl, listener);\n\n        \n    assertEquals(false, notified.get());\n    assertEquals(2, latch.getCount());\n\n    registry.setBad(false);\n\n    for (int i = 0; i < 20; i++) {\n        logger.info(\"failback registry retry, times:\" + i);\n            \n        if (latch.getCount() == 0)\n            break;\n        Thread.sleep(sleepTime);\n    }\n    assertEquals(0, latch.getCount());\n        \n    assertEquals(false, notified.get());\n}",
        "summary_tokens": [
            "test",
            "method",
            "for",
            "retry"
        ]
    },
    {
        "id": 836,
        "code": "private void clean() {\n    if (admin) {\n        for (Set<URL> providers : new HashSet<Set<URL>>(received.values())) {\n            for (URL url : new HashSet<URL>(providers)) {\n                if (isExpired(url)) {\n                    if (logger.isWarnEnabled()) {\n                        logger.warn(\"Clean expired provider \" + url);\n                    }\n                    doUnregister(url);\n                }\n            }\n        }\n    }\n}",
        "summary_tokens": [
            "remove",
            "the",
            "expired",
            "providers",
            "only",
            "when",
            "clean",
            "parameter",
            "is",
            "true"
        ]
    },
    {
        "id": 837,
        "code": "public void destroy() {\n    super.destroy();\n    try {\n        ExecutorUtil.cancelScheduledFuture(cleanFuture);\n    } catch (Throwable t) {\n        logger.warn(t.getMessage(), t);\n    }\n    try {\n        multicastSocket.leaveGroup(multicastAddress);\n        multicastSocket.close();\n    } catch (Throwable t) {\n        logger.warn(t.getMessage(), t);\n    }\n    ExecutorUtil.gracefulShutdown(cleanExecutor, cleanPeriod);\n}",
        "summary_tokens": [
            "remove",
            "the",
            "expired",
            "providers",
            "if",
            "clean",
            "is",
            "true",
            "leave",
            "the",
            "multicast",
            "group",
            "and",
            "close",
            "the",
            "multicast",
            "socket"
        ]
    },
    {
        "id": 838,
        "code": "void testUrlError() {\n    Assertions.assertThrows(UnknownHostException.class, () -> {\n        try {\n            URL errorUrl = URL.valueOf(\"multicast://mullticast.local/\");\n            new MulticastRegistry(errorUrl);\n        } catch (IllegalStateException e) {\n            throw e.getCause();\n        }\n    });\n}",
        "summary_tokens": [
            "test",
            "method",
            "for",
            "org"
        ]
    },
    {
        "id": 839,
        "code": "void testAnyHost() {\n    Assertions.assertThrows(IllegalStateException.class, () -> {\n        URL errorUrl = URL.valueOf(\"multicast://0.0.0.0/\");\n        new MulticastRegistry(errorUrl);\n    });\n}",
        "summary_tokens": [
            "test",
            "method",
            "for",
            "org"
        ]
    },
    {
        "id": 840,
        "code": "void testGetCustomPort() {\n    int port = NetUtils.getAvailablePort(20880 + new Random().nextInt(10000));\n    URL customPortUrl = URL.valueOf(\"multicast://239.239.239.239:\" + port);\n    MulticastRegistry multicastRegistry = new MulticastRegistry(customPortUrl);\n    assertThat(multicastRegistry.getUrl().getPort(), is(port));\n}",
        "summary_tokens": [
            "test",
            "method",
            "for",
            "org"
        ]
    },
    {
        "id": 841,
        "code": "void testRegister() {\n    Set<URL> registered;\n        \n    registered = registry.getRegistered();\n    for (URL url : registered) {\n        registry.unregister(url);\n    }\n\n    for (int i = 0; i < 2; i++) {\n        registry.register(serviceUrl);\n        registered = registry.getRegistered();\n        assertTrue(registered.contains(serviceUrl));\n    }\n        \n    registered = registry.getRegistered();\n    assertEquals(1, registered.size());\n}",
        "summary_tokens": [
            "test",
            "method",
            "for",
            "org"
        ]
    },
    {
        "id": 842,
        "code": "void testUnregister() {\n    Set<URL> registered;\n\n        \n    registry.register(serviceUrl);\n    registered = registry.getRegistered();\n    assertTrue(registered.contains(serviceUrl));\n\n        \n    registered = registry.getRegistered();\n    registry.unregister(serviceUrl);\n    assertFalse(registered.contains(serviceUrl));\n}",
        "summary_tokens": [
            "test",
            "method",
            "for",
            "org"
        ]
    },
    {
        "id": 843,
        "code": "void testSubscribe() {\n        \n    final URL[] notifyUrl = new URL[1];\n    for (int i = 0; i < 10; i++) {\n        registry.register(serviceUrl);\n        registry.subscribe(consumerUrl, urls -> {\n            notifyUrl[0] = urls.get(0);\n\n            Map<URL, Set<NotifyListener>> subscribed = registry.getSubscribed();\n            assertEquals(consumerUrl, subscribed.keySet().iterator().next());\n        });\n        if (!EMPTY_PROTOCOL.equalsIgnoreCase(notifyUrl[0].getProtocol())) {\n            break;\n        }\n    }\n    assertEquals(serviceUrl.toFullString(), notifyUrl[0].toFullString());\n}",
        "summary_tokens": [
            "test",
            "method",
            "for",
            "org"
        ]
    },
    {
        "id": 844,
        "code": "void testUnsubscribe() {\n        \n    registry.subscribe(consumerUrl, new NotifyListener() {\n        @Override\n        public void notify(List<URL> urls) {\n                \n        }\n    });\n\n        \n    registry.unsubscribe(consumerUrl, new NotifyListener() {\n        @Override\n        public void notify(List<URL> urls) {\n            Map<URL, Set<NotifyListener>> subscribed = registry.getSubscribed();\n            Set<NotifyListener> listeners = subscribed.get(consumerUrl);\n            assertTrue(listeners.isEmpty());\n\n            Map<URL, Set<URL>> received = registry.getReceived();\n            assertTrue(received.get(consumerUrl).isEmpty());\n        }\n    });\n}",
        "summary_tokens": [
            "test",
            "method",
            "for",
            "org"
        ]
    },
    {
        "id": 845,
        "code": "void testAvailability() {\n    int port = NetUtils.getAvailablePort(20880 + new Random().nextInt(10000));\n    MulticastRegistry registry = new MulticastRegistry(URL.valueOf(\"multicast://224.5.6.8:\" + port));\n    assertTrue(registry.isAvailable());\n}",
        "summary_tokens": [
            "test",
            "method",
            "for",
            "multicast",
            "registry",
            "is",
            "available"
        ]
    },
    {
        "id": 846,
        "code": "void testDestroy() {\n    MulticastSocket socket = registry.getMulticastSocket();\n    assertFalse(socket.isClosed());\n\n        \n    registry.destroy();\n    socket = registry.getMulticastSocket();\n    assertTrue(socket.isClosed());\n}",
        "summary_tokens": [
            "test",
            "method",
            "for",
            "multicast",
            "registry",
            "destroy"
        ]
    },
    {
        "id": 847,
        "code": "void testDefaultPort() {\n    MulticastRegistry multicastRegistry = new MulticastRegistry(URL.valueOf(\"multicast://224.5.6.7\"));\n    try {\n        MulticastSocket multicastSocket = multicastRegistry.getMulticastSocket();\n        Assertions.assertEquals(1234, multicastSocket.getLocalPort());\n    } finally {\n        multicastRegistry.destroy();\n    }\n}",
        "summary_tokens": [
            "test",
            "method",
            "for",
            "org"
        ]
    },
    {
        "id": 848,
        "code": "void testCustomedPort() {\n    int port = NetUtils.getAvailablePort(20880 + new Random().nextInt(10000));\n    MulticastRegistry multicastRegistry = new MulticastRegistry(URL.valueOf(\"multicast://224.5.6.7:\" + port));\n    try {\n        MulticastSocket multicastSocket = multicastRegistry.getMulticastSocket();\n        assertEquals(port, multicastSocket.getLocalPort());\n    } finally {\n        multicastRegistry.destroy();\n    }\n}",
        "summary_tokens": [
            "test",
            "method",
            "for",
            "org"
        ]
    },
    {
        "id": 849,
        "code": "private Set<String> getServiceNames(URL url, NacosAggregateListener listener) {\n    if (isAdminProtocol(url)) {\n        scheduleServiceNamesLookup(url, listener);\n        return getServiceNamesForOps(url);\n    } else {\n        return getServiceNames0(url);\n    }\n}",
        "summary_tokens": [
            "get",
            "the",
            "service",
            "names",
            "from",
            "the",
            "specified",
            "url",
            "url"
        ]
    },
    {
        "id": 850,
        "code": "private boolean isConformRules(String serviceName) {\n    return serviceName.split(NAME_SEPARATOR, -1).length == 4;\n}",
        "summary_tokens": [
            "verify",
            "whether",
            "it",
            "is",
            "a",
            "dubbo",
            "service"
        ]
    },
    {
        "id": 851,
        "code": "private String getLegacySubscribedServiceName(URL url) {\n    StringBuilder serviceNameBuilder = new StringBuilder(DEFAULT_CATEGORY);\n    appendIfPresent(serviceNameBuilder, url, INTERFACE_KEY);\n    appendIfPresent(serviceNameBuilder, url, VERSION_KEY);\n    appendIfPresent(serviceNameBuilder, url, GROUP_KEY);\n    return serviceNameBuilder.toString();\n}",
        "summary_tokens": [
            "get",
            "the",
            "legacy",
            "subscribed",
            "service",
            "name",
            "for",
            "compatible",
            "with",
            "dubbo",
            "0"
        ]
    },
    {
        "id": 852,
        "code": "private Set<String> getServiceNamesForOps(URL url) {\n    Set<String> serviceNames = getAllServiceNames();\n    filterServiceNames(serviceNames, url);\n    return serviceNames;\n}",
        "summary_tokens": [
            "get",
            "the",
            "service",
            "names",
            "for",
            "dubbo",
            "ops"
        ]
    },
    {
        "id": 853,
        "code": "private void notifySubscriber(URL url, String serviceName, NacosAggregateListener listener, Collection<Instance> instances) {\n    List<Instance> enabledInstances = new LinkedList<>(instances);\n    if (enabledInstances.size() > 0) {\n            \n        filterEnabledInstances(enabledInstances);\n    }\n    List<URL> aggregatedUrls = toUrlWithEmpty(url, listener.saveAndAggregateAllInstances(serviceName, enabledInstances));\n    NacosRegistry.this.notify(url, listener.getNotifyListener(), aggregatedUrls);\n}",
        "summary_tokens": [
            "notify",
            "the",
            "enabled",
            "instance",
            "instances",
            "to",
            "subscriber"
        ]
    },
    {
        "id": 854,
        "code": "private List<String> getCategories(URL url) {\n    return ANY_VALUE.equals(url.getServiceInterface()) ?\n        ALL_SUPPORTED_CATEGORIES : Arrays.asList(DEFAULT_CATEGORY);\n}",
        "summary_tokens": [
            "get",
            "the",
            "categories",
            "from",
            "url"
        ]
    },
    {
        "id": 855,
        "code": "public static NacosServiceName valueOf(URL url) {\n    return new NacosServiceName(url);\n}",
        "summary_tokens": [
            "build",
            "an",
            "instance",
            "of",
            "nacos",
            "service",
            "name"
        ]
    },
    {
        "id": 856,
        "code": "public boolean isConcrete() {\n    return isConcrete(serviceInterface) && isConcrete(version) && isConcrete(group);\n}",
        "summary_tokens": [
            "is",
            "the",
            "concrete",
            "service",
            "name",
            "or",
            "not"
        ]
    },
    {
        "id": 857,
        "code": "public static Instance toInstance(ServiceInstance serviceInstance) {\n    Instance instance = new Instance();\n    instance.setServiceName(serviceInstance.getServiceName());\n    instance.setIp(serviceInstance.getHost());\n    instance.setPort(serviceInstance.getPort());\n    instance.setMetadata(serviceInstance.getSortedMetadata());\n    instance.setEnabled(serviceInstance.isEnabled());\n    instance.setHealthy(serviceInstance.isHealthy());\n    return instance;\n}",
        "summary_tokens": [
            "convert",
            "the",
            "service",
            "instance",
            "to",
            "instance"
        ]
    },
    {
        "id": 858,
        "code": "public static ServiceInstance toServiceInstance(URL registryUrl, Instance instance) {\n    DefaultServiceInstance serviceInstance =\n        new DefaultServiceInstance(\n            NamingUtils.getServiceName(instance.getServiceName()),\n            instance.getIp(), instance.getPort(),\n            ScopeModelUtil.getApplicationModel(registryUrl.getScopeModel()));\n    serviceInstance.setMetadata(instance.getMetadata());\n    serviceInstance.setEnabled(instance.isEnabled());\n    serviceInstance.setHealthy(instance.isHealthy());\n    return serviceInstance;\n}",
        "summary_tokens": [
            "convert",
            "the",
            "instance",
            "to",
            "service",
            "instance"
        ]
    },
    {
        "id": 859,
        "code": "public static String getGroup(URL connectionURL) {\n        \n    String group = connectionURL.getParameter(GROUP_KEY, DEFAULT_GROUP);\n    return connectionURL.getParameter(NACOS_GROUP_KEY, group);\n}",
        "summary_tokens": [
            "the",
            "group",
            "of",
            "naming",
            "service",
            "to",
            "register"
        ]
    },
    {
        "id": 860,
        "code": "public static NacosNamingServiceWrapper createNamingService(URL connectionURL) {\n    Properties nacosProperties = buildNacosProperties(connectionURL);\n    NamingService namingService;\n    try {\n        namingService = NacosFactory.createNamingService(nacosProperties);\n    } catch (NacosException e) {\n        if (logger.isErrorEnabled()) {\n            logger.error(e.getErrMsg(), e);\n        }\n        throw new IllegalStateException(e);\n    }\n    return new NacosNamingServiceWrapper(namingService);\n}",
        "summary_tokens": [
            "create",
            "an",
            "instance",
            "of",
            "naming",
            "service",
            "from",
            "specified",
            "url",
            "connection",
            "url"
        ]
    },
    {
        "id": 861,
        "code": "private void fetchLatestAddresses() {\n        \n    Map<URL, Set<NotifyListener>> recoverSubscribed = new HashMap<>(getSubscribed());\n    if (!recoverSubscribed.isEmpty()) {\n        if (logger.isInfoEnabled()) {\n            logger.info(\"Fetching the latest urls of \" + recoverSubscribed.keySet());\n        }\n        for (Map.Entry<URL, Set<NotifyListener>> entry : recoverSubscribed.entrySet()) {\n            URL url = entry.getKey();\n            for (NotifyListener listener : entry.getValue()) {\n                removeFailedSubscribed(url, listener);\n                addFailedSubscribed(url, listener);\n            }\n        }\n    }\n}",
        "summary_tokens": [
            "when",
            "zookeeper",
            "connection",
            "recovered",
            "from",
            "a",
            "connection",
            "loss",
            "it",
            "needs",
            "to",
            "fetch",
            "the",
            "latest",
            "provider",
            "list"
        ]
    },
    {
        "id": 862,
        "code": "default boolean canHandleIdle() {\n    return false;\n}",
        "summary_tokens": [
            "whether",
            "the",
            "implementation",
            "can",
            "sense",
            "and",
            "handle",
            "the",
            "idle",
            "connection"
        ]
    },
    {
        "id": 863,
        "code": "private static SslProvider findSslProvider() {\n    if (OpenSsl.isAvailable()) {\n        logger.debug(\"Using OPENSSL provider.\");\n        return SslProvider.OPENSSL;\n    }\n    if (checkJdkProvider()) {\n        logger.debug(\"Using JDK provider.\");\n        return SslProvider.JDK;\n    }\n    throw new IllegalStateException(\n            \"Could not find any valid TLS provider, please check your dependency or deployment environment, \" +\n                    \"usually netty-tcnative, Conscrypt, or Jetty NPN/ALPN is needed.\");\n}",
        "summary_tokens": [
            "returns",
            "open",
            "ssl",
            "if",
            "available",
            "otherwise",
            "returns",
            "the",
            "jdk",
            "provider"
        ]
    },
    {
        "id": 864,
        "code": "private static void timeoutCheck(DefaultFuture future) {\n    TimeoutCheckTask task = new TimeoutCheckTask(future.getId());\n    future.timeoutCheckTask = TIME_OUT_TIMER.get().newTimeout(task, future.getTimeout(), TimeUnit.MILLISECONDS);\n}",
        "summary_tokens": [
            "check",
            "time",
            "out",
            "of",
            "the",
            "future"
        ]
    },
    {
        "id": 865,
        "code": "public static DefaultFuture newFuture(Channel channel, Request request, int timeout, ExecutorService executor) {\n    final DefaultFuture future = new DefaultFuture(channel, request, timeout);\n    future.setExecutor(executor);\n        \n    if (executor instanceof ThreadlessExecutor) {\n        ((ThreadlessExecutor) executor).setWaitingFuture(future);\n    }\n        \n    timeoutCheck(future);\n    return future;\n}",
        "summary_tokens": [
            "init",
            "a",
            "default",
            "future",
            "0"
        ]
    },
    {
        "id": 866,
        "code": "public static void closeChannel(Channel channel) {\n    for (Map.Entry<Long, Channel> entry : CHANNELS.entrySet()) {\n        if (channel.equals(entry.getValue())) {\n            DefaultFuture future = getFuture(entry.getKey());\n            if (future != null && !future.isDone()) {\n                Response disconnectResponse = new Response(future.getId());\n                disconnectResponse.setStatus(Response.CHANNEL_INACTIVE);\n                disconnectResponse.setErrorMessage(\"Channel \" +\n                    channel + \" is inactive. Directly return the unFinished request : \" +\n                    (logger.isDebugEnabled() ? future.getRequest() : future.getRequest().copyWithoutData()));\n                DefaultFuture.received(channel, disconnectResponse);\n            }\n        }\n    }\n}",
        "summary_tokens": [
            "close",
            "a",
            "channel",
            "when",
            "a",
            "channel",
            "is",
            "inactive",
            "directly",
            "return",
            "the",
            "unfinished",
            "requests"
        ]
    },
    {
        "id": 867,
        "code": "private long calculateLeastDuration(int time) {\n    if (time / HEARTBEAT_CHECK_TICK <= 0) {\n        return LEAST_HEARTBEAT_DURATION;\n    } else {\n        return time / HEARTBEAT_CHECK_TICK;\n    }\n}",
        "summary_tokens": [
            "each",
            "interval",
            "cannot",
            "be",
            "less",
            "than",
            "0",
            "ms"
        ]
    },
    {
        "id": 868,
        "code": "private long calculateLeastDuration(int time) {\n    if (time / HEARTBEAT_CHECK_TICK <= 0) {\n        return LEAST_HEARTBEAT_DURATION;\n    } else {\n        return time / HEARTBEAT_CHECK_TICK;\n    }\n}",
        "summary_tokens": [
            "each",
            "interval",
            "cannot",
            "be",
            "less",
            "than",
            "0",
            "ms"
        ]
    },
    {
        "id": 869,
        "code": "public ChannelHandler getDelegateHandler() {\n    return handler;\n}",
        "summary_tokens": [
            "return",
            "the",
            "final",
            "handler",
            "which",
            "may",
            "have",
            "been",
            "wrapped"
        ]
    },
    {
        "id": 870,
        "code": "public static byte[] getNullBytesOf(Serialization s) {\n    return ID_NULLBYTES_MAP.computeIfAbsent(s.getContentTypeId(), k -> {\n            \n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        byte[] nullBytes = new byte[0];\n        try {\n            ObjectOutput out = s.serialize(null, baos);\n            out.writeObject(null);\n            out.flushBuffer();\n            nullBytes = baos.toByteArray();\n            baos.close();\n        } catch (Exception e) {\n            logger.warn(\"Serialization extension \" + s.getClass().getName() + \" not support serializing null object, return an empty bytes instead.\");\n        }\n        return nullBytes;\n    });\n}",
        "summary_tokens": [
            "get",
            "the",
            "null",
            "object",
            "serialize",
            "result",
            "byte",
            "of",
            "serialization",
            "from",
            "the",
            "cache",
            "if",
            "not",
            "generate",
            "it",
            "first"
        ]
    },
    {
        "id": 871,
        "code": "public static byte[] getPayload(InputStream is) throws IOException {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    byte[] buffer = getBuffer(is.available());\n    int len;\n    while ((len = is.read(buffer)) > -1) {\n        baos.write(buffer, 0, len);\n    }\n    baos.flush();\n    return baos.toByteArray();\n}",
        "summary_tokens": [
            "read",
            "all",
            "payload",
            "to",
            "byte"
        ]
    },
    {
        "id": 872,
        "code": "public static boolean isHeartBeat(byte[] payload, byte proto) {\n    return Arrays.equals(payload, getNullBytesOf(getSerializationById(proto)));\n}",
        "summary_tokens": [
            "check",
            "if",
            "payload",
            "is",
            "null",
            "object",
            "serialize",
            "result",
            "byte",
            "of",
            "serialization"
        ]
    },
    {
        "id": 873,
        "code": "public ExecutorService getPreferredExecutorService(Object msg) {\n    if (msg instanceof Response) {\n        Response response = (Response) msg;\n        DefaultFuture responseFuture = DefaultFuture.getFuture(response.getId());\n            \n        if (responseFuture == null) {\n            return getSharedExecutorService();\n        } else {\n            ExecutorService executor = responseFuture.getExecutor();\n            if (executor == null || executor.isShutdown()) {\n                executor = getSharedExecutorService();\n            }\n            return executor;\n        }\n    } else {\n        return getSharedExecutorService();\n    }\n}",
        "summary_tokens": [
            "currently",
            "this",
            "method",
            "is",
            "mainly",
            "customized",
            "to",
            "facilitate",
            "the",
            "thread",
            "model",
            "on",
            "consumer",
            "side"
        ]
    },
    {
        "id": 874,
        "code": "public ExecutorService getSharedExecutorService() {\n        \n        \n    if (url.getApplicationModel() == null || url.getApplicationModel().isDestroyed()) {\n        return GlobalResourcesRepository.getGlobalExecutorService();\n    }\n\n        \n    ApplicationModel applicationModel = url.getOrDefaultApplicationModel();\n\n    ExecutorRepository executorRepository =\n            applicationModel.getExtensionLoader(ExecutorRepository.class).getDefaultExtension();\n\n    ExecutorService executor = executorRepository.getExecutor(url);\n\n    if (executor == null) {\n        executor = executorRepository.createExecutorIfAbsent(url);\n    }\n\n    return executor;\n}",
        "summary_tokens": [
            "get",
            "the",
            "shared",
            "executor",
            "for",
            "current",
            "server",
            "or",
            "client"
        ]
    },
    {
        "id": 875,
        "code": "public static Object getRequestWithoutData(Object message) {\n    if (logger.isDebugEnabled()) {\n        return message;\n    }\n    if (message instanceof Request) {\n        Request request = (Request) message;\n        request.setData(null);\n        return request;\n    } else if (message instanceof Response) {\n        Response response = (Response) message;\n        response.setResult(null);\n        return response;\n    }\n    return message;\n}",
        "summary_tokens": [
            "only",
            "log",
            "body",
            "in",
            "debugger",
            "mode",
            "for",
            "size",
            "security",
            "consideration"
        ]
    },
    {
        "id": 876,
        "code": "public ZookeeperClient connect(URL url) {\n    ZookeeperClient zookeeperClient;\n        \n    List<String> addressList = getURLBackupAddress(url);\n        \n    if ((zookeeperClient = fetchAndUpdateZookeeperClientCache(addressList)) != null && zookeeperClient.isConnected()) {\n        logger.info(\"find valid zookeeper client from the cache for address: \" + url);\n        return zookeeperClient;\n    }\n        \n    synchronized (zookeeperClientMap) {\n        if ((zookeeperClient = fetchAndUpdateZookeeperClientCache(addressList)) != null && zookeeperClient.isConnected()) {\n            logger.info(\"find valid zookeeper client from the cache for address: \" + url);\n            return zookeeperClient;\n        }\n\n        zookeeperClient = createZookeeperClient(url);\n        logger.info(\"No valid zookeeper client found from cache, therefore create a new client for url. \" + url);\n        writeToClientMap(addressList, zookeeperClient);\n    }\n    return zookeeperClient;\n}",
        "summary_tokens": [
            "share",
            "connect",
            "for",
            "registry",
            "metadata",
            "etc"
        ]
    },
    {
        "id": 877,
        "code": "public ZookeeperClient fetchAndUpdateZookeeperClientCache(List<String> addressList) {\n    ZookeeperClient zookeeperClient = null;\n    for (String address : addressList) {\n        if ((zookeeperClient = zookeeperClientMap.get(address)) != null && zookeeperClient.isConnected()) {\n            break;\n        }\n    }\n        \n    if (zookeeperClient != null && zookeeperClient.isConnected()) {\n        writeToClientMap(addressList, zookeeperClient);\n    }\n    return zookeeperClient;\n}",
        "summary_tokens": [
            "get",
            "the",
            "zookeeper",
            "client",
            "from",
            "cache",
            "the",
            "zookeeper",
            "client",
            "must",
            "be",
            "connected"
        ]
    },
    {
        "id": 878,
        "code": "public List<String> getURLBackupAddress(URL url) {\n    List<String> addressList = new ArrayList<>();\n    addressList.add(url.getAddress());\n    addressList.addAll(url.getParameter(RemotingConstants.BACKUP_KEY, Collections.emptyList()));\n\n    String authPrefix = null;\n    if (StringUtils.isNotEmpty(url.getUsername())) {\n        StringBuilder buf = new StringBuilder();\n        buf.append(url.getUsername());\n        if (StringUtils.isNotEmpty(url.getPassword())) {\n            buf.append(':');\n            buf.append(url.getPassword());\n        }\n        buf.append('@');\n        authPrefix = buf.toString();\n    }\n\n    if (StringUtils.isNotEmpty(authPrefix)) {\n        List<String> authedAddressList = new ArrayList<>(addressList.size());\n        for (String addr : addressList) {\n            authedAddressList.add(authPrefix + addr);\n        }\n        return authedAddressList;\n    }\n\n    return addressList;\n}",
        "summary_tokens": [
            "get",
            "all",
            "zookeeper",
            "urls",
            "such",
            "as",
            "zookeeper",
            "0"
        ]
    },
    {
        "id": 879,
        "code": "void writeToClientMap(List<String> addressList, ZookeeperClient zookeeperClient) {\n    for (String address : addressList) {\n        zookeeperClientMap.put(address, zookeeperClient);\n    }\n}",
        "summary_tokens": [
            "write",
            "address",
            "zookeeper",
            "client",
            "relationship",
            "to",
            "map"
        ]
    },
    {
        "id": 880,
        "code": "URL toClientURL(URL url) {\n    Map<String, String> parameterMap = new HashMap<>();\n        \n    if (url.getParameter(TIMEOUT_KEY) != null) {\n        parameterMap.put(TIMEOUT_KEY, url.getParameter(TIMEOUT_KEY));\n    }\n    if (url.getParameter(RemotingConstants.BACKUP_KEY) != null) {\n        parameterMap.put(RemotingConstants.BACKUP_KEY, url.getParameter(RemotingConstants.BACKUP_KEY));\n    }\n\n    return new ServiceConfigURL(url.getProtocol(), url.getUsername(), url.getPassword(), url.getHost(), url.getPort(),\n            ZookeeperTransporter.class.getName(), parameterMap);\n}",
        "summary_tokens": [
            "redefine",
            "the",
            "url",
            "for",
            "zookeeper"
        ]
    },
    {
        "id": 881,
        "code": "public void timeoutNotSend() throws Exception {\n    final DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");\n    System.out.println(\"before a future is create , time is : \" + LocalDateTime.now().format(formatter));\n        \n    DefaultFuture f = defaultFuture(5000);\n    while (!f.isDone()) {\n            \n        Thread.sleep(100);\n    }\n    System.out.println(\"after a future is timeout , time is : \" + LocalDateTime.now().format(formatter));\n\n        \n    try {\n        f.get();\n    } catch (Exception e) {\n        Assertions.assertTrue(e.getCause() instanceof TimeoutException, \"catch exception is not timeout exception!\");\n        System.out.println(e.getMessage());\n    }\n}",
        "summary_tokens": [
            "for",
            "example",
            "it",
            "will",
            "print",
            "like",
            "this",
            "before",
            "a",
            "future",
            "is",
            "create",
            "time",
            "is",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "after",
            "a",
            "future",
            "is",
            "timeout",
            "time",
            "is",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "p",
            "the",
            "exception",
            "info",
            "print",
            "like",
            "sending",
            "request",
            "timeout",
            "in",
            "client",
            "side",
            "by",
            "scan",
            "timer"
        ]
    },
    {
        "id": 882,
        "code": "public void timeoutSend() throws Exception {\n    final DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");\n    System.out.println(\"before a future is create , time is : \" + LocalDateTime.now().format(formatter));\n        \n    Channel channel = new MockedChannel();\n    Request request = new Request(10);\n    DefaultFuture f = DefaultFuture.newFuture(channel, request, 5000, null);\n        \n    DefaultFuture.sent(channel, request);\n    while (!f.isDone()) {\n            \n        Thread.sleep(100);\n    }\n    System.out.println(\"after a future is timeout , time is : \" + LocalDateTime.now().format(formatter));\n\n        \n    try {\n        f.get();\n    } catch (Exception e) {\n        Assertions.assertTrue(e.getCause() instanceof TimeoutException, \"catch exception is not timeout exception!\");\n        System.out.println(e.getMessage());\n    }\n}",
        "summary_tokens": [
            "for",
            "example",
            "it",
            "will",
            "print",
            "like",
            "this",
            "before",
            "a",
            "future",
            "is",
            "create",
            "time",
            "is",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "after",
            "a",
            "future",
            "is",
            "timeout",
            "time",
            "is",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "p",
            "the",
            "exception",
            "info",
            "print",
            "like",
            "waiting",
            "server",
            "side",
            "response",
            "timeout",
            "by",
            "scan",
            "timer"
        ]
    },
    {
        "id": 883,
        "code": "public void interruptSend() throws Exception {\n    final DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");\n    System.out.println(\"before a future is create , time is : \" + LocalDateTime.now().format(formatter));\n        \n    Channel channel = new MockedChannel();\n    int channelId = 10;\n    Request request = new Request(channelId);\n    ExecutorService sharedExecutor = ExtensionLoader.getExtensionLoader(ExecutorRepository.class)\n            .getDefaultExtension().createExecutorIfAbsent(URL.valueOf(\"dubbo://127.0.0.1:23456\"));\n    ThreadlessExecutor executor = new ThreadlessExecutor();\n    DefaultFuture f = DefaultFuture.newFuture(channel, request, 1000, executor);\n        \n    DefaultFuture.sent(channel, request);\n        \n    try {\n        new InterruptThread(Thread.currentThread()).start();\n        executor.waitAndDrain();\n        f.get();\n    } catch (Exception e) {\n        Assertions.assertTrue(e instanceof InterruptedException, \"catch exception is not interrupted exception!\");\n        System.out.println(e.getMessage());\n    }\n        \n    Thread.sleep(1500);\n    System.out.println(\"after a future is timeout , time is : \" + LocalDateTime.now().format(formatter));\n\n    DefaultFuture future = DefaultFuture.getFuture(channelId);\n        \n    Assertions.assertNull(future);\n}",
        "summary_tokens": [
            "for",
            "example",
            "it",
            "will",
            "print",
            "like",
            "this",
            "before",
            "a",
            "future",
            "is",
            "created",
            "time",
            "is",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "null",
            "after",
            "a",
            "future",
            "is",
            "timeout",
            "time",
            "is",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0"
        ]
    },
    {
        "id": 884,
        "code": "private DefaultFuture defaultFuture(int timeout) {\n    Channel channel = new MockedChannel();\n    Request request = new Request(index.getAndIncrement());\n    return DefaultFuture.newFuture(channel, request, timeout, null);\n}",
        "summary_tokens": [
            "mock",
            "a",
            "default",
            "future"
        ]
    },
    {
        "id": 885,
        "code": "public void testReceivedEventInvokeDirect() throws RemotingException {\n    handler = new ConnectionOrderedChannelHandler(new BizChannelHandler(false), url);\n    ThreadPoolExecutor executor = (ThreadPoolExecutor) getField(handler, \"SHARED_EXECUTOR\", 1);\n    executor.shutdown();\n    executor = (ThreadPoolExecutor) getField(handler, \"executor\", 1);\n    executor.shutdown();\n    Request req = new Request();\n    req.setHeartbeat(true);\n    final AtomicInteger count = new AtomicInteger(0);\n    handler.received(new MockedChannel() {\n        @Override\n        public void send(Object message) throws RemotingException {\n            Assertions.assertTrue(((Response) message).isHeartbeat(), \"response.heartbeat\");\n            count.incrementAndGet();\n        }\n    }, req);\n    Assertions.assertEquals(1, count.get(), \"channel.send must be invoke\");\n}",
        "summary_tokens": [
            "events",
            "do",
            "not",
            "pass",
            "through",
            "the",
            "thread",
            "pool",
            "and",
            "execute",
            "directly",
            "on",
            "the",
            "io"
        ]
    },
    {
        "id": 886,
        "code": "public void testToList() {\n    List<List<String>> table = new LinkedList<>();\n    table.add(Arrays.asList(\"abc\",\"abc\",\"abc\"));\n    table.add(Arrays.asList(\"1\",\"2\",\"3\"));\n    table.add(Arrays.asList(\"x\",\"y\",\"z\"));\n\n    String toList = TelnetUtils.toList(table);\n\n    Assertions.assertTrue(toList.contains(\"abc - abc - abc\"));\n    Assertions.assertTrue(toList.contains(\"1   - 2   - 3\"));\n    Assertions.assertTrue(toList.contains(\"x   - y   - z\"));\n}",
        "summary_tokens": [
            "abc",
            "abc",
            "abc",
            "0",
            "0",
            "0",
            "x",
            "y",
            "z"
        ]
    },
    {
        "id": 887,
        "code": "public void testToTable() {\n    List<List<String>> table = new LinkedList<>();\n    table.add(Arrays.asList(\"abc\",\"abc\",\"abc\"));\n    table.add(Arrays.asList(\"1\",\"2\",\"3\"));\n    table.add(Arrays.asList(\"x\",\"y\",\"z\"));\n\n    String toTable = TelnetUtils.toTable(new String[]{\"A\",\"B\",\"C\"},table);\n\n    Assertions.assertTrue(toTable.contains(\"| A   | B   | C   |\"));\n    Assertions.assertTrue(toTable.contains(\"| abc | abc | abc |\"));\n    Assertions.assertTrue(toTable.contains(\"| 1   | 2   | 3   |\"));\n    Assertions.assertTrue(toTable.contains(\"| x   | y   | z   |\"));\n}",
        "summary_tokens": [
            "a",
            "b",
            "c",
            "abc",
            "abc",
            "abc",
            "0",
            "0",
            "0",
            "x",
            "y",
            "z"
        ]
    },
    {
        "id": 888,
        "code": "public boolean canHandleIdle() {\n    return false;\n}",
        "summary_tokens": [
            "following",
            "methods",
            "are",
            "extended",
            "from",
            "remoting",
            "server",
            "useless",
            "for",
            "http",
            "servers"
        ]
    },
    {
        "id": 889,
        "code": "static NettyChannel getOrAddChannel(Channel ch, URL url, ChannelHandler handler) {\n    if (ch == null) {\n        return null;\n    }\n    NettyChannel ret = CHANNEL_MAP.get(ch);\n    if (ret == null) {\n        NettyChannel nettyChannel = new NettyChannel(ch, url, handler);\n        if (ch.isActive()) {\n            nettyChannel.markActive(true);\n            ret = CHANNEL_MAP.putIfAbsent(ch, nettyChannel);\n        }\n        if (ret == null) {\n            ret = nettyChannel;\n        }\n    }\n    return ret;\n}",
        "summary_tokens": [
            "get",
            "dubbo",
            "channel",
            "by",
            "netty",
            "channel",
            "through",
            "channel",
            "cache"
        ]
    },
    {
        "id": 890,
        "code": "static void removeChannelIfDisconnected(Channel ch) {\n    if (ch != null && !ch.isActive()) {\n        NettyChannel nettyChannel = CHANNEL_MAP.remove(ch);\n        if (nettyChannel != null) {\n            nettyChannel.markActive(false);\n        }\n    }\n}",
        "summary_tokens": [
            "remove",
            "the",
            "inactive",
            "channel"
        ]
    },
    {
        "id": 891,
        "code": "public void send(Object message, boolean sent) throws RemotingException {\n        \n    super.send(message, sent);\n\n    boolean success = true;\n    int timeout = 0;\n    try {\n        ChannelFuture future = channel.writeAndFlush(message);\n        if (sent) {\n                \n            timeout = getUrl().getPositiveParameter(TIMEOUT_KEY, DEFAULT_TIMEOUT);\n            success = future.await(timeout);\n        }\n        Throwable cause = future.cause();\n        if (cause != null) {\n            throw cause;\n        }\n    } catch (Throwable e) {\n        removeChannelIfDisconnected(channel);\n        throw new RemotingException(this, \"Failed to send message \" + PayloadDropper.getRequestWithoutData(message) + \" to \" + getRemoteAddress() + \", cause: \" + e.getMessage(), e);\n    }\n    if (!success) {\n        throw new RemotingException(this, \"Failed to send message \" + PayloadDropper.getRequestWithoutData(message) + \" to \" + getRemoteAddress()\n                + \"in timeout(\" + timeout + \"ms) limit\");\n    }\n}",
        "summary_tokens": [
            "send",
            "message",
            "by",
            "netty",
            "and",
            "whether",
            "to",
            "wait",
            "the",
            "completion",
            "of",
            "the",
            "send"
        ]
    },
    {
        "id": 892,
        "code": "private static Response buildErrorResponse(Request request, Throwable t) {\n    Response response = new Response(request.getId(), request.getVersion());\n    response.setStatus(Response.BAD_REQUEST);\n    response.setErrorMessage(StringUtils.toString(t));\n    return response;\n}",
        "summary_tokens": [
            "build",
            "a",
            "bad",
            "request",
            "s",
            "response"
        ]
    },
    {
        "id": 893,
        "code": "protected void doOpen() throws Throwable {\n    bootstrap = new ServerBootstrap();\n\n    bossGroup = createBossGroup();\n    workerGroup = createWorkerGroup();\n\n    final NettyServerHandler nettyServerHandler = createNettyServerHandler();\n    channels = nettyServerHandler.getChannels();\n\n    initServerBootstrap(nettyServerHandler);\n\n        \n    ChannelFuture channelFuture = bootstrap.bind(getBindAddress());\n    channelFuture.syncUninterruptibly();\n    channel = channelFuture.channel();\n\n}",
        "summary_tokens": [
            "init",
            "and",
            "start",
            "netty",
            "server"
        ]
    },
    {
        "id": 894,
        "code": "static FormattingTuple format(final String messagePattern,\n                              Object argA, Object argB) {\n    return arrayFormat(messagePattern, new Object[]{argA, argB});\n}",
        "summary_tokens": [
            "performs",
            "a",
            "two",
            "argument",
            "substitution",
            "for",
            "the",
            "message",
            "pattern",
            "passed",
            "as",
            "parameter"
        ]
    },
    {
        "id": 895,
        "code": "static FormattingTuple arrayFormat(final String messagePattern,\n                                   final Object[] argArray) {\n\n    Throwable throwableCandidate = getThrowableCandidate(argArray);\n\n    if (messagePattern == null) {\n        return new FormattingTuple(null, argArray, throwableCandidate);\n    }\n\n    if (argArray == null) {\n        return new FormattingTuple(messagePattern);\n    }\n\n    int i = 0;\n    int j;\n    StringBuffer sbuf = new StringBuffer(messagePattern.length() + 50);\n\n    int l;\n    for (l = 0; l < argArray.length; l++) {\n\n        j = messagePattern.indexOf(DELIM_STR, i);\n\n        if (j == -1) {\n                \n            if (i == 0) { \n                return new FormattingTuple(messagePattern, argArray,\n                        throwableCandidate);\n            } else { \n                    \n                sbuf.append(messagePattern.substring(i));\n                return new FormattingTuple(sbuf.toString(), argArray,\n                        throwableCandidate);\n            }\n        } else {\n            if (isEscapedDelimeter(messagePattern, j)) {\n                if (!isDoubleEscaped(messagePattern, j)) {\n                    l--; \n                    sbuf.append(messagePattern, i, j - 1);\n                    sbuf.append(DELIM_START);\n                    i = j + 1;\n                } else {\n                        \n                        \n                        \n                    sbuf.append(messagePattern, i, j - 1);\n                    deeplyAppendParameter(sbuf, argArray[l], new HashMap<Object[], Void>());\n                    i = j + 2;\n                }\n            } else {\n                    \n                sbuf.append(messagePattern, i, j);\n                deeplyAppendParameter(sbuf, argArray[l], new HashMap<Object[], Void>());\n                i = j + 2;\n            }\n        }\n    }\n        \n    sbuf.append(messagePattern.substring(i));\n    if (l < argArray.length - 1) {\n        return new FormattingTuple(sbuf.toString(), argArray, throwableCandidate);\n    } else {\n        return new FormattingTuple(sbuf.toString(), argArray, null);\n    }\n}",
        "summary_tokens": [
            "same",
            "principle",
            "as",
            "the",
            "format",
            "string",
            "object",
            "and",
            "format",
            "string",
            "object",
            "object",
            "methods",
            "except",
            "that",
            "any",
            "number",
            "of",
            "arguments",
            "can",
            "be",
            "passed",
            "in",
            "an",
            "array"
        ]
    },
    {
        "id": 896,
        "code": "CuratorFramework getClient() {\n    return client;\n}",
        "summary_tokens": [
            "just",
            "for",
            "unit",
            "test"
        ]
    },
    {
        "id": 897,
        "code": "CuratorFramework getClient() {\n    return client;\n}",
        "summary_tokens": [
            "just",
            "for",
            "unit",
            "test"
        ]
    },
    {
        "id": 898,
        "code": "public void setAttachments(Map<String, String> map) {\n    this.attachments = map == null ? new HashMap<>() : new HashMap<>(map);\n}",
        "summary_tokens": [
            "append",
            "all",
            "items",
            "from",
            "the",
            "map",
            "into",
            "the",
            "attachment",
            "if",
            "map",
            "is",
            "empty",
            "then",
            "nothing",
            "happens"
        ]
    },
    {
        "id": 899,
        "code": "public Object getValue() {\n    return getAppResponse().getValue();\n}",
        "summary_tokens": [
            "notice",
            "the",
            "return",
            "type",
            "of",
            "get",
            "value",
            "is",
            "the",
            "actual",
            "type",
            "of",
            "the",
            "rpc",
            "method",
            "not",
            "app",
            "response"
        ]
    },
    {
        "id": 900,
        "code": "public void setValue(Object value) {\n    try {\n        if (responseFuture.isDone()) {\n            responseFuture.get().setValue(value);\n        } else {\n            AppResponse appResponse = new AppResponse(invocation);\n            appResponse.setValue(value);\n            responseFuture.complete(appResponse);\n        }\n    } catch (Exception e) {\n            \n        logger.error(\"Got exception when trying to fetch the underlying result from AsyncRpcResult.\");\n        throw new RpcException(e);\n    }\n}",
        "summary_tokens": [
            "completable",
            "future",
            "can",
            "only",
            "be",
            "completed",
            "once",
            "so",
            "try",
            "to",
            "update",
            "the",
            "result",
            "of",
            "one",
            "completed",
            "completable",
            "future",
            "will",
            "have",
            "no",
            "effect"
        ]
    },
    {
        "id": 901,
        "code": "public Result get() throws InterruptedException, ExecutionException {\n    if (executor != null && executor instanceof ThreadlessExecutor) {\n        ThreadlessExecutor threadlessExecutor = (ThreadlessExecutor) executor;\n        threadlessExecutor.waitAndDrain();\n    }\n    return responseFuture.get();\n}",
        "summary_tokens": [
            "this",
            "method",
            "will",
            "always",
            "return",
            "after",
            "a",
            "maximum",
            "timeout",
            "waiting",
            "0"
        ]
    },
    {
        "id": 902,
        "code": "public static AsyncRpcResult newDefaultAsyncResult(AppResponse appResponse, Invocation invocation) {\n    return new AsyncRpcResult(CompletableFuture.completedFuture(appResponse), invocation);\n}",
        "summary_tokens": [
            "some",
            "utility",
            "methods",
            "used",
            "to",
            "quickly",
            "generate",
            "default",
            "async",
            "rpc",
            "result",
            "instance"
        ]
    },
    {
        "id": 903,
        "code": "default List<ProtocolServer> getServers() {\n    return Collections.emptyList();\n}",
        "summary_tokens": [
            "get",
            "all",
            "servers",
            "serving",
            "this",
            "protocol"
        ]
    },
    {
        "id": 904,
        "code": "public static RpcContextAttachment getServerContext() {\n    return SERVER_LOCAL.get();\n}",
        "summary_tokens": [
            "get",
            "server",
            "side",
            "context"
        ]
    },
    {
        "id": 905,
        "code": "public static void removeServerContext() {\n    SERVER_LOCAL.remove();\n}",
        "summary_tokens": [
            "remove",
            "server",
            "side",
            "context"
        ]
    },
    {
        "id": 906,
        "code": "public static RpcContextAttachment getClientAttachment() {\n    return CLIENT_ATTACHMENT.get();\n}",
        "summary_tokens": [
            "get",
            "consumer",
            "side",
            "attachment",
            "a",
            "b",
            "in",
            "a",
            "side"
        ]
    },
    {
        "id": 907,
        "code": "public static RpcContextAttachment getServerAttachment() {\n    return SERVER_ATTACHMENT.get();\n}",
        "summary_tokens": [
            "get",
            "provider",
            "side",
            "attachment",
            "from",
            "consumer",
            "a",
            "b",
            "in",
            "b",
            "side"
        ]
    },
    {
        "id": 908,
        "code": "public static RpcServiceContext getServiceContext() {\n    return SERVICE_CONTEXT.get();\n}",
        "summary_tokens": [
            "using",
            "to",
            "pass",
            "environment",
            "parameters",
            "in",
            "the",
            "whole",
            "invocation"
        ]
    },
    {
        "id": 909,
        "code": "public static void removeContext() {\n    if (CLIENT_ATTACHMENT.get().canRemove()) {\n        CLIENT_ATTACHMENT.remove();\n    }\n    if (SERVER_ATTACHMENT.get().canRemove()) {\n        SERVER_ATTACHMENT.remove();\n    }\n    SERVER_LOCAL.remove();\n    SERVICE_CONTEXT.remove();\n    CANCELLATION_CONTEXT.remove();\n}",
        "summary_tokens": [
            "customized",
            "for",
            "internal",
            "use"
        ]
    },
    {
        "id": 910,
        "code": "public <T> T getRequest(Class<T> clazz) {\n    return SERVICE_CONTEXT.get().getRequest(clazz);\n}",
        "summary_tokens": [
            "get",
            "the",
            "request",
            "object",
            "of",
            "the",
            "underlying",
            "rpc",
            "protocol",
            "e"
        ]
    },
    {
        "id": 911,
        "code": "public <T> T getResponse(Class<T> clazz) {\n    return SERVICE_CONTEXT.get().getResponse(clazz);\n}",
        "summary_tokens": [
            "get",
            "the",
            "response",
            "object",
            "of",
            "the",
            "underlying",
            "rpc",
            "protocol",
            "e"
        ]
    },
    {
        "id": 912,
        "code": "public String getLocalHostName() {\n    return SERVICE_CONTEXT.get().getLocalHostName();\n}",
        "summary_tokens": [
            "get",
            "local",
            "host",
            "name"
        ]
    },
    {
        "id": 913,
        "code": "public String getRemoteAddressString() {\n    return SERVICE_CONTEXT.get().getRemoteAddressString();\n}",
        "summary_tokens": [
            "get",
            "remote",
            "address",
            "string"
        ]
    },
    {
        "id": 914,
        "code": "public String getRemoteHostName() {\n    return SERVICE_CONTEXT.get().getRemoteHostName();\n}",
        "summary_tokens": [
            "get",
            "remote",
            "host",
            "name"
        ]
    },
    {
        "id": 915,
        "code": "public String getAttachment(String key) {\n    String client = CLIENT_ATTACHMENT.get().getAttachment(key);\n    if (StringUtils.isEmpty(client)) {\n        return SERVER_ATTACHMENT.get().getAttachment(key);\n    }\n    return client;\n}",
        "summary_tokens": [
            "also",
            "see",
            "get",
            "object",
            "attachment",
            "string"
        ]
    },
    {
        "id": 916,
        "code": "public boolean isServerSide() {\n    return SERVICE_CONTEXT.get().isServerSide();\n}",
        "summary_tokens": [
            "replace",
            "to",
            "is",
            "provider",
            "side"
        ]
    },
    {
        "id": 917,
        "code": "public boolean isClientSide() {\n    return SERVICE_CONTEXT.get().isClientSide();\n}",
        "summary_tokens": [
            "replace",
            "to",
            "is",
            "consumer",
            "side"
        ]
    },
    {
        "id": 918,
        "code": "public List<Invoker<?>> getInvokers() {\n    return SERVICE_CONTEXT.get().getInvokers();\n}",
        "summary_tokens": [
            "replace",
            "to",
            "get",
            "urls"
        ]
    },
    {
        "id": 919,
        "code": "public Invoker<?> getInvoker() {\n    return SERVICE_CONTEXT.get().getInvoker();\n}",
        "summary_tokens": [
            "replace",
            "to",
            "get",
            "url"
        ]
    },
    {
        "id": 920,
        "code": "public Invocation getInvocation() {\n    return SERVICE_CONTEXT.get().getInvocation();\n}",
        "summary_tokens": [
            "replace",
            "to",
            "get",
            "method",
            "name",
            "get",
            "parameter",
            "types",
            "get",
            "arguments"
        ]
    },
    {
        "id": 921,
        "code": "public void asyncCall(Runnable runnable) {\n    SERVICE_CONTEXT.get().asyncCall(runnable);\n}",
        "summary_tokens": [
            "one",
            "way",
            "async",
            "call",
            "send",
            "request",
            "only",
            "and",
            "result",
            "is",
            "not",
            "required"
        ]
    },
    {
        "id": 922,
        "code": "public String getAttachment(String key) {\n    Object value = attachments.get(key);\n    if (value instanceof String) {\n        return (String) value;\n    }\n    return null; \n}",
        "summary_tokens": [
            "also",
            "see",
            "get",
            "object",
            "attachment",
            "string"
        ]
    },
    {
        "id": 923,
        "code": "public RpcContextAttachment copyOf(boolean needCopy) {\n    if (!isValid()) {\n        return null;\n    }\n\n    if (needCopy) {\n        RpcContextAttachment copy = new RpcContextAttachment();\n        if (CollectionUtils.isNotEmptyMap(attachments)) {\n            copy.attachments.putAll(this.attachments);\n        }\n        if (asyncContext != null) {\n            copy.asyncContext = this.asyncContext;\n        }\n        return copy;\n    } else {\n        return this;\n    }\n}",
        "summary_tokens": [
            "also",
            "see",
            "rpc",
            "service",
            "context",
            "copy",
            "of",
            "boolean"
        ]
    },
    {
        "id": 924,
        "code": "public <T> T getRequest(Class<T> clazz) {\n    return (request != null && clazz.isAssignableFrom(request.getClass())) ? (T) request : null;\n}",
        "summary_tokens": [
            "get",
            "the",
            "request",
            "object",
            "of",
            "the",
            "underlying",
            "rpc",
            "protocol",
            "e"
        ]
    },
    {
        "id": 925,
        "code": "public <T> T getResponse(Class<T> clazz) {\n    return (response != null && clazz.isAssignableFrom(response.getClass())) ? (T) response : null;\n}",
        "summary_tokens": [
            "get",
            "the",
            "response",
            "object",
            "of",
            "the",
            "underlying",
            "rpc",
            "protocol",
            "e"
        ]
    },
    {
        "id": 926,
        "code": "public String getLocalHostName() {\n    String host = localAddress == null ? null : localAddress.getHostName();\n    if (StringUtils.isEmpty(host)) {\n        return getLocalHost();\n    }\n    return host;\n}",
        "summary_tokens": [
            "get",
            "local",
            "host",
            "name"
        ]
    },
    {
        "id": 927,
        "code": "public String getRemoteAddressString() {\n    return getRemoteHost() + \":\" + getRemotePort();\n}",
        "summary_tokens": [
            "get",
            "remote",
            "address",
            "string"
        ]
    },
    {
        "id": 928,
        "code": "public String getRemoteHostName() {\n    return remoteAddress == null ? null : remoteAddress.getHostName();\n}",
        "summary_tokens": [
            "get",
            "remote",
            "host",
            "name"
        ]
    },
    {
        "id": 929,
        "code": "public boolean isServerSide() {\n    return isProviderSide();\n}",
        "summary_tokens": [
            "replace",
            "to",
            "is",
            "provider",
            "side"
        ]
    },
    {
        "id": 930,
        "code": "public boolean isClientSide() {\n    return isConsumerSide();\n}",
        "summary_tokens": [
            "replace",
            "to",
            "is",
            "consumer",
            "side"
        ]
    },
    {
        "id": 931,
        "code": "public List<Invoker<?>> getInvokers() {\n    return invokers == null && invoker != null ? (List) Arrays.asList(invoker) : invokers;\n}",
        "summary_tokens": [
            "replace",
            "to",
            "get",
            "urls"
        ]
    },
    {
        "id": 932,
        "code": "public Invoker<?> getInvoker() {\n    return invoker;\n}",
        "summary_tokens": [
            "replace",
            "to",
            "get",
            "url"
        ]
    },
    {
        "id": 933,
        "code": "public Invocation getInvocation() {\n    return invocation;\n}",
        "summary_tokens": [
            "replace",
            "to",
            "get",
            "method",
            "name",
            "get",
            "parameter",
            "types",
            "get",
            "arguments"
        ]
    },
    {
        "id": 934,
        "code": "public void asyncCall(Runnable runnable) {\n    try {\n        setAttachment(RETURN_KEY, Boolean.FALSE.toString());\n        runnable.run();\n    } catch (Throwable e) {\n            \n        throw new RpcException(\"oneway call error .\" + e.getMessage(), e);\n    } finally {\n        removeAttachment(RETURN_KEY);\n    }\n}",
        "summary_tokens": [
            "one",
            "way",
            "async",
            "call",
            "send",
            "request",
            "only",
            "and",
            "result",
            "is",
            "not",
            "required"
        ]
    },
    {
        "id": 935,
        "code": "public RpcServiceContext copyOf(boolean needCopy) {\n    if (needCopy) {\n        RpcServiceContext copy = new RpcServiceContext();\n        copy.arguments = this.arguments;\n        copy.consumerUrl = this.consumerUrl;\n        copy.invocation = this.invocation;\n        copy.invokers = this.invokers;\n        copy.invoker = this.invoker;\n        copy.localAddress = this.localAddress;\n        copy.methodName = this.methodName;\n        copy.needPrintRouterSnapshot = this.needPrintRouterSnapshot;\n        copy.parameterTypes = this.parameterTypes;\n        copy.remoteAddress = this.remoteAddress;\n        copy.remoteApplicationName = this.remoteApplicationName;\n        copy.request = this.request;\n        copy.response = this.response;\n        copy.url = this.url;\n        copy.urls = this.urls;\n        return copy;\n    } else {\n        return this;\n    }\n}",
        "summary_tokens": [
            "only",
            "part",
            "of",
            "the",
            "properties",
            "are",
            "copied",
            "the",
            "others",
            "are",
            "either",
            "not",
            "used",
            "currently",
            "or",
            "can",
            "be",
            "got",
            "from",
            "invocation"
        ]
    },
    {
        "id": 936,
        "code": "public static RpcStatus getStatus(URL url, String methodName) {\n    String uri = url.toIdentityString();\n    ConcurrentMap<String, RpcStatus> map = METHOD_STATISTICS.computeIfAbsent(uri, k -> new ConcurrentHashMap<>());\n    return map.computeIfAbsent(methodName, k -> new RpcStatus());\n}",
        "summary_tokens": [
            "url",
            "method",
            "name",
            "status"
        ]
    },
    {
        "id": 937,
        "code": "public long getFailedAverageElapsed() {\n    long failed = getFailed();\n    if (failed == 0) {\n        return 0;\n    }\n    return getFailedElapsed() / failed;\n}",
        "summary_tokens": [
            "get",
            "failed",
            "average",
            "elapsed"
        ]
    },
    {
        "id": 938,
        "code": "public long getFailedMaxElapsed() {\n    return failedMaxElapsed.get();\n}",
        "summary_tokens": [
            "get",
            "failed",
            "max",
            "elapsed"
        ]
    },
    {
        "id": 939,
        "code": "public long getSucceededAverageElapsed() {\n    long succeeded = getSucceeded();\n    if (succeeded == 0) {\n        return 0;\n    }\n    return getSucceededElapsed() / succeeded;\n}",
        "summary_tokens": [
            "get",
            "succeeded",
            "average",
            "elapsed"
        ]
    },
    {
        "id": 940,
        "code": "public long getSucceededMaxElapsed() {\n    return succeededMaxElapsed.get();\n}",
        "summary_tokens": [
            "get",
            "succeeded",
            "max",
            "elapsed"
        ]
    },
    {
        "id": 941,
        "code": "public long getAverageTps() {\n    if (getTotalElapsed() >= 1000L) {\n        return getTotal() / (getTotalElapsed() / 1000L);\n    }\n    return getTotal();\n}",
        "summary_tokens": [
            "calculate",
            "average",
            "tps",
            "transaction",
            "per",
            "second"
        ]
    },
    {
        "id": 942,
        "code": "public static TriRpcStatus getStatus(Throwable throwable) {\n    return getStatus(throwable, null);\n}",
        "summary_tokens": [
            "todo",
            "the",
            "remaining",
            "exceptions",
            "are",
            "converted",
            "to",
            "status"
        ]
    },
    {
        "id": 943,
        "code": "public Result invoke(Invoker<?> invoker, Invocation inv) throws RpcException {\n    if (scheduled.compareAndSet(false, true)) {\n        inv.getModuleModel().getApplicationModel().getFrameworkModel().getBeanFactory()\n            .getBean(FrameworkExecutorRepository.class).getSharedScheduledExecutor()\n            .scheduleWithFixedDelay(this::writeLogToFile, LOG_OUTPUT_INTERVAL, LOG_OUTPUT_INTERVAL, TimeUnit.MILLISECONDS);\n    }\n    Optional<AccessLogData> optionalAccessLogData = Optional.empty();\n    String accessLogKey = null;\n    try {\n        accessLogKey = invoker.getUrl().getParameter(Constants.ACCESS_LOG_KEY);\n        if (ConfigUtils.isNotEmpty(accessLogKey)) {\n            optionalAccessLogData = Optional.of(buildAccessLogData(invoker, inv));\n        }\n    } catch (Throwable t) {\n        logger.warn(\"Exception in AccessLogFilter of service(\" + invoker + \" -> \" + inv + \")\", t);\n    }\n    try {\n        return invoker.invoke(inv);\n    } finally {\n        String finalAccessLogKey = accessLogKey;\n        optionalAccessLogData.ifPresent(logData -> {\n            logData.setOutTime(new Date());\n            log(finalAccessLogKey, logData);\n        });\n    }\n}",
        "summary_tokens": [
            "this",
            "method",
            "logs",
            "the",
            "access",
            "log",
            "for",
            "service",
            "method",
            "invocation",
            "call"
        ]
    },
    {
        "id": 944,
        "code": "public void afterUnExport() {\n}",
        "summary_tokens": [
            "subclasses",
            "need",
            "to",
            "override",
            "this",
            "method",
            "to",
            "destroy",
            "resources"
        ]
    },
    {
        "id": 945,
        "code": "public static AccessLogData newLogData() {\n    return new AccessLogData();\n}",
        "summary_tokens": [
            "get",
            "new",
            "instance",
            "of",
            "log",
            "data"
        ]
    },
    {
        "id": 946,
        "code": "public void setInvocationTime(Date invocationTime) {\n    set(INVOCATION_TIME, invocationTime);\n}",
        "summary_tokens": [
            "set",
            "the",
            "invocation",
            "date"
        ]
    },
    {
        "id": 947,
        "code": "public void setOutTime(Date outTime) {\n    set(OUT_TIME, outTime);\n}",
        "summary_tokens": [
            "set",
            "the",
            "out",
            "date"
        ]
    },
    {
        "id": 948,
        "code": "private void setRemoteHost(String remoteHost) {\n    set(REMOTE_HOST, remoteHost);\n}",
        "summary_tokens": [
            "set",
            "caller",
            "remote",
            "host"
        ]
    },
    {
        "id": 949,
        "code": "private void setRemotePort(Integer remotePort) {\n    set(REMOTE_PORT, remotePort);\n}",
        "summary_tokens": [
            "set",
            "caller",
            "remote",
            "port"
        ]
    },
    {
        "id": 950,
        "code": "private void setLocalPort(Integer localPort) {\n    set(LOCAL_PORT, localPort);\n}",
        "summary_tokens": [
            "set",
            "local",
            "port",
            "of",
            "exported",
            "service"
        ]
    },
    {
        "id": 951,
        "code": "public void setMethodName(String methodName) {\n    set(METHOD_NAME, methodName);\n}",
        "summary_tokens": [
            "set",
            "target",
            "method",
            "name"
        ]
    },
    {
        "id": 952,
        "code": "public void setTypes(Class[] types) {\n    set(TYPES, types != null ? Arrays.copyOf(types, types.length) : null);\n}",
        "summary_tokens": [
            "set",
            "invocation",
            "s",
            "method",
            "s",
            "input",
            "parameter",
            "s",
            "types"
        ]
    },
    {
        "id": 953,
        "code": "public String getServiceName() {\n    return get(SERVICE).toString();\n}",
        "summary_tokens": [
            "return",
            "gthe",
            "service",
            "of",
            "access",
            "log",
            "entry"
        ]
    },
    {
        "id": 954,
        "code": "private Object get(String key) {\n    return data.get(key);\n}",
        "summary_tokens": [
            "return",
            "value",
            "of",
            "key"
        ]
    },
    {
        "id": 955,
        "code": "private void set(String key, Object value) {\n    data.put(key, value);\n}",
        "summary_tokens": [
            "add",
            "log",
            "key",
            "along",
            "with",
            "his",
            "value"
        ]
    },
    {
        "id": 956,
        "code": "public static void attachInvocationIdIfAsync(URL url, Invocation inv) {\n    if (isAttachInvocationId(url, inv) && getInvocationId(inv) == null && inv instanceof RpcInvocation) {\n        inv.setAttachment(ID_KEY, String.valueOf(INVOKE_ID.getAndIncrement()));\n    }\n}",
        "summary_tokens": [
            "idempotent",
            "operation",
            "invocation",
            "id",
            "will",
            "be",
            "added",
            "in",
            "async",
            "operation",
            "by",
            "default"
        ]
    },
    {
        "id": 957,
        "code": "public void testAppResponseWithEmptyStackTraceException() {\n    Throwable throwable = buildEmptyStackTraceException();\n    assumeFalse(throwable == null);\n    AppResponse appResponse = new AppResponse(throwable);\n\n    StackTraceElement[] stackTrace = appResponse.getException().getStackTrace();\n    Assertions.assertNotNull(stackTrace);\n    Assertions.assertEquals(0,stackTrace.length);\n}",
        "summary_tokens": [
            "please",
            "run",
            "this",
            "test",
            "in",
            "run",
            "mode"
        ]
    },
    {
        "id": 958,
        "code": "public void testSetExceptionWithEmptyStackTraceException() {\n    Throwable throwable = buildEmptyStackTraceException();\n    assumeFalse(throwable == null);\n    AppResponse appResponse = new AppResponse();\n    appResponse.setException(throwable);\n\n    StackTraceElement[] stackTrace = appResponse.getException().getStackTrace();\n    Assertions.assertNotNull(stackTrace);\n    Assertions.assertEquals(0,stackTrace.length);\n}",
        "summary_tokens": [
            "please",
            "run",
            "this",
            "test",
            "in",
            "run",
            "mode"
        ]
    },
    {
        "id": 959,
        "code": "public void testAttachInvocationIdIfAsync_normal() {\n    URL url = URL.valueOf(\"dubbo://localhost/?test.async=true\");\n    Map<String, Object> attachments = new HashMap<>();\n    attachments.put(\"aa\", \"bb\");\n    Invocation inv = new RpcInvocation(\"test\", \"DemoService\", \"\", new Class[] {}, new String[] {}, attachments);\n    RpcUtils.attachInvocationIdIfAsync(url, inv);\n    long id1 = RpcUtils.getInvocationId(inv);\n    RpcUtils.attachInvocationIdIfAsync(url, inv);\n    long id2 = RpcUtils.getInvocationId(inv);\n    assertEquals(id1, id2); \n    assertTrue(id1 >= 0);\n    assertEquals(\"bb\", attachments.get(\"aa\"));\n}",
        "summary_tokens": [
            "regular",
            "scenario",
            "async",
            "invocation",
            "in",
            "url",
            "verify",
            "0"
        ]
    },
    {
        "id": 960,
        "code": "public void testAttachInvocationIdIfAsync_sync() {\n    URL url = URL.valueOf(\"dubbo://localhost/\");\n    Invocation inv = new RpcInvocation(\"test\", \"DemoService\", \"\", new Class[] {}, new String[] {});\n    RpcUtils.attachInvocationIdIfAsync(url, inv);\n    assertNull(RpcUtils.getInvocationId(inv));\n}",
        "summary_tokens": [
            "scenario",
            "sync",
            "invocation",
            "no",
            "attachment",
            "added",
            "by",
            "default",
            "verify",
            "no",
            "id",
            "attribute",
            "added",
            "in",
            "attachment"
        ]
    },
    {
        "id": 961,
        "code": "public void testAttachInvocationIdIfAsync_nullAttachments() {\n    URL url = URL.valueOf(\"dubbo://localhost/?test.async=true\");\n    Invocation inv = new RpcInvocation(\"test\", \"DemoService\", \"\", new Class[] {}, new String[] {});\n    RpcUtils.attachInvocationIdIfAsync(url, inv);\n    assertTrue(RpcUtils.getInvocationId(inv) >= 0L);\n}",
        "summary_tokens": [
            "scenario",
            "async",
            "invocation",
            "add",
            "attachment",
            "by",
            "default",
            "verify",
            "no",
            "error",
            "report",
            "when",
            "the",
            "original",
            "attachment",
            "is",
            "null"
        ]
    },
    {
        "id": 962,
        "code": "public void testAttachInvocationIdIfAsync_forceNotAttache() {\n    URL url = URL.valueOf(\"dubbo://localhost/?test.async=true&\" + AUTO_ATTACH_INVOCATIONID_KEY + \"=false\");\n    Invocation inv = new RpcInvocation(\"test\", \"DemoService\", \"\", new Class[] {}, new String[] {});\n    RpcUtils.attachInvocationIdIfAsync(url, inv);\n    assertNull(RpcUtils.getInvocationId(inv));\n}",
        "summary_tokens": [
            "scenario",
            "explicitly",
            "configure",
            "to",
            "not",
            "add",
            "attachment",
            "verify",
            "no",
            "id",
            "attribute",
            "added",
            "in",
            "attachment"
        ]
    },
    {
        "id": 963,
        "code": "public void testAttachInvocationIdIfAsync_forceAttache() {\n    URL url = URL.valueOf(\"dubbo://localhost/?\" + AUTO_ATTACH_INVOCATIONID_KEY + \"=true\");\n    Invocation inv = new RpcInvocation(\"test\", \"DemoService\", \"\", new Class[] {}, new String[] {});\n    RpcUtils.attachInvocationIdIfAsync(url, inv);\n    assertNotNull(RpcUtils.getInvocationId(inv));\n}",
        "summary_tokens": [
            "scenario",
            "explicitly",
            "configure",
            "to",
            "add",
            "attachment",
            "verify",
            "id",
            "attribute",
            "added",
            "in",
            "attachment"
        ]
    },
    {
        "id": 964,
        "code": "private String exportOrUnexportCallbackService(Channel channel, RpcInvocation inv, URL url, Class clazz, Object inst, Boolean export) throws IOException {\n    int instid = System.identityHashCode(inst);\n\n    Map<String, String> params = new HashMap<>(3);\n        \n    params.put(IS_SERVER_KEY, Boolean.FALSE.toString());\n        \n    params.put(IS_CALLBACK_SERVICE, Boolean.TRUE.toString());\n    String group = (inv == null ? null : (String) inv.getObjectAttachmentWithoutConvert(GROUP_KEY));\n    if (group != null && group.length() > 0) {\n        params.put(GROUP_KEY, group);\n    }\n        \n    params.put(METHODS_KEY, StringUtils.join(ClassUtils.getDeclaredMethodNames(clazz), \",\"));\n\n    Map<String, String> tmpMap = new HashMap<>();\n    if (url != null) {\n        Map<String, String> parameters = url.getParameters();\n        if (parameters != null && !parameters.isEmpty()) {\n            tmpMap.putAll(parameters);\n        }\n    }\n    tmpMap.putAll(params);\n\n    tmpMap.remove(VERSION_KEY);\n    tmpMap.remove(Constants.BIND_PORT_KEY); \n    tmpMap.put(INTERFACE_KEY, clazz.getName());\n    URL exportUrl = new ServiceConfigURL(DubboProtocol.NAME, channel.getLocalAddress().getAddress().getHostAddress(),\n        channel.getLocalAddress().getPort(), clazz.getName() + \".\" + instid, tmpMap);\n\n        \n    String cacheKey = getClientSideCallbackServiceCacheKey(instid);\n    String countKey = getClientSideCountKey(clazz.getName());\n    if (export) {\n            \n        if (!channel.hasAttribute(cacheKey)) {\n            if (!isInstancesOverLimit(channel, url, clazz.getName(), instid, false)) {\n                ModuleModel moduleModel;\n                if (inv.getServiceModel() == null) {\n                        \n                    moduleModel = ApplicationModel.defaultModel().getDefaultModule();\n                    logger.error(\"Unable to get Service Model from Invocation. Please check if your invocation failed! \" +\n                        \"This error only happen in UT cases! Invocation:\" + inv);\n                } else {\n                    moduleModel = inv.getServiceModel().getModuleModel();\n                }\n\n                ServiceDescriptor serviceDescriptor = moduleModel.getServiceRepository().registerService(clazz);\n                ServiceMetadata serviceMetadata = new ServiceMetadata(clazz.getName() + \".\" + instid, exportUrl.getGroup(), exportUrl.getVersion(), clazz);\n                String serviceKey = BaseServiceMetadata.buildServiceKey(exportUrl.getPath(), group, exportUrl.getVersion());\n                ProviderModel providerModel = new ProviderModel(serviceKey, inst, serviceDescriptor, moduleModel, serviceMetadata, ClassUtils.getClassLoader(clazz));\n                moduleModel.getServiceRepository().registerProvider(providerModel);\n\n                exportUrl = exportUrl.setScopeModel(moduleModel);\n                exportUrl = exportUrl.setServiceModel(providerModel);\n                Invoker<?> invoker = proxyFactory.getInvoker(inst, clazz, exportUrl);\n                    \n                Exporter<?> exporter = protocolSPI.export(invoker);\n                    \n                channel.setAttribute(cacheKey, exporter);\n                logger.info(\"Export a callback service :\" + exportUrl + \", on \" + channel + \", url is: \" + url);\n                increaseInstanceCount(channel, countKey);\n            }\n        }\n    } else {\n        if (channel.hasAttribute(cacheKey)) {\n            Exporter<?> exporter = (Exporter<?>) channel.getAttribute(cacheKey);\n            exporter.unexport();\n            channel.removeAttribute(cacheKey);\n            decreaseInstanceCount(channel, countKey);\n        }\n    }\n    return String.valueOf(instid);\n}",
        "summary_tokens": [
            "export",
            "or",
            "unexport",
            "callback",
            "service",
            "on",
            "client",
            "side"
        ]
    },
    {
        "id": 965,
        "code": "private Object referOrDestroyCallbackService(Channel channel, URL url, Class<?> clazz, Invocation inv, int instid, boolean isRefer) {\n    Object proxy;\n    String invokerCacheKey = getServerSideCallbackInvokerCacheKey(channel, clazz.getName(), instid);\n    String proxyCacheKey = getServerSideCallbackServiceCacheKey(channel, clazz.getName(), instid);\n    proxy = channel.getAttribute(proxyCacheKey);\n    String countkey = getServerSideCountKey(channel, clazz.getName());\n    if (isRefer) {\n        if (proxy == null) {\n            URL referurl = URL.valueOf(\"callback://\" + url.getAddress() + \"/\" + clazz.getName() + \"?\" + INTERFACE_KEY + \"=\" + clazz.getName());\n            referurl = referurl.addParametersIfAbsent(url.getParameters()).removeParameter(METHODS_KEY);\n            if (!isInstancesOverLimit(channel, referurl, clazz.getName(), instid, true)) {\n                url.getOrDefaultApplicationModel().getDefaultModule().getServiceRepository().registerService(clazz);\n                @SuppressWarnings(\"rawtypes\")\n                Invoker<?> invoker = new ChannelWrappedInvoker(clazz, channel, referurl, String.valueOf(instid));\n                proxy = proxyFactory.getProxy(invoker);\n                channel.setAttribute(proxyCacheKey, proxy);\n                channel.setAttribute(invokerCacheKey, invoker);\n                increaseInstanceCount(channel, countkey);\n\n                    \n                    \n                Set<Invoker<?>> callbackInvokers = (Set<Invoker<?>>) channel.getAttribute(CHANNEL_CALLBACK_KEY);\n                if (callbackInvokers == null) {\n                    callbackInvokers = new ConcurrentHashSet<>(1);\n                    channel.setAttribute(CHANNEL_CALLBACK_KEY, callbackInvokers);\n                }\n                callbackInvokers.add(invoker);\n                logger.info(\"method \" + inv.getMethodName() + \" include a callback service :\" + invoker.getUrl() + \", a proxy :\" + invoker + \" has been created.\");\n            }\n        }\n    } else {\n        if (proxy != null) {\n            Invoker<?> invoker = (Invoker<?>) channel.getAttribute(invokerCacheKey);\n            try {\n                Set<Invoker<?>> callbackInvokers = (Set<Invoker<?>>) channel.getAttribute(CHANNEL_CALLBACK_KEY);\n                if (callbackInvokers != null) {\n                    callbackInvokers.remove(invoker);\n                }\n                invoker.destroy();\n            } catch (Exception e) {\n                logger.error(e.getMessage(), e);\n            }\n                \n            channel.removeAttribute(proxyCacheKey);\n            channel.removeAttribute(invokerCacheKey);\n            decreaseInstanceCount(channel, countkey);\n        }\n    }\n    return proxy;\n}",
        "summary_tokens": [
            "refer",
            "or",
            "destroy",
            "callback",
            "service",
            "on",
            "server",
            "side"
        ]
    },
    {
        "id": 966,
        "code": "private void destroyInternal(boolean closeAll) {\n        \n        \n        \n    if (!super.isDestroyed()) {\n            \n        destroyLock.lock();\n        try {\n            if (super.isDestroyed()) {\n                return;\n            }\n            super.destroy();\n            if (invokers != null) {\n                invokers.remove(this);\n            }\n            for (ExchangeClient client : clients) {\n                try {\n                    if (closeAll) {\n                        client.closeAll(serverShutdownTimeout);\n                    } else {\n                        client.close(serverShutdownTimeout);\n                    }\n                } catch (Throwable t) {\n                    logger.warn(t.getMessage(), t);\n                }\n            }\n\n        } finally {\n            destroyLock.unlock();\n        }\n    }\n}",
        "summary_tokens": [
            "when",
            "destroy",
            "unused",
            "invoker",
            "close",
            "all",
            "should",
            "be",
            "true"
        ]
    },
    {
        "id": 967,
        "code": "public static DubboProtocol getDubboProtocol() {\n    return (DubboProtocol) ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(DubboProtocol.NAME, false);\n}",
        "summary_tokens": [
            "use",
            "dubbo",
            "protocol",
            "get",
            "dubbo",
            "protocol",
            "scope",
            "model",
            "instead"
        ]
    },
    {
        "id": 968,
        "code": "private boolean checkClientCanUse(List<ReferenceCountExchangeClient> referenceCountExchangeClients) {\n    if (CollectionUtils.isEmpty(referenceCountExchangeClients)) {\n        return false;\n    }\n\n        \n    return referenceCountExchangeClients.stream()\n        .noneMatch(referenceCountExchangeClient -> referenceCountExchangeClient == null\n            || referenceCountExchangeClient.getCount() <= 0 || referenceCountExchangeClient.isClosed());\n}",
        "summary_tokens": [
            "check",
            "if",
            "the",
            "client",
            "list",
            "is",
            "all",
            "available"
        ]
    },
    {
        "id": 969,
        "code": "private void batchClientRefIncr(List<ReferenceCountExchangeClient> referenceCountExchangeClients) {\n    if (CollectionUtils.isEmpty(referenceCountExchangeClients)) {\n        return;\n    }\n    referenceCountExchangeClients.stream()\n        .filter(Objects::nonNull)\n        .forEach(ReferenceCountExchangeClient::incrementAndGetCount);\n}",
        "summary_tokens": [
            "increase",
            "the",
            "reference",
            "count",
            "if",
            "we",
            "create",
            "new",
            "invoker",
            "shares",
            "same",
            "connection",
            "the",
            "connection",
            "will",
            "be",
            "closed",
            "without",
            "any",
            "reference"
        ]
    },
    {
        "id": 970,
        "code": "private ReferenceCountExchangeClient buildReferenceCountExchangeClient(URL url) {\n    ExchangeClient exchangeClient = initClient(url);\n    ReferenceCountExchangeClient client = new ReferenceCountExchangeClient(exchangeClient, DubboCodec.NAME);\n        \n    int shutdownTimeout = ConfigurationUtils.getServerShutdownTimeout(url.getScopeModel());\n    client.setShutdownWaitTime(shutdownTimeout);\n    return client;\n}",
        "summary_tokens": [
            "build",
            "a",
            "single",
            "client"
        ]
    },
    {
        "id": 971,
        "code": "private void closeReferenceCountExchangeClient(ReferenceCountExchangeClient client) {\n    if (client == null) {\n        return;\n    }\n\n    try {\n        if (logger.isInfoEnabled()) {\n            logger.info(\"Close dubbo connect: \" + client.getLocalAddress() + \"-->\" + client.getRemoteAddress());\n        }\n\n        client.close(client.getShutdownWaitTime());\n\n            \n            \n\n    } catch (Throwable t) {\n        logger.warn(t.getMessage(), t);\n    }\n}",
        "summary_tokens": [
            "close",
            "reference",
            "count",
            "exchange",
            "client"
        ]
    },
    {
        "id": 972,
        "code": "private Invocation getInvocationWithoutData(Invocation invocation) {\n    if (logger.isDebugEnabled()) {\n        return invocation;\n    }\n    if (invocation instanceof RpcInvocation) {\n        RpcInvocation rpcInvocation = (RpcInvocation) invocation;\n        rpcInvocation.setArguments(null);\n        return rpcInvocation;\n    }\n    return invocation;\n}",
        "summary_tokens": [
            "only",
            "log",
            "body",
            "in",
            "debugger",
            "mode",
            "for",
            "size",
            "security",
            "consideration"
        ]
    },
    {
        "id": 973,
        "code": "public void close() {\n    close(0);\n}",
        "summary_tokens": [
            "close",
            "is",
            "not",
            "idempotent",
            "any",
            "longer"
        ]
    },
    {
        "id": 974,
        "code": "private void closeInternal(int timeout, boolean closeAll) {\n    if (closeAll || referenceCount.decrementAndGet() <= 0) {\n        if (timeout == 0) {\n            client.close();\n\n        } else {\n            client.close(timeout);\n        }\n\n        replaceWithLazyClient();\n    }\n}",
        "summary_tokens": [
            "when",
            "destroy",
            "unused",
            "invoker",
            "close",
            "all",
            "should",
            "be",
            "true"
        ]
    },
    {
        "id": 975,
        "code": "private void replaceWithLazyClient() {\n        \n    if (disconnectCount.getAndIncrement() % warningPeriod == 1) {\n        logger.warn(url.getAddress() + \" \" + url.getServiceKey() + \" safe guard client , should not be called ,must have a bug.\");\n    }\n\n        \n    if (!(client instanceof LazyConnectExchangeClient)) {\n        client = new LazyConnectExchangeClient(url, client.getExchangeHandler());\n    }\n}",
        "summary_tokens": [
            "when",
            "closing",
            "the",
            "client",
            "the",
            "client",
            "needs",
            "to",
            "be",
            "set",
            "to",
            "lazy",
            "connect",
            "exchange",
            "client",
            "and",
            "if",
            "a",
            "new",
            "call",
            "is",
            "made",
            "the",
            "client",
            "will",
            "resurrect"
        ]
    },
    {
        "id": 976,
        "code": "public void incrementAndGetCount() {\n    referenceCount.incrementAndGet();\n}",
        "summary_tokens": [
            "the",
            "reference",
            "count",
            "of",
            "current",
            "exchange",
            "client",
            "connection",
            "will",
            "be",
            "closed",
            "if",
            "all",
            "invokers",
            "destroyed"
        ]
    },
    {
        "id": 977,
        "code": "public void test_not_share_connect() {\n    init(1, 1);\n    Assertions.assertNotSame(demoClient.getLocalAddress(), helloClient.getLocalAddress());\n    Assertions.assertNotSame(demoClient, helloClient);\n    destroy();\n}",
        "summary_tokens": [
            "test",
            "connection",
            "not",
            "sharing"
        ]
    },
    {
        "id": 978,
        "code": "public void test_multi_share_connect() {\n        \n    final int shareConnectionNum = 3;\n\n    init(0, shareConnectionNum);\n\n    List<ReferenceCountExchangeClient> helloReferenceClientList = getReferenceClientList(helloServiceInvoker);\n    Assertions.assertEquals(shareConnectionNum, helloReferenceClientList.size());\n\n    List<ReferenceCountExchangeClient> demoReferenceClientList = getReferenceClientList(demoServiceInvoker);\n    Assertions.assertEquals(shareConnectionNum, demoReferenceClientList.size());\n\n        \n    Assertions.assertEquals(helloReferenceClientList, demoReferenceClientList);\n\n    Assertions.assertEquals(demoClient.getLocalAddress(), helloClient.getLocalAddress());\n    Assertions.assertEquals(demoClient, helloClient);\n\n    destroy();\n}",
        "summary_tokens": [
            "test",
            "using",
            "multiple",
            "shared",
            "connections"
        ]
    },
    {
        "id": 979,
        "code": "public void test_multi_destroy() {\n    init(0, 1);\n    DubboAppender.doStart();\n    DubboAppender.clear();\n    demoServiceInvoker.destroy();\n    demoServiceInvoker.destroy();\n    Assertions.assertEquals(\"hello\", helloService.hello());\n    Assertions.assertEquals(0, LogUtil.findMessage(errorMsg), \"should not  warning message\");\n    LogUtil.checkNoError();\n    DubboAppender.doStop();\n    destroy();\n}",
        "summary_tokens": [
            "test",
            "counter",
            "won",
            "t",
            "count",
            "down",
            "incorrectly",
            "when",
            "invoker",
            "is",
            "destroyed",
            "for",
            "multiple",
            "times"
        ]
    },
    {
        "id": 980,
        "code": "public void test_counter_error() {\n    init(0, 1);\n    DubboAppender.doStart();\n    DubboAppender.clear();\n\n        \n    ReferenceCountExchangeClient client = getReferenceClient(helloServiceInvoker);\n\n        \n    client.close();\n    Assertions.assertEquals(\"hello\", helloService.hello());\n    Assertions.assertEquals(0, LogUtil.findMessage(errorMsg), \"should not warning message\");\n\n        \n    client.close();\n\n        \n    try {\n        Thread.sleep(1000);\n    } catch (InterruptedException e) {\n        Assertions.fail();\n    }\n\n        \n    Assertions.assertFalse(client.isClosed(), \"client status close\");\n        \n    Assertions.assertTrue(helloServiceInvoker.isAvailable(), \"invoker status unavailable\");\n\n        \n    Assertions.assertEquals(\"hello\", helloService.hello());\n    Assertions.assertEquals(1, LogUtil.findMessage(errorMsg), \"should warning message\");\n\n        \n    Assertions.assertEquals(\"hello\", helloService.hello());\n    Assertions.assertEquals(1, LogUtil.findMessage(errorMsg), \"should warning message\");\n\n    DubboAppender.doStop();\n\n        \n    client.close();\n\n        \n    Assertions.assertFalse(client.isClosed(), \"client status close\");\n        \n    Assertions.assertTrue(helloServiceInvoker.isAvailable(), \"invoker status unavailable\");\n\n        \n    Assertions.assertEquals(\"hello\", helloService.hello());\n\n    destroy();\n}",
        "summary_tokens": [
            "test",
            "against",
            "invocation",
            "still",
            "succeed",
            "even",
            "if",
            "counter",
            "has",
            "error"
        ]
    },
    {
        "id": 981,
        "code": "public void testTelnetDubboDecoded() throws InterruptedException, IOException {\n    ByteBuf dubboByteBuf = createDubboByteBuf();\n\n    ByteBuf telnetByteBuf = Unpooled.wrappedBuffer(\"test\\r\".getBytes());\n    EmbeddedChannel ch = null;\n    try {\n        Codec2 codec = ExtensionLoader.getExtensionLoader(Codec2.class).getExtension(\"dubbo\");\n        URL url = new ServiceConfigURL(\"dubbo\", \"localhost\", 22226);\n        NettyCodecAdapter adapter = new NettyCodecAdapter(codec, url, new MockChannelHandler());\n\n        MockHandler mockHandler = new MockHandler((msg) -> {\n            if (checkTelnetDecoded(msg)) {\n                telnetDubbo.incrementAndGet();\n            }\n        },\n                new MultiMessageHandler(\n                        new DecodeHandler(\n                                new HeaderExchangeHandler(new ExchangeHandlerAdapter() {\n                                    @Override\n                                    public CompletableFuture<Object> reply(ExchangeChannel channel, Object msg) {\n                                        if (checkDubboDecoded(msg)) {\n                                            telnetDubbo.incrementAndGet();\n                                        }\n\n                                        return getDefaultFuture();\n                                    }\n                                }))));\n\n        ch = new LocalEmbeddedChannel();\n        ch.pipeline()\n                .addLast(\"decoder\", adapter.getDecoder())\n                .addLast(\"handler\", mockHandler);\n\n        ch.writeInbound(telnetByteBuf);\n        ch.writeInbound(Unpooled.wrappedBuffer(Unpooled.wrappedBuffer(\"\\n\".getBytes()), dubboByteBuf));\n    } catch (Exception e) {\n        e.printStackTrace();\n    } finally {\n        if (ch != null) {\n            ch.close().await(200, TimeUnit.MILLISECONDS);\n        }\n    }\n\n    TimeUnit.MILLISECONDS.sleep(100);\n\n    Assertions.assertEquals(2, telnetDubbo.get());\n}",
        "summary_tokens": [
            "telnet",
            "and",
            "dubbo",
            "request"
        ]
    },
    {
        "id": 982,
        "code": "public void testTelnetTelnetDecoded() throws InterruptedException {\n    ByteBuf firstByteBuf = Unpooled.wrappedBuffer(\"ls\\r\".getBytes());\n    ByteBuf secondByteBuf = Unpooled.wrappedBuffer(\"\\nls\\r\\n\".getBytes());\n\n    EmbeddedChannel ch = null;\n    try {\n        Codec2 codec = ExtensionLoader.getExtensionLoader(Codec2.class).getExtension(\"dubbo\");\n        URL url = new ServiceConfigURL(\"dubbo\", \"localhost\", 22226);\n        NettyCodecAdapter adapter = new NettyCodecAdapter(codec, url, new MockChannelHandler());\n\n        MockHandler mockHandler = new MockHandler((msg) -> {\n            if (checkTelnetDecoded(msg)) {\n                telnetTelnet.incrementAndGet();\n            }\n        },\n                new MultiMessageHandler(\n                        new DecodeHandler(\n                                new HeaderExchangeHandler(new ExchangeHandlerAdapter() {\n                                    @Override\n                                    public CompletableFuture<Object> reply(ExchangeChannel channel, Object msg) {\n                                        return getDefaultFuture();\n                                    }\n                                }))));\n\n        ch = new LocalEmbeddedChannel();\n        ch.pipeline()\n                .addLast(\"decoder\", adapter.getDecoder())\n                .addLast(\"handler\", mockHandler);\n\n        ch.writeInbound(firstByteBuf);\n        ch.writeInbound(secondByteBuf);\n    } catch (Exception e) {\n        e.printStackTrace();\n    } finally {\n        if (ch != null) {\n            ch.close().await(200, TimeUnit.MILLISECONDS);\n        }\n    }\n\n    TimeUnit.MILLISECONDS.sleep(100);\n\n    Assertions.assertEquals(2, telnetTelnet.get());\n}",
        "summary_tokens": [
            "note",
            "this",
            "test",
            "case",
            "actually",
            "will",
            "fail",
            "but",
            "the",
            "probability",
            "of",
            "this",
            "case",
            "is",
            "very",
            "small",
            "and",
            "users",
            "should",
            "use",
            "telnet",
            "in",
            "new",
            "qos",
            "port",
            "default",
            "port",
            "is",
            "0",
            "since",
            "dubbo",
            "0"
        ]
    },
    {
        "id": 983,
        "code": "public void testDubboDubboDecoded() throws InterruptedException, IOException {\n    ByteBuf dubboByteBuf = createDubboByteBuf();\n\n    ByteBuf firstDubboByteBuf = dubboByteBuf.copy(0, 50);\n    ByteBuf secondLeftDubboByteBuf = dubboByteBuf.copy(50, dubboByteBuf.readableBytes() - 50);\n    ByteBuf secondDubboByteBuf = Unpooled.wrappedBuffer(secondLeftDubboByteBuf, dubboByteBuf);\n\n\n    EmbeddedChannel ch = null;\n    try {\n        Codec2 codec = ExtensionLoader.getExtensionLoader(Codec2.class).getExtension(\"dubbo\");\n        URL url = new ServiceConfigURL(\"dubbo\", \"localhost\", 22226);\n        NettyCodecAdapter adapter = new NettyCodecAdapter(codec, url, new MockChannelHandler());\n\n        MockHandler mockHandler = new MockHandler(null,\n                new MultiMessageHandler(\n                        new DecodeHandler(\n                                new HeaderExchangeHandler(new ExchangeHandlerAdapter() {\n                                    @Override\n                                    public CompletableFuture<Object> reply(ExchangeChannel channel, Object msg) {\n                                        if (checkDubboDecoded(msg)) {\n                                            dubboDubbo.incrementAndGet();\n                                        }\n                                        return getDefaultFuture();\n                                    }\n                                }))));\n\n        ch = new LocalEmbeddedChannel();\n        ch.pipeline()\n                .addLast(\"decoder\", adapter.getDecoder())\n                .addLast(\"handler\", mockHandler);\n\n        ch.writeInbound(firstDubboByteBuf);\n        ch.writeInbound(secondDubboByteBuf);\n    } catch (Exception e) {\n        e.printStackTrace();\n    } finally {\n        if (ch != null) {\n            ch.close().await(200, TimeUnit.MILLISECONDS);\n        }\n    }\n\n    TimeUnit.MILLISECONDS.sleep(100);\n\n    Assertions.assertEquals(2, dubboDubbo.get());\n}",
        "summary_tokens": [
            "dubbo",
            "and",
            "dubbo",
            "request"
        ]
    },
    {
        "id": 984,
        "code": "public void testDubboTelnetDecoded() throws InterruptedException, IOException {\n    ByteBuf dubboByteBuf = createDubboByteBuf();\n    ByteBuf firstDubboByteBuf = dubboByteBuf.copy(0, 50);\n    ByteBuf secondLeftDubboByteBuf = dubboByteBuf.copy(50, dubboByteBuf.readableBytes());\n\n    ByteBuf telnetByteBuf = Unpooled.wrappedBuffer(\"\\r\\n\".getBytes());\n    ByteBuf secondByteBuf = Unpooled.wrappedBuffer(secondLeftDubboByteBuf, telnetByteBuf);\n\n    EmbeddedChannel ch = null;\n    try {\n        Codec2 codec = ExtensionLoader.getExtensionLoader(Codec2.class).getExtension(\"dubbo\");\n        URL url = new ServiceConfigURL(\"dubbo\", \"localhost\", 22226);\n        NettyCodecAdapter adapter = new NettyCodecAdapter(codec, url, new MockChannelHandler());\n\n        MockHandler mockHandler = new MockHandler((msg) -> {\n            if (checkTelnetDecoded(msg)) {\n                dubboTelnet.incrementAndGet();\n            }\n        },\n                new MultiMessageHandler(\n                        new DecodeHandler(\n                                new HeaderExchangeHandler(new ExchangeHandlerAdapter() {\n                                    @Override\n                                    public CompletableFuture<Object> reply(ExchangeChannel channel, Object msg) {\n                                        if (checkDubboDecoded(msg)) {\n                                            dubboTelnet.incrementAndGet();\n                                        }\n                                        return getDefaultFuture();\n                                    }\n                                }))));\n\n        ch = new LocalEmbeddedChannel();\n        ch.pipeline()\n                .addLast(\"decoder\", adapter.getDecoder())\n                .addLast(\"handler\", mockHandler);\n\n        ch.writeInbound(firstDubboByteBuf);\n        ch.writeInbound(secondByteBuf);\n    } catch (Exception e) {\n        e.printStackTrace();\n    } finally {\n        if (ch != null) {\n            ch.close().await(200, TimeUnit.MILLISECONDS);\n        }\n    }\n\n    TimeUnit.MILLISECONDS.sleep(100);\n\n    Assertions.assertEquals(2, dubboTelnet.get());\n}",
        "summary_tokens": [
            "dubbo",
            "and",
            "telnet",
            "request"
        ]
    },
    {
        "id": 985,
        "code": "public List<ServerServiceDefinition> getServices() {\n    return Collections.unmodifiableList(new ArrayList<>(services.values()));\n}",
        "summary_tokens": [
            "returns",
            "the",
            "service",
            "definitions",
            "in",
            "this",
            "registry"
        ]
    },
    {
        "id": 986,
        "code": "private int getErrorCode(Throwable e) {\n    if (e instanceof StatusException) {\n        StatusException statusException = (StatusException) e;\n        Status status = statusException.getStatus();\n        if (status.getCode() == Status.Code.DEADLINE_EXCEEDED) {\n            return RpcException.TIMEOUT_EXCEPTION;\n        }\n    }\n    return RpcException.UNKNOWN_EXCEPTION;\n}",
        "summary_tokens": [
            "fixme",
            "convert",
            "g",
            "rpc",
            "exceptions",
            "to",
            "equivalent",
            "dubbo",
            "exceptions"
        ]
    },
    {
        "id": 987,
        "code": "private ReferenceCountManagedChannel getSharedChannel(URL url) {\n    String key = url.getAddress();\n    ReferenceCountManagedChannel channel = channelMap.get(key);\n\n    if (channel != null && !channel.isTerminated()) {\n        channel.incrementAndGetCount();\n        return channel;\n    }\n\n    synchronized (lock) {\n        channel = channelMap.get(key);\n            \n        if (channel != null && !channel.isTerminated()) {\n            channel.incrementAndGetCount();\n        } else {\n            channel = new ReferenceCountManagedChannel(initChannel(url));\n            channelMap.put(key, channel);\n        }\n    }\n\n    return channel;\n}",
        "summary_tokens": [
            "get",
            "shared",
            "channel",
            "connection"
        ]
    },
    {
        "id": 988,
        "code": "public int incrementAndGetCount() {\n    return referenceCount.incrementAndGet();\n}",
        "summary_tokens": [
            "the",
            "reference",
            "count",
            "of",
            "current",
            "exchange",
            "client",
            "connection",
            "will",
            "be",
            "closed",
            "if",
            "all",
            "invokers",
            "destroyed"
        ]
    },
    {
        "id": 989,
        "code": "public static GreeterStub newStub(io.grpc.Channel channel) {\n    io.grpc.stub.AbstractStub.StubFactory<GreeterStub> factory =\n        new io.grpc.stub.AbstractStub.StubFactory<GreeterStub>() {\n            @Override\n            public GreeterStub newStub(io.grpc.Channel channel, io.grpc.CallOptions callOptions) {\n                return new GreeterStub(channel, callOptions);\n            }\n        };\n    return GreeterStub.newStub(factory, channel);\n}",
        "summary_tokens": [
            "creates",
            "a",
            "new",
            "async",
            "stub",
            "that",
            "supports",
            "all",
            "call",
            "types",
            "for",
            "the",
            "service"
        ]
    },
    {
        "id": 990,
        "code": "public static GreeterBlockingStub newBlockingStub(\n    io.grpc.Channel channel) {\n    io.grpc.stub.AbstractStub.StubFactory<GreeterBlockingStub> factory =\n        new io.grpc.stub.AbstractStub.StubFactory<GreeterBlockingStub>() {\n            @Override\n            public GreeterBlockingStub newStub(io.grpc.Channel channel, io.grpc.CallOptions callOptions) {\n                return new GreeterBlockingStub(channel, callOptions);\n            }\n        };\n    return GreeterBlockingStub.newStub(factory, channel);\n}",
        "summary_tokens": [
            "creates",
            "a",
            "new",
            "blocking",
            "style",
            "stub",
            "that",
            "supports",
            "unary",
            "and",
            "streaming",
            "output",
            "calls",
            "on",
            "the",
            "service"
        ]
    },
    {
        "id": 991,
        "code": "public static GreeterFutureStub newFutureStub(\n    io.grpc.Channel channel) {\n    io.grpc.stub.AbstractStub.StubFactory<GreeterFutureStub> factory =\n        new io.grpc.stub.AbstractStub.StubFactory<GreeterFutureStub>() {\n            @Override\n            public GreeterFutureStub newStub(io.grpc.Channel channel, io.grpc.CallOptions callOptions) {\n                return new GreeterFutureStub(channel, callOptions);\n            }\n        };\n    return GreeterFutureStub.newStub(factory, channel);\n}",
        "summary_tokens": [
            "creates",
            "a",
            "new",
            "listenable",
            "future",
            "style",
            "stub",
            "that",
            "supports",
            "unary",
            "calls",
            "on",
            "the",
            "service"
        ]
    },
    {
        "id": 992,
        "code": "public String getMessage() {\n    Object ref = message_;\n    if (ref instanceof String) {\n        return (String) ref;\n    } else {\n        com.google.protobuf.ByteString bs =\n            (com.google.protobuf.ByteString) ref;\n        String s = bs.toStringUtf8();\n        message_ = s;\n        return s;\n    }\n}",
        "summary_tokens": [
            "code",
            "string",
            "message",
            "0",
            "code"
        ]
    },
    {
        "id": 993,
        "code": "public com.google.protobuf.ByteString\ngetMessageBytes() {\n    Object ref = message_;\n    if (ref instanceof String) {\n        com.google.protobuf.ByteString b =\n            com.google.protobuf.ByteString.copyFromUtf8(\n                (String) ref);\n        message_ = b;\n        return b;\n    } else {\n        return (com.google.protobuf.ByteString) ref;\n    }\n}",
        "summary_tokens": [
            "code",
            "string",
            "message",
            "0",
            "code"
        ]
    },
    {
        "id": 994,
        "code": "public String getName() {\n    Object ref = name_;\n    if (ref instanceof String) {\n        return (String) ref;\n    } else {\n        com.google.protobuf.ByteString bs =\n            (com.google.protobuf.ByteString) ref;\n        String s = bs.toStringUtf8();\n        name_ = s;\n        return s;\n    }\n}",
        "summary_tokens": [
            "code",
            "string",
            "name",
            "0",
            "code"
        ]
    },
    {
        "id": 995,
        "code": "public com.google.protobuf.ByteString\ngetNameBytes() {\n    Object ref = name_;\n    if (ref instanceof String) {\n        com.google.protobuf.ByteString b =\n            com.google.protobuf.ByteString.copyFromUtf8(\n                (String) ref);\n        name_ = b;\n        return b;\n    } else {\n        return (com.google.protobuf.ByteString) ref;\n    }\n}",
        "summary_tokens": [
            "code",
            "string",
            "name",
            "0",
            "code"
        ]
    },
    {
        "id": 996,
        "code": "protected String getContextPath(URL url) {\n    String contextPath = url.getPath();\n    if (contextPath != null) {\n        if (contextPath.equalsIgnoreCase(url.getParameter(INTERFACE_KEY))) {\n            return \"\";\n        }\n        if (contextPath.endsWith(url.getParameter(INTERFACE_KEY))) {\n            contextPath = contextPath.substring(0, contextPath.lastIndexOf(url.getParameter(INTERFACE_KEY)));\n        }\n        return contextPath.endsWith(\"/\") ? contextPath.substring(0, contextPath.length() - 1) : contextPath;\n    } else {\n        return \"\";\n    }\n}",
        "summary_tokens": [
            "get",
            "path",
            "will",
            "return",
            "contextpath",
            "path",
            "0"
        ]
    },
    {
        "id": 997,
        "code": "default void disableAutoRequest() {\n    disableAutoFlowControl();\n}",
        "summary_tokens": [
            "swaps",
            "to",
            "manual",
            "flow",
            "control",
            "where",
            "no",
            "message",
            "will",
            "be",
            "delivered",
            "to",
            "stream",
            "observer",
            "on",
            "next",
            "object",
            "unless",
            "it",
            "is",
            "request",
            "request",
            "ed"
        ]
    },
    {
        "id": 998,
        "code": "public static DeadlineFuture newFuture(String serviceName, String methodName, String address,\n    int timeout, ExecutorService executor) {\n    final DeadlineFuture future = new DeadlineFuture(serviceName, methodName, address, timeout);\n    future.setExecutor(executor);\n        \n    if (executor instanceof ThreadlessExecutor) {\n        ((ThreadlessExecutor) executor).setWaitingFuture(future);\n    }\n    return future;\n}",
        "summary_tokens": [
            "init",
            "a",
            "deadline",
            "future",
            "0"
        ]
    },
    {
        "id": 999,
        "code": "protected RpcInvocation buildInvocation(MethodDescriptor methodDescriptor) {\n    final URL url = invoker.getUrl();\n    RpcInvocation inv = new RpcInvocation(url.getServiceModel(),\n        methodDescriptor.getMethodName(),\n        serviceDescriptor.getInterfaceName(), url.getProtocolServiceKey(),\n        methodDescriptor.getParameterClasses(),\n        new Object[0]);\n    inv.setTargetServiceUniqueName(url.getServiceKey());\n    inv.setReturnTypes(methodDescriptor.getReturnTypes());\n    inv.setObjectAttachments(StreamUtils.toAttachments(requestMetadata));\n    inv.put(REMOTE_ADDRESS_KEY, stream.remoteAddress());\n        \n    String timeout = (String) requestMetadata.get(TripleHeaderEnum.TIMEOUT.getHeader());\n    try {\n        if (Objects.nonNull(timeout)) {\n            this.timeout = parseTimeoutToMills(timeout);\n        }\n    } catch (Throwable t) {\n        LOGGER.warn(String.format(\"Failed to parse request timeout set from:%s, service=%s \"\n            + \"method=%s\", timeout, serviceDescriptor.getInterfaceName(), methodName));\n    }\n    if (null != requestMetadata.get(TripleHeaderEnum.CONSUMER_APP_NAME_KEY.getHeader())) {\n        inv.put(TripleHeaderEnum.CONSUMER_APP_NAME_KEY,\n            requestMetadata.get(TripleHeaderEnum.CONSUMER_APP_NAME_KEY.getHeader()));\n    }\n    return inv;\n}",
        "summary_tokens": [
            "build",
            "the",
            "rpc",
            "invocation",
            "with",
            "metadata",
            "and",
            "execute",
            "header",
            "filter"
        ]
    },
    {
        "id": 1000,
        "code": "protected void responseErr(TriRpcStatus status) {\n    if (closed) {\n        return;\n    }\n    closed = true;\n    stream.complete(status, null);\n    LOGGER.error(\"Triple request error: service=\" + serviceName + \" method\" + methodName,\n        status.asException());\n}",
        "summary_tokens": [
            "error",
            "in",
            "create",
            "stream",
            "unsupported",
            "config",
            "or",
            "triple",
            "protocol",
            "error"
        ]
    },
    {
        "id": 1001,
        "code": "private void processHeader() {\n    int type = accumulate.readUnsignedByte();\n    if ((type & RESERVED_MASK) != 0) {\n        throw new RpcException(\"gRPC frame header malformed: reserved bits not zero\");\n    }\n    compressedFlag = (type & COMPRESSED_FLAG_MASK) != 0;\n\n    requiredLength = accumulate.readInt();\n\n        \n    state = GrpcDecodeState.PAYLOAD;\n}",
        "summary_tokens": [
            "processes",
            "the",
            "grpc",
            "compression",
            "header",
            "which",
            "is",
            "composed",
            "of",
            "the",
            "compression",
            "flag",
            "and",
            "the",
            "outer",
            "frame",
            "length"
        ]
    },
    {
        "id": 1002,
        "code": "private void processBody() {\n        \n        \n        \n    byte[] stream = compressedFlag ? getCompressedBody() : getUncompressedBody();\n\n    listener.onRawMessage(stream);\n\n        \n    state = GrpcDecodeState.HEADER;\n    requiredLength = HEADER_LENGTH;\n}",
        "summary_tokens": [
            "processes",
            "the",
            "grpc",
            "message",
            "body",
            "which",
            "depending",
            "on",
            "frame",
            "header",
            "flags",
            "may",
            "be",
            "compressed"
        ]
    },
    {
        "id": 1003,
        "code": "public void subscribe(final CallStreamObserver<T> downstream) {\n    if (downstream == null) {\n        throw new NullPointerException();\n    }\n    if (this.downstream == null && SUBSCRIBED.compareAndSet(false, true)) {\n        this.downstream = downstream;\n        subscription.request(1);\n    }\n}",
        "summary_tokens": [
            "binding",
            "the",
            "downstream",
            "and",
            "call",
            "subscription",
            "request",
            "0"
        ]
    },
    {
        "id": 1004,
        "code": "public static <TRequest, TResponse, TInvoker> Mono<TResponse> oneToOne(Invoker<TInvoker> invoker,\n                                                             Mono<TRequest> monoRequest,\n                                                             StubMethodDescriptor methodDescriptor) {\n    try {\n        return Mono.create(emitter -> monoRequest.subscribe(\n                request -> StubInvocationUtil.unaryCall(invoker, methodDescriptor, request, new StreamObserver<TResponse>() {\n                    @Override\n                    public void onNext(TResponse tResponse) {\n                        emitter.success(tResponse);\n                    }\n\n                    @Override\n                    public void onError(Throwable throwable) {\n                        emitter.error(throwable);\n                    }\n\n                    @Override\n                    public void onCompleted() {\n                            \n                    }\n                }),\n                emitter::error\n            ));\n    } catch (Throwable throwable) {\n        return Mono.error(throwable);\n    }\n}",
        "summary_tokens": [
            "implements",
            "a",
            "unary",
            "unary",
            "call",
            "as",
            "mono",
            "mono"
        ]
    },
    {
        "id": 1005,
        "code": "public static <TRequest, TResponse, TInvoker> Flux<TResponse> oneToMany(Invoker<TInvoker> invoker,\n                                                                        Mono<TRequest> monoRequest,\n                                                                        StubMethodDescriptor methodDescriptor) {\n    try {\n        return monoRequest\n            .flatMapMany(request -> {\n                ClientTripleReactorPublisher<TResponse> clientPublisher = new ClientTripleReactorPublisher<>();\n                StubInvocationUtil.serverStreamCall(invoker, methodDescriptor, request, clientPublisher);\n                return clientPublisher;\n            });\n    } catch (Throwable throwable) {\n        return Flux.error(throwable);\n    }\n}",
        "summary_tokens": [
            "implements",
            "a",
            "unary",
            "stream",
            "call",
            "as",
            "mono",
            "flux"
        ]
    },
    {
        "id": 1006,
        "code": "public static <TRequest, TResponse, TInvoker> Mono<TResponse> manyToOne(Invoker<TInvoker> invoker,\n                                                                        Flux<TRequest> requestFlux,\n                                                                        StubMethodDescriptor methodDescriptor) {\n    try {\n        ClientTripleReactorSubscriber<TRequest> clientSubscriber = requestFlux.subscribeWith(new ClientTripleReactorSubscriber<>());\n        ClientTripleReactorPublisher<TResponse> clientPublisher = new ClientTripleReactorPublisher<>(\n            s -> clientSubscriber.subscribe((CallStreamObserver<TRequest>) s),\n            clientSubscriber::cancel);\n        return Mono.from(clientPublisher).doOnSubscribe(dummy ->\n            StubInvocationUtil.biOrClientStreamCall(invoker, methodDescriptor, clientPublisher));\n    } catch (Throwable throwable) {\n        return Mono.error(throwable);\n    }\n}",
        "summary_tokens": [
            "implements",
            "a",
            "stream",
            "unary",
            "call",
            "as",
            "flux",
            "mono"
        ]
    },
    {
        "id": 1007,
        "code": "public static <TRequest, TResponse, TInvoker> Flux<TResponse> manyToMany(Invoker<TInvoker> invoker,\n                                                                         Flux<TRequest> requestFlux,\n                                                                         StubMethodDescriptor methodDescriptor) {\n    try {\n        ClientTripleReactorSubscriber<TRequest> clientSubscriber = requestFlux.subscribeWith(new ClientTripleReactorSubscriber<>());\n        ClientTripleReactorPublisher<TResponse> clientPublisher = new ClientTripleReactorPublisher<>(\n            s -> clientSubscriber.subscribe((CallStreamObserver<TRequest>) s),\n            clientSubscriber::cancel);\n        return Flux.from(clientPublisher).doOnSubscribe(dummy ->\n            StubInvocationUtil.biOrClientStreamCall(invoker, methodDescriptor, clientPublisher));\n    } catch (Throwable throwable) {\n        return Flux.error(throwable);\n    }\n}",
        "summary_tokens": [
            "implements",
            "a",
            "stream",
            "stream",
            "call",
            "as",
            "flux",
            "flux"
        ]
    },
    {
        "id": 1008,
        "code": "public static <T, R> void oneToOne(T request,\n                                   StreamObserver<R> responseObserver,\n                                   Function<Mono<T>, Mono<R>> func) {\n    func.apply(Mono.just(request)).subscribe(res -> {\n        CompletableFuture.completedFuture(res)\n            .whenComplete((r, t) -> {\n                if (t != null) {\n                    responseObserver.onError(t);\n                } else {\n                    responseObserver.onNext(r);\n                    responseObserver.onCompleted();\n                }\n            });\n    });\n}",
        "summary_tokens": [
            "implements",
            "a",
            "unary",
            "unary",
            "call",
            "as",
            "mono",
            "mono"
        ]
    },
    {
        "id": 1009,
        "code": "public static <T, R> void oneToMany(T request,\n                                    StreamObserver<R> responseObserver,\n                                    Function<Mono<T>, Flux<R>> func) {\n    try {\n        Flux<R> response = func.apply(Mono.just(request));\n        ServerTripleReactorSubscriber<R> subscriber = response.subscribeWith(new ServerTripleReactorSubscriber<>());\n        subscriber.subscribe((ServerCallToObserverAdapter<R>) responseObserver);\n    } catch (Throwable throwable) {\n        responseObserver.onError(throwable);\n    }\n}",
        "summary_tokens": [
            "implements",
            "a",
            "unary",
            "stream",
            "call",
            "as",
            "mono",
            "flux"
        ]
    },
    {
        "id": 1010,
        "code": "public static <T, R> StreamObserver<T> manyToOne(StreamObserver<R> responseObserver,\n                                                  Function<Flux<T>, Mono<R>> func) {\n    ServerTripleReactorPublisher<T> serverPublisher = new ServerTripleReactorPublisher<T>((CallStreamObserver<R>) responseObserver);\n    try {\n        Mono<R> responseMono = func.apply(Flux.from(serverPublisher));\n        responseMono.subscribe(value -> {\n                    \n                if (!serverPublisher.isCancelled()) {\n                    responseObserver.onNext(value);\n                }\n            },\n            throwable -> {\n                    \n                if (!serverPublisher.isCancelled()) {\n                    responseObserver.onError(throwable);\n                }\n            },\n            responseObserver::onCompleted\n        );\n        serverPublisher.startRequest();\n    } catch (Throwable throwable) {\n        responseObserver.onError(throwable);\n    }\n    return serverPublisher;\n}",
        "summary_tokens": [
            "implements",
            "a",
            "stream",
            "unary",
            "call",
            "as",
            "flux",
            "mono"
        ]
    },
    {
        "id": 1011,
        "code": "public static <T, R> StreamObserver<T> manyToMany(StreamObserver<R> responseObserver,\n                                                  Function<Flux<T>, Flux<R>> func) {\n        \n    ServerTripleReactorPublisher<T> serverPublisher = new ServerTripleReactorPublisher<T>((CallStreamObserver<R>) responseObserver);\n    try {\n        Flux<R> responseFlux = func.apply(Flux.from(serverPublisher));\n        ServerTripleReactorSubscriber<R> serverSubscriber = responseFlux.subscribeWith(new ServerTripleReactorSubscriber<>());\n        serverSubscriber.subscribe((CallStreamObserver<R>) responseObserver);\n        serverPublisher.startRequest();\n    } catch (Throwable throwable) {\n        responseObserver.onError(throwable);\n    }\n\n    return serverPublisher;\n}",
        "summary_tokens": [
            "implements",
            "a",
            "stream",
            "stream",
            "call",
            "as",
            "flux",
            "flux"
        ]
    },
    {
        "id": 1012,
        "code": "public void setStatus(String service, HealthCheckResponse.ServingStatus status) {\n    healthService.setStatus(service, status);\n}",
        "summary_tokens": [
            "updates",
            "the",
            "status",
            "of",
            "the",
            "server"
        ]
    },
    {
        "id": 1013,
        "code": "public void clearStatus(String service) {\n    healthService.clearStatus(service);\n}",
        "summary_tokens": [
            "clears",
            "the",
            "health",
            "status",
            "record",
            "of",
            "a",
            "service"
        ]
    },
    {
        "id": 1014,
        "code": "public void enterTerminalState() {\n    healthService.enterTerminalState();\n}",
        "summary_tokens": [
            "enter",
            "terminal",
            "state",
            "causes",
            "the",
            "health",
            "status",
            "manager",
            "to",
            "mark",
            "all",
            "services",
            "as",
            "not",
            "serving",
            "and",
            "prevents",
            "future",
            "updates",
            "to",
            "services"
        ]
    },
    {
        "id": 1015,
        "code": "public static void convertAttachment(DefaultHttp2Headers headers,\n    Map<String, Object> attachments) {\n    if (attachments == null) {\n        return;\n    }\n    for (Map.Entry<String, Object> entry : attachments.entrySet()) {\n        final String key = entry.getKey().toLowerCase(Locale.ROOT);\n        if (Http2Headers.PseudoHeaderName.isPseudoHeader(key)) {\n            continue;\n        }\n        if (TripleHeaderEnum.containsExcludeAttachments(key)) {\n            continue;\n        }\n        final Object v = entry.getValue();\n        convertSingleAttachment(headers, key, v);\n    }\n}",
        "summary_tokens": [
            "parse",
            "and",
            "put",
            "the",
            "kv",
            "pairs",
            "into",
            "metadata"
        ]
    },
    {
        "id": 1016,
        "code": "private static void convertSingleAttachment(DefaultHttp2Headers headers, String key, Object v) {\n    try {\n        if (v instanceof String || v instanceof Number || v instanceof Boolean) {\n            String str = v.toString();\n            headers.set(key, str);\n        } else if (v instanceof byte[]) {\n            String str = encodeBase64ASCII((byte[]) v);\n            headers.set(key + TripleConstant.HEADER_BIN_SUFFIX, str);\n        }\n    } catch (Throwable t) {\n        LOGGER.warn(\"Meet exception when convert single attachment key:\" + key + \" value=\" + v,\n            t);\n    }\n}",
        "summary_tokens": [
            "convert",
            "each",
            "user",
            "s",
            "attach",
            "value",
            "to",
            "metadata"
        ]
    },
    {
        "id": 1017,
        "code": "private void responsePlainTextError(int code, TriRpcStatus status) {\n    Http2Headers headers = new DefaultHttp2Headers(true).status(String.valueOf(code))\n        .setInt(TripleHeaderEnum.STATUS_KEY.getHeader(), status.code.code)\n        .set(TripleHeaderEnum.MESSAGE_KEY.getHeader(), status.description)\n        .set(TripleHeaderEnum.CONTENT_TYPE_KEY.getHeader(), TripleConstant.TEXT_PLAIN_UTF8);\n    writeQueue.enqueue(HeaderQueueCommand.createHeaders(headers, false));\n    writeQueue.enqueue(TextDataQueueCommand.createCommand(status.description, true));\n}",
        "summary_tokens": [
            "error",
            "before",
            "create",
            "server",
            "stream",
            "http",
            "plain",
            "text",
            "will",
            "be",
            "returned"
        ]
    },
    {
        "id": 1018,
        "code": "private void responseErr(TriRpcStatus status) {\n    Http2Headers trailers = new DefaultHttp2Headers().status(OK.codeAsText())\n        .set(HttpHeaderNames.CONTENT_TYPE, TripleConstant.CONTENT_PROTO)\n        .setInt(TripleHeaderEnum.STATUS_KEY.getHeader(), status.code.code)\n        .set(TripleHeaderEnum.MESSAGE_KEY.getHeader(), status.toEncodedMessage());\n    sendTrailers(trailers);\n}",
        "summary_tokens": [
            "error",
            "in",
            "create",
            "stream",
            "unsupported",
            "config",
            "or",
            "triple",
            "protocol",
            "error"
        ]
    },
    {
        "id": 1019,
        "code": "protected Map<String, Object> headersToMap(Http2Headers trailers) {\n    if (trailers == null) {\n        return Collections.emptyMap();\n    }\n    Map<String, Object> attachments = new HashMap<>(trailers.size());\n    for (Map.Entry<CharSequence, CharSequence> header : trailers) {\n        String key = header.getKey().toString();\n        if (key.endsWith(TripleConstant.HEADER_BIN_SUFFIX)\n            && key.length() > TripleConstant.HEADER_BIN_SUFFIX.length()) {\n            try {\n                String realKey = key.substring(0,\n                    key.length() - TripleConstant.HEADER_BIN_SUFFIX.length());\n                byte[] value = StreamUtils.decodeASCIIByte(header.getValue());\n                attachments.put(realKey, value);\n            } catch (Exception e) {\n                LOGGER.error(\"Failed to parse response attachment key=\" + key, e);\n            }\n        } else {\n            attachments.put(key, header.getValue().toString());\n        }\n    }\n    return attachments;\n}",
        "summary_tokens": [
            "parse",
            "metadata",
            "to",
            "a",
            "kv",
            "pairs",
            "map"
        ]
    },
    {
        "id": 1020,
        "code": "default Throwable readThrowable() throws IOException, ClassNotFoundException {\n    Object obj = readObject();\n    if (!(obj instanceof Throwable)) {\n        throw new IOException(\"Response data error, expect Throwable, but get \" + obj);\n    }\n    return (Throwable) obj;\n}",
        "summary_tokens": [
            "the",
            "following",
            "methods",
            "are",
            "customized",
            "for",
            "the",
            "requirement",
            "of",
            "dubbo",
            "s",
            "rpc",
            "protocol",
            "implementation"
        ]
    },
    {
        "id": 1021,
        "code": "default void writeThrowable(Object obj) throws IOException {\n    writeObject(obj);\n}",
        "summary_tokens": [
            "the",
            "following",
            "methods",
            "are",
            "customized",
            "for",
            "the",
            "requirement",
            "of",
            "dubbo",
            "s",
            "rpc",
            "protocol",
            "implementation"
        ]
    },
    {
        "id": 1022,
        "code": "public static void registerClass(Class<?> clazz, Object serializer) {\n    if (clazz == null) {\n        throw new IllegalArgumentException(\"Class registered to kryo cannot be null!\");\n    }\n    REGISTRATIONS.put(clazz, serializer);\n}",
        "summary_tokens": [
            "only",
            "supposed",
            "to",
            "be",
            "called",
            "at",
            "startup",
            "time"
        ]
    },
    {
        "id": 1023,
        "code": "public Set<String> dubboBasePackages(ConfigurableEnvironment environment) {\n    PropertyResolver propertyResolver = dubboScanBasePackagesPropertyResolver(environment);\n    return propertyResolver.getProperty(BASE_PACKAGES_PROPERTY_NAME, Set.class, emptySet());\n}",
        "summary_tokens": [
            "the",
            "bean",
            "is",
            "used",
            "to",
            "scan",
            "the",
            "packages",
            "of",
            "dubbo",
            "service",
            "classes"
        ]
    },
    {
        "id": 1024,
        "code": "protected Map<String, String> resolveStatusCheckerNamesMap() {\n\n    Map<String, String> statusCheckerNamesMap = new LinkedHashMap<>();\n\n    statusCheckerNamesMap.putAll(resolveStatusCheckerNamesMapFromDubboHealthIndicatorProperties());\n\n    statusCheckerNamesMap.putAll(resolveStatusCheckerNamesMapFromProtocolConfigs());\n\n    statusCheckerNamesMap.putAll(resolveStatusCheckerNamesMapFromProviderConfig());\n\n    return statusCheckerNamesMap;\n\n}",
        "summary_tokens": [
            "resolves",
            "the",
            "map",
            "of",
            "status",
            "checker",
            "s",
            "name",
            "and",
            "its",
            "source"
        ]
    },
    {
        "id": 1025,
        "code": "public ServiceAnnotationPostProcessor serviceAnnotationBeanProcessor(@Qualifier(BASE_PACKAGES_BEAN_NAME)\n                                                                   Set<String> packagesToScan) {\n    return new ServiceAnnotationPostProcessor(packagesToScan);\n}",
        "summary_tokens": [
            "creates",
            "service",
            "annotation",
            "post",
            "processor",
            "bean"
        ]
    },
    {
        "id": 1026,
        "code": "public Set<String> dubboBasePackages(Environment environment) {\n    PropertyResolver propertyResolver = dubboScanBasePackagesPropertyResolver(environment);\n    return propertyResolver.getProperty(BASE_PACKAGES_PROPERTY_NAME, Set.class, emptySet());\n}",
        "summary_tokens": [
            "the",
            "bean",
            "is",
            "used",
            "to",
            "scan",
            "the",
            "packages",
            "of",
            "dubbo",
            "service",
            "classes"
        ]
    },
    {
        "id": 1027,
        "code": "public int getOrder() {\n    return LOWEST_PRECEDENCE + 1;\n}",
        "summary_tokens": [
            "keep",
            "the",
            "order",
            "being",
            "higher",
            "than",
            "common",
            "annotation",
            "bean",
            "post",
            "processor",
            "get",
            "order",
            "that",
            "is",
            "ordered",
            "lowest",
            "precedence"
        ]
    },
    {
        "id": 1028,
        "code": "private void resolveUniqueApplicationConfigBean(BeanDefinitionRegistry registry, ListableBeanFactory beanFactory) {\n\n    String[] beansNames = beanNamesForTypeIncludingAncestors(beanFactory, ApplicationConfig.class);\n\n    if (beansNames.length < 2) { \n        return;\n    }\n\n    Environment environment = beanFactory.getBean(ENVIRONMENT_BEAN_NAME, Environment.class);\n\n        \n    Stream.of(beansNames)\n        .filter(beansName -> isConfiguredApplicationConfigBeanName(environment, beansName))\n        .forEach(registry::removeBeanDefinition);\n\n    beansNames = beanNamesForTypeIncludingAncestors(beanFactory, ApplicationConfig.class);\n\n    if (beansNames.length > 1) {\n        throw new IllegalStateException(String.format(\"There are more than one instances of %s, whose bean definitions : %s\",\n            ApplicationConfig.class.getSimpleName(),\n            Stream.of(beansNames)\n                .map(registry::getBeanDefinition)\n                .collect(Collectors.toList()))\n        );\n    }\n}",
        "summary_tokens": [
            "resolve",
            "the",
            "unique",
            "application",
            "config",
            "bean"
        ]
    },
    {
        "id": 1029,
        "code": "private void setAllowBeanDefinitionOverriding(Map<String, Object> defaultProperties) {\n    defaultProperties.put(ALLOW_BEAN_DEFINITION_OVERRIDING_PROPERTY, Boolean.TRUE.toString());\n}",
        "summary_tokens": [
            "set",
            "allow",
            "bean",
            "definition",
            "overriding",
            "property",
            "spring"
        ]
    },
    {
        "id": 1030,
        "code": "private void addOrReplace(MutablePropertySources propertySources,\n                          Map<String, Object> map) {\n    MapPropertySource target = null;\n    if (propertySources.contains(PROPERTY_SOURCE_NAME)) {\n        PropertySource<?> source = propertySources.get(PROPERTY_SOURCE_NAME);\n        if (source instanceof MapPropertySource) {\n            target = (MapPropertySource) source;\n            for (Map.Entry<String,Object> entry : map.entrySet()) {\n                String key = entry.getKey();\n                if (!target.containsProperty(key)) {\n                    target.getSource().put(key, entry.getValue());\n                }\n            }\n        }\n    }\n    if (target == null) {\n        target = new MapPropertySource(PROPERTY_SOURCE_NAME, map);\n    }\n    if (!propertySources.contains(PROPERTY_SOURCE_NAME)) {\n        propertySources.addLast(target);\n    }\n}",
        "summary_tokens": [
            "copy",
            "from",
            "bus",
            "environment",
            "post",
            "processor",
            "add",
            "or",
            "replace",
            "mutable",
            "property",
            "sources",
            "map"
        ]
    },
    {
        "id": 1031,
        "code": "public boolean needRegistryCenter(TestIdentifier testIdentifier) {\n    return supportEmbeddedZookeeper(testIdentifier);\n}",
        "summary_tokens": [
            "checks",
            "if",
            "current",
            "test",
            "identifier",
            "need",
            "registry",
            "center"
        ]
    },
    {
        "id": 1032,
        "code": "private boolean supportEmbeddedZookeeper(TestIdentifier testIdentifier) {\n    if (!enableEmbeddedZookeeper) {\n        return false;\n    }\n    TestSource testSource = testIdentifier.getSource().orElse(null);\n    if (testSource instanceof ClassSource) {\n        String packageName = ((ClassSource) testSource).getJavaClass().getPackage().getName();\n        for (String pkgName : PACKAGE_NAME) {\n            if (packageName.contains(pkgName)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}",
        "summary_tokens": [
            "checks",
            "if",
            "the",
            "current",
            "test",
            "identifier",
            "need",
            "embedded",
            "zookeeper"
        ]
    },
    {
        "id": 1033,
        "code": "default String getConnectionAddress(){\n    return getConnectionAddress1();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "default",
            "connection",
            "address",
            "in",
            "single",
            "registry",
            "center"
        ]
    },
    {
        "id": 1034,
        "code": "public static void startup() throws Exception {\n    INSTANCE.startup();\n}",
        "summary_tokens": [
            "start",
            "the",
            "registry",
            "center"
        ]
    },
    {
        "id": 1035,
        "code": "public static void reset() throws Exception {\n    INSTANCE.reset();\n}",
        "summary_tokens": [
            "reset",
            "the",
            "registry",
            "center"
        ]
    },
    {
        "id": 1036,
        "code": "public static void shutdown() throws Exception {\n    INSTANCE.shutdown();\n}",
        "summary_tokens": [
            "stop",
            "the",
            "registry",
            "center"
        ]
    },
    {
        "id": 1037,
        "code": "private static String getEmbeddedZookeeperDirectory() {\n    String directory;\n        \n    directory = System.getProperty(CONFIG_EMBEDDED_ZOOKEEPER_DIRECTORY);\n    logger.info(String.format(\"The customized directory is %s to store zookeeper binary archive.\",directory));\n    if (StringUtils.isNotEmpty(directory)) {\n        return directory;\n    }\n        \n    logger.info(String.format(\"The user home is %s to store zookeeper binary archive.\",directory));\n    directory = System.getProperty(\"user.home\");\n    logger.info(String.format(\"user.home is %s\",directory));\n    if (StringUtils.isEmpty(directory)) {\n            \n        directory = System.getProperty(\"java.io.tmpdir\");\n        logger.info(String.format(\"The temporary directory is %s to store zookeeper binary archive.\",directory));\n    }\n    Assert.notEmptyString(directory, \"The directory to store zookeeper binary archive cannot be null or empty.\");\n    return directory + File.separator + \".tmp\" + File.separator + \"zookeeper\";\n\n}",
        "summary_tokens": [
            "returns",
            "the",
            "directory",
            "to",
            "store",
            "zookeeper",
            "binary",
            "archive"
        ]
    },
    {
        "id": 1038,
        "code": "private static Path getTargetFilePath() {\n    String zookeeperDirectory = getEmbeddedZookeeperDirectory();\n    Path targetFilePath = Paths.get(zookeeperDirectory, TARGET_ZOOKEEPER_FILE_NAME);\n    logger.info(\"Target file's absolute directory: \" + targetFilePath);\n    return targetFilePath;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "target",
            "file",
            "path"
        ]
    },
    {
        "id": 1039,
        "code": "private static OS getOS() {\n    String osName = System.getProperty(\"os.name\").toLowerCase();\n    OS os = OS.Unix;\n    if (osName.contains(\"windows\")) {\n        os = OS.Windows;\n    }\n    return os;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "operating",
            "system"
        ]
    },
    {
        "id": 1040,
        "code": "private void put(OS os, Command command, Processor processor) {\n    Map<Command, Processor> commandProcessorMap = this.processors.get(os);\n    if (commandProcessorMap == null) {\n        commandProcessorMap = new HashMap<>();\n        this.processors.put(os, commandProcessorMap);\n    }\n    commandProcessorMap.put(command, processor);\n}",
        "summary_tokens": [
            "store",
            "all",
            "initialized",
            "processor",
            "instances"
        ]
    },
    {
        "id": 1041,
        "code": "private Processor get(OS os, Command command) {\n    Map<Command, Processor> commandProcessorMap = this.processors.get(os);\n    Objects.requireNonNull(commandProcessorMap, \"The command with the OS cannot be null\");\n    Processor processor = commandProcessorMap.get(command);\n    Objects.requireNonNull(processor, \"The processor cannot be null\");\n    return processor;\n}",
        "summary_tokens": [
            "gets",
            "the",
            "processor",
            "with",
            "the",
            "given",
            "os",
            "type",
            "and",
            "command"
        ]
    },
    {
        "id": 1042,
        "code": "public String getVersion() {\n    return DEFAULT_ZOOKEEPER_VERSION;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "zookeeper",
            "s",
            "version"
        ]
    },
    {
        "id": 1043,
        "code": "public int[] getClientPorts() {\n    return CLIENT_PORTS;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "client",
            "ports",
            "of",
            "zookeeper"
        ]
    },
    {
        "id": 1044,
        "code": "public int[] getAdminServerPorts() {\n    return DEFAULT_ADMIN_SERVER_PORTS;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "admin",
            "server",
            "ports",
            "of",
            "zookeeper"
        ]
    },
    {
        "id": 1045,
        "code": "public static String getConnectionAddress() {\n    return CONFIG.getConnectionAddress();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "connection",
            "address",
            "in",
            "single",
            "registry",
            "center"
        ]
    },
    {
        "id": 1046,
        "code": "public static String getConnectionAddress1() {\n    return CONFIG.getConnectionAddress1();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "first",
            "connection",
            "address",
            "in",
            "multiple",
            "registry",
            "centers"
        ]
    },
    {
        "id": 1047,
        "code": "public static String getConnectionAddress2() {\n    return CONFIG.getConnectionAddress2();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "second",
            "connection",
            "address",
            "in",
            "multiple",
            "registry",
            "centers"
        ]
    },
    {
        "id": 1048,
        "code": "public static String getConnectionAddressKey() {\n    return CONFIG.getConnectionAddressKey();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "default",
            "connection",
            "address",
            "key",
            "in",
            "single",
            "registry",
            "center"
        ]
    },
    {
        "id": 1049,
        "code": "public static String getConnectionAddressKey1() {\n    return CONFIG.getConnectionAddressKey1();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "first",
            "connection",
            "address",
            "key",
            "in",
            "multiple",
            "registry",
            "center"
        ]
    },
    {
        "id": 1050,
        "code": "public static String getConnectionAddressKey2() {\n    return CONFIG.getConnectionAddressKey2();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "second",
            "connection",
            "address",
            "key",
            "in",
            "multiple",
            "registry",
            "center"
        ]
    },
    {
        "id": 1051,
        "code": "public void setSourceFile(Path sourceFile) {\n    this.sourceFile = sourceFile;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "source",
            "file",
            "path",
            "of",
            "downloaded",
            "zookeeper",
            "binary",
            "archive"
        ]
    },
    {
        "id": 1052,
        "code": "public Path getSourceFile() {\n    return this.sourceFile;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "source",
            "file",
            "path",
            "of",
            "downloaded",
            "zookeeper",
            "binary",
            "archive"
        ]
    },
    {
        "id": 1053,
        "code": "public String getUnpackedDirectory() {\n    return unpackedDirectory;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "directory",
            "after",
            "unpacked",
            "zookeeper",
            "archive",
            "binary",
            "file"
        ]
    },
    {
        "id": 1054,
        "code": "public void setUnpackedDirectory(String unpackedDirectory) {\n    this.unpackedDirectory = unpackedDirectory;\n}",
        "summary_tokens": [
            "sets",
            "the",
            "directory",
            "after",
            "unpacked",
            "zookeeper",
            "archive",
            "binary",
            "file"
        ]
    },
    {
        "id": 1055,
        "code": "public String getVersion() {\n    return config.getVersion();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "zookeeper",
            "s",
            "version"
        ]
    },
    {
        "id": 1056,
        "code": "public int[] getClientPorts() {\n    return config.getClientPorts();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "client",
            "ports",
            "of",
            "zookeeper"
        ]
    },
    {
        "id": 1057,
        "code": "public int[] getAdminServerPorts() {\n    return config.getAdminServerPorts();\n}",
        "summary_tokens": [
            "returns",
            "the",
            "admin",
            "server",
            "ports",
            "of",
            "zookeeper"
        ]
    },
    {
        "id": 1058,
        "code": "public void register(int clientPort, int pid) {\n    this.processIds.put(clientPort, pid);\n}",
        "summary_tokens": [
            "register",
            "the",
            "process",
            "id",
            "of",
            "zookeeper"
        ]
    },
    {
        "id": 1059,
        "code": "public Integer getPid(int clientPort) {\n    return this.processIds.get(clientPort);\n}",
        "summary_tokens": [
            "returns",
            "the",
            "pid",
            "of",
            "zookeeper",
            "instance",
            "with",
            "the",
            "given",
            "client",
            "port"
        ]
    },
    {
        "id": 1060,
        "code": "public void removePid(int clientPort){\n    this.processIds.remove(clientPort);\n}",
        "summary_tokens": [
            "remove",
            "the",
            "registered",
            "pid",
            "with",
            "the",
            "given",
            "client",
            "port"
        ]
    },
    {
        "id": 1061,
        "code": "public ExecutorService getExecutorService() {\n    return DEFAULT_EXECUTOR_SERVICE;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "default",
            "executor",
            "service",
            "to",
            "manage",
            "the",
            "lifecycle",
            "of",
            "zookeeper"
        ]
    },
    {
        "id": 1062,
        "code": "public ExecuteWatchdog getWatchdog() {\n    return WATCHDOG;\n}",
        "summary_tokens": [
            "returns",
            "the",
            "execute",
            "watchdog"
        ]
    },
    {
        "id": 1063,
        "code": "public void destroy() {\n    this.processIds.clear();\n    this.WATCHDOG.destroyProcess();\n    try {\n        DEFAULT_EXECUTOR_SERVICE.shutdownNow();\n    } catch (SecurityException | NullPointerException ex) {\n        return;\n    }\n    try {\n        DEFAULT_EXECUTOR_SERVICE.awaitTermination(5, TimeUnit.SECONDS);\n    } catch (InterruptedException ex) {\n        Thread.currentThread().interrupt();\n    }\n}",
        "summary_tokens": [
            "destroy",
            "all",
            "registered",
            "resources"
        ]
    },
    {
        "id": 1064,
        "code": "private void updateConfig(ZookeeperContext context, int clientPort, int adminServerPort) throws DubboTestException {\n    Path zookeeperConf = Paths.get(context.getSourceFile().getParent().toString(),\n            String.valueOf(clientPort),\n            context.getUnpackedDirectory(),\n            \"conf\");\n    File zooSample = Paths.get(zookeeperConf.toString(), \"zoo_sample.cfg\").toFile();\n    int availableAdminServerPort = NetUtils.getAvailablePort(adminServerPort);\n    Properties properties = new Properties();\n    try {\n        properties.load(new FileInputStream(zooSample));\n        properties.setProperty(\"clientPort\", String.valueOf(clientPort));\n        properties.setProperty(\"admin.serverPort\", String.valueOf(availableAdminServerPort));\n        Path dataDir = Paths.get(zookeeperConf.getParent().toString(), \"data\");\n        if (!Files.exists(dataDir)) {\n            try {\n                logger.info(\"It is creating the data directory...\");\n                Files.createDirectories(dataDir);\n            } catch (IOException e) {\n                throw new RuntimeException(String.format(\"Failed to create the data directory to save zookeeper binary file, file path:%s\", context.getSourceFile()), e);\n            }\n        }\n        properties.setProperty(\"dataDir\", dataDir.toString());\n        FileOutputStream oFile = null;\n        try {\n            oFile = new FileOutputStream(Paths.get(zookeeperConf.toString(), \"zoo.cfg\").toFile());\n            properties.store(oFile, \"\");\n        } finally {\n            try {\n                oFile.close();\n            } catch (IOException e) {\n                throw new DubboTestException(\"Failed to close file\", e);\n            }\n        }\n        logger.info(\"The configuration information of zoo.cfg are as below,\\n\" +\n                \"which located in \" + zooSample.getAbsolutePath() + \"\\n\" +\n                propertiesToString(properties));\n    } catch (IOException e) {\n        throw new DubboTestException(String.format(\"Failed to update %s file\", zooSample), e);\n    }\n\n    File log4j = Paths.get(zookeeperConf.toString(), \"log4j.properties\").toFile();\n    try {\n        properties.load(new FileInputStream(log4j));\n        Path logDir = Paths.get(zookeeperConf.getParent().toString(), \"logs\");\n        if (!Files.exists(logDir)) {\n            try {\n                logger.info(\"It is creating the log directory...\");\n                Files.createDirectories(logDir);\n            } catch (IOException e) {\n                throw new RuntimeException(String.format(\"Failed to create the log directory to save zookeeper binary file, file path:%s\", context.getSourceFile()), e);\n            }\n        }\n        properties.setProperty(\"zookeeper.log.dir\", logDir.toString());\n        FileOutputStream oFile = null;\n        try {\n            oFile = new FileOutputStream(Paths.get(zookeeperConf.toString(), \"log4j.properties\").toFile());\n            properties.store(oFile, \"\");\n        } finally {\n            try {\n                oFile.close();\n            } catch (IOException e) {\n                throw new DubboTestException(\"Failed to close file\", e);\n            }\n        }\n        logger.info(\"The configuration information of log4j.properties are as below,\\n\" +\n                \"which located in \" + log4j.getAbsolutePath() + \"\\n\" +\n                propertiesToString(properties));\n    } catch (IOException e) {\n        throw new DubboTestException(String.format(\"Failed to update %s file\", zooSample), e);\n    }\n}",
        "summary_tokens": [
            "update",
            "the",
            "config",
            "file",
            "with",
            "the",
            "given",
            "client",
            "port",
            "and",
            "admin",
            "server",
            "port"
        ]
    },
    {
        "id": 1065,
        "code": "private String propertiesToString(Properties properties) {\n    StringBuilder builder = new StringBuilder();\n    for (Object key : properties.keySet()) {\n        builder.append(key);\n        builder.append(\": \");\n        builder.append(properties.get(key));\n        builder.append(\"\\n\");\n    }\n    return builder.toString();\n}",
        "summary_tokens": [
            "convert",
            "the",
            "properties",
            "instance",
            "to",
            "string"
        ]
    },
    {
        "id": 1066,
        "code": "private boolean checkFile(Path filePath) {\n    return Files.exists(filePath) && filePath.toFile().isFile();\n}",
        "summary_tokens": [
            "returns",
            "true",
            "if",
            "the",
            "file",
            "exists",
            "with",
            "the",
            "given",
            "file",
            "path",
            "otherwise",
            "false"
        ]
    },
    {
        "id": 1067,
        "code": "private void download(String url, Path targetPath) throws ExecutionException, InterruptedException, IOException, TimeoutException {\n    AsyncHttpClient asyncHttpClient = new DefaultAsyncHttpClient(\n        new DefaultAsyncHttpClientConfig.Builder()\n            .setConnectTimeout(CONNECT_TIMEOUT)\n            .setRequestTimeout(REQUEST_TIMEOUT)\n            .setMaxRequestRetry(1)\n            .build());\n    Future<Response> responseFuture = asyncHttpClient.prepareGet(url).execute(new AsyncCompletionHandler<Response>() {\n        @Override\n        public Response onCompleted(Response response) {\n            logger.info(\"Download zookeeper binary archive file successfully! download url: \" + url);\n            return response;\n        }\n\n        @Override\n        public void onThrowable(Throwable t) {\n            logger.warn(\"Failed to download the file, download url: \" + url);\n            super.onThrowable(t);\n        }\n    });\n        \n    Response response = responseFuture.get(REQUEST_TIMEOUT * 2, TimeUnit.MILLISECONDS);\n    Files.copy(response.getResponseBodyAsStream(), targetPath, StandardCopyOption.REPLACE_EXISTING);\n}",
        "summary_tokens": [
            "download",
            "the",
            "file",
            "with",
            "the",
            "given",
            "url"
        ]
    },
    {
        "id": 1068,
        "code": "private void unpack(ZookeeperContext context, int clientPort) throws DubboTestException {\n    File sourceFile = context.getSourceFile().toFile();\n    Path targetPath = Paths.get(context.getSourceFile().getParent().toString(),\n        String.valueOf(clientPort));\n        \n    if (targetPath.toFile() != null && targetPath.toFile().isDirectory()) {\n        logger.info(String.format(\"The file has been unpacked, target path:%s\", targetPath.toString()));\n        return;\n    }\n    try (FileInputStream fileInputStream = new FileInputStream(sourceFile);\n         GzipCompressorInputStream gzipCompressorInputStream = new GzipCompressorInputStream(fileInputStream);\n         TarArchiveInputStream tarArchiveInputStream = new TarArchiveInputStream(gzipCompressorInputStream, \"UTF-8\")) {\n        File targetFile = targetPath.toFile();\n        TarArchiveEntry entry;\n        while ((entry = tarArchiveInputStream.getNextTarEntry()) != null) {\n            if (entry.isDirectory()) {\n                continue;\n            }\n            File curFile = new File(targetFile, entry.getName());\n            File parent = curFile.getParentFile();\n            if (!parent.exists()) {\n                parent.mkdirs();\n            }\n            try (FileOutputStream outputStream = new FileOutputStream(curFile)) {\n                IOUtils.copy(tarArchiveInputStream, outputStream);\n            }\n        }\n    } catch (IOException e) {\n        throw new DubboTestException(String.format(\"Failed to unpack the zookeeper binary file\"), e);\n    }\n}",
        "summary_tokens": [
            "unpack",
            "the",
            "zookeeper",
            "binary",
            "file"
        ]
    },
    {
        "id": 1069,
        "code": "private void findPid(ZookeeperWindowsContext context, int clientPort) {\n    logger.info(String.format(\"Find the pid of the zookeeper with port %d\", clientPort));\n    Executor executor = new DefaultExecutor();\n    executor.setExitValues(null);\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\n    ByteArrayOutputStream ins = new ByteArrayOutputStream();\n    ByteArrayInputStream in = new ByteArrayInputStream(ins.toByteArray());\n    executor.setStreamHandler(new PumpStreamHandler(out, null, in));\n    CommandLine cmdLine = new CommandLine(\"cmd.exe\");\n    cmdLine.addArgument(\"/c\");\n    cmdLine.addArgument(\"netstat -ano | findstr \" + clientPort);\n    try {\n        executor.execute(cmdLine);\n        String result = out.toString();\n        logger.info(String.format(\"Find result: %s\", result));\n        if (StringUtils.isNotEmpty(result)) {\n            String[] values = result.split(\"\\\\r\\\\n\");\n                \n                \n                \n                \n                \n                \n                \n            if (values != null && values.length > 0) {\n                for (int i = 0; i < values.length; i++) {\n                    List<String> segments = Arrays.stream(values[i].trim().split(\" \"))\n                        .filter(str -> !\"\".equals(str))\n                        .collect(Collectors.toList());\n                        \n                        \n                        \n                        \n                        \n                        \n                    if (segments != null && segments.size() == 5) {\n                        if (this.check(segments.get(1), clientPort)) {\n                            int pid = Integer.valueOf(segments.get(segments.size() - 1).trim());\n                            context.register(clientPort, pid);\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n    } catch (IOException e) {\n        throw new DubboTestException(String.format(\"Failed to find the PID of zookeeper with port %d\", clientPort), e);\n    }\n}",
        "summary_tokens": [
            "find",
            "the",
            "pid",
            "of",
            "zookeeper",
            "instance"
        ]
    },
    {
        "id": 1070,
        "code": "private boolean check(String segment, int clientPort) {\n    return (\"[::]:\" + clientPort).equalsIgnoreCase(segment)\n        || (\"0.0.0.0:\" + clientPort).equalsIgnoreCase(segment)\n        || (\"127.0.0.1:\" + clientPort).equalsIgnoreCase(segment);\n}",
        "summary_tokens": [
            "checks",
            "if",
            "segment",
            "is",
            "valid",
            "ip",
            "and",
            "port",
            "pair"
        ]
    },
    {
        "id": 1071,
        "code": "private void logErrorStream(final InputStream errorStream) {\n    try (final BufferedReader reader = new BufferedReader(new InputStreamReader(errorStream))) {\n        String line;\n        while ((line = reader.readLine()) != null) {\n            logger.error(line);\n        }\n    } catch (IOException e) {\n            \n    }\n}",
        "summary_tokens": [
            "prints",
            "the",
            "error",
            "log",
            "after",
            "run",
            "process"
        ]
    },
    {
        "id": 1072,
        "code": "private void awaitProcessReady(final InputStream inputStream) throws DubboTestException {\n    final StringBuilder log = new StringBuilder();\n    try (final BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream))) {\n        String line;\n        while ((line = reader.readLine()) != null) {\n            if (this.getPattern().matcher(line).matches()) {\n                return;\n            }\n            log.append('\\n').append(line);\n        }\n    } catch (IOException e) {\n        throw new DubboTestException(\"Failed to read the log after executed process.\", e);\n    }\n    throw new DubboTestException(\"Ready pattern not found in log, log: \" + log);\n}",
        "summary_tokens": [
            "wait",
            "until",
            "the",
            "server",
            "is",
            "started",
            "successfully"
        ]
    }
]